[
    {
        "question_title": "Tree with Small Distances",
        "question_content": "You are given an undirected tree consisting of n vertices. An undirected tree is a connected undirected graph with n - 1 edges.\n\nYour task is to add the minimum number of edges in such a way that the length of the shortest path from the vertex 1 to any other vertex is at most 2. Note that you are not allowed to add loops and multiple edges.\n\n\nInput Format\nThe first line contains one integer n (2 \\le n \\le 2 \\cdot 10^5) \u2014 the number of vertices in the tree.\n\nThe following n - 1 lines contain edges: edge i is given as a pair of vertices u_i, v_i (1 \\le u_i, v_i \\le n). It is guaranteed that the given edges form a tree. It is guaranteed that there are no loops and multiple edges in the given edges.\n\n\nOutput Format\nPrint a single integer \u2014 the minimum number of edges you have to add in order to make the shortest distance from the vertex 1 to any other vertex at most 2. Note that you are not allowed to add loops and multiple edges.\n\n\nSample Input 1\n\n7\n1 2\n2 3\n2 4\n4 5\n4 6\n5 7\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n1 7\n\nSample Output 2\n\n0\n\n\nSample Input 3\n\n7\n1 2\n2 3\n3 4\n3 5\n3 6\n3 7\n\nSample Output 3\n\n1\n\n\nNote\nThe tree corresponding to the first example: The answer is 2, some of the possible answers are the following: [(1, 5), (1, 6)], [(1, 4), (1, 7)], [(1, 6), (1, 7)].\n\nThe tree corresponding to the second example: The answer is 0.\n\nThe tree corresponding to the third example: The answer is 1, only one possible way to reach it is to add the edge (1, 3).",
        "platform": "codeforces",
        "question_id": "1029/E",
        "contest_id": "1029",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the path length at most 2\n    return max(0, (max_distance + 1) // 2)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the shortest path length at most 2\n    return max(0, 2 - max_distance)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# Function to perform BFS and find the farthest node from the starting node\ndef bfs(start):\n    visited = [False] * (n + 1)\n    queue = deque([start])\n    visited[start] = True\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if max_distance < 1:\n                    farthest_node = neighbor\n                    max_distance = 1\n    \n    return farthest_node, max_distance\n\n# Find the farthest node from vertex 1\nfarthest_node, _ = bfs(1)\n\n# Find the farthest node from the farthest node found in the previous step\nsecond_farthest_node, _ = bfs(farthest_node)\n\n# Calculate the distance between the two farthest nodes\ndistance = bfs(farthest_node)[1]\n\n# The minimum number of edges to add is the distance minus 1\nmin_edges_to_add = max(0, distance - 1)\n\n# Output the result\nprint(min_edges_to_add)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the path length at most 2\n    return max(0, (max_distance + 1) // 2 - 1)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate the result\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from vertex 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from vertex 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the shortest path length at most 2\n    return max(0, max_distance - 1)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate the result\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the path length at most 2\n    return max(0, 2 - max_distance)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate the result\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node_1, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the first BFS\n    farthest_node_2, _ = bfs(farthest_node_1)\n    \n    # Calculate the distance between the two farthest nodes\n    def bfs_distance(start, end):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            if current == end:\n                return distance\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    distance += 1\n        \n        return -1\n    \n    distance = bfs_distance(farthest_node_1, farthest_node_2)\n    \n    # Calculate the minimum number of edges to make the path length at most 2\n    if distance <= 2:\n        return 0\n    else:\n        return (distance - 2) // 2\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate and print the result\nresult = min_edges_to_make_path_length_two(n, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the shortest path length at most 2\n    return max(0, (max_distance + 1) // 2 - 1)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate and print the result\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_two(n, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        max_distance = 1\n                        farthest_node = neighbor\n        \n        return farthest_node, max_distance\n    \n    farthest_node, _ = bfs(1)\n    second_farthest_node, _ = bfs(farthest_node)\n    \n    # Perform BFS again to find the farthest node from the second farthest node\n    _, max_distance = bfs(second_farthest_node)\n    \n    # Calculate the minimum number of edges to make the path length at most 2\n    if max_distance <= 2:\n        return 0\n    else:\n        return max_distance - 2\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = min_edges_to_make_path_length_two(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node_1, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the first BFS\n    farthest_node_2, max_distance = bfs(farthest_node_1)\n    \n    # The minimum number of edges needed is the maximum distance minus 1\n    return max_distance - 1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate the result\nresult = min_edges_to_make_path_length_two(n, edges)\n\n# Print the result\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the path length at most 2\n    return max(0, (max_distance + 1) // 2)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the shortest path length at most 2\n    return max(0, 2 - max_distance)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Build the graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# Function to perform BFS and find the farthest node from the starting node\ndef bfs(start):\n    visited = [False] * (n + 1)\n    queue = deque([start])\n    visited[start] = True\n    farthest_node = start\n    max_distance = 0\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if max_distance < 1:\n                    farthest_node = neighbor\n                    max_distance = 1\n    \n    return farthest_node, max_distance\n\n# Find the farthest node from vertex 1\nfarthest_node, _ = bfs(1)\n\n# Find the farthest node from the farthest node found in the previous step\nsecond_farthest_node, _ = bfs(farthest_node)\n\n# Calculate the distance between the two farthest nodes\ndistance = bfs(farthest_node)[1]\n\n# The minimum number of edges to add is the distance minus 1\nmin_edges_to_add = max(0, distance - 1)\n\n# Output the result\nprint(min_edges_to_add)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the path length at most 2\n    return max(0, (max_distance + 1) // 2 - 1)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate the result\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from vertex 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from vertex 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the shortest path length at most 2\n    return max(0, max_distance - 1)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate the result\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the path length at most 2\n    return max(0, 2 - max_distance)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate the result\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node_1, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the first BFS\n    farthest_node_2, _ = bfs(farthest_node_1)\n    \n    # Calculate the distance between the two farthest nodes\n    def bfs_distance(start, end):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            if current == end:\n                return distance\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    distance += 1\n        \n        return -1\n    \n    distance = bfs_distance(farthest_node_1, farthest_node_2)\n    \n    # Calculate the minimum number of edges to make the path length at most 2\n    if distance <= 2:\n        return 0\n    else:\n        return (distance - 2) // 2\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate and print the result\nresult = min_edges_to_make_path_length_two(n, edges)\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_at_most_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the previous step\n    _, max_distance = bfs(farthest_node)\n    \n    # The minimum number of edges to make the shortest path length at most 2\n    return max(0, (max_distance + 1) // 2 - 1)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate and print the result\nresult = min_edges_to_make_path_length_at_most_two(n, edges)\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_two(n, edges):\n    # Build the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        max_distance = 1\n                        farthest_node = neighbor\n        \n        return farthest_node, max_distance\n    \n    farthest_node, _ = bfs(1)\n    second_farthest_node, _ = bfs(farthest_node)\n    \n    # Perform BFS again to find the farthest node from the second farthest node\n    _, max_distance = bfs(second_farthest_node)\n    \n    # Calculate the minimum number of edges to make the path length at most 2\n    if max_distance <= 2:\n        return 0\n    else:\n        return max_distance - 2\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = min_edges_to_make_path_length_two(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_edges_to_make_path_length_two(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Perform BFS to find the farthest node from node 1\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if max_distance < 1:\n                        farthest_node = neighbor\n                        max_distance = 1\n        \n        return farthest_node, max_distance\n    \n    # Find the farthest node from node 1\n    farthest_node_1, _ = bfs(1)\n    \n    # Find the farthest node from the farthest node found in the first BFS\n    farthest_node_2, max_distance = bfs(farthest_node_1)\n    \n    # The minimum number of edges needed is the maximum distance minus 1\n    return max_distance - 1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate the result\nresult = min_edges_to_make_path_length_two(n, edges)\n\n# Print the result\nprint(result)"
        ]
    },
    {
        "question_title": "Familiar Operations",
        "question_content": "You are given two positive integers a and b. There are two possible operations:\n\n1. multiply one of the numbers by some prime p;\n2. divide one of the numbers on its prime factor p.\n\nWhat is the minimum number of operations required to obtain two integers having the same number of divisors? You are given several such pairs, you need to find the answer for each of them.\n\n\nInput Format\nThe first line contains a single integer t (1 \\le t \\le 10^5) \u2014 the number of pairs of integers for which you are to find the answer.\n\nEach of the next t lines contain two integers a_i and b_i (1 \\le a_i, b_i \\le 10^6).\n\n\nOutput Format\nOutput t lines \u2014 the i-th of them should contain the answer for the pair a_i, b_i.\n\n\nSample Input 1\n\n8\n9 10\n100 17\n220 70\n17 19\n4 18\n32 20\n100 32\n224 385\n\nSample Output 1\n\n1\n3\n1\n0\n1\n0\n1\n1\n\n\nNote\nThese are the numbers with equal number of divisors, which are optimal to obtain in the sample test case:\n\n- (27, 10), 4 divisors\n- (100, 1156), 9 divisors\n- (220, 140), 12 divisors\n- (17, 19), 2 divisors\n- (12, 18), 6 divisors\n- (50, 32), 6 divisors\n- (224, 1925), 12 divisors\n\nNote that there can be several optimal pairs of numbers.",
        "platform": "codeforces",
        "question_id": "1031/F",
        "contest_id": "1031",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef num_divisors(factors):\n    divisors = 1\n    for exponent in factors.values():\n        divisors *= (exponent + 1)\n    return divisors\n\ndef min_operations(a, b):\n    fa = prime_factors(a)\n    fb = prime_factors(b)\n    da = num_divisors(fa)\n    db = num_divisors(fb)\n    \n    if da == db:\n        return 0\n    \n    operations = 0\n    if da < db:\n        fa, fb = fb, fa\n        da, db = db, da\n    \n    for p in fa:\n        if p not in fb:\n            operations += 1\n        else:\n            fa[p] -= 1\n            if fa[p] == 0:\n                del fa[p]\n            fb[p] += 1\n    \n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import sqrt\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    \n    operations = 0\n    while da != db:\n        if da < db:\n            a *= 2\n            da = count_divisors(a)\n            operations += 1\n        else:\n            b *= 2\n            db = count_divisors(b)\n            operations += 1\n    return operations\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    index += 2\n    results.append(min_operations(a, b))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import Counter\nfrom math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef count_divisors(n):\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    divisors = 1\n    for count in factor_counts.values():\n        divisors *= (count + 1)\n    return divisors\n\ndef min_operations(a, b):\n    da, db = count_divisors(a), count_divisors(b)\n    if da == db:\n        return 0\n    if da < db:\n        a, b = b, a\n        da, db = db, da\n    operations = 0\n    while da != db:\n        if da % db == 0:\n            da //= db\n        else:\n            prime = prime_factors(da)[0]\n            if prime in prime_factors(b):\n                da //= prime\n            else:\n                db *= prime\n            operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import sqrt\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    \n    operations = float('inf')\n    for p in range(2, int(sqrt(max(a, b))) + 1):\n        if a % p == 0:\n            new_a = a // p\n            new_da = count_divisors(new_a)\n            if new_da == db:\n                operations = min(operations, 1)\n            if new_da < db:\n                operations = min(operations, 1 + min_operations(new_a, b))\n        if b % p == 0:\n            new_b = b // p\n            new_db = count_divisors(new_b)\n            if new_db == da:\n                operations = min(operations, 1)\n            if new_db < da:\n                operations = min(operations, 1 + min_operations(a, new_b))\n    \n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef num_divisors(factors):\n    divisors = 1\n    for exponent in factors.values():\n        divisors *= (exponent + 1)\n    return divisors\n\ndef min_operations(a, b):\n    fa = prime_factors(a)\n    fb = prime_factors(b)\n    da = num_divisors(fa)\n    db = num_divisors(fb)\n    \n    if da == db:\n        return 0\n    \n    operations = 0\n    if da < db:\n        a, b = b, a\n        fa, fb = fb, fa\n        da, db = db, da\n    \n    for p in fa:\n        if p not in fb:\n            operations += 1\n        elif fa[p] > fb[p]:\n            operations += (fa[p] - fb[p])\n    \n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import sqrt\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    \n    operations = 0\n    if da < db:\n        a, b = b, a\n        da, db = db, da\n    \n    while da != db:\n        if a % 2 == 0:\n            a //= 2\n        else:\n            a //= 3\n        da = count_divisors(a)\n        operations += 1\n    \n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef num_divisors(factors):\n    divisors = 1\n    for exponent in factors.values():\n        divisors *= (exponent + 1)\n    return divisors\n\ndef min_operations(a, b):\n    fa = prime_factors(a)\n    fb = prime_factors(b)\n    da = num_divisors(fa)\n    db = num_divisors(fb)\n    \n    if da == db:\n        return 0\n    \n    operations = 0\n    if da < db:\n        a, b = b, a\n        fa, fb = fb, fa\n        da, db = db, da\n    \n    for p in fa:\n        if p not in fb:\n            operations += 1\n        else:\n            if fa[p] > fb[p]:\n                operations += fa[p] - fb[p]\n    \n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import Counter\nfrom math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef count_divisors(n):\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    divisors = 1\n    for count in factor_counts.values():\n        divisors *= (count + 1)\n    return divisors\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    if da < db:\n        a, b = b, a\n        da, db = db, da\n    operations = 0\n    while da != db:\n        if da % db == 0:\n            da //= db\n        else:\n            prime = prime_factors(da)[0]\n            da //= prime\n            operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import sqrt\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    \n    operations = 0\n    while da != db:\n        if da < db:\n            a *= 2\n            da = count_divisors(a)\n            operations += 1\n        else:\n            b *= 2\n            db = count_divisors(b)\n            operations += 1\n    return operations\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    index += 2\n    results.append(min_operations(a, b))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom math import sqrt\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    \n    operations = 0\n    while da != db:\n        if da < db:\n            a *= 2\n            da = count_divisors(a)\n            operations += 1\n        else:\n            b *= 2\n            db = count_divisors(b)\n            operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef num_divisors(factors):\n    divisors = 1\n    for exponent in factors.values():\n        divisors *= (exponent + 1)\n    return divisors\n\ndef min_operations(a, b):\n    fa = prime_factors(a)\n    fb = prime_factors(b)\n    da = num_divisors(fa)\n    db = num_divisors(fb)\n    \n    if da == db:\n        return 0\n    \n    operations = 0\n    if da < db:\n        fa, fb = fb, fa\n        da, db = db, da\n    \n    for p in fa:\n        if p not in fb:\n            operations += 1\n        else:\n            fa[p] -= 1\n            if fa[p] == 0:\n                del fa[p]\n            fb[p] += 1\n    \n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import sqrt\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    \n    operations = 0\n    while da != db:\n        if da < db:\n            a *= 2\n            da = count_divisors(a)\n            operations += 1\n        else:\n            b *= 2\n            db = count_divisors(b)\n            operations += 1\n    return operations\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    index += 2\n    results.append(min_operations(a, b))\n\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import Counter\nfrom math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef count_divisors(n):\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    divisors = 1\n    for count in factor_counts.values():\n        divisors *= (count + 1)\n    return divisors\n\ndef min_operations(a, b):\n    da, db = count_divisors(a), count_divisors(b)\n    if da == db:\n        return 0\n    if da < db:\n        a, b = b, a\n        da, db = db, da\n    operations = 0\n    while da != db:\n        if da % db == 0:\n            da //= db\n        else:\n            prime = prime_factors(da)[0]\n            if prime in prime_factors(b):\n                da //= prime\n            else:\n                db *= prime\n            operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import sqrt\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    \n    operations = float('inf')\n    for p in range(2, int(sqrt(max(a, b))) + 1):\n        if a % p == 0:\n            new_a = a // p\n            new_da = count_divisors(new_a)\n            if new_da == db:\n                operations = min(operations, 1)\n            if new_da < db:\n                operations = min(operations, 1 + min_operations(new_a, b))\n        if b % p == 0:\n            new_b = b // p\n            new_db = count_divisors(new_b)\n            if new_db == da:\n                operations = min(operations, 1)\n            if new_db < da:\n                operations = min(operations, 1 + min_operations(a, new_b))\n    \n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef num_divisors(factors):\n    divisors = 1\n    for exponent in factors.values():\n        divisors *= (exponent + 1)\n    return divisors\n\ndef min_operations(a, b):\n    fa = prime_factors(a)\n    fb = prime_factors(b)\n    da = num_divisors(fa)\n    db = num_divisors(fb)\n    \n    if da == db:\n        return 0\n    \n    operations = 0\n    if da < db:\n        a, b = b, a\n        fa, fb = fb, fa\n        da, db = db, da\n    \n    for p in fa:\n        if p not in fb:\n            operations += 1\n        elif fa[p] > fb[p]:\n            operations += (fa[p] - fb[p])\n    \n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import sqrt\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    \n    operations = 0\n    if da < db:\n        a, b = b, a\n        da, db = db, da\n    \n    while da != db:\n        if a % 2 == 0:\n            a //= 2\n        else:\n            a //= 3\n        da = count_divisors(a)\n        operations += 1\n    \n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        while (n % i) == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n //= i\n        i += 1\n    if n > 1:\n        factors[n] = 1\n    return factors\n\ndef num_divisors(factors):\n    divisors = 1\n    for exponent in factors.values():\n        divisors *= (exponent + 1)\n    return divisors\n\ndef min_operations(a, b):\n    fa = prime_factors(a)\n    fb = prime_factors(b)\n    da = num_divisors(fa)\n    db = num_divisors(fb)\n    \n    if da == db:\n        return 0\n    \n    operations = 0\n    if da < db:\n        a, b = b, a\n        fa, fb = fb, fa\n        da, db = db, da\n    \n    for p in fa:\n        if p not in fb:\n            operations += 1\n        else:\n            if fa[p] > fb[p]:\n                operations += fa[p] - fb[p]\n    \n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import Counter\nfrom math import sqrt\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef count_divisors(n):\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n    divisors = 1\n    for count in factor_counts.values():\n        divisors *= (count + 1)\n    return divisors\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    if da < db:\n        a, b = b, a\n        da, db = db, da\n    operations = 0\n    while da != db:\n        if da % db == 0:\n            da //= db\n        else:\n            prime = prime_factors(da)[0]\n            da //= prime\n            operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import sqrt\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    \n    operations = 0\n    while da != db:\n        if da < db:\n            a *= 2\n            da = count_divisors(a)\n            operations += 1\n        else:\n            b *= 2\n            db = count_divisors(b)\n            operations += 1\n    return operations\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    index += 2\n    results.append(min_operations(a, b))\n\nfor result in results:\n    print(result)",
            "import sys\nfrom math import sqrt\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(sqrt(n)) + 1):\n        if n % i == 0:\n            if i * i == n:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef min_operations(a, b):\n    da = count_divisors(a)\n    db = count_divisors(b)\n    if da == db:\n        return 0\n    \n    operations = 0\n    while da != db:\n        if da < db:\n            a *= 2\n            da = count_divisors(a)\n            operations += 1\n        else:\n            b *= 2\n            db = count_divisors(b)\n            operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        results.append(min_operations(a, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Covered Points",
        "question_content": "You are given n segments on a Cartesian plane. Each segment's endpoints have integer coordinates. Segments can intersect with each other. No two segments lie on the same line.\n\nCount the number of distinct points with integer coordinates, which are covered by at least one segment.\n\n\nInput Format\nThe first line contains a single integer n (1 \\le n \\le 1000) \u2014 the number of segments.\n\nEach of the next n lines contains four integers Ax_i, Ay_i, Bx_i, By_i (-10^6 \\le Ax_i, Ay_i, Bx_i, By_i \\le 10^6) \u2014 the coordinates of the endpoints A, B (A \\ne B) of the i-th segment.\n\nIt is guaranteed that no two segments lie on the same line.\n\n\nOutput Format\nPrint a single integer \u2014 the number of distinct points with integer coordinates, which are covered by at least one segment.\n\n\nSample Input 1\n\n9\n0 0 4 4\n-1 5 4 0\n4 0 4 4\n5 2 11 2\n6 1 6 7\n5 6 11 6\n10 1 10 7\n7 0 9 8\n10 -1 11 -1\n\nSample Output 1\n\n42\n\n\nSample Input 2\n\n4\n-1 2 1 2\n-1 0 1 0\n-1 0 0 3\n0 3 1 0\n\nSample Output 2\n\n7\n\n\nNote\nThe image for the first example:\n\nSeveral key points are marked blue, the answer contains some non-marked points as well.\n\nThe image for the second example:",
        "platform": "codeforces",
        "question_id": "1036/E",
        "contest_id": "1036",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for i in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        x, y = x1, y1\n        add_point(points, x, y)\n        while x != x2 or y != y2:\n            x += dx\n            y += dy\n            add_point(points, x, y)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    points = defaultdict(bool)\n    \n    index = 1\n    for i in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for i in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(len(points))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = abs(x2 - x1)\n        dy = abs(y2 - y1)\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if (x1, y1) > (x2, y2):\n            x1, y1, x2, y2 = x2, y2, x1, y1\n        for i in range(g + 1):\n            add_point(points, x1 + dx * i, y1 + dy * i)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    if (x, y) not in points:\n        points.add((x, y))\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        x, y = x1, y1\n        add_point(points, x, y)\n        while x != x2 or y != y2:\n            x += dx\n            y += dy\n            add_point(points, x, y)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = set()\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(len(points))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        x, y = x1, y1\n        add_point(points, x, y)\n        while x != x2 or y != y2:\n            x += dx\n            y += dy\n            add_point(points, x, y)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for i in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        x, y = x1, y1\n        add_point(points, x, y)\n        while x != x2 or y != y2:\n            x += dx\n            y += dy\n            add_point(points, x, y)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    points = defaultdict(bool)\n    \n    index = 1\n    for i in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for i in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(len(points))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = abs(x2 - x1)\n        dy = abs(y2 - y1)\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if (x1, y1) > (x2, y2):\n            x1, y1, x2, y2 = x2, y2, x1, y1\n        for i in range(g + 1):\n            add_point(points, x1 + dx * i, y1 + dy * i)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    if (x, y) not in points:\n        points.add((x, y))\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        x, y = x1, y1\n        add_point(points, x, y)\n        while x != x2 or y != y2:\n            x += dx\n            y += dy\n            add_point(points, x, y)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = set()\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(len(points))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        if dx > 0:\n            for i in range(g + 1):\n                add_point(points, x1 + i * dx, y1 + i * dy)\n        else:\n            for i in range(g + 1):\n                add_point(points, x1 - i * dx, y1 - i * dy)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef add_point(points, x, y):\n    points[(x, y)] = True\n\ndef add_segment_points(points, x1, y1, x2, y2):\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            add_point(points, x1, y)\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            add_point(points, x, y1)\n    else:\n        dx = x2 - x1\n        dy = y2 - y1\n        g = gcd(dx, dy)\n        dx //= g\n        dy //= g\n        x, y = x1, y1\n        add_point(points, x, y)\n        while x != x2 or y != y2:\n            x += dx\n            y += dy\n            add_point(points, x, y)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    points = defaultdict(bool)\n    \n    for _ in range(n):\n        x1 = int(data[index])\n        y1 = int(data[index + 1])\n        x2 = int(data[index + 2])\n        y2 = int(data[index + 3])\n        index += 4\n        add_segment_points(points, x1, y1, x2, y2)\n    \n    print(sum(points.values()))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Maximum Reduction",
        "question_content": "Given an array a of n integers and an integer k (2 \\le k \\le n), where each element of the array is denoted by a_i (0 \\le i < n). Perform the operation z given below on a and print the value of z(a,k) modulo 10^{9}+7.\n\n\nInput Format\nThe first line of input contains two integers n and k (2 \\le k \\le n \\le 10^6)\u00a0\u2014 the length of the initial array a and the parameter k.\n\nThe second line of input contains n integers a_0, a_1, \\ldots, a_{n - 1} (1 \\le a_{i} \\le 10^9)\u00a0\u2014 the elements of the array a.\n\n\nOutput Format\nOutput the only integer, the value of z(a,k) modulo 10^9+7.\n\n\nSample Input 1\n\n3 2\n9 1 10\n\nSample Output 1\n\n29\n\n\nSample Input 2\n\n5 3\n5 8 7 1 9\n\nSample Output 2\n\n34\n\n\nNote\nIn the first example:\n\n- for a=(9,1,10), ans=19 and b=(9,10),\n- for a=(9,10), ans=10 and b=(10),\n- for a=(10), ans=0.\n\nSo the returned value is 19+10+0=29.\n\nIn the second example:\n\n- for a=(5,8,7,1,9), ans=25 and b=(8,8,9),\n- for a=(8,8,9), ans=9 and b=(9),\n- for a=(9), ans=0.\n\nSo the returned value is 25+9+0=34.",
        "platform": "codeforces",
        "question_id": "1037/F",
        "contest_id": "1037",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = []\n        for i in range(0, len(a), k):\n            b.append(max(a[i:i+k]))\n        a = b\n        ans += sum(a)\n    return ans % MOD\n\nprint(z(a, k))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = []\n        for i in range(0, len(a), k):\n            b.append(sum(a[i:i+k]))\n        a = b\n        ans = (ans + sum(a)) % MOD\n    return ans\n\nprint(z(a, k))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans += sum(b)\n        a = b[1:]\n    return ans % MOD\n\nprint(z(a, k))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate z(a, k)\ndef z(a, k):\n    MOD = 10**9 + 7\n    result = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans = sum(b)\n        result = (result + ans) % MOD\n        a = b[1:]\n    return result\n\n# Calculate and print the result\nprint(z(a, k))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans = (ans + sum(b)) % MOD\n        a = b[1:]\n    return ans\n\nprint(z(a, k))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans += sum(b)\n        a = b[1:]\n    return ans % MOD\n\nprint(z(a, k))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans += sum(b)\n        a = b[1:]\n    return ans % MOD\n\nprint(z(a, k))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    if k == 1:\n        return sum(a) % MOD\n    ans = 0\n    for i in range(n):\n        if i + k - 1 < n:\n            ans += sum(a[i:i+k]) % MOD\n    return ans % MOD\n\nresult = z(a, k)\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans += sum(b)\n        a = b[1:]\n    return ans % MOD\n\nprint(z(a, k))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans = (ans + sum(b)) % MOD\n        a = b[1:]\n    return ans\n\nprint(z(a, k))\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = []\n        for i in range(0, len(a), k):\n            b.append(max(a[i:i+k]))\n        a = b\n        ans += sum(a)\n    return ans % MOD\n\nprint(z(a, k))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = []\n        for i in range(0, len(a), k):\n            b.append(sum(a[i:i+k]))\n        a = b\n        ans = (ans + sum(a)) % MOD\n    return ans\n\nprint(z(a, k))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans += sum(b)\n        a = b[1:]\n    return ans % MOD\n\nprint(z(a, k))",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate z(a, k)\ndef z(a, k):\n    MOD = 10**9 + 7\n    result = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans = sum(b)\n        result = (result + ans) % MOD\n        a = b[1:]\n    return result\n\n# Calculate and print the result\nprint(z(a, k))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans = (ans + sum(b)) % MOD\n        a = b[1:]\n    return ans\n\nprint(z(a, k))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans += sum(b)\n        a = b[1:]\n    return ans % MOD\n\nprint(z(a, k))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans += sum(b)\n        a = b[1:]\n    return ans % MOD\n\nprint(z(a, k))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    if k == 1:\n        return sum(a) % MOD\n    ans = 0\n    for i in range(n):\n        if i + k - 1 < n:\n            ans += sum(a[i:i+k]) % MOD\n    return ans % MOD\n\nresult = z(a, k)\nprint(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans += sum(b)\n        a = b[1:]\n    return ans % MOD\n\nprint(z(a, k))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nMOD = 10**9 + 7\n\ndef z(a, k):\n    ans = 0\n    while len(a) >= k:\n        b = a[:k]\n        ans = (ans + sum(b)) % MOD\n        a = b[1:]\n    return ans\n\nprint(z(a, k))"
        ]
    },
    {
        "question_title": "You Are Given a Tree",
        "question_content": "A tree is an undirected graph with exactly one simple path between each pair of vertices. We call a set of simple paths k-valid if each vertex of the tree belongs to no more than one of these paths (including endpoints) and each path consists of exactly k vertices.\n\nYou are given a tree with n vertices. For each k from 1 to n inclusive find what is the maximum possible size of a k-valid set of simple paths.\n\n\nInput Format\nThe first line of the input contains a single integer n (2 \\le n \\le 100\\,000)\u00a0\u2014 the number of vertices in the tree.\n\nThen following n - 1 lines describe the tree, each of them contains two integers v, u (1 \\le v, u \\le n)\u00a0\u2014 endpoints of the corresponding edge.\n\nIt is guaranteed, that the given graph is a tree.\n\n\nOutput Format\nOutput n numbers, the i-th of which is the maximum possible number of paths in an i-valid set of paths.\n\n\nSample Input 1\n\n7\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n\nSample Output 1\n\n7\n3\n2\n1\n1\n1\n1\n\n\nSample Input 2\n\n6\n1 2\n2 3\n2 4\n1 5\n5 6\n\nSample Output 2\n\n6\n2\n2\n1\n1\n0\n\n\nNote\nOne way to achieve the optimal number of paths for the second sample is illustrated in the following picture:",
        "platform": "codeforces",
        "question_id": "1039/D",
        "contest_id": "1039",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, edges\n\ndef find_max_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def bfs(start):\n        queue = deque([start])\n        visited = set([start])\n        parent = {start: None}\n        level = 0\n        while queue:\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        parent[neighbor] = node\n                        queue.append(neighbor)\n            level += 1\n        return level\n    \n    max_paths = [0] * (n + 1)\n    for i in range(1, n + 1):\n        level = bfs(i)\n        max_paths[level] = max(max_paths[level], 1)\n        current = i\n        while current is not None:\n            parent = current\n            current = parent\n            level -= 1\n            if level > 0:\n                max_paths[level] = max(max_paths[level], 1)\n    \n    for i in range(2, n + 1):\n        max_paths[i] = max(max_paths[i], max_paths[i - 1])\n    \n    return max_paths[1:]\n\ndef main():\n    n, edges = read_input()\n    result = find_max_paths(n, edges)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def dfs(node, parent, k):\n        if k == 1:\n            return 1\n        if k == 2:\n            return 2\n        if k == 3:\n            return 3\n        if k == 4:\n            return 4\n        if k == 5:\n            return 5\n        if k == 6:\n            return 6\n        if k == 7:\n            return 7\n        if k == 8:\n            return 8\n        if k == 9:\n            return 9\n        if k == 10:\n            return 10\n        if k == 11:\n            return 11\n        if k == 12:\n            return 12\n        if k == 13:\n            return 13\n        if k == 14:\n            return 14\n        if k == 15:\n            return 15\n        if k == 16:\n            return 16\n        if k == 17:\n            return 17\n        if k == 18:\n            return 18\n        if k == 19:\n            return 19\n        if k == 20:\n            return 20\n        if k == 21:\n            return 21\n        if k == 22:\n            return 22\n        if k == 23:\n            return 23\n        if k == 24:\n            return 24\n        if k == 25:\n            return 25\n        if k == 26:\n            return 26\n        if k == 27:\n            return 27\n        if k == 28:\n            return 28\n        if k == 29:\n            return 29\n        if k == 30:\n            return 30\n        if k == 31:\n            return 31\n        if k == 32:\n            return 32\n        if k == 33:\n            return 33\n        if k == 34:\n            return 34\n        if k == 35:\n            return 35\n        if k == 36:\n            return 36\n        if k == 37:\n            return 37\n        if k == 38:\n            return 38\n        if k == 39:\n            return 39\n        if k == 40:\n            return 40\n        if k == 41:\n            return 41\n        if k == 42:\n            return 42\n        if k == 43:\n            return 43\n        if k == 44:\n            return 44\n        if k == 45:\n            return 45\n        if k == 46:\n            return 46\n        if k == 47:\n            return 47\n        if k == 48:\n            return 48\n        if k == 49:\n            return 49\n        if k == 50:\n            return 50\n        if k == 51:\n            return 51\n        if k == 52:\n            return 52\n        if k == 53:\n            return 53\n        if k == 54:\n            return 54\n        if k == 55:\n            return 55\n        if k == 56:\n            return 56\n        if k == 57:\n            return 57\n        if k == 58:\n            return 58\n        if k == 59:\n            return 59\n        if k == 60:\n            return 60\n        if k == 61:\n            return 61\n        if k == 62:\n            return 62\n        if k == 63:\n            return 63\n        if k == 64:\n            return 64\n        if k == 65:\n            return 65\n        if k == 66:\n            return 66\n        if k == 67:\n            return 67\n        if k == 68:\n            return 68\n        if k == 69:\n            return 69\n        if k == 70:\n            return 70\n        if k == 71:\n            return 71\n        if k == 72:\n            return 72\n        if k == 73:\n            return 73\n        if k == 74:\n            return 74\n        if k == 75:\n            return 75\n        if k == 76:\n            return 76\n        if k == 77:\n            return 77\n        if k == 78:\n            return 78\n        if k == 79:\n            return 79\n        if k == 80:\n            return 80\n        if k == 81:\n            return 81\n        if k == 82:\n            return 82\n        if k == 83:\n            return 83\n        if k == 84:\n            return 84\n        if k == 85:\n            return 85\n        if k == 86:\n            return 86\n        if k == 87:\n            return 87\n        if k == 88:\n            return 88\n        if k == 89:\n            return 89\n        if k == 90:\n            return 90\n        if k == 91:\n            return 91\n        if k == 92:\n            return 92\n        if k == 93:\n            return 93\n        if k == 94:\n            return 94\n        if k == 95:\n            return 95\n        if k == 96:\n            return 96\n        if k == 97:\n            return 97\n        if k == 98:\n            return 98\n        if k == 99:\n            return 99\n        if k == 100:\n            return 100\n        return 0\n    \n    result = [0] * n\n    for k in range(1, n + 1):\n        result[k - 1] = dfs(1, -1, k)\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    v = int(data[2 * i + 1])\n    u = int(data[2 * i + 2])\n    edges.append((v, u))\n\n# Solve the problem\nresult = max_k_valid_paths(n, edges)\n\n# Write output\nprint(\" \".join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, edges\n\ndef max_k_valid_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        path = []\n        while queue:\n            node = queue.popleft()\n            path.append(node)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        return path\n    \n    def max_paths(path):\n        path_length = len(path)\n        if path_length % 2 == 0:\n            return path_length // 2\n        else:\n            return (path_length - 1) // 2\n    \n    max_paths_list = []\n    for i in range(1, n + 1):\n        path = bfs(i)\n        max_paths_list.append(max_paths(path))\n    \n    return max_paths_list\n\ndef main():\n    n, edges = read_input()\n    result = max_k_valid_paths(n, edges)\n    for num in result:\n        print(num)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def dfs(node, parent, path):\n        path.append(node)\n        max_paths = 0\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                max_paths = max(max_paths, dfs(neighbor, node, path))\n        if len(path) % 2 == 0:\n            max_paths = max(max_paths, len(path) // 2)\n        path.pop()\n        return max_paths\n    \n    max_paths = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_paths[i] = dfs(i, -1, [])\n    \n    return max_paths[1:]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = max_k_valid_paths(n, edges)\n\n# Write output\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for v, u in edges:\n        adj_list[v].append(u)\n        adj_list[u].append(v)\n    \n    # Function to perform BFS and find the maximum number of k-valid paths\n    def bfs_max_paths(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        path_count = 0\n        \n        while queue:\n            current = queue.popleft()\n            path_count += 1\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        \n        return path_count\n    \n    # Calculate the maximum number of k-valid paths for each k from 1 to n\n    results = []\n    for k in range(1, n + 1):\n        max_paths = 0\n        for i in range(1, n + 1):\n            if not visited[i]:\n                max_paths += bfs_max_paths(i)\n        results.append(max_paths)\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate and print the results\nresults = max_k_valid_paths(n, edges)\nprint(\" \".join(map(str, results)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        level = 0\n        while queue:\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n            level += 1\n        return level\n    \n    max_paths = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_paths[i] = bfs(i)\n    \n    return max_paths[1:]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = max_k_valid_paths(n, edges)\n\n# Write output\nprint(\" \".join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for v, u in edges:\n        adj_list[v].append(u)\n        adj_list[u].append(v)\n    \n    # Function to perform BFS and find the maximum number of k-valid paths\n    def bfs_max_k_valid_paths(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        paths = 0\n        \n        while queue:\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                for neighbor in adj_list[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n                        paths += 1\n        \n        return paths\n    \n    # Calculate the maximum number of k-valid paths for each k from 1 to n\n    result = []\n    for k in range(1, n + 1):\n        result.append(bfs_max_k_valid_paths(k))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = max_k_valid_paths(n, edges)\n\n# Write output\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def dfs(node, parent, path):\n        path.append(node)\n        max_paths = 0\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                max_paths = max(max_paths, dfs(neighbor, node, path))\n        if len(path) == k:\n            return 1\n        elif len(path) > k:\n            return 0\n        return max_paths\n    \n    result = [0] * (n + 1)\n    for k in range(1, n + 1):\n        for node in range(1, n + 1):\n            result[k] = max(result[k], dfs(node, -1, []))\n    return result[1:]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = max_k_valid_paths(n, edges)\n\n# Write output\nprint(\" \".join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform BFS and find the maximum number of k-valid paths\ndef max_k_valid_paths(n, tree):\n    result = [0] * (n + 1)\n    \n    for k in range(1, n + 1):\n        visited = [False] * (n + 1)\n        queue = deque()\n        \n        for i in range(1, n + 1):\n            if not visited[i]:\n                queue.append(i)\n                visited[i] = True\n                path_length = 1\n                \n                while queue:\n                    node = queue.popleft()\n                    for neighbor in tree[node]:\n                        if not visited[neighbor]:\n                            visited[neighbor] = True\n                            queue.append(neighbor)\n                            path_length += 1\n                            if path_length == k:\n                                result[k] += 1\n                                break\n                    if path_length == k:\n                        break\n    \n    return result[1:]\n\n# Get the result\nresult = max_k_valid_paths(n, tree)\n\n# Print the result\nprint(\" \".join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, edges\n\ndef find_max_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def dfs(node, parent):\n        nonlocal max_paths\n        if len(graph[node]) == 1 and node != 1:\n            max_paths += 1\n            return 1\n        paths = 0\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                paths += dfs(neighbor, node)\n        if paths % 2 == 0:\n            max_paths += paths // 2\n        else:\n            max_paths += paths // 2 + 1\n        return paths + 1\n    \n    max_paths = 0\n    dfs(1, -1)\n    return max_paths\n\ndef main():\n    n, edges = read_input()\n    results = []\n    for k in range(1, n + 1):\n        max_paths = find_max_paths(n, edges)\n        results.append(max_paths)\n    print(\" \".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, edges\n\ndef find_max_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def bfs(start):\n        queue = deque([start])\n        visited = set([start])\n        parent = {start: None}\n        level = 0\n        while queue:\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        parent[neighbor] = node\n                        queue.append(neighbor)\n            level += 1\n        return level\n    \n    max_paths = [0] * (n + 1)\n    for i in range(1, n + 1):\n        level = bfs(i)\n        max_paths[level] = max(max_paths[level], 1)\n        current = i\n        while current is not None:\n            parent = current\n            current = parent\n            level -= 1\n            if level > 0:\n                max_paths[level] = max(max_paths[level], 1)\n    \n    for i in range(2, n + 1):\n        max_paths[i] = max(max_paths[i], max_paths[i - 1])\n    \n    return max_paths[1:]\n\ndef main():\n    n, edges = read_input()\n    result = find_max_paths(n, edges)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def dfs(node, parent, k):\n        if k == 1:\n            return 1\n        if k == 2:\n            return 2\n        if k == 3:\n            return 3\n        if k == 4:\n            return 4\n        if k == 5:\n            return 5\n        if k == 6:\n            return 6\n        if k == 7:\n            return 7\n        if k == 8:\n            return 8\n        if k == 9:\n            return 9\n        if k == 10:\n            return 10\n        if k == 11:\n            return 11\n        if k == 12:\n            return 12\n        if k == 13:\n            return 13\n        if k == 14:\n            return 14\n        if k == 15:\n            return 15\n        if k == 16:\n            return 16\n        if k == 17:\n            return 17\n        if k == 18:\n            return 18\n        if k == 19:\n            return 19\n        if k == 20:\n            return 20\n        if k == 21:\n            return 21\n        if k == 22:\n            return 22\n        if k == 23:\n            return 23\n        if k == 24:\n            return 24\n        if k == 25:\n            return 25\n        if k == 26:\n            return 26\n        if k == 27:\n            return 27\n        if k == 28:\n            return 28\n        if k == 29:\n            return 29\n        if k == 30:\n            return 30\n        if k == 31:\n            return 31\n        if k == 32:\n            return 32\n        if k == 33:\n            return 33\n        if k == 34:\n            return 34\n        if k == 35:\n            return 35\n        if k == 36:\n            return 36\n        if k == 37:\n            return 37\n        if k == 38:\n            return 38\n        if k == 39:\n            return 39\n        if k == 40:\n            return 40\n        if k == 41:\n            return 41\n        if k == 42:\n            return 42\n        if k == 43:\n            return 43\n        if k == 44:\n            return 44\n        if k == 45:\n            return 45\n        if k == 46:\n            return 46\n        if k == 47:\n            return 47\n        if k == 48:\n            return 48\n        if k == 49:\n            return 49\n        if k == 50:\n            return 50\n        if k == 51:\n            return 51\n        if k == 52:\n            return 52\n        if k == 53:\n            return 53\n        if k == 54:\n            return 54\n        if k == 55:\n            return 55\n        if k == 56:\n            return 56\n        if k == 57:\n            return 57\n        if k == 58:\n            return 58\n        if k == 59:\n            return 59\n        if k == 60:\n            return 60\n        if k == 61:\n            return 61\n        if k == 62:\n            return 62\n        if k == 63:\n            return 63\n        if k == 64:\n            return 64\n        if k == 65:\n            return 65\n        if k == 66:\n            return 66\n        if k == 67:\n            return 67\n        if k == 68:\n            return 68\n        if k == 69:\n            return 69\n        if k == 70:\n            return 70\n        if k == 71:\n            return 71\n        if k == 72:\n            return 72\n        if k == 73:\n            return 73\n        if k == 74:\n            return 74\n        if k == 75:\n            return 75\n        if k == 76:\n            return 76\n        if k == 77:\n            return 77\n        if k == 78:\n            return 78\n        if k == 79:\n            return 79\n        if k == 80:\n            return 80\n        if k == 81:\n            return 81\n        if k == 82:\n            return 82\n        if k == 83:\n            return 83\n        if k == 84:\n            return 84\n        if k == 85:\n            return 85\n        if k == 86:\n            return 86\n        if k == 87:\n            return 87\n        if k == 88:\n            return 88\n        if k == 89:\n            return 89\n        if k == 90:\n            return 90\n        if k == 91:\n            return 91\n        if k == 92:\n            return 92\n        if k == 93:\n            return 93\n        if k == 94:\n            return 94\n        if k == 95:\n            return 95\n        if k == 96:\n            return 96\n        if k == 97:\n            return 97\n        if k == 98:\n            return 98\n        if k == 99:\n            return 99\n        if k == 100:\n            return 100\n        return 0\n    \n    result = [0] * n\n    for k in range(1, n + 1):\n        result[k - 1] = dfs(1, -1, k)\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    v = int(data[2 * i + 1])\n    u = int(data[2 * i + 2])\n    edges.append((v, u))\n\n# Solve the problem\nresult = max_k_valid_paths(n, edges)\n\n# Write output\nprint(\" \".join(map(str, result)))",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, edges\n\ndef max_k_valid_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        path = []\n        while queue:\n            node = queue.popleft()\n            path.append(node)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        return path\n    \n    def max_paths(path):\n        path_length = len(path)\n        if path_length % 2 == 0:\n            return path_length // 2\n        else:\n            return (path_length - 1) // 2\n    \n    max_paths_list = []\n    for i in range(1, n + 1):\n        path = bfs(i)\n        max_paths_list.append(max_paths(path))\n    \n    return max_paths_list\n\ndef main():\n    n, edges = read_input()\n    result = max_k_valid_paths(n, edges)\n    for num in result:\n        print(num)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def dfs(node, parent, path):\n        path.append(node)\n        max_paths = 0\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                max_paths = max(max_paths, dfs(neighbor, node, path))\n        if len(path) % 2 == 0:\n            max_paths = max(max_paths, len(path) // 2)\n        path.pop()\n        return max_paths\n    \n    max_paths = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_paths[i] = dfs(i, -1, [])\n    \n    return max_paths[1:]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = max_k_valid_paths(n, edges)\n\n# Write output\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for v, u in edges:\n        adj_list[v].append(u)\n        adj_list[u].append(v)\n    \n    # Function to perform BFS and find the maximum number of k-valid paths\n    def bfs_max_paths(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        path_count = 0\n        \n        while queue:\n            current = queue.popleft()\n            path_count += 1\n            for neighbor in adj_list[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        \n        return path_count\n    \n    # Calculate the maximum number of k-valid paths for each k from 1 to n\n    results = []\n    for k in range(1, n + 1):\n        max_paths = 0\n        for i in range(1, n + 1):\n            if not visited[i]:\n                max_paths += bfs_max_paths(i)\n        results.append(max_paths)\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Calculate and print the results\nresults = max_k_valid_paths(n, edges)\nprint(\" \".join(map(str, results)))",
            "import sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        level = 0\n        while queue:\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n            level += 1\n        return level\n    \n    max_paths = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_paths[i] = bfs(i)\n    \n    return max_paths[1:]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = max_k_valid_paths(n, edges)\n\n# Write output\nprint(\" \".join(map(str, result)))",
            "import sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    # Build the adjacency list for the tree\n    adj_list = defaultdict(list)\n    for v, u in edges:\n        adj_list[v].append(u)\n        adj_list[u].append(v)\n    \n    # Function to perform BFS and find the maximum number of k-valid paths\n    def bfs_max_k_valid_paths(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        paths = 0\n        \n        while queue:\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                for neighbor in adj_list[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n                        paths += 1\n        \n        return paths\n    \n    # Calculate the maximum number of k-valid paths for each k from 1 to n\n    result = []\n    for k in range(1, n + 1):\n        result.append(bfs_max_k_valid_paths(k))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = max_k_valid_paths(n, edges)\n\n# Write output\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import defaultdict, deque\n\ndef max_k_valid_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def dfs(node, parent, path):\n        path.append(node)\n        max_paths = 0\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                max_paths = max(max_paths, dfs(neighbor, node, path))\n        if len(path) == k:\n            return 1\n        elif len(path) > k:\n            return 0\n        return max_paths\n    \n    result = [0] * (n + 1)\n    for k in range(1, n + 1):\n        for node in range(1, n + 1):\n            result[k] = max(result[k], dfs(node, -1, []))\n    return result[1:]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n - 1)]\n\n# Solve the problem\nresult = max_k_valid_paths(n, edges)\n\n# Write output\nprint(\" \".join(map(str, result)))",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform BFS and find the maximum number of k-valid paths\ndef max_k_valid_paths(n, tree):\n    result = [0] * (n + 1)\n    \n    for k in range(1, n + 1):\n        visited = [False] * (n + 1)\n        queue = deque()\n        \n        for i in range(1, n + 1):\n            if not visited[i]:\n                queue.append(i)\n                visited[i] = True\n                path_length = 1\n                \n                while queue:\n                    node = queue.popleft()\n                    for neighbor in tree[node]:\n                        if not visited[neighbor]:\n                            visited[neighbor] = True\n                            queue.append(neighbor)\n                            path_length += 1\n                            if path_length == k:\n                                result[k] += 1\n                                break\n                    if path_length == k:\n                        break\n    \n    return result[1:]\n\n# Get the result\nresult = max_k_valid_paths(n, tree)\n\n# Print the result\nprint(\" \".join(map(str, result)))",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, edges\n\ndef find_max_paths(n, edges):\n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    def dfs(node, parent):\n        nonlocal max_paths\n        if len(graph[node]) == 1 and node != 1:\n            max_paths += 1\n            return 1\n        paths = 0\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                paths += dfs(neighbor, node)\n        if paths % 2 == 0:\n            max_paths += paths // 2\n        else:\n            max_paths += paths // 2 + 1\n        return paths + 1\n    \n    max_paths = 0\n    dfs(1, -1)\n    return max_paths\n\ndef main():\n    n, edges = read_input()\n    results = []\n    for k in range(1, n + 1):\n        max_paths = find_max_paths(n, edges)\n        results.append(max_paths)\n    print(\" \".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Leaf Sets",
        "question_content": "You are given an undirected tree, consisting of n vertices.\n\nThe vertex is called a leaf if it has exactly one vertex adjacent to it.\n\nThe distance between some pair of vertices is the number of edges in the shortest path between them.\n\nLet's call some set of leaves beautiful if the maximum distance between any pair of leaves in it is less or equal to k.\n\nYou want to split all leaves into non-intersecting beautiful sets. What is the minimal number of sets in such a split?\n\n\nInput Format\nThe first line contains two integers n and k (3 \\le n \\le 10^6, 1 \\le k \\le 10^6) \u2014 the number of vertices in the tree and the maximum distance between any pair of leaves in each beautiful set.\n\nEach of the next n - 1 lines contains two integers v_i and u_i (1 \\le v_i, u_i \\le n) \u2014 the description of the i-th edge.\n\nIt is guaranteed that the given edges form a tree.\n\n\nOutput Format\nPrint a single integer \u2014 the minimal number of beautiful sets the split can have.\n\n\nSample Input 1\n\n9 3\n1 2\n1 3\n2 4\n2 5\n3 6\n6 7\n6 8\n3 9\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n5 3\n1 2\n2 3\n3 4\n4 5\n\nSample Output 2\n\n2\n\n\nSample Input 3\n\n6 1\n1 2\n1 3\n1 4\n1 5\n1 6\n\nSample Output 3\n\n5\n\n\nNote\nHere is the graph for the first example:",
        "platform": "codeforces",
        "question_id": "1042/F",
        "contest_id": "1042",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import deque\n\ndef min_beautiful_sets(n, k, edges):\n    # Build the adjacency list\n    adj = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        adj[v].append(u)\n        adj[u].append(v)\n    \n    # Find all leaves\n    leaves = [i for i in range(1, n + 1) if len(adj[i]) == 1]\n    \n    # Function to perform BFS and find the diameter of the tree\n    def bfs_diameter(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest = start\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    farthest = neighbor\n        return farthest\n    \n    # Find the farthest leaf from any leaf\n    farthest_leaf = bfs_diameter(leaves[0])\n    farthest_leaf = bfs_diameter(farthest_leaf)\n    \n    # Calculate the diameter of the tree\n    diameter = bfs_diameter(farthest_leaf)\n    \n    # Calculate the minimum number of beautiful sets\n    if diameter <= k:\n        return 1\n    else:\n        return (diameter + k - 1) // k\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\nedges = []\nfor i in range(n - 1):\n    v = int(data[2 + 2 * i])\n    u = int(data[3 + 2 * i])\n    edges.append((v, u))\n\n# Solve the problem\nresult = min_beautiful_sets(n, k, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, k, edges\n\ndef find_leaves(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    leaves = []\n    for i in range(1, n + 1):\n        if len(graph[i]) == 1:\n            leaves.append(i)\n    \n    return leaves\n\ndef bfs_to_find_furthest_leaf(start, graph):\n    queue = deque([start])\n    visited = set([start])\n    furthest_leaf = start\n    max_distance = 0\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                if len(graph[neighbor]) == 1:\n                    if max_distance < len(visited):\n                        max_distance = len(visited)\n                        furthest_leaf = neighbor\n    \n    return furthest_leaf, max_distance\n\ndef solve(n, k, edges):\n    leaves = find_leaves(n, edges)\n    beautiful_sets = 0\n    \n    while leaves:\n        start = leaves[0]\n        furthest_leaf, distance = bfs_to_find_furthest_leaf(start, edges)\n        if distance <= k:\n            beautiful_sets += 1\n            leaves = [leaf for leaf in leaves if leaf != furthest_leaf]\n        else:\n            beautiful_sets += 1\n            leaves = [leaf for leaf in leaves if leaf != start]\n    \n    return beautiful_sets\n\ndef main():\n    n, k, edges = read_input()\n    result = solve(n, k, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, k, edges\n\ndef find_leaves(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    leaves = []\n    for i in range(1, n + 1):\n        if len(graph[i]) == 1:\n            leaves.append(i)\n    \n    return leaves\n\ndef bfs_to_find_furthest_leaf(n, graph, start):\n    visited = [False] * (n + 1)\n    queue = deque([start])\n    visited[start] = True\n    furthest_leaf = start\n    max_distance = 0\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if graph[neighbor].count(current) == 1:\n                    furthest_leaf = neighbor\n                    max_distance += 1\n    \n    return furthest_leaf, max_distance\n\ndef solve(n, k, edges):\n    leaves = find_leaves(n, edges)\n    beautiful_sets = 0\n    \n    while leaves:\n        furthest_leaf, max_distance = bfs_to_find_furthest_leaf(n, edges, leaves[0])\n        if max_distance <= k:\n            beautiful_sets += 1\n            leaves.remove(furthest_leaf)\n        else:\n            break\n    \n    return beautiful_sets\n\ndef main():\n    n, k, edges = read_input()\n    result = solve(n, k, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef min_beautiful_sets(n, k, edges):\n    # Build the graph\n    graph = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    # Find all leaves\n    leaves = [i for i in range(1, n + 1) if len(graph[i]) == 1]\n    \n    # Function to perform BFS and find the farthest leaf from a given leaf\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest = start\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    farthest = neighbor\n        return farthest\n    \n    # Function to find the diameter of the tree\n    def tree_diameter():\n        leaf = leaves[0]\n        farthest = bfs(leaf)\n        return bfs(farthest)\n    \n    diameter = tree_diameter()\n    \n    # Calculate the minimum number of beautiful sets\n    if diameter <= k:\n        return 1\n    else:\n        return (diameter + k - 1) // k\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\nfor i in range(n - 1):\n    v = int(data[2 + 2 * i])\n    u = int(data[3 + 2 * i])\n    edges.append((v, u))\n\n# Output the result\nprint(min_beautiful_sets(n, k, edges))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, k, edges\n\ndef find_leaves(n, edges):\n    graph = defaultdict(list)\n    degree = [0] * (n + 1)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n        degree[v] += 1\n        degree[u] += 1\n    leaves = []\n    for i in range(1, n + 1):\n        if degree[i] == 1:\n            leaves.append(i)\n    return leaves\n\ndef bfs_to_find_furthest_leaf(n, graph, start):\n    visited = [False] * (n + 1)\n    queue = deque([start])\n    visited[start] = True\n    furthest_leaf = start\n    max_distance = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if max_distance < 1:\n                    max_distance = 1\n                    furthest_leaf = neighbor\n    return furthest_leaf, max_distance\n\ndef solve(n, k, edges):\n    leaves = find_leaves(n, edges)\n    beautiful_sets = 0\n    while leaves:\n        furthest_leaf, max_distance = bfs_to_find_furthest_leaf(n, edges, leaves[0])\n        if max_distance <= k:\n            beautiful_sets += 1\n            leaves.remove(furthest_leaf)\n        else:\n            break\n    return beautiful_sets\n\ndef main():\n    n, k, edges = read_input()\n    result = solve(n, k, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef min_beautiful_sets(n, k, edges):\n    # Build the adjacency list\n    adj = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        adj[v].append(u)\n        adj[u].append(v)\n    \n    # Find all leaves\n    leaves = [i for i in range(1, n + 1) if len(adj[i]) == 1]\n    \n    # Function to find the farthest leaf from a given leaf\n    def farthest_leaf(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest = start\n        while queue:\n            current = queue.popleft()\n            farthest = current\n            for neighbor in adj[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        return farthest\n    \n    # Function to find the diameter of the tree\n    def tree_diameter():\n        leaf1 = leaves[0]\n        leaf2 = farthest_leaf(leaf1)\n        return farthest_leaf(leaf2)\n    \n    diameter = tree_diameter()\n    \n    # Calculate the minimum number of beautiful sets\n    if diameter <= k:\n        return 1\n    else:\n        return (diameter + k - 1) // k\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\nfor i in range(n - 1):\n    v = int(data[2 + 2 * i])\n    u = int(data[3 + 2 * i])\n    edges.append((v, u))\n\n# Output the result\nprint(min_beautiful_sets(n, k, edges))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\n\nedges = []\nfor i in range(n - 1):\n    v = int(data[2 + 2 * i]) - 1\n    u = int(data[3 + 2 * i]) - 1\n    edges.append((v, u))\n\n# Build the graph\ngraph = defaultdict(list)\nfor v, u in edges:\n    graph[v].append(u)\n    graph[u].append(v)\n\n# Find all leaves\nleaves = [i for i in range(n) if len(graph[i]) == 1]\n\n# Function to find the farthest leaf from a given leaf\ndef farthest_leaf(start):\n    visited = [False] * n\n    queue = deque([start])\n    visited[start] = True\n    farthest = start\n    max_distance = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if len(graph[neighbor]) == 1:\n                    if max_distance < len(graph[current]):\n                        max_distance = len(graph[current])\n                        farthest = neighbor\n    return farthest\n\n# Function to find the diameter of the tree\ndef tree_diameter():\n    leaf1 = leaves[0]\n    leaf2 = farthest_leaf(leaf1)\n    return farthest_leaf(leaf2)\n\n# Calculate the diameter of the tree\ndiameter = tree_diameter()\n\n# Calculate the minimum number of beautiful sets\nmin_beautiful_sets = (diameter + k - 1) // k\n\n# Output the result\nprint(min_beautiful_sets)\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, k, edges\n\ndef find_leaves(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degree = [0] * (n + 1)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n        degree[v] += 1\n        degree[u] += 1\n    leaves = []\n    for i in range(1, n + 1):\n        if degree[i] == 1:\n            leaves.append(i)\n    return leaves\n\ndef bfs_to_find_furthest_leaf(start, graph, visited):\n    queue = deque([start])\n    visited[start] = True\n    furthest_leaf = start\n    max_distance = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if max_distance < abs(current - neighbor):\n                    max_distance = abs(current - neighbor)\n                    furthest_leaf = neighbor\n    return furthest_leaf, max_distance\n\ndef solve(n, k, edges):\n    leaves = find_leaves(n, edges)\n    visited = [False] * (n + 1)\n    beautiful_sets = 0\n    while leaves:\n        start = leaves[0]\n        furthest_leaf, _ = bfs_to_find_furthest_leaf(start, graph, visited)\n        beautiful_set = [furthest_leaf]\n        visited[furthest_leaf] = True\n        while beautiful_set:\n            new_leaves = []\n            for leaf in beautiful_set:\n                for neighbor in graph[leaf]:\n                    if not visited[neighbor]:\n                        new_leaves.append(neighbor)\n                        visited[neighbor] = True\n            beautiful_set = new_leaves\n        beautiful_sets += 1\n        leaves = [leaf for leaf in leaves if not visited[leaf]]\n    return beautiful_sets\n\nn, k, edges = read_input()\nprint(solve(n, k, edges))\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, k, edges\n\ndef find_leaves(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    leaves = []\n    for i in range(1, n + 1):\n        if len(graph[i]) == 1:\n            leaves.append(i)\n    \n    return leaves\n\ndef bfs_to_find_furthest_leaf(start, graph):\n    queue = deque([start])\n    visited = set([start])\n    furthest_leaf = start\n    max_distance = 0\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                if len(graph[neighbor]) == 1:\n                    if max_distance < len(visited):\n                        max_distance = len(visited)\n                        furthest_leaf = neighbor\n    \n    return furthest_leaf, max_distance\n\ndef solve(n, k, edges):\n    leaves = find_leaves(n, edges)\n    beautiful_sets = 0\n    \n    while leaves:\n        start = leaves[0]\n        furthest_leaf, distance = bfs_to_find_furthest_leaf(start, edges)\n        if distance <= k:\n            beautiful_sets += 1\n            leaves = [leaf for leaf in leaves if leaf != start and leaf != furthest_leaf]\n        else:\n            beautiful_sets += 1\n            leaves = [leaf for leaf in leaves if leaf != start]\n    \n    return beautiful_sets\n\ndef main():\n    n, k, edges = read_input()\n    result = solve(n, k, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef min_beautiful_sets(n, k, edges):\n    # Build the adjacency list\n    adj = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        adj[v].append(u)\n        adj[u].append(v)\n    \n    # Find all leaves\n    leaves = [i for i in range(1, n + 1) if len(adj[i]) == 1]\n    \n    # Function to find the farthest leaf from a given leaf\n    def farthest_leaf(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest = start\n        while queue:\n            current = queue.popleft()\n            for neighbor in adj[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    farthest = neighbor\n                    queue.append(neighbor)\n        return farthest\n    \n    # Function to find the diameter of the tree\n    def tree_diameter():\n        leaf1 = leaves[0]\n        leaf2 = farthest_leaf(leaf1)\n        return farthest_leaf(leaf2)\n    \n    # Calculate the diameter of the tree\n    diameter = tree_diameter()\n    \n    # The minimum number of beautiful sets is the diameter divided by (k + 1)\n    return (diameter + k) // (k + 1)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(n - 1)]\n\n# Output the result\nprint(min_beautiful_sets(n, k, edges))\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import deque\n\ndef min_beautiful_sets(n, k, edges):\n    # Build the adjacency list\n    adj = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        adj[v].append(u)\n        adj[u].append(v)\n    \n    # Find all leaves\n    leaves = [i for i in range(1, n + 1) if len(adj[i]) == 1]\n    \n    # Function to perform BFS and find the diameter of the tree\n    def bfs_diameter(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest = start\n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    farthest = neighbor\n        return farthest\n    \n    # Find the farthest leaf from any leaf\n    farthest_leaf = bfs_diameter(leaves[0])\n    farthest_leaf = bfs_diameter(farthest_leaf)\n    \n    # Calculate the diameter of the tree\n    diameter = bfs_diameter(farthest_leaf)\n    \n    # Calculate the minimum number of beautiful sets\n    if diameter <= k:\n        return 1\n    else:\n        return (diameter + k - 1) // k\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\nedges = []\nfor i in range(n - 1):\n    v = int(data[2 + 2 * i])\n    u = int(data[3 + 2 * i])\n    edges.append((v, u))\n\n# Solve the problem\nresult = min_beautiful_sets(n, k, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, k, edges\n\ndef find_leaves(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    leaves = []\n    for i in range(1, n + 1):\n        if len(graph[i]) == 1:\n            leaves.append(i)\n    \n    return leaves\n\ndef bfs_to_find_furthest_leaf(start, graph):\n    queue = deque([start])\n    visited = set([start])\n    furthest_leaf = start\n    max_distance = 0\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                if len(graph[neighbor]) == 1:\n                    if max_distance < len(visited):\n                        max_distance = len(visited)\n                        furthest_leaf = neighbor\n    \n    return furthest_leaf, max_distance\n\ndef solve(n, k, edges):\n    leaves = find_leaves(n, edges)\n    beautiful_sets = 0\n    \n    while leaves:\n        start = leaves[0]\n        furthest_leaf, distance = bfs_to_find_furthest_leaf(start, edges)\n        if distance <= k:\n            beautiful_sets += 1\n            leaves = [leaf for leaf in leaves if leaf != furthest_leaf]\n        else:\n            beautiful_sets += 1\n            leaves = [leaf for leaf in leaves if leaf != start]\n    \n    return beautiful_sets\n\ndef main():\n    n, k, edges = read_input()\n    result = solve(n, k, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, k, edges\n\ndef find_leaves(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    leaves = []\n    for i in range(1, n + 1):\n        if len(graph[i]) == 1:\n            leaves.append(i)\n    \n    return leaves\n\ndef bfs_to_find_furthest_leaf(n, graph, start):\n    visited = [False] * (n + 1)\n    queue = deque([start])\n    visited[start] = True\n    furthest_leaf = start\n    max_distance = 0\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if graph[neighbor].count(current) == 1:\n                    furthest_leaf = neighbor\n                    max_distance += 1\n    \n    return furthest_leaf, max_distance\n\ndef solve(n, k, edges):\n    leaves = find_leaves(n, edges)\n    beautiful_sets = 0\n    \n    while leaves:\n        furthest_leaf, max_distance = bfs_to_find_furthest_leaf(n, edges, leaves[0])\n        if max_distance <= k:\n            beautiful_sets += 1\n            leaves.remove(furthest_leaf)\n        else:\n            break\n    \n    return beautiful_sets\n\ndef main():\n    n, k, edges = read_input()\n    result = solve(n, k, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef min_beautiful_sets(n, k, edges):\n    # Build the graph\n    graph = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    # Find all leaves\n    leaves = [i for i in range(1, n + 1) if len(graph[i]) == 1]\n    \n    # Function to perform BFS and find the farthest leaf from a given leaf\n    def bfs(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest = start\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    farthest = neighbor\n        return farthest\n    \n    # Function to find the diameter of the tree\n    def tree_diameter():\n        leaf = leaves[0]\n        farthest = bfs(leaf)\n        return bfs(farthest)\n    \n    diameter = tree_diameter()\n    \n    # Calculate the minimum number of beautiful sets\n    if diameter <= k:\n        return 1\n    else:\n        return (diameter + k - 1) // k\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\nfor i in range(n - 1):\n    v = int(data[2 + 2 * i])\n    u = int(data[3 + 2 * i])\n    edges.append((v, u))\n\n# Output the result\nprint(min_beautiful_sets(n, k, edges))",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, k, edges\n\ndef find_leaves(n, edges):\n    graph = defaultdict(list)\n    degree = [0] * (n + 1)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n        degree[v] += 1\n        degree[u] += 1\n    leaves = []\n    for i in range(1, n + 1):\n        if degree[i] == 1:\n            leaves.append(i)\n    return leaves\n\ndef bfs_to_find_furthest_leaf(n, graph, start):\n    visited = [False] * (n + 1)\n    queue = deque([start])\n    visited[start] = True\n    furthest_leaf = start\n    max_distance = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if max_distance < 1:\n                    max_distance = 1\n                    furthest_leaf = neighbor\n    return furthest_leaf, max_distance\n\ndef solve(n, k, edges):\n    leaves = find_leaves(n, edges)\n    beautiful_sets = 0\n    while leaves:\n        furthest_leaf, max_distance = bfs_to_find_furthest_leaf(n, edges, leaves[0])\n        if max_distance <= k:\n            beautiful_sets += 1\n            leaves.remove(furthest_leaf)\n        else:\n            break\n    return beautiful_sets\n\ndef main():\n    n, k, edges = read_input()\n    result = solve(n, k, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef min_beautiful_sets(n, k, edges):\n    # Build the adjacency list\n    adj = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        adj[v].append(u)\n        adj[u].append(v)\n    \n    # Find all leaves\n    leaves = [i for i in range(1, n + 1) if len(adj[i]) == 1]\n    \n    # Function to find the farthest leaf from a given leaf\n    def farthest_leaf(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest = start\n        while queue:\n            current = queue.popleft()\n            farthest = current\n            for neighbor in adj[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        return farthest\n    \n    # Function to find the diameter of the tree\n    def tree_diameter():\n        leaf1 = leaves[0]\n        leaf2 = farthest_leaf(leaf1)\n        return farthest_leaf(leaf2)\n    \n    diameter = tree_diameter()\n    \n    # Calculate the minimum number of beautiful sets\n    if diameter <= k:\n        return 1\n    else:\n        return (diameter + k - 1) // k\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\nfor i in range(n - 1):\n    v = int(data[2 + 2 * i])\n    u = int(data[3 + 2 * i])\n    edges.append((v, u))\n\n# Output the result\nprint(min_beautiful_sets(n, k, edges))",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\n\nedges = []\nfor i in range(n - 1):\n    v = int(data[2 + 2 * i]) - 1\n    u = int(data[3 + 2 * i]) - 1\n    edges.append((v, u))\n\n# Build the graph\ngraph = defaultdict(list)\nfor v, u in edges:\n    graph[v].append(u)\n    graph[u].append(v)\n\n# Find all leaves\nleaves = [i for i in range(n) if len(graph[i]) == 1]\n\n# Function to find the farthest leaf from a given leaf\ndef farthest_leaf(start):\n    visited = [False] * n\n    queue = deque([start])\n    visited[start] = True\n    farthest = start\n    max_distance = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if len(graph[neighbor]) == 1:\n                    if max_distance < len(graph[current]):\n                        max_distance = len(graph[current])\n                        farthest = neighbor\n    return farthest\n\n# Function to find the diameter of the tree\ndef tree_diameter():\n    leaf1 = leaves[0]\n    leaf2 = farthest_leaf(leaf1)\n    return farthest_leaf(leaf2)\n\n# Calculate the diameter of the tree\ndiameter = tree_diameter()\n\n# Calculate the minimum number of beautiful sets\nmin_beautiful_sets = (diameter + k - 1) // k\n\n# Output the result\nprint(min_beautiful_sets)",
            "import sys\nfrom collections import deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, k, edges\n\ndef find_leaves(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    degree = [0] * (n + 1)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n        degree[v] += 1\n        degree[u] += 1\n    leaves = []\n    for i in range(1, n + 1):\n        if degree[i] == 1:\n            leaves.append(i)\n    return leaves\n\ndef bfs_to_find_furthest_leaf(start, graph, visited):\n    queue = deque([start])\n    visited[start] = True\n    furthest_leaf = start\n    max_distance = 0\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if max_distance < abs(current - neighbor):\n                    max_distance = abs(current - neighbor)\n                    furthest_leaf = neighbor\n    return furthest_leaf, max_distance\n\ndef solve(n, k, edges):\n    leaves = find_leaves(n, edges)\n    visited = [False] * (n + 1)\n    beautiful_sets = 0\n    while leaves:\n        start = leaves[0]\n        furthest_leaf, _ = bfs_to_find_furthest_leaf(start, graph, visited)\n        beautiful_set = [furthest_leaf]\n        visited[furthest_leaf] = True\n        while beautiful_set:\n            new_leaves = []\n            for leaf in beautiful_set:\n                for neighbor in graph[leaf]:\n                    if not visited[neighbor]:\n                        new_leaves.append(neighbor)\n                        visited[neighbor] = True\n            beautiful_set = new_leaves\n        beautiful_sets += 1\n        leaves = [leaf for leaf in leaves if not visited[leaf]]\n    return beautiful_sets\n\nn, k, edges = read_input()\nprint(solve(n, k, edges))",
            "import sys\nfrom collections import deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        edges.append((v, u))\n        index += 2\n    return n, k, edges\n\ndef find_leaves(n, edges):\n    graph = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    leaves = []\n    for i in range(1, n + 1):\n        if len(graph[i]) == 1:\n            leaves.append(i)\n    \n    return leaves\n\ndef bfs_to_find_furthest_leaf(start, graph):\n    queue = deque([start])\n    visited = set([start])\n    furthest_leaf = start\n    max_distance = 0\n    \n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                if len(graph[neighbor]) == 1:\n                    if max_distance < len(visited):\n                        max_distance = len(visited)\n                        furthest_leaf = neighbor\n    \n    return furthest_leaf, max_distance\n\ndef solve(n, k, edges):\n    leaves = find_leaves(n, edges)\n    beautiful_sets = 0\n    \n    while leaves:\n        start = leaves[0]\n        furthest_leaf, distance = bfs_to_find_furthest_leaf(start, edges)\n        if distance <= k:\n            beautiful_sets += 1\n            leaves = [leaf for leaf in leaves if leaf != start and leaf != furthest_leaf]\n        else:\n            beautiful_sets += 1\n            leaves = [leaf for leaf in leaves if leaf != start]\n    \n    return beautiful_sets\n\ndef main():\n    n, k, edges = read_input()\n    result = solve(n, k, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef min_beautiful_sets(n, k, edges):\n    # Build the adjacency list\n    adj = [[] for _ in range(n + 1)]\n    for v, u in edges:\n        adj[v].append(u)\n        adj[u].append(v)\n    \n    # Find all leaves\n    leaves = [i for i in range(1, n + 1) if len(adj[i]) == 1]\n    \n    # Function to find the farthest leaf from a given leaf\n    def farthest_leaf(start):\n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        farthest = start\n        while queue:\n            current = queue.popleft()\n            for neighbor in adj[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    farthest = neighbor\n                    queue.append(neighbor)\n        return farthest\n    \n    # Function to find the diameter of the tree\n    def tree_diameter():\n        leaf1 = leaves[0]\n        leaf2 = farthest_leaf(leaf1)\n        return farthest_leaf(leaf2)\n    \n    # Calculate the diameter of the tree\n    diameter = tree_diameter()\n    \n    # The minimum number of beautiful sets is the diameter divided by (k + 1)\n    return (diameter + k) // (k + 1)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(n - 1)]\n\n# Output the result\nprint(min_beautiful_sets(n, k, edges))"
        ]
    },
    {
        "question_title": "Space Isaac",
        "question_content": "Everybody seems to think that the Martians are green, but it turns out they are metallic pink and fat. Ajs has two bags of distinct nonnegative integers. The bags are disjoint, and the union of the sets of numbers in the bags is \\{0,1,\u2026,M-1\\}, for some positive integer M. Ajs draws a number from the first bag and a number from the second bag, and then sums them modulo M.\n\nWhat are the residues modulo M that Ajs cannot obtain with this action?\n\n\nInput Format\nThe first line contains two positive integer N (1 \\leq N \\leq 200\\,000) and M (N+1 \\leq M \\leq 10^{9}), denoting the number of the elements in the first bag and the modulus, respectively.\n\nThe second line contains N nonnegative integers a_1,a_2,\\ldots,a_N (0 \\leq a_1<a_2< \\ldots< a_N<M), the contents of the first bag.\n\n\nOutput Format\nIn the first line, output the cardinality K of the set of residues modulo M which Ajs cannot obtain.\n\nIn the second line of the output, print K space-separated integers greater or equal than zero and less than M, which represent the residues Ajs cannot obtain. The outputs should be sorted in increasing order of magnitude. If K=0, do not output the second line.\n\n\nSample Input 1\n\n2 5\n3 4\n\nSample Output 1\n\n1\n2\n\n\nSample Input 2\n\n4 1000000000\n5 25 125 625\n\nSample Output 2\n\n0\n\n\nSample Input 3\n\n2 4\n1 3\n\nSample Output 3\n\n2\n0 2\n\n\nNote\nIn the first sample, the first bag and the second bag contain \\{3,4\\} and \\{0,1,2\\}, respectively. Ajs can obtain every residue modulo 5 except the residue 2: 4+1 \\equiv 0, \\, 4+2 \\equiv 1, \\, 3+0 \\equiv 3, \\, 3+1 \\equiv 4 modulo 5. One can check that there is no choice of elements from the first and the second bag which sum to 2 modulo 5.\n\nIn the second sample, the contents of the first bag are \\{5,25,125,625\\}, while the second bag contains all other nonnegative integers with at most 9 decimal digits. Every residue modulo 1\\,000\\,000\\,000 can be obtained as a sum of an element in the first bag and an element in the second bag.",
        "platform": "codeforces",
        "question_id": "1045/B",
        "contest_id": "1045",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize variables\nresidues = set(range(M))\nfor a in A:\n    residues -= set((a + b) % M for b in range(M))\n\n# Output the result\nK = len(residues)\nif K > 0:\n    print(K)\n    print(*sorted(residues))\nelse:\n    print(0)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of obtainable residues\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of obtainable residues\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize variables\nresidues = set(range(M))\nfor a in A:\n    residues -= set((a + b) % M for b in range(M))\n\n# Output the result\nK = len(residues)\nif K > 0:\n    print(K)\n    print(*sorted(residues))\nelse:\n    print(0)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize the set of residues that can be obtained\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of obtainable residues\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of obtainable residues\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of possible residues\npossible_residues = set(range(M))\n\n# Iterate through each element in the first bag\nfor a in A:\n    # Remove all residues that cannot be obtained with the current element\n    possible_residues -= { (a + b) % M for b in range(M) }\n\n# Output the cardinality of the set of residues that cannot be obtained\nprint(len(possible_residues))\n\n# Output the residues that cannot be obtained\nif possible_residues:\n    print(' '.join(map(str, sorted(possible_residues))))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of obtainable residues\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize variables\nresidues = set(range(M))\nfor a in A:\n    residues -= { (a + b) % M for b in range(M) }\n\n# Output the result\nK = len(residues)\nif K > 0:\n    print(K)\n    print(*sorted(residues))\nelse:\n    print(0)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize variables\nresidues = set(range(M))\nfor a in A:\n    residues -= set((a + b) % M for b in range(M))\n\n# Output the result\nK = len(residues)\nif K > 0:\n    print(K)\n    print(*sorted(residues))\nelse:\n    print(0)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of obtainable residues\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of obtainable residues\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize variables\nresidues = set(range(M))\nfor a in A:\n    residues -= set((a + b) % M for b in range(M))\n\n# Output the result\nK = len(residues)\nif K > 0:\n    print(K)\n    print(*sorted(residues))\nelse:\n    print(0)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize the set of residues that can be obtained\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of obtainable residues\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of obtainable residues\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of possible residues\npossible_residues = set(range(M))\n\n# Iterate through each element in the first bag\nfor a in A:\n    # Remove all residues that cannot be obtained with the current element\n    possible_residues -= { (a + b) % M for b in range(M) }\n\n# Output the cardinality of the set of residues that cannot be obtained\nprint(len(possible_residues))\n\n# Output the residues that cannot be obtained\nif possible_residues:\n    print(' '.join(map(str, sorted(possible_residues))))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize a set to keep track of obtainable residues\nobtainable = set()\n\n# Iterate through all pairs of elements from the two bags\nfor a in A:\n    for b in range(M):\n        obtainable.add((a + b) % M)\n\n# Find the residues that cannot be obtained\nunobtainable = [i for i in range(M) if i not in obtainable]\n\n# Output the result\nprint(len(unobtainable))\nif unobtainable:\n    print(\" \".join(map(str, unobtainable)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nA = list(map(int, data[2:]))\n\n# Initialize variables\nresidues = set(range(M))\nfor a in A:\n    residues -= { (a + b) % M for b in range(M) }\n\n# Output the result\nK = len(residues)\nif K > 0:\n    print(K)\n    print(*sorted(residues))\nelse:\n    print(0)"
        ]
    },
    {
        "question_title": "The Shortest Statement",
        "question_content": "You are given a weighed undirected connected graph, consisting of n vertices and m edges.\n\nYou should answer q queries, the i-th query is to find the shortest distance between vertices u_i and v_i.\n\n\nInput Format\nThe first line contains two integers n and m (1 \\le n, m \\le 10^5, m - n \\le 20) \u2014 the number of vertices and edges in the graph.\n\nNext m lines contain the edges: the i-th edge is a triple of integers v_i, u_i, d_i (1 \\le u_i, v_i \\le n, 1 \\le d_i \\le 10^9, u_i \\neq v_i). This triple means that there is an edge between vertices u_i and v_i of weight d_i. It is guaranteed that graph contains no self-loops and multiple edges.\n\nThe next line contains a single integer q (1 \\le q \\le 10^5) \u2014 the number of queries.\n\nEach of the next q lines contains two integers u_i and v_i (1 \\le u_i, v_i \\le n) \u2014 descriptions of the queries.\n\nPay attention to the restriction m - n \\le 20.\n\n\nOutput Format\nPrint q lines.\n\nThe i-th line should contain the answer to the i-th query \u2014 the shortest distance between vertices u_i and v_i.\n\n\nSample Input 1\n\n3 3\n1 2 3\n2 3 1\n3 1 5\n3\n1 2\n1 3\n2 3\n\nSample Output 1\n\n3\n4\n1\n\n\nSample Input 2\n\n8 13\n1 2 4\n2 3 6\n3 4 1\n4 5 12\n5 6 3\n6 7 8\n7 8 7\n1 4 1\n1 8 3\n2 6 9\n2 7 1\n4 6 3\n6 8 2\n8\n1 5\n1 7\n2 3\n2 8\n3 7\n3 4\n6 8\n7 8\n\nSample Output 2\n\n7\n5\n6\n7\n7\n1\n2\n7",
        "platform": "codeforces",
        "question_id": "1051/F",
        "contest_id": "1051",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        queries.append((u, v))\n        index += 2\n    \n    distances = dijkstra(graph, 1, n)\n    \n    for u, v in queries:\n        print(distances[u] + distances[v])\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        queries.append((u, v))\n        index += 2\n    \n    distances = dijkstra(graph, 1, n)\n    \n    for u, v in queries:\n        print(distances[u] + distances[v])\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        queries.append((u, v))\n        index += 2\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    distances = dijkstra(graph, 1, n)\n    \n    for u, v in queries:\n        print(distances[u] + distances[v])\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        queries.append((u, v))\n        index += 2\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        queries.append((u, v))\n        index += 2\n    \n    distances = dijkstra(graph, 1, n)\n    \n    for u, v in queries:\n        print(distances[u] + distances[v])\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        queries.append((u, v))\n        index += 2\n    \n    distances = dijkstra(graph, 1, n)\n    \n    for u, v in queries:\n        print(distances[u] + distances[v])\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        queries.append((u, v))\n        index += 2\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    distances = dijkstra(graph, 1, n)\n    \n    for u, v in queries:\n        print(distances[u] + distances[v])\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        queries.append((u, v))\n        index += 2\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node]:\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        d = int(data[index + 2])\n        index += 3\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        queries.append((u, v))\n    \n    for u, v in queries:\n        distances = dijkstra(graph, u, n)\n        print(distances[v])\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Increasing Frequency",
        "question_content": "You are given array a of length n. You can choose one segment [l, r] (1 \\le l \\le r \\le n) and integer value k (positive, negative or even zero) and change a_l, a_{l + 1}, \\dots, a_r by k each (i.e. a_i := a_i + k for each l \\le i \\le r).\n\nWhat is the maximum possible number of elements with value c that can be obtained after one such operation?\n\n\nInput Format\nThe first line contains two integers n and c (1 \\le n \\le 5 \\cdot 10^5, 1 \\le c \\le 5 \\cdot 10^5) \u2014 the length of array and the value c to obtain.\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le 5 \\cdot 10^5) \u2014 array a.\n\n\nOutput Format\nPrint one integer \u2014 the maximum possible number of elements with value c which can be obtained after performing operation described above.\n\n\nSample Input 1\n\n6 9\n9 9 9 9 9 9\n\nSample Output 1\n\n6\n\n\nSample Input 2\n\n3 2\n6 2 6\n\nSample Output 2\n\n2\n\n\nNote\nIn the first example we can choose any segment and k = 0. The array will stay same.\n\nIn the second example we can choose segment [1, 3] and k = -4. The array will become [2, -2, 2].",
        "platform": "codeforces",
        "question_id": "1082/E",
        "contest_id": "1082",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nn, c = map(int, input().split())\na = list(map(int, input().split()))\n\n# Count the number of elements already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return the count\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum possible number of elements equal to c is n-1\n    print(n-1)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return n\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum number of elements that can be made equal to c\n    # is the number of elements that are not equal to c plus one\n    print(n - count_c + 1)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the count of elements equal to c\ncount = a.count(c)\n\n# Iterate through the array to find the maximum possible number of elements equal to c\nfor i in range(n):\n    if a[i] < c:\n        count += 1\n    elif a[i] > c:\n        count -= 1\n\n# Print the result\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return n\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum possible number of elements equal to c is n-1\n    print(n-1)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount = a.count(c)\n\n# Iterate through the array to find the maximum possible number of elements equal to c\nfor i in range(n):\n    if a[i] < c:\n        count += 1\n    elif a[i] > c:\n        count -= 1\n\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return n\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum possible number of elements with value c is n - 1\n    print(n - 1)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return n\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum number of elements that can be made equal to c\n    # is n - 1 (since we can increase one element to c by decreasing another)\n    print(n - 1)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount = a.count(c)\n\n# Iterate through the array to find the maximum possible number of elements equal to c\nfor i in range(n):\n    if a[i] < c:\n        count += 1\n    elif a[i] > c:\n        count -= 1\n\nprint(count)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount = a.count(c)\n\n# Iterate through the array to find the maximum possible number of elements equal to c\nfor i in range(n):\n    if a[i] == c:\n        continue\n    # Try to make the current element equal to c by changing the segment [i, n-1]\n    if a[i] < c:\n        k = c - a[i]\n        if k % 2 == 0:\n            count += 1\n    else:\n        k = a[i] - c\n        if k % 2 == 0:\n            count += 1\n\nprint(count)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return n\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum possible number of elements with value c is n - 1\n    print(n - 1)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nn, c = map(int, input().split())\na = list(map(int, input().split()))\n\n# Count the number of elements already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return the count\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum possible number of elements equal to c is n-1\n    print(n-1)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return n\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum number of elements that can be made equal to c\n    # is the number of elements that are not equal to c plus one\n    print(n - count_c + 1)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the count of elements equal to c\ncount = a.count(c)\n\n# Iterate through the array to find the maximum possible number of elements equal to c\nfor i in range(n):\n    if a[i] < c:\n        count += 1\n    elif a[i] > c:\n        count -= 1\n\n# Print the result\nprint(count)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return n\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum possible number of elements equal to c is n-1\n    print(n-1)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount = a.count(c)\n\n# Iterate through the array to find the maximum possible number of elements equal to c\nfor i in range(n):\n    if a[i] < c:\n        count += 1\n    elif a[i] > c:\n        count -= 1\n\nprint(count)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return n\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum possible number of elements with value c is n - 1\n    print(n - 1)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return n\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum number of elements that can be made equal to c\n    # is n - 1 (since we can increase one element to c by decreasing another)\n    print(n - 1)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount = a.count(c)\n\n# Iterate through the array to find the maximum possible number of elements equal to c\nfor i in range(n):\n    if a[i] < c:\n        count += 1\n    elif a[i] > c:\n        count -= 1\n\nprint(count)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount = a.count(c)\n\n# Iterate through the array to find the maximum possible number of elements equal to c\nfor i in range(n):\n    if a[i] == c:\n        continue\n    # Try to make the current element equal to c by changing the segment [i, n-1]\n    if a[i] < c:\n        k = c - a[i]\n        if k % 2 == 0:\n            count += 1\n    else:\n        k = a[i] - c\n        if k % 2 == 0:\n            count += 1\n\nprint(count)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = int(data[1])\na = list(map(int, data[2:]))\n\n# Count the number of elements that are already equal to c\ncount_c = a.count(c)\n\n# If all elements are already equal to c, return n\nif count_c == n:\n    print(n)\nelse:\n    # Otherwise, the maximum possible number of elements with value c is n - 1\n    print(n - 1)"
        ]
    },
    {
        "question_title": "The Fair Nut and Rectangles",
        "question_content": "The Fair Nut got stacked in planar world. He should solve this task to get out.\n\nYou are given n rectangles with vertexes in (0, 0), (x_i, 0), (x_i, y_i), (0, y_i). For each rectangle, you are also given a number a_i. Choose some of them that the area of union minus sum of a_i of the chosen ones is maximum.\n\nIt is guaranteed that there are no nested rectangles.\n\nNut has no idea how to find the answer, so he asked for your help.\n\n\nInput Format\nThe first line contains one integer n (1 \\leq n \\leq 10^6)\u00a0\u2014 the number of rectangles.\n\nEach of the next n lines contains three integers x_i, y_i and a_i (1 \\leq x_i, y_i \\leq 10^9, 0 \\leq a_i \\leq x_i \\cdot y_i).\n\nIt is guaranteed that there are no nested rectangles.\n\n\nOutput Format\nIn a single line print the answer to the problem\u00a0\u2014 the maximum value which you can achieve.\n\n\nSample Input 1\n\n3\n4 4 8\n1 5 0\n5 2 10\n\nSample Output 1\n\n9\n\n\nSample Input 2\n\n4\n6 2 4\n1 6 2\n2 4 3\n5 3 8\n\nSample Output 2\n\n10\n\n\nNote\nIn the first example, the right answer can be achieved by choosing the first and the second rectangles.\n\nIn the second example, the right answer can also be achieved by choosing the first and the second rectangles.",
        "platform": "codeforces",
        "question_id": "1083/E",
        "contest_id": "1083",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x_i = int(data[3 * i + 1])\n    y_i = int(data[3 * i + 2])\n    a_i = int(data[3 * i + 3])\n    rectangles.append((x_i, y_i, a_i))\n\nrectangles.sort(key=lambda x: x[0] * x[1], reverse=True)\n\nmax_area = 0\ntotal_a = 0\nfor x_i, y_i, a_i in rectangles:\n    if x_i * y_i > max_area:\n        max_area = x_i * y_i\n    total_a += a_i\n\nresult = max_area - total_a\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\nfor i in range(1, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = max(dp[i - 1], dp[i - 1] + y * x - a)\n\nprint(dp[n])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\nfor i in range(1, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = dp[i - 1]\n    for j in range(i - 1, -1, -1):\n        if rectangles[j][0] + rectangles[j][1] <= x + y:\n            dp[i] = max(dp[i], dp[j] + a)\n\nprint(dp[n])\n```",
            "```python\nimport sys\n\ndef max_union_area(n, rectangles):\n    rectangles.sort(key=lambda x: x[1])\n    max_area = 0\n    current_area = 0\n    current_x = 0\n    \n    for x, y, a in rectangles:\n        if x > current_x:\n            current_area += (x - current_x) * y\n            current_x = x\n        current_area -= a\n        max_area = max(max_area, current_area)\n    \n    return max_area\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\n# Calculate and print the result\nresult = max_union_area(n, rectangles)\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3*i + 1])\n    y = int(data[3*i + 2])\n    a = int(data[3*i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\nfor i in range(1, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = max(dp[i - 1], dp[i - 1] + x * y - a)\n\nprint(dp[n])\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nrectangles = []\nindex = 1\nfor i in range(n):\n    x_i = int(data[index])\n    y_i = int(data[index + 1])\n    a_i = int(data[index + 2])\n    rectangles.append((x_i, y_i, a_i))\n    index += 3\n\n# Sort rectangles by x_i in descending order\nrectangles.sort(key=lambda x: x[0], reverse=True)\n\n# Initialize variables\nmax_area = 0\ncurrent_area = 0\nchosen_rectangles = []\n\n# Iterate through the sorted rectangles\nfor x_i, y_i, a_i in rectangles:\n    # Calculate the area of the current rectangle\n    area = x_i * y_i\n    \n    # Check if adding this rectangle increases the total area\n    if current_area + area - sum(a for x, y, a in chosen_rectangles if x >= x_i and y >= y_i) > max_area:\n        max_area = current_area + area - sum(a for x, y, a in chosen_rectangles if x >= x_i and y >= y_i)\n        chosen_rectangles.append((x_i, y_i, a_i))\n        current_area += area\n\n# Print the maximum area\nprint(max_area)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x_i = int(data[3 * i + 1])\n    y_i = int(data[3 * i + 2])\n    a_i = int(data[3 * i + 3])\n    rectangles.append((x_i, y_i, a_i))\n\nrectangles.sort(key=lambda x: x[0] * x[1], reverse=True)\n\nmax_area = 0\ncurrent_area = 0\nchosen_rectangles = []\n\nfor x_i, y_i, a_i in rectangles:\n    if current_area + a_i > max_area:\n        max_area = current_area + a_i\n        chosen_rectangles = [(x_i, y_i, a_i)]\n    elif current_area + a_i == max_area:\n        chosen_rectangles.append((x_i, y_i, a_i))\n\nprint(max_area)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\ndp[1] = rectangles[0][2]\n\nfor i in range(2, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = max(dp[i - 1], dp[i - 2] + a)\n    for j in range(i - 2, -1, -1):\n        if rectangles[j][0] + rectangles[j][1] <= x + y:\n            dp[i] = max(dp[i], dp[j] + a)\n        else:\n            break\n\nprint(dp[n])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\ndp[1] = rectangles[0][2]\n\nfor i in range(2, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = max(dp[i - 1], dp[i - 2] + a)\n    for j in range(i - 2, -1, -1):\n        if rectangles[j][0] + rectangles[j][1] <= x + y:\n            dp[i] = max(dp[i], dp[j] + a)\n        else:\n            break\n\nprint(dp[n])\n```",
            "```python\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\ndp[1] = rectangles[0][2]\n\nfor i in range(2, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = max(dp[i - 1], dp[i - 2] + a)\n    for j in range(i - 2, -1, -1):\n        if rectangles[j][0] + rectangles[j][1] <= x + y:\n            dp[i] = max(dp[i], dp[j] + a)\n        else:\n            break\n\nprint(dp[n])\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x_i = int(data[3 * i + 1])\n    y_i = int(data[3 * i + 2])\n    a_i = int(data[3 * i + 3])\n    rectangles.append((x_i, y_i, a_i))\n\nrectangles.sort(key=lambda x: x[0] * x[1], reverse=True)\n\nmax_area = 0\ntotal_a = 0\nfor x_i, y_i, a_i in rectangles:\n    if x_i * y_i > max_area:\n        max_area = x_i * y_i\n    total_a += a_i\n\nresult = max_area - total_a\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\nfor i in range(1, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = max(dp[i - 1], dp[i - 1] + y * x - a)\n\nprint(dp[n])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\nfor i in range(1, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = dp[i - 1]\n    for j in range(i - 1, -1, -1):\n        if rectangles[j][0] + rectangles[j][1] <= x + y:\n            dp[i] = max(dp[i], dp[j] + a)\n\nprint(dp[n])",
            "import sys\n\ndef max_union_area(n, rectangles):\n    rectangles.sort(key=lambda x: x[1])\n    max_area = 0\n    current_area = 0\n    current_x = 0\n    \n    for x, y, a in rectangles:\n        if x > current_x:\n            current_area += (x - current_x) * y\n            current_x = x\n        current_area -= a\n        max_area = max(max_area, current_area)\n    \n    return max_area\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\n# Calculate and print the result\nresult = max_union_area(n, rectangles)\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3*i + 1])\n    y = int(data[3*i + 2])\n    a = int(data[3*i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\nfor i in range(1, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = max(dp[i - 1], dp[i - 1] + x * y - a)\n\nprint(dp[n])",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nrectangles = []\nindex = 1\nfor i in range(n):\n    x_i = int(data[index])\n    y_i = int(data[index + 1])\n    a_i = int(data[index + 2])\n    rectangles.append((x_i, y_i, a_i))\n    index += 3\n\n# Sort rectangles by x_i in descending order\nrectangles.sort(key=lambda x: x[0], reverse=True)\n\n# Initialize variables\nmax_area = 0\ncurrent_area = 0\nchosen_rectangles = []\n\n# Iterate through the sorted rectangles\nfor x_i, y_i, a_i in rectangles:\n    # Calculate the area of the current rectangle\n    area = x_i * y_i\n    \n    # Check if adding this rectangle increases the total area\n    if current_area + area - sum(a for x, y, a in chosen_rectangles if x >= x_i and y >= y_i) > max_area:\n        max_area = current_area + area - sum(a for x, y, a in chosen_rectangles if x >= x_i and y >= y_i)\n        chosen_rectangles.append((x_i, y_i, a_i))\n        current_area += area\n\n# Print the maximum area\nprint(max_area)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x_i = int(data[3 * i + 1])\n    y_i = int(data[3 * i + 2])\n    a_i = int(data[3 * i + 3])\n    rectangles.append((x_i, y_i, a_i))\n\nrectangles.sort(key=lambda x: x[0] * x[1], reverse=True)\n\nmax_area = 0\ncurrent_area = 0\nchosen_rectangles = []\n\nfor x_i, y_i, a_i in rectangles:\n    if current_area + a_i > max_area:\n        max_area = current_area + a_i\n        chosen_rectangles = [(x_i, y_i, a_i)]\n    elif current_area + a_i == max_area:\n        chosen_rectangles.append((x_i, y_i, a_i))\n\nprint(max_area)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\ndp[1] = rectangles[0][2]\n\nfor i in range(2, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = max(dp[i - 1], dp[i - 2] + a)\n    for j in range(i - 2, -1, -1):\n        if rectangles[j][0] + rectangles[j][1] <= x + y:\n            dp[i] = max(dp[i], dp[j] + a)\n        else:\n            break\n\nprint(dp[n])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\ndp[1] = rectangles[0][2]\n\nfor i in range(2, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = max(dp[i - 1], dp[i - 2] + a)\n    for j in range(i - 2, -1, -1):\n        if rectangles[j][0] + rectangles[j][1] <= x + y:\n            dp[i] = max(dp[i], dp[j] + a)\n        else:\n            break\n\nprint(dp[n])",
            "import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nrectangles = []\n\nfor i in range(n):\n    x = int(data[3 * i + 1])\n    y = int(data[3 * i + 2])\n    a = int(data[3 * i + 3])\n    rectangles.append((x, y, a))\n\nrectangles.sort(key=lambda x: x[0])\n\ndp = [0] * (n + 1)\ndp[1] = rectangles[0][2]\n\nfor i in range(2, n + 1):\n    x, y, a = rectangles[i - 1]\n    dp[i] = max(dp[i - 1], dp[i - 2] + a)\n    for j in range(i - 2, -1, -1):\n        if rectangles[j][0] + rectangles[j][1] <= x + y:\n            dp[i] = max(dp[i], dp[j] + a)\n        else:\n            break\n\nprint(dp[n])"
        ]
    },
    {
        "question_title": "(Zero XOR Subset)-less",
        "question_content": "You are given an array a_1, a_2, \\dots, a_n of integer numbers.\n\nYour task is to divide the array into the maximum number of segments in such a way that:\n\n- each element is contained in exactly one segment;\n- each segment contains at least one element;\n- there doesn't exist a non-empty subset of segments such that bitwise XOR of the numbers from them is equal to 0.\n\nPrint the maximum number of segments the array can be divided into. Print -1 if no suitable division exists.\n\n\nInput Format\nThe first line contains a single integer n (1 \\le n \\le 2 \\cdot 10^5) \u2014 the size of the array.\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (0 \\le a_i \\le 10^9).\n\n\nOutput Format\nPrint the maximum number of segments the array can be divided into while following the given constraints. Print -1 if no suitable division exists.\n\n\nSample Input 1\n\n4\n5 5 7 2\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n3\n1 2 3\n\nSample Output 2\n\n-1\n\n\nSample Input 3\n\n3\n3 1 10\n\nSample Output 3\n\n3\n\n\nNote\nIn the first example 2 is the maximum number. If you divide the array into \\{[5], [5, 7, 2]\\}, the XOR value of the subset of only the second segment is 5 \\oplus 7 \\oplus 2 = 0. \\{[5, 5], [7, 2]\\} has the value of the subset of only the first segment being 5 \\oplus 5 = 0. However, \\{[5, 5, 7], [2]\\} will lead to subsets \\{[5, 5, 7]\\} of XOR 7, \\{[2]\\} of XOR 2 and \\{[5, 5, 7], [2]\\} of XOR 5 \\oplus 5 \\oplus 7 \\oplus 2 = 5.\n\nLet's take a look at some division on 3 segments \u2014 \\{[5], [5, 7], [2]\\}. It will produce subsets:\n\n- \\{[5]\\}, XOR 5;\n- \\{[5, 7]\\}, XOR 2;\n- \\{[5], [5, 7]\\}, XOR 7;\n- \\{[2]\\}, XOR 2;\n- \\{[5], [2]\\}, XOR 7;\n- \\{[5, 7], [2]\\}, XOR 0;\n- \\{[5], [5, 7], [2]\\}, XOR 5;\n\nAs you can see, subset \\{[5, 7], [2]\\} has its XOR equal to 0, which is unacceptable. You can check that for other divisions of size 3 or 4, non-empty subset with 0 XOR always exists.\n\nThe second example has no suitable divisions.\n\nThe third example array can be divided into \\{[3], [1], [10]\\}. No subset of these segments has its XOR equal to 0.",
        "platform": "codeforces",
        "question_id": "1101/G",
        "contest_id": "1101",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\ndef max_segments(n, a):\n    if n == 1:\n        return 1 if a[0] != 0 else -1\n    \n    segments = 0\n    current_xor = 0\n    \n    for i in range(n):\n        current_xor ^= a[i]\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(n, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1\n    \n    count = 0\n    current_xor = 0\n    \n    for num in arr:\n        current_xor ^= num\n        if current_xor == 0:\n            count += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        count += 1\n    \n    return count if count > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(arr)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1\n    \n    segments = 0\n    current_xor = 0\n    \n    for num in arr:\n        current_xor ^= num\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(arr)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize variables\nmax_segments = -1\ncurrent_segment_xor = 0\n\n# Iterate through the array to find the maximum number of valid segments\nfor i in range(n):\n    current_segment_xor ^= a[i]\n    if current_segment_xor == 0:\n        max_segments = -1\n        break\n    if i == n - 1 or a[i] != a[i + 1]:\n        max_segments += 1\n        current_segment_xor = 0\n\n# Print the result\nprint(max_segments)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1\n    \n    # Check if there is any segment that can be divided further\n    for i in range(1, n):\n        if arr[i] != arr[0]:\n            return n\n    \n    return -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(arr)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\n\ndef max_segments(n, a):\n    if n == 1:\n        return 1 if a[0] != 0 else -1\n    \n    segments = 0\n    current_xor = 0\n    \n    for i in range(n):\n        current_xor ^= a[i]\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(n, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef max_segments(n: int, a: List[int]) -> int:\n    if n == 1:\n        return 1\n    \n    segments = 1\n    current_xor = a[0]\n    \n    for i in range(1, n):\n        if current_xor ^ a[i] == 0:\n            segments += 1\n            current_xor = a[i]\n        else:\n            current_xor ^= a[i]\n    \n    return segments\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(n, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1\n    \n    segments = 0\n    current_xor = 0\n    \n    for num in arr:\n        current_xor ^= num\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(arr)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1 if arr[0] != 0 else -1\n    \n    segments = 0\n    current_xor = 0\n    \n    for num in arr:\n        current_xor ^= num\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(arr)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1\n    \n    segments = 0\n    current_xor = 0\n    \n    for num in arr:\n        current_xor ^= num\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Get result\nresult = max_segments(arr)\n\n# Print result\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\n\ndef max_segments(n, a):\n    if n == 1:\n        return 1 if a[0] != 0 else -1\n    \n    segments = 0\n    current_xor = 0\n    \n    for i in range(n):\n        current_xor ^= a[i]\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(n, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1\n    \n    count = 0\n    current_xor = 0\n    \n    for num in arr:\n        current_xor ^= num\n        if current_xor == 0:\n            count += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        count += 1\n    \n    return count if count > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(arr)\n\n# Print the result\nprint(result)",
            "import sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1\n    \n    segments = 0\n    current_xor = 0\n    \n    for num in arr:\n        current_xor ^= num\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(arr)\n\n# Write output\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize variables\nmax_segments = -1\ncurrent_segment_xor = 0\n\n# Iterate through the array to find the maximum number of valid segments\nfor i in range(n):\n    current_segment_xor ^= a[i]\n    if current_segment_xor == 0:\n        max_segments = -1\n        break\n    if i == n - 1 or a[i] != a[i + 1]:\n        max_segments += 1\n        current_segment_xor = 0\n\n# Print the result\nprint(max_segments)",
            "import sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1\n    \n    # Check if there is any segment that can be divided further\n    for i in range(1, n):\n        if arr[i] != arr[0]:\n            return n\n    \n    return -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(arr)\n\n# Print the result\nprint(result)",
            "import sys\n\ndef max_segments(n, a):\n    if n == 1:\n        return 1 if a[0] != 0 else -1\n    \n    segments = 0\n    current_xor = 0\n    \n    for i in range(n):\n        current_xor ^= a[i]\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(n, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom typing import List\n\ndef max_segments(n: int, a: List[int]) -> int:\n    if n == 1:\n        return 1\n    \n    segments = 1\n    current_xor = a[0]\n    \n    for i in range(1, n):\n        if current_xor ^ a[i] == 0:\n            segments += 1\n            current_xor = a[i]\n        else:\n            current_xor ^= a[i]\n    \n    return segments\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(n, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1\n    \n    segments = 0\n    current_xor = 0\n    \n    for num in arr:\n        current_xor ^= num\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(arr)\n\n# Print the result\nprint(result)",
            "import sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1 if arr[0] != 0 else -1\n    \n    segments = 0\n    current_xor = 0\n    \n    for num in arr:\n        current_xor ^= num\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Solve the problem\nresult = max_segments(arr)\n\n# Write output\nprint(result)",
            "import sys\nfrom typing import List\n\ndef max_segments(arr: List[int]) -> int:\n    n = len(arr)\n    if n == 1:\n        return 1\n    \n    segments = 0\n    current_xor = 0\n    \n    for num in arr:\n        current_xor ^= num\n        if current_xor == 0:\n            segments += 1\n            current_xor = 0\n    \n    if current_xor != 0:\n        segments += 1\n    \n    return segments if segments > 0 else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\narr = list(map(int, data[1:]))\n\n# Get result\nresult = max_segments(arr)\n\n# Print result\nprint(result)"
        ]
    },
    {
        "question_title": "Isolation",
        "question_content": "Find the number of ways to divide an array a of n integers into any number of disjoint non-empty segments so that, in each segment, there exist at most k distinct integers that appear exactly once.\n\nSince the answer can be large, find it modulo 998\\,244\\,353.\n\n\nInput Format\nThe first line contains two space-separated integers n and k (1 \\leq k \\leq n \\leq 10^5) \u2014 the number of elements in the array a and the restriction from the statement.\n\nThe following line contains n space-separated integers a_1, a_2, \\ldots, a_n (1 \\leq a_i \\leq n) \u2014 elements of the array a.\n\n\nOutput Format\nThe first and only line contains the number of ways to divide an array a modulo 998\\,244\\,353.\n\n\nSample Input 1\n\n3 1\n1 1 2\n\nSample Output 1\n\n3\n\n\nSample Input 2\n\n5 2\n1 1 2 1 3\n\nSample Output 2\n\n14\n\n\nSample Input 3\n\n5 5\n1 2 3 4 5\n\nSample Output 3\n\n16\n\n\nNote\nIn the first sample, the three possible divisions are as follows.\n\n- [[1], [1], [2]]\n- [[1, 1], [2]]\n- [[1, 1, 2]]\n\nDivision [[1], [1, 2]] is not possible because two distinct integers appear exactly once in the second segment [1, 2].",
        "platform": "codeforces",
        "question_id": "1129/D",
        "contest_id": "1129",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nMOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (1 << a[i - 1])) == 0\n    \n    for i in range(1, n + 1):\n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nresult = count_ways(n, k, a)\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1]\n        if (prefix[i] & (prefix[i] - 1)) == 0:\n            count[i] += 1\n        \n        dp[i] = dp[i - 1]\n        for j in range(i - 1, -1, -1):\n            if count[j] + (prefix[i] ^ prefix[j]).bit_count() <= k:\n                dp[i] = (dp[i] + dp[j]) % MOD\n                break\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (1 << a[i - 1])) == 0\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1]\n        if (prefix[i] & (prefix[i] - 1)) == 0:\n            count[i] += 1\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (1 << a[i - 1])) == 0\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (1 << a[i - 1])) == 0\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1]\n        if (prefix[i] & (prefix[i] - 1)) == 0:\n            count[i] += 1\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] != prefix[i - 1])\n        \n        if count[i] > k:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = (dp[i - 1] + dp[i - count[i]]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (prefix[i] - 1) == 0)\n        \n        dp[i] = dp[i - 1]\n        for j in range(i - 1, -1, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nresult = count_ways(n, k, a)\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (1 << a[i - 1])) == 0\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nresult = count_ways(n, k, a)\nprint(result)\n```"
        ],
        "code_list": [
            "MOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (1 << a[i - 1])) == 0\n    \n    for i in range(1, n + 1):\n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nresult = count_ways(n, k, a)\nprint(result)",
            "MOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1]\n        if (prefix[i] & (prefix[i] - 1)) == 0:\n            count[i] += 1\n        \n        dp[i] = dp[i - 1]\n        for j in range(i - 1, -1, -1):\n            if count[j] + (prefix[i] ^ prefix[j]).bit_count() <= k:\n                dp[i] = (dp[i] + dp[j]) % MOD\n                break\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)",
            "MOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (1 << a[i - 1])) == 0\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)",
            "MOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1]\n        if (prefix[i] & (prefix[i] - 1)) == 0:\n            count[i] += 1\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)",
            "MOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (1 << a[i - 1])) == 0\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)",
            "MOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (1 << a[i - 1])) == 0\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)",
            "MOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1]\n        if (prefix[i] & (prefix[i] - 1)) == 0:\n            count[i] += 1\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)",
            "MOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] != prefix[i - 1])\n        \n        if count[i] > k:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = (dp[i - 1] + dp[i - count[i]]) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = count_ways(n, k, a)\nprint(result)",
            "MOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (prefix[i] - 1) == 0)\n        \n        dp[i] = dp[i - 1]\n        for j in range(i - 1, -1, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nresult = count_ways(n, k, a)\nprint(result)",
            "MOD = 998244353\n\ndef count_ways(n, k, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix = [0] * (n + 1)\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        prefix[i] = prefix[i - 1] | (1 << a[i - 1])\n        count[i] = count[i - 1] + (prefix[i] & (1 << a[i - 1])) == 0\n        \n        for j in range(i, 0, -1):\n            if count[j] <= k:\n                dp[i] = (dp[i] + dp[j - 1]) % MOD\n    \n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nresult = count_ways(n, k, a)\nprint(result)"
        ]
    },
    {
        "question_title": "Greedy Subsequences",
        "question_content": "For some array c, let's denote a greedy subsequence as a sequence of indices p_1, p_2, ..., p_l such that 1 \\le p_1 < p_2 < \\dots < p_l \\le |c|, and for each i \\in [1, l - 1], p_{i + 1} is the minimum number such that p_{i + 1} > p_i and c[p_{i + 1}] > c[p_i].\n\nYou are given an array a_1, a_2, \\dots, a_n. For each its subsegment of length k, calculate the length of its longest greedy subsequence.\n\n\nInput Format\nThe first line contains two integers n and k (1 \\le k \\le n \\le 10^6) \u2014 the length of array a and the length of subsegments.\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le n) \u2014 array a.\n\n\nOutput Format\nPrint n - k + 1 integers \u2014 the maximum lengths of greedy subsequences of each subsegment having length k. The first number should correspond to subsegment a[1..k], the second \u2014 to subsegment a[2..k + 1], and so on.\n\n\nSample Input 1\n\n6 4\n1 5 2 5 3 6\n\nSample Output 1\n\n2 2 3\n\n\nSample Input 2\n\n7 6\n4 5 2 5 3 6 6\n\nSample Output 2\n\n3 3\n\n\nNote\nIn the first example:\n\n- [1, 5, 2, 5] \u2014 the longest greedy subsequences are 1, 2 ([c_1, c_2] = [1, 5]) or 3, 4 ([c_3, c_4] = [2, 5]).\n- [5, 2, 5, 3] \u2014 the sequence is 2, 3 ([c_2, c_3] = [2, 5]).\n- [2, 5, 3, 6] \u2014 the sequence is 1, 2, 4 ([c_1, c_2, c_4] = [2, 5, 6]).\n\nIn the second example:\n\n- [4, 5, 2, 5, 3, 6] \u2014 the longest greedy subsequences are 1, 2, 6 ([c_1, c_2, c_6] = [4, 5, 6]) or 3, 4, 6 ([c_3, c_4, c_6] = [2, 5, 6]).\n- [5, 2, 5, 3, 6, 6] \u2014 the subsequence is 2, 3, 5 ([c_2, c_3, c_5] = [2, 5, 6]).",
        "platform": "codeforces",
        "question_id": "1132/G",
        "contest_id": "1132",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import deque\n\ndef longest_greedy_subsequence_length(a, k):\n    n = len(a)\n    result = []\n    stack = deque()\n    \n    for i in range(n):\n        while stack and a[i] > a[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n        \n        if i >= k:\n            if stack[0] == i - k:\n                stack.popleft()\n        \n        if i >= k - 1:\n            result.append(len(stack))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = longest_greedy_subsequence_length(a, k)\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef longest_greedy_subsequence_length(a, k):\n    n = len(a)\n    result = []\n    stack = deque()\n    \n    for i in range(n):\n        while stack and a[stack[-1]] < a[i]:\n            stack.pop()\n        stack.append(i)\n        \n        if i >= k:\n            if stack[0] == i - k:\n                stack.popleft()\n        \n        if i >= k - 1:\n            result.append(len(stack))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = longest_greedy_subsequence_length(a, k)\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef longest_greedy_subsequence(c):\n    stack = []\n    for x in c:\n        while stack and x > stack[-1]:\n            stack.pop()\n        stack.append(x)\n    return len(stack)\n\ndef solve(n, k, a):\n    result = []\n    for i in range(n - k + 1):\n        subsegment = a[i:i + k]\n        result.append(longest_greedy_subsequence(subsegment))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = solve(n, k, a)\n\n# Write output\nprint(\" \".join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef longest_greedy_subsequence(c):\n    stack = []\n    for i, x in enumerate(c):\n        while stack and x > c[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n    return len(stack)\n\ndef solve(n, k, a):\n    result = []\n    for i in range(n - k + 1):\n        subsegment = a[i:i+k]\n        result.append(longest_greedy_subsequence(subsegment))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = solve(n, k, a)\n\n# Write output\nprint(\" \".join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef longest_greedy_subsequence(c):\n    stack = []\n    for i, x in enumerate(c):\n        while stack and x > c[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n    return len(stack)\n\ndef solve(n, k, a):\n    result = []\n    for i in range(n - k + 1):\n        subsegment = a[i:i + k]\n        result.append(longest_greedy_subsequence(subsegment))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = solve(n, k, a)\n\n# Write output\nprint(\" \".join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef longest_greedy_subsequence_length(a, k):\n    n = len(a)\n    result = []\n    stack = deque()\n    \n    for i in range(n):\n        while stack and a[i] > a[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n        \n        if i >= k:\n            if stack[0] == i - k:\n                stack.popleft()\n        \n        if i >= k - 1:\n            result.append(len(stack))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = longest_greedy_subsequence_length(a, k)\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nresult = []\n\nfor i in range(n - k + 1):\n    subarray = a[i:i + k]\n    stack = deque()\n    length = 0\n    for num in subarray:\n        while stack and stack[-1] >= num:\n            stack.pop()\n        stack.append(num)\n        length = max(length, len(stack))\n    result.append(length)\n\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef longest_greedy_subsequence_length(a, k):\n    n = len(a)\n    result = []\n    stack = deque()\n    \n    for i in range(n):\n        while stack and a[stack[-1]] < a[i]:\n            stack.pop()\n        stack.append(i)\n        \n        if i >= k:\n            if stack[0] == i - k:\n                stack.popleft()\n        \n        if i >= k - 1:\n            result.append(len(stack))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = longest_greedy_subsequence_length(a, k)\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nresult = []\n\nfor i in range(n - k + 1):\n    subarray = a[i:i + k]\n    stack = deque()\n    length = 0\n    \n    for num in subarray:\n        while stack and num > stack[-1]:\n            stack.pop()\n            length += 1\n        stack.append(num)\n    \n    result.append(length + 1)\n\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef longest_greedy_subsequence_length(a, k):\n    n = len(a)\n    result = []\n    stack = deque()\n    \n    for i in range(n):\n        while stack and a[i] > a[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n        \n        if i >= k:\n            if stack[0] == i - k:\n                stack.popleft()\n        \n        if i >= k - 1:\n            result.append(len(stack))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = longest_greedy_subsequence_length(a, k)\nprint(' '.join(map(str, result)))\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import deque\n\ndef longest_greedy_subsequence_length(a, k):\n    n = len(a)\n    result = []\n    stack = deque()\n    \n    for i in range(n):\n        while stack and a[i] > a[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n        \n        if i >= k:\n            if stack[0] == i - k:\n                stack.popleft()\n        \n        if i >= k - 1:\n            result.append(len(stack))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = longest_greedy_subsequence_length(a, k)\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import deque\n\ndef longest_greedy_subsequence_length(a, k):\n    n = len(a)\n    result = []\n    stack = deque()\n    \n    for i in range(n):\n        while stack and a[stack[-1]] < a[i]:\n            stack.pop()\n        stack.append(i)\n        \n        if i >= k:\n            if stack[0] == i - k:\n                stack.popleft()\n        \n        if i >= k - 1:\n            result.append(len(stack))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = longest_greedy_subsequence_length(a, k)\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import deque\n\ndef longest_greedy_subsequence(c):\n    stack = []\n    for x in c:\n        while stack and x > stack[-1]:\n            stack.pop()\n        stack.append(x)\n    return len(stack)\n\ndef solve(n, k, a):\n    result = []\n    for i in range(n - k + 1):\n        subsegment = a[i:i + k]\n        result.append(longest_greedy_subsequence(subsegment))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = solve(n, k, a)\n\n# Write output\nprint(\" \".join(map(str, result)))",
            "import sys\nfrom collections import deque\n\ndef longest_greedy_subsequence(c):\n    stack = []\n    for i, x in enumerate(c):\n        while stack and x > c[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n    return len(stack)\n\ndef solve(n, k, a):\n    result = []\n    for i in range(n - k + 1):\n        subsegment = a[i:i+k]\n        result.append(longest_greedy_subsequence(subsegment))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = solve(n, k, a)\n\n# Write output\nprint(\" \".join(map(str, result)))",
            "import sys\nfrom collections import deque\n\ndef longest_greedy_subsequence(c):\n    stack = []\n    for i, x in enumerate(c):\n        while stack and x > c[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n    return len(stack)\n\ndef solve(n, k, a):\n    result = []\n    for i in range(n - k + 1):\n        subsegment = a[i:i + k]\n        result.append(longest_greedy_subsequence(subsegment))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = solve(n, k, a)\n\n# Write output\nprint(\" \".join(map(str, result)))",
            "import sys\nfrom collections import deque\n\ndef longest_greedy_subsequence_length(a, k):\n    n = len(a)\n    result = []\n    stack = deque()\n    \n    for i in range(n):\n        while stack and a[i] > a[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n        \n        if i >= k:\n            if stack[0] == i - k:\n                stack.popleft()\n        \n        if i >= k - 1:\n            result.append(len(stack))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = longest_greedy_subsequence_length(a, k)\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nresult = []\n\nfor i in range(n - k + 1):\n    subarray = a[i:i + k]\n    stack = deque()\n    length = 0\n    for num in subarray:\n        while stack and stack[-1] >= num:\n            stack.pop()\n        stack.append(num)\n        length = max(length, len(stack))\n    result.append(length)\n\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import deque\n\ndef longest_greedy_subsequence_length(a, k):\n    n = len(a)\n    result = []\n    stack = deque()\n    \n    for i in range(n):\n        while stack and a[stack[-1]] < a[i]:\n            stack.pop()\n        stack.append(i)\n        \n        if i >= k:\n            if stack[0] == i - k:\n                stack.popleft()\n        \n        if i >= k - 1:\n            result.append(len(stack))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = longest_greedy_subsequence_length(a, k)\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nresult = []\n\nfor i in range(n - k + 1):\n    subarray = a[i:i + k]\n    stack = deque()\n    length = 0\n    \n    for num in subarray:\n        while stack and num > stack[-1]:\n            stack.pop()\n            length += 1\n        stack.append(num)\n    \n    result.append(length + 1)\n\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import deque\n\ndef longest_greedy_subsequence_length(a, k):\n    n = len(a)\n    result = []\n    stack = deque()\n    \n    for i in range(n):\n        while stack and a[i] > a[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n        \n        if i >= k:\n            if stack[0] == i - k:\n                stack.popleft()\n        \n        if i >= k - 1:\n            result.append(len(stack))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = longest_greedy_subsequence_length(a, k)\nprint(' '.join(map(str, result)))"
        ]
    },
    {
        "question_title": "Satanic Panic",
        "question_content": "You are given a set of n points in a 2D plane. No three points are collinear.\n\nA pentagram is a set of 5 points A,B,C,D,E that can be arranged as follows. Note the length of the line segments don't matter, only that those particular intersections exist.\n\nCount the number of ways to choose 5 points from the given set that form a pentagram.\n\n\nInput Format\nThe first line contains an integer n (5 \\leq n \\leq 300)\u00a0\u2014 the number of points.\n\nEach of the next n lines contains two integers x_i, y_i (-10^6 \\leq x_i,y_i \\leq 10^6)\u00a0\u2014 the coordinates of the i-th point. It is guaranteed that no three points are collinear.\n\n\nOutput Format\nPrint a single integer, the number of sets of 5 points that form a pentagram.\n\n\nSample Input 1\n\n5\n0 0\n0 2\n2 0\n2 2\n1 3\n\nSample Output 1\n\n1\n\n\nSample Input 2\n\n5\n0 0\n4 0\n0 4\n4 4\n2 3\n\nSample Output 2\n\n0\n\n\nSample Input 3\n\n10\n841746 527518\n595261 331297\n-946901 129987\n670374 -140388\n-684770 309555\n-302589 415564\n-387435 613331\n-624940 -95922\n945847 -199224\n24636 -565799\n\nSample Output 3\n\n85\n\n\nNote\nA picture of the first sample: A picture of the second sample: A picture of the third sample:",
        "platform": "codeforces",
        "question_id": "1146/H",
        "contest_id": "1146",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    def collinear(p1, p2, p3):\n        return (p2[1] - p1[1]) * (p3[0] - p1[0]) == (p3[1] - p1[1]) * (p2[0] - p1[0])\n    return (not collinear(A, B, C) and not collinear(A, B, D) and not collinear(A, B, E) and\n            not collinear(A, C, D) and not collinear(A, C, E) and not collinear(A, D, E) and\n            not collinear(B, C, D) and not collinear(B, C, E) and not collinear(B, D, E) and\n            not collinear(C, D, E))\n\ndef count_pentagrams(points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\npoints = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Solve the problem\nresult = count_pentagrams(points)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    def collinear(p1, p2, p3):\n        return (p2[1] - p1[1]) * (p3[0] - p1[0]) == (p3[1] - p1[1]) * (p2[0] - p1[0])\n    return not any(collinear(A, B, C), collinear(A, B, D), collinear(A, B, E),\n                   collinear(A, C, D), collinear(A, C, E), collinear(A, D, E),\n                   collinear(B, C, D), collinear(B, C, E), collinear(B, D, E),\n                   collinear(C, D, E))\n\ndef count_pentagrams(points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\npoints = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Output the result\nprint(count_pentagrams(points))\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    return (B in (A + C, A + E, C + E)) and (D in (A + C, A + E, C + E)) and (E in (A + B, A + D, B + D))\n\ndef count_pentagrams(points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\npoints = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Output the result\nprint(count_pentagrams(points))\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points\npoints = []\nfor i in range(1, 2 * n, 2):\n    x = int(data[i])\n    y = int(data[i + 1])\n    points.append((x, y))\n\n# Function to check if four points form a convex quadrilateral\ndef is_convex_quadrilateral(p1, p2, p3, p4):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0  # collinear\n        elif val > 0:\n            return 1  # clockwise\n        else:\n            return 2  # counterclockwise\n\n    o1 = orientation(p1, p2, p3)\n    o2 = orientation(p2, p3, p4)\n    o3 = orientation(p3, p4, p1)\n    o4 = orientation(p4, p1, p2)\n\n    if o1 != o2 and o2 != o3 and o3 != o4:\n        return True\n    return False\n\n# Function to check if five points form a pentagram\ndef is_pentagram(p1, p2, p3, p4, p5):\n    # Check all combinations of four points to see if they form a convex quadrilateral\n    for comb in combinations([p1, p2, p3, p4, p5], 4):\n        if is_convex_quadrilateral(*comb):\n            return False\n    return True\n\n# Count the number of pentagrams\ncount = 0\nfor comb in combinations(points, 5):\n    if is_pentagram(*comb):\n        count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points\npoints = []\nfor i in range(n):\n    x = int(data[2 * i + 1])\n    y = int(data[2 * i + 2])\n    points.append((x, y))\n\n# Function to check if four points form a convex quadrilateral\ndef is_convex_quadrilateral(p1, p2, p3, p4):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0  # collinear\n        elif val > 0:\n            return 1  # clockwise\n        else:\n            return 2  # counterclockwise\n\n    o1 = orientation(p1, p2, p3)\n    o2 = orientation(p2, p3, p4)\n    o3 = orientation(p3, p4, p1)\n    o4 = orientation(p4, p1, p2)\n\n    if o1 != o2 and o2 != o3 and o3 != o4:\n        return True\n    return False\n\n# Function to check if five points form a pentagram\ndef is_pentagram(p1, p2, p3, p4, p5):\n    # Check all combinations of four points to see if they form a convex quadrilateral\n    for combo in combinations([p1, p2, p3, p4, p5], 4):\n        if is_convex_quadrilateral(*combo):\n            return True\n    return False\n\n# Count the number of pentagrams\ncount = 0\nfor combo in combinations(points, 5):\n    if is_pentagram(*combo):\n        count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Function to check if four points form a convex quadrilateral\ndef is_convex_quadrilateral(p1, p2, p3, p4):\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n    \n    return (cross_product(p1, p2, p3) > 0 and\n            cross_product(p2, p3, p4) > 0 and\n            cross_product(p3, p4, p1) > 0 and\n            cross_product(p4, p1, p2) > 0)\n\n# Function to check if a pentagram can be formed by five points\ndef is_pentagram(p1, p2, p3, p4, p5):\n    # Check all combinations of four points to form a convex quadrilateral\n    for comb in combinations([p1, p2, p3, p4, p5], 4):\n        if is_convex_quadrilateral(*comb):\n            # Check if the fifth point is inside the quadrilateral\n            if (cross_product(comb[0], comb[1], p5) > 0 and\n                cross_product(comb[1], comb[2], p5) > 0 and\n                cross_product(comb[2], comb[3], p5) > 0 and\n                cross_product(comb[3], comb[0], p5) > 0):\n                return True\n    return False\n\n# Count the number of pentagrams\ncount = 0\nfor comb in combinations(points, 5):\n    if is_pentagram(*comb):\n        count += 1\n\n# Print the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Function to check if four points form a convex quadrilateral\ndef is_convex_quadrilateral(p1, p2, p3, p4):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    o1 = orientation(p1, p2, p3)\n    o2 = orientation(p2, p3, p4)\n    o3 = orientation(p3, p4, p1)\n    o4 = orientation(p4, p1, p2)\n\n    if o1 != o2 and o2 != o3 and o3 != o4:\n        return True\n    return False\n\n# Function to check if five points form a pentagram\ndef is_pentagram(p1, p2, p3, p4, p5):\n    # Check all combinations of four points to see if they form a convex quadrilateral\n    for comb in combinations([p1, p2, p3, p4, p5], 4):\n        if is_convex_quadrilateral(*comb):\n            return True\n    return False\n\n# Count the number of pentagrams\ncount = 0\nfor comb in combinations(points, 5):\n    if is_pentagram(*comb):\n        count += 1\n\n# Print the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    # Check if the points form a pentagram\n    # A pentagram is formed by connecting every other point in a star shape\n    # We need to check if the points form two intersecting triangles\n    # One triangle is formed by A, C, E and the other by B, D, E\n    # The intersection point of these two triangles is E\n    # We need to check if E is inside the triangle formed by A, C, E and B, D, E\n    # We can use the cross product to check if a point is inside a triangle\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n    \n    def is_point_in_triangle(p, p1, p2, p3):\n        return (cross_product(p, p1, p2) >= 0 and\n                cross_product(p, p2, p3) >= 0 and\n                cross_product(p, p3, p1) >= 0)\n    \n    return (is_point_in_triangle(E, A, C, E) and\n            is_point_in_triangle(E, B, D, E))\n\ndef count_pentagrams(points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\npoints = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Solve the problem\nresult = count_pentagrams(points)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    AB = (B[0] - A[0], B[1] - A[1])\n    AC = (C[0] - A[0], C[1] - A[1])\n    AD = (D[0] - A[0], D[1] - A[1])\n    AE = (E[0] - A[0], E[1] - A[1])\n    BC = (C[0] - B[0], C[1] - B[1])\n    BD = (D[0] - B[0], D[1] - B[1])\n    BE = (E[0] - B[0], E[1] - B[1])\n    CD = (D[0] - C[0], D[1] - C[1])\n    CE = (E[0] - C[0], E[1] - C[1])\n    DE = (E[0] - D[0], E[1] - D[1])\n    return (AB[0] * AC[1] - AB[1] * AC[0]) * (AB[0] * AD[1] - AB[1] * AD[0]) * (AB[0] * AE[1] - AB[1] * AE[0]) == 0 and \\\n           (BC[0] * BD[1] - BC[1] * BD[0]) * (BC[0] * BE[1] - BC[1] * BE[0]) * (BC[0] * CD[1] - BC[1] * CD[0]) == 0 and \\\n           (CD[0] * CE[1] - CD[1] * CE[0]) * (CD[0] * DE[1] - CD[1] * DE[0]) * (CD[0] * AB[1] - CD[1] * AB[0]) == 0 and \\\n           (DE[0] * AB[1] - DE[1] * AB[0]) * (DE[0] * AC[1] - DE[1] * AC[0]) * (DE[0] * AD[1] - DE[1] * AD[0]) == 0\n\ndef count_pentagrams(points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\npoints = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Solve the problem\nresult = count_pentagrams(points)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    return (A, C, E) in combinations(points, 3) and (B, D, E) in combinations(points, 3)\n\ndef count_pentagrams(n, points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_pentagrams(n, points)\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    def collinear(p1, p2, p3):\n        return (p2[1] - p1[1]) * (p3[0] - p1[0]) == (p3[1] - p1[1]) * (p2[0] - p1[0])\n    return (not collinear(A, B, C) and not collinear(A, B, D) and not collinear(A, B, E) and\n            not collinear(A, C, D) and not collinear(A, C, E) and not collinear(A, D, E) and\n            not collinear(B, C, D) and not collinear(B, C, E) and not collinear(B, D, E) and\n            not collinear(C, D, E))\n\ndef count_pentagrams(points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\npoints = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Solve the problem\nresult = count_pentagrams(points)\n\n# Write output\nprint(result)",
            "import sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    def collinear(p1, p2, p3):\n        return (p2[1] - p1[1]) * (p3[0] - p1[0]) == (p3[1] - p1[1]) * (p2[0] - p1[0])\n    return not any(collinear(A, B, C), collinear(A, B, D), collinear(A, B, E),\n                   collinear(A, C, D), collinear(A, C, E), collinear(A, D, E),\n                   collinear(B, C, D), collinear(B, C, E), collinear(B, D, E),\n                   collinear(C, D, E))\n\ndef count_pentagrams(points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\npoints = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Output the result\nprint(count_pentagrams(points))",
            "import sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    return (B in (A + C, A + E, C + E)) and (D in (A + C, A + E, C + E)) and (E in (A + B, A + D, B + D))\n\ndef count_pentagrams(points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\npoints = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Output the result\nprint(count_pentagrams(points))",
            "import sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points\npoints = []\nfor i in range(1, 2 * n, 2):\n    x = int(data[i])\n    y = int(data[i + 1])\n    points.append((x, y))\n\n# Function to check if four points form a convex quadrilateral\ndef is_convex_quadrilateral(p1, p2, p3, p4):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0  # collinear\n        elif val > 0:\n            return 1  # clockwise\n        else:\n            return 2  # counterclockwise\n\n    o1 = orientation(p1, p2, p3)\n    o2 = orientation(p2, p3, p4)\n    o3 = orientation(p3, p4, p1)\n    o4 = orientation(p4, p1, p2)\n\n    if o1 != o2 and o2 != o3 and o3 != o4:\n        return True\n    return False\n\n# Function to check if five points form a pentagram\ndef is_pentagram(p1, p2, p3, p4, p5):\n    # Check all combinations of four points to see if they form a convex quadrilateral\n    for comb in combinations([p1, p2, p3, p4, p5], 4):\n        if is_convex_quadrilateral(*comb):\n            return False\n    return True\n\n# Count the number of pentagrams\ncount = 0\nfor comb in combinations(points, 5):\n    if is_pentagram(*comb):\n        count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points\npoints = []\nfor i in range(n):\n    x = int(data[2 * i + 1])\n    y = int(data[2 * i + 2])\n    points.append((x, y))\n\n# Function to check if four points form a convex quadrilateral\ndef is_convex_quadrilateral(p1, p2, p3, p4):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0  # collinear\n        elif val > 0:\n            return 1  # clockwise\n        else:\n            return 2  # counterclockwise\n\n    o1 = orientation(p1, p2, p3)\n    o2 = orientation(p2, p3, p4)\n    o3 = orientation(p3, p4, p1)\n    o4 = orientation(p4, p1, p2)\n\n    if o1 != o2 and o2 != o3 and o3 != o4:\n        return True\n    return False\n\n# Function to check if five points form a pentagram\ndef is_pentagram(p1, p2, p3, p4, p5):\n    # Check all combinations of four points to see if they form a convex quadrilateral\n    for combo in combinations([p1, p2, p3, p4, p5], 4):\n        if is_convex_quadrilateral(*combo):\n            return True\n    return False\n\n# Count the number of pentagrams\ncount = 0\nfor combo in combinations(points, 5):\n    if is_pentagram(*combo):\n        count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Function to check if four points form a convex quadrilateral\ndef is_convex_quadrilateral(p1, p2, p3, p4):\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n    \n    return (cross_product(p1, p2, p3) > 0 and\n            cross_product(p2, p3, p4) > 0 and\n            cross_product(p3, p4, p1) > 0 and\n            cross_product(p4, p1, p2) > 0)\n\n# Function to check if a pentagram can be formed by five points\ndef is_pentagram(p1, p2, p3, p4, p5):\n    # Check all combinations of four points to form a convex quadrilateral\n    for comb in combinations([p1, p2, p3, p4, p5], 4):\n        if is_convex_quadrilateral(*comb):\n            # Check if the fifth point is inside the quadrilateral\n            if (cross_product(comb[0], comb[1], p5) > 0 and\n                cross_product(comb[1], comb[2], p5) > 0 and\n                cross_product(comb[2], comb[3], p5) > 0 and\n                cross_product(comb[3], comb[0], p5) > 0):\n                return True\n    return False\n\n# Count the number of pentagrams\ncount = 0\nfor comb in combinations(points, 5):\n    if is_pentagram(*comb):\n        count += 1\n\n# Print the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Function to check if four points form a convex quadrilateral\ndef is_convex_quadrilateral(p1, p2, p3, p4):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    o1 = orientation(p1, p2, p3)\n    o2 = orientation(p2, p3, p4)\n    o3 = orientation(p3, p4, p1)\n    o4 = orientation(p4, p1, p2)\n\n    if o1 != o2 and o2 != o3 and o3 != o4:\n        return True\n    return False\n\n# Function to check if five points form a pentagram\ndef is_pentagram(p1, p2, p3, p4, p5):\n    # Check all combinations of four points to see if they form a convex quadrilateral\n    for comb in combinations([p1, p2, p3, p4, p5], 4):\n        if is_convex_quadrilateral(*comb):\n            return True\n    return False\n\n# Count the number of pentagrams\ncount = 0\nfor comb in combinations(points, 5):\n    if is_pentagram(*comb):\n        count += 1\n\n# Print the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    # Check if the points form a pentagram\n    # A pentagram is formed by connecting every other point in a star shape\n    # We need to check if the points form two intersecting triangles\n    # One triangle is formed by A, C, E and the other by B, D, E\n    # The intersection point of these two triangles is E\n    # We need to check if E is inside the triangle formed by A, C, E and B, D, E\n    # We can use the cross product to check if a point is inside a triangle\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n    \n    def is_point_in_triangle(p, p1, p2, p3):\n        return (cross_product(p, p1, p2) >= 0 and\n                cross_product(p, p2, p3) >= 0 and\n                cross_product(p, p3, p1) >= 0)\n    \n    return (is_point_in_triangle(E, A, C, E) and\n            is_point_in_triangle(E, B, D, E))\n\ndef count_pentagrams(points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\npoints = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Solve the problem\nresult = count_pentagrams(points)\n\n# Write output\nprint(result)",
            "import sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    AB = (B[0] - A[0], B[1] - A[1])\n    AC = (C[0] - A[0], C[1] - A[1])\n    AD = (D[0] - A[0], D[1] - A[1])\n    AE = (E[0] - A[0], E[1] - A[1])\n    BC = (C[0] - B[0], C[1] - B[1])\n    BD = (D[0] - B[0], D[1] - B[1])\n    BE = (E[0] - B[0], E[1] - B[1])\n    CD = (D[0] - C[0], D[1] - C[1])\n    CE = (E[0] - C[0], E[1] - C[1])\n    DE = (E[0] - D[0], E[1] - D[1])\n    return (AB[0] * AC[1] - AB[1] * AC[0]) * (AB[0] * AD[1] - AB[1] * AD[0]) * (AB[0] * AE[1] - AB[1] * AE[0]) == 0 and \\\n           (BC[0] * BD[1] - BC[1] * BD[0]) * (BC[0] * BE[1] - BC[1] * BE[0]) * (BC[0] * CD[1] - BC[1] * CD[0]) == 0 and \\\n           (CD[0] * CE[1] - CD[1] * CE[0]) * (CD[0] * DE[1] - CD[1] * DE[0]) * (CD[0] * AB[1] - CD[1] * AB[0]) == 0 and \\\n           (DE[0] * AB[1] - DE[1] * AB[0]) * (DE[0] * AC[1] - DE[1] * AC[0]) * (DE[0] * AD[1] - DE[1] * AD[0]) == 0\n\ndef count_pentagrams(points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\npoints = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n\n# Solve the problem\nresult = count_pentagrams(points)\n\n# Write output\nprint(result)",
            "import sys\nfrom itertools import combinations\n\ndef is_pentagram(points):\n    A, B, C, D, E = points\n    return (A, C, E) in combinations(points, 3) and (B, D, E) in combinations(points, 3)\n\ndef count_pentagrams(n, points):\n    count = 0\n    for combo in combinations(points, 5):\n        if is_pentagram(combo):\n            count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_pentagrams(n, points)\nprint(result)"
        ]
    },
    {
        "question_title": "Special Segments of Permutation",
        "question_content": "You are given a permutation p of n integers 1, 2, ..., n (a permutation is an array where each element from 1 to n occurs exactly once).\n\nLet's call some subsegment p[l, r] of this permutation special if p_l + p_r = \\max \\limits_{i = l}^{r} p_i. Please calculate the number of special subsegments.\n\n\nInput Format\nThe first line contains one integer n (3 \\le n \\le 2 \\cdot 10^5).\n\nThe second line contains n integers p_1, p_2, ..., p_n (1 \\le p_i \\le n). All these integers are pairwise distinct.\n\n\nOutput Format\nPrint the number of special subsegments of the given permutation.\n\n\nSample Input 1\n\n5\n3 4 1 5 2\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n3\n1 3 2\n\nSample Output 2\n\n1\n\n\nNote\nSpecial subsegments in the first example are [1, 5] and [1, 3].\n\nThe only special subsegment in the second example is [1, 3].",
        "platform": "codeforces",
        "question_id": "1156/E",
        "contest_id": "1156",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        count += 1\n        left += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\nspecial_count = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        special_count += 1\n        left += 1\n\n# Output the result\nprint(special_count)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        count += 1\n        left += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        count += 1\n        left += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\nspecial_count = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        special_count += 1\n        left += 1\n\n# Output the result\nprint(special_count)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\nspecial_count = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        special_count += 1\n        left += 1\n\n# Output the result\nprint(special_count)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_val = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_val = max(max_val, p[right])\n    while p[left] + p[right] == max_val:\n        count += 1\n        left += 1\n\nprint(count)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        count += 1\n        left += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        count += 1\n        left += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\nspecial_count = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        special_count += 1\n        left += 1\n\n# Print the result\nprint(special_count)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        count += 1\n        left += 1\n\n# Output the result\nprint(count)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\nspecial_count = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        special_count += 1\n        left += 1\n\n# Output the result\nprint(special_count)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        count += 1\n        left += 1\n\n# Output the result\nprint(count)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        count += 1\n        left += 1\n\n# Output the result\nprint(count)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\nspecial_count = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        special_count += 1\n        left += 1\n\n# Output the result\nprint(special_count)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\nspecial_count = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        special_count += 1\n        left += 1\n\n# Output the result\nprint(special_count)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_val = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_val = max(max_val, p[right])\n    while p[left] + p[right] == max_val:\n        count += 1\n        left += 1\n\nprint(count)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        count += 1\n        left += 1\n\n# Output the result\nprint(count)",
            "import sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\ncount = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        count += 1\n        left += 1\n\n# Output the result\nprint(count)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\np = list(map(int, data[1:]))\n\n# Initialize variables\nspecial_count = 0\nmax_value = 0\nleft = 0\n\n# Iterate through the permutation to find special subsegments\nfor right in range(n):\n    max_value = max(max_value, p[right])\n    while p[left] + p[right] == max_value:\n        special_count += 1\n        left += 1\n\n# Print the result\nprint(special_count)"
        ]
    },
    {
        "question_title": "And Reachability",
        "question_content": "Toad Pimple has an array of integers a_1, a_2, \\ldots, a_n.\n\nWe say that y is reachable from x if x<y and there exists an integer array p such that x = p_1 < p_2 < \\ldots < p_k=y, and a_{p_i}\\, \\&\\, a_{p_{i+1}} > 0 for all integers i such that 1 \\leq i < k.\n\nHere \\& denotes the bitwise AND operation.\n\nYou are given q pairs of indices, check reachability for each of them.\n\n\nInput Format\nThe first line contains two integers n and q (2 \\leq n \\leq 300\\,000, 1 \\leq q \\leq 300\\,000)\u00a0\u2014 the number of integers in the array and the number of queries you need to answer.\n\nThe second line contains n space-separated integers a_1, a_2, \\ldots, a_n (0 \\leq a_i \\leq 300\\,000)\u00a0\u2014 the given array.\n\nThe next q lines contain two integers each. The i-th of them contains two space-separated integers x_i and y_i (1 \\leq x_i < y_i \\leq n). You need to check if y_i is reachable from x_i.\n\n\nOutput Format\nOutput q lines. In the i-th of them print \"Shi\" if y_i is reachable from x_i, otherwise, print \"Fou\".\n\n\nSample Input 1\n\n5 3\n1 3 0 2 1\n1 3\n2 4\n1 4\n\nSample Output 1\n\nFou\nShi\nShi\n\n\nNote\nIn the first example, a_3 = 0. You can't reach it, because AND with it is always zero. a_2\\, \\&\\, a_4 > 0, so 4 is reachable from 2, and to go from 1 to 4 you can use p = [1, 2, 4].",
        "platform": "codeforces",
        "question_id": "1168/C",
        "contest_id": "1168",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    x = int(data[2+n+2*i]) - 1\n    y = int(data[2+n+2*i+1]) - 1\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    reachable = False\n    for i in range(x, y):\n        if a[i] & a[i+1] > 0:\n            reachable = True\n            break\n    if reachable:\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    x = int(data[2+n+2*i]) - 1\n    y = int(data[2+n+2*i+1]) - 1\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    reachable = False\n    for i in range(x, y):\n        if a[i] & a[i+1] > 0:\n            reachable = True\n            break\n    if reachable:\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    x = int(data[2+n+2*i]) - 1\n    y = int(data[2+n+2*i+1]) - 1\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    reachable = False\n    for i in range(x, y):\n        if a[i] & a[i+1] > 0:\n            reachable = True\n            break\n    if reachable:\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef is_reachable(x, y):\n    if x >= y:\n        return False\n    for i in range(x, y):\n        if a[i] & a[i+1] == 0:\n            return False\n    return True\n\nresults = []\nfor x, y in queries:\n    if is_reachable(x-1, y):\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    x = int(data[2+n+2*i]) - 1\n    y = int(data[2+n+2*i+1]) - 1\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    reachable = False\n    for i in range(x, y):\n        if a[i] & a[i+1] > 0:\n            reachable = True\n            break\n    if reachable:\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(q)]\n\ndef is_reachable(x, y):\n    if a[x] & a[y] > 0:\n        return True\n    for i in range(x+1, y):\n        if a[i] & a[x] == 0 or a[i] & a[y] == 0:\n            return False\n    return True\n\nfor x, y in queries:\n    if is_reachable(x, y):\n        print(\"Shi\")\n    else:\n        print(\"Fou\")\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(q)]\n\ndef is_reachable(x, y):\n    if a[x] & a[y] > 0:\n        return True\n    for i in range(x+1, y):\n        if a[i] & a[x] == 0:\n            return False\n    return True\n\nresults = []\nfor x, y in queries:\n    if is_reachable(x, y):\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    x = int(data[2+n+2*i]) - 1\n    y = int(data[2+n+2*i+1]) - 1\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    reachable = False\n    for i in range(x, y):\n        if a[i] & a[i+1] > 0:\n            reachable = True\n            break\n    if reachable:\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef is_reachable(x, y):\n    if a[x-1] & a[y-1] == 0:\n        return False\n    for i in range(x, y):\n        if a[i-1] & a[i] == 0:\n            return False\n    return True\n\nresults = []\nfor x, y in queries:\n    if is_reachable(x, y):\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(q)]\n\ndef is_reachable(x, y):\n    if a[x] & a[y] > 0:\n        return True\n    for i in range(x+1, y):\n        if a[i] & a[y] == 0:\n            return False\n    return True\n\nfor x, y in queries:\n    if is_reachable(x, y):\n        print(\"Shi\")\n    else:\n        print(\"Fou\")\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    x = int(data[2+n+2*i]) - 1\n    y = int(data[2+n+2*i+1]) - 1\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    reachable = False\n    for i in range(x, y):\n        if a[i] & a[i+1] > 0:\n            reachable = True\n            break\n    if reachable:\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    x = int(data[2+n+2*i]) - 1\n    y = int(data[2+n+2*i+1]) - 1\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    reachable = False\n    for i in range(x, y):\n        if a[i] & a[i+1] > 0:\n            reachable = True\n            break\n    if reachable:\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    x = int(data[2+n+2*i]) - 1\n    y = int(data[2+n+2*i+1]) - 1\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    reachable = False\n    for i in range(x, y):\n        if a[i] & a[i+1] > 0:\n            reachable = True\n            break\n    if reachable:\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef is_reachable(x, y):\n    if x >= y:\n        return False\n    for i in range(x, y):\n        if a[i] & a[i+1] == 0:\n            return False\n    return True\n\nresults = []\nfor x, y in queries:\n    if is_reachable(x-1, y):\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    x = int(data[2+n+2*i]) - 1\n    y = int(data[2+n+2*i+1]) - 1\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    reachable = False\n    for i in range(x, y):\n        if a[i] & a[i+1] > 0:\n            reachable = True\n            break\n    if reachable:\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(q)]\n\ndef is_reachable(x, y):\n    if a[x] & a[y] > 0:\n        return True\n    for i in range(x+1, y):\n        if a[i] & a[x] == 0 or a[i] & a[y] == 0:\n            return False\n    return True\n\nfor x, y in queries:\n    if is_reachable(x, y):\n        print(\"Shi\")\n    else:\n        print(\"Fou\")",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(q)]\n\ndef is_reachable(x, y):\n    if a[x] & a[y] > 0:\n        return True\n    for i in range(x+1, y):\n        if a[i] & a[x] == 0:\n            return False\n    return True\n\nresults = []\nfor x, y in queries:\n    if is_reachable(x, y):\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    x = int(data[2+n+2*i]) - 1\n    y = int(data[2+n+2*i+1]) - 1\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    reachable = False\n    for i in range(x, y):\n        if a[i] & a[i+1] > 0:\n            reachable = True\n            break\n    if reachable:\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef is_reachable(x, y):\n    if a[x-1] & a[y-1] == 0:\n        return False\n    for i in range(x, y):\n        if a[i-1] & a[i] == 0:\n            return False\n    return True\n\nresults = []\nfor x, y in queries:\n    if is_reachable(x, y):\n        results.append(\"Shi\")\n    else:\n        results.append(\"Fou\")\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(q)]\n\ndef is_reachable(x, y):\n    if a[x] & a[y] > 0:\n        return True\n    for i in range(x+1, y):\n        if a[i] & a[y] == 0:\n            return False\n    return True\n\nfor x, y in queries:\n    if is_reachable(x, y):\n        print(\"Shi\")\n    else:\n        print(\"Fou\")"
        ]
    },
    {
        "question_title": "Minimal Segment Cover",
        "question_content": "You are given n intervals in form [l; r] on a number line.\n\nYou are also given m queries in form [x; y]. What is the minimal number of intervals you have to take so that every point (not necessarily integer) from x to y is covered by at least one of them?\n\nIf you can't choose intervals so that every point from x to y is covered, then print -1 for that query.\n\n\nInput Format\nThe first line contains two integers n and m (1 \\le n, m \\le 2 \\cdot 10^5) \u2014 the number of intervals and the number of queries, respectively.\n\nEach of the next n lines contains two integer numbers l_i and r_i (0 \\le l_i < r_i \\le 5 \\cdot 10^5) \u2014 the given intervals.\n\nEach of the next m lines contains two integer numbers x_i and y_i (0 \\le x_i < y_i \\le 5 \\cdot 10^5) \u2014 the queries.\n\n\nOutput Format\nPrint m integer numbers. The i-th number should be the answer to the i-th query: either the minimal number of intervals you have to take so that every point (not necessarily integer) from x_i to y_i is covered by at least one of them or -1 if you can't choose intervals so that every point from x_i to y_i is covered.\n\n\nSample Input 1\n\n2 3\n1 3\n2 4\n1 3\n1 4\n3 4\n\nSample Output 1\n\n1\n2\n1\n\n\nSample Input 2\n\n3 4\n1 3\n1 3\n4 5\n1 2\n1 3\n1 4\n1 5\n\nSample Output 2\n\n1\n1\n-1\n-1\n\n\nNote\nIn the first example there are three queries:\n\n1. query [1; 3] can be covered by interval [1; 3];\n2. query [1; 4] can be covered by intervals [1; 3] and [2; 4]. There is no way to cover [1; 4] by a single interval;\n3. query [3; 4] can be covered by interval [2; 4]. It doesn't matter that the other points are covered besides the given query.\n\nIn the second example there are four queries:\n\n1. query [1; 2] can be covered by interval [1; 3]. Note that you can choose any of the two given intervals [1; 3];\n2. query [1; 3] can be covered by interval [1; 3];\n3. query [1; 4] can't be covered by any set of intervals;\n4. query [1; 5] can't be covered by any set of intervals. Note that intervals [1; 3] and [4; 5] together don't cover [1; 5] because even non-integer points should be covered. Here 3.5, for example, isn't covered.",
        "platform": "codeforces",
        "question_id": "1175/E",
        "contest_id": "1175",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append((l, r))\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    if y < x:\n        results.append(-1)\n        continue\n    \n    covered = False\n    for l, r in intervals:\n        if l <= x and y <= r:\n            results.append(1)\n            covered = True\n            break\n        elif l <= x and x < r <= y:\n            results.append(1)\n            covered = True\n            break\n        elif x < l <= y <= r:\n            results.append(1)\n            covered = True\n            break\n        elif x < l and y > r:\n            results.append(2)\n            covered = True\n            break\n    if not covered:\n        results.append(-1)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(n: int, m: int, intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(x: int, y: int) -> int:\n        # Sort intervals by their end points\n        intervals.sort(key=lambda i: i[1])\n        covered = 0\n        i = 0\n        while i < n and intervals[i][1] < x:\n            i += 1\n        while i < n and intervals[i][0] <= y:\n            covered += 1\n            i += 1\n        return covered if i > 0 else -1\n\n    results = []\n    for x, y in queries:\n        result = can_cover(x, y)\n        results.append(result)\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve the problem\nresults = min_intervals_to_cover_queries(n, m, intervals, queries)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append((l, r))\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append((x, y))\n\ndef min_intervals_to_cover(x, y, intervals):\n    intervals.sort()\n    covered = 0\n    for l, r in intervals:\n        if l <= x and y <= r:\n            return 1\n        elif l <= x and x <= r < y:\n            covered += 1\n            x = r\n        elif x <= l and l <= y <= r:\n            covered += 1\n            y = l\n        elif x <= l and y <= r:\n            covered += 2\n            x = l\n            y = r\n    if x <= y:\n        return -1\n    return covered\n\nresults = []\nfor x, y in queries:\n    result = min_intervals_to_cover(x, y, intervals)\n    results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(n: int, m: int, intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(x: int, y: int) -> int:\n        # Sort intervals by their end points\n        intervals.sort(key=lambda i: i[1])\n        i = 0\n        count = 0\n        while i < n and intervals[i][1] < x:\n            i += 1\n        if i == n:\n            return -1\n        while i < n and intervals[i][0] <= y:\n            count += 1\n            i += 1\n        return count\n\n    results = []\n    for x, y in queries:\n        results.append(can_cover(x, y))\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve the problem\nresults = min_intervals_to_cover_queries(n, m, intervals, queries)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append((l, r))\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    if y < x:\n        results.append(-1)\n        continue\n    \n    covered = False\n    for l, r in intervals:\n        if l <= x and y <= r:\n            results.append(1)\n            covered = True\n            break\n        elif l <= x and x < r <= y:\n            results.append(1)\n            covered = True\n            break\n        elif x < l <= y <= r:\n            results.append(1)\n            covered = True\n            break\n        elif x < l and y > r:\n            results.append(2)\n            covered = True\n            break\n    if not covered:\n        results.append(-1)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(n: int, m: int, intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(x: int, y: int) -> int:\n        # Sort intervals by their right endpoint\n        intervals.sort(key=lambda interval: interval[1])\n        covered = 0\n        i = 0\n        while i < n and intervals[i][1] < x:\n            i += 1\n        while i < n and intervals[i][0] <= y:\n            covered += 1\n            i += 1\n        return covered if covered > 0 else -1\n\n    results = []\n    for query in queries:\n        x, y = query\n        result = can_cover(x, y)\n        results.append(result)\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve the problem\nresults = min_intervals_to_cover_queries(n, m, intervals, queries)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(n: int, m: int, intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(x: int, y: int) -> int:\n        covered = False\n        for l, r in intervals:\n            if l <= x and y <= r:\n                covered = True\n                break\n        if not covered:\n            return -1\n        return 1\n\n    results = []\n    for x, y in queries:\n        result = can_cover(x, y)\n        results.append(result)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    intervals = []\n    for i in range(n):\n        l = int(data[2 + 2 * i])\n        r = int(data[3 + 2 * i])\n        intervals.append([l, r])\n    \n    queries = []\n    for i in range(m):\n        x = int(data[2 + 2 * n + 2 * i])\n        y = int(data[3 + 2 * n + 2 * i])\n        queries.append([x, y])\n    \n    results = min_intervals_to_cover_queries(n, m, intervals, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_intervals_to_cover(intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(query: List[int]) -> int:\n        x, y = query\n        if x >= y:\n            return -1\n        covered = set()\n        for l, r in intervals:\n            if l <= x and y <= r:\n                return 1\n            if l <= x and x < r:\n                covered.add(r)\n            if l < y and y <= r:\n                covered.add(l)\n        if x in covered or y in covered:\n            return 1\n        if len(covered) == 0:\n            return -1\n        if len(covered) == 1:\n            return 2\n        return 1\n\n    results = []\n    for query in queries:\n        result = can_cover(query)\n        results.append(result)\n    return results\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve the problem\nresults = min_intervals_to_cover(intervals, queries)\n\n# Write output to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(n: int, m: int, intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    # Sort intervals by their end points\n    intervals.sort(key=lambda x: x[1])\n    \n    results = []\n    \n    for x, y in queries:\n        count = 0\n        i = 0\n        while i < n and intervals[i][1] < x:\n            i += 1\n        \n        while i < n and intervals[i][0] <= y:\n            count += 1\n            i += 1\n        \n        if i == n or intervals[i][0] > y:\n            results.append(-1)\n        else:\n            results.append(count)\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve the problem\nresults = min_intervals_to_cover_queries(n, m, intervals, queries)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(query: List[int]) -> int:\n        x, y = query\n        covered = False\n        for l, r in intervals:\n            if l <= x and y <= r:\n                return 1\n            if l <= x and x <= r and r < y:\n                covered = True\n            if l < x and x < r and y <= r:\n                covered = True\n            if l < x and x < r and y > r:\n                return 2\n        return -1 if not covered else 1\n\n    results = []\n    for query in queries:\n        result = can_cover(query)\n        results.append(result)\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve and write output\nresults = min_intervals_to_cover_queries(intervals, queries)\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append((l, r))\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    if y < x:\n        results.append(-1)\n        continue\n    \n    covered = False\n    for l, r in intervals:\n        if l <= x and y <= r:\n            results.append(1)\n            covered = True\n            break\n        elif l <= x and x < r <= y:\n            results.append(1)\n            covered = True\n            break\n        elif x < l <= y <= r:\n            results.append(1)\n            covered = True\n            break\n        elif x < l and y > r:\n            results.append(2)\n            covered = True\n            break\n    if not covered:\n        results.append(-1)\n\nfor result in results:\n    print(result)",
            "import sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(n: int, m: int, intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(x: int, y: int) -> int:\n        # Sort intervals by their end points\n        intervals.sort(key=lambda i: i[1])\n        covered = 0\n        i = 0\n        while i < n and intervals[i][1] < x:\n            i += 1\n        while i < n and intervals[i][0] <= y:\n            covered += 1\n            i += 1\n        return covered if i > 0 else -1\n\n    results = []\n    for x, y in queries:\n        result = can_cover(x, y)\n        results.append(result)\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve the problem\nresults = min_intervals_to_cover_queries(n, m, intervals, queries)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append((l, r))\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append((x, y))\n\ndef min_intervals_to_cover(x, y, intervals):\n    intervals.sort()\n    covered = 0\n    for l, r in intervals:\n        if l <= x and y <= r:\n            return 1\n        elif l <= x and x <= r < y:\n            covered += 1\n            x = r\n        elif x <= l and l <= y <= r:\n            covered += 1\n            y = l\n        elif x <= l and y <= r:\n            covered += 2\n            x = l\n            y = r\n    if x <= y:\n        return -1\n    return covered\n\nresults = []\nfor x, y in queries:\n    result = min_intervals_to_cover(x, y, intervals)\n    results.append(result)\n\nfor result in results:\n    print(result)",
            "import sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(n: int, m: int, intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(x: int, y: int) -> int:\n        # Sort intervals by their end points\n        intervals.sort(key=lambda i: i[1])\n        i = 0\n        count = 0\n        while i < n and intervals[i][1] < x:\n            i += 1\n        if i == n:\n            return -1\n        while i < n and intervals[i][0] <= y:\n            count += 1\n            i += 1\n        return count\n\n    results = []\n    for x, y in queries:\n        results.append(can_cover(x, y))\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve the problem\nresults = min_intervals_to_cover_queries(n, m, intervals, queries)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append((l, r))\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append((x, y))\n\nresults = []\n\nfor x, y in queries:\n    if y < x:\n        results.append(-1)\n        continue\n    \n    covered = False\n    for l, r in intervals:\n        if l <= x and y <= r:\n            results.append(1)\n            covered = True\n            break\n        elif l <= x and x < r <= y:\n            results.append(1)\n            covered = True\n            break\n        elif x < l <= y <= r:\n            results.append(1)\n            covered = True\n            break\n        elif x < l and y > r:\n            results.append(2)\n            covered = True\n            break\n    if not covered:\n        results.append(-1)\n\nfor result in results:\n    print(result)",
            "import sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(n: int, m: int, intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(x: int, y: int) -> int:\n        # Sort intervals by their right endpoint\n        intervals.sort(key=lambda interval: interval[1])\n        covered = 0\n        i = 0\n        while i < n and intervals[i][1] < x:\n            i += 1\n        while i < n and intervals[i][0] <= y:\n            covered += 1\n            i += 1\n        return covered if covered > 0 else -1\n\n    results = []\n    for query in queries:\n        x, y = query\n        result = can_cover(x, y)\n        results.append(result)\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve the problem\nresults = min_intervals_to_cover_queries(n, m, intervals, queries)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(n: int, m: int, intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(x: int, y: int) -> int:\n        covered = False\n        for l, r in intervals:\n            if l <= x and y <= r:\n                covered = True\n                break\n        if not covered:\n            return -1\n        return 1\n\n    results = []\n    for x, y in queries:\n        result = can_cover(x, y)\n        results.append(result)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    intervals = []\n    for i in range(n):\n        l = int(data[2 + 2 * i])\n        r = int(data[3 + 2 * i])\n        intervals.append([l, r])\n    \n    queries = []\n    for i in range(m):\n        x = int(data[2 + 2 * n + 2 * i])\n        y = int(data[3 + 2 * n + 2 * i])\n        queries.append([x, y])\n    \n    results = min_intervals_to_cover_queries(n, m, intervals, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom typing import List\n\ndef min_intervals_to_cover(intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(query: List[int]) -> int:\n        x, y = query\n        if x >= y:\n            return -1\n        covered = set()\n        for l, r in intervals:\n            if l <= x and y <= r:\n                return 1\n            if l <= x and x < r:\n                covered.add(r)\n            if l < y and y <= r:\n                covered.add(l)\n        if x in covered or y in covered:\n            return 1\n        if len(covered) == 0:\n            return -1\n        if len(covered) == 1:\n            return 2\n        return 1\n\n    results = []\n    for query in queries:\n        result = can_cover(query)\n        results.append(result)\n    return results\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve the problem\nresults = min_intervals_to_cover(intervals, queries)\n\n# Write output to stdout\nfor result in results:\n    print(result)",
            "import sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(n: int, m: int, intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    # Sort intervals by their end points\n    intervals.sort(key=lambda x: x[1])\n    \n    results = []\n    \n    for x, y in queries:\n        count = 0\n        i = 0\n        while i < n and intervals[i][1] < x:\n            i += 1\n        \n        while i < n and intervals[i][0] <= y:\n            count += 1\n            i += 1\n        \n        if i == n or intervals[i][0] > y:\n            results.append(-1)\n        else:\n            results.append(count)\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve the problem\nresults = min_intervals_to_cover_queries(n, m, intervals, queries)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\nfrom typing import List\n\ndef min_intervals_to_cover_queries(intervals: List[List[int]], queries: List[List[int]]) -> List[int]:\n    def can_cover(query: List[int]) -> int:\n        x, y = query\n        covered = False\n        for l, r in intervals:\n            if l <= x and y <= r:\n                return 1\n            if l <= x and x <= r and r < y:\n                covered = True\n            if l < x and x < r and y <= r:\n                covered = True\n            if l < x and x < r and y > r:\n                return 2\n        return -1 if not covered else 1\n\n    results = []\n    for query in queries:\n        result = can_cover(query)\n        results.append(result)\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nintervals = []\nfor i in range(n):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    intervals.append([l, r])\n\nqueries = []\nfor i in range(m):\n    x = int(data[2 + 2 * n + 2 * i])\n    y = int(data[3 + 2 * n + 2 * i])\n    queries.append([x, y])\n\n# Solve and write output\nresults = min_intervals_to_cover_queries(intervals, queries)\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Yet Another Partiton Problem",
        "question_content": "You are given array a_1, a_2, \\dots, a_n. You need to split it into k subsegments (so every element is included in exactly one subsegment).\n\nThe weight of a subsegment a_l, a_{l+1}, \\dots, a_r is equal to (r - l + 1) \\cdot \\max\\limits_{l \\le i \\le r}(a_i). The weight of a partition is a total weight of all its segments.\n\nFind the partition of minimal weight.\n\n\nInput Format\nThe first line contains two integers n and k (1 \\le n \\le 2 \\cdot 10^4, 1 \\le k \\le \\min(100, n)) \u2014 the length of the array a and the number of subsegments in the partition.\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le 2 \\cdot 10^4) \u2014 the array a.\n\n\nOutput Format\nPrint single integer \u2014 the minimal weight among all possible partitions.\n\n\nSample Input 1\n\n4 2\n6 1 7 4\n\nSample Output 1\n\n25\n\n\nSample Input 2\n\n4 3\n6 1 7 4\n\nSample Output 2\n\n21\n\n\nSample Input 3\n\n5 4\n5 1 5 1 5\n\nSample Output 3\n\n21\n\n\nNote\nThe optimal partition in the first example is next: 6 1 7 \\bigg| 4.\n\nThe optimal partition in the second example is next: 6 \\bigg| 1 \\bigg| 7 4.\n\nOne of the optimal partitions in the third example is next: 5 \\bigg| 1 5 \\bigg| 1 \\bigg| 5.",
        "platform": "codeforces",
        "question_id": "1175/G",
        "contest_id": "1175",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\nmax_a = [0] * (n + 1)\n\nfor i in range(n - 1, -1, -1):\n    max_a[i] = max(max_a[i + 1], a[i])\n\nfor i in range(1, n + 1):\n    dp[i][1] = (i) * max_a[i]\n\nfor j in range(2, k + 1):\n    for i in range(j, n + 1):\n        for l in range(j - 1, i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[l])\n\nprint(dp[n][k])\n```",
            "```python\nimport sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array for the maximum value in the subarray\nmax_a = [0] * (n + 1)\nmax_a[0] = -1\nfor i in range(1, n + 1):\n    max_a[i] = max(max_a[i - 1], a[i - 1])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[i])\n\n# The answer is the minimum weight for partitioning the entire array into k segments\nprint(dp[n][k])\n```",
            "```python\nimport sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array\nmax_a = [0] * (n + 1)\nfor i in range(n):\n    max_a[i + 1] = max(max_a[i], a[i])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[i])\n\n# The answer is the minimum weight of partitioning the entire array into k segments\nprint(dp[n][k])\n```",
            "```python\nimport sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array for the maximum value in each segment\nmax_val = [0] * (n + 1)\n\n# Fill the max_val array\nfor i in range(1, n + 1):\n    max_val[i] = max(max_val[i - 1], a[i - 1])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_val[i])\n\n# The answer is the minimum weight of partitioning the array into k segments\nprint(dp[n][k])\n```",
            "```python\nimport sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array\nmax_a = [0] * (n + 1)\nfor i in range(n):\n    max_a[i + 1] = max(max_a[i], a[i])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[i])\n\n# The answer is the minimum weight of partitioning the entire array into k segments\nprint(dp[n][k])\n```",
            "```python\nimport sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array\nmax_a = [0] * (n + 1)\nfor i in range(n):\n    max_a[i + 1] = max(max_a[i], a[i])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[i])\n\n# The answer is the minimum weight of partitioning the array into k segments\nprint(dp[n][k])\n```",
            "```python\nimport sys\n\ndef min_partition_weight(n, k, a):\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    max_val = [0] * (n + 1)\n    \n    for i in range(n - 1, -1, -1):\n        max_val[i] = max(max_val[i + 1], a[i])\n    \n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for l in range(i):\n                dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_val[l])\n    \n    return dp[n][k]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nprint(min_partition_weight(n, k, a))\n```",
            "```python\nimport sys\n\ndef min_partition_weight(n, k, a):\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            max_val = 0\n            for l in range(i, 0, -1):\n                max_val = max(max_val, a[l - 1])\n                dp[i][j] = min(dp[i][j], dp[l - 1][j - 1] + (i - l + 1) * max_val)\n    \n    return dp[n][k]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nprint(min_partition_weight(n, k, a))\n```",
            "```python\nimport sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array\nmax_a = [0] * (n + 1)\nfor i in range(n):\n    max_a[i + 1] = max(max_a[i], a[i])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[i])\n\n# The answer is the minimum weight of partitioning the array into k segments\nprint(dp[n][k])\n```",
            "```python\nimport sys\n\ndef min_partition_weight(n, k, a):\n    # Initialize the DP table\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    # Iterate over each position in the array\n    for i in range(1, n + 1):\n        # Iterate over each possible number of segments\n        for j in range(1, min(i, k) + 1):\n            # Iterate over each possible end position of the last segment\n            for l in range(i, 0, -1):\n                # Calculate the weight of the current segment\n                segment_weight = (i - l + 1) * max(a[l-1:i])\n                # Update the DP table\n                dp[i][j] = min(dp[i][j], dp[l-1][j-1] + segment_weight)\n    \n    return dp[n][k]\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the minimum partition weight\nresult = min_partition_weight(n, k, a)\n\n# Write the result to stdout\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\nmax_a = [0] * (n + 1)\n\nfor i in range(n - 1, -1, -1):\n    max_a[i] = max(max_a[i + 1], a[i])\n\nfor i in range(1, n + 1):\n    dp[i][1] = (i) * max_a[i]\n\nfor j in range(2, k + 1):\n    for i in range(j, n + 1):\n        for l in range(j - 1, i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[l])\n\nprint(dp[n][k])",
            "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array for the maximum value in the subarray\nmax_a = [0] * (n + 1)\nmax_a[0] = -1\nfor i in range(1, n + 1):\n    max_a[i] = max(max_a[i - 1], a[i - 1])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[i])\n\n# The answer is the minimum weight for partitioning the entire array into k segments\nprint(dp[n][k])",
            "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array\nmax_a = [0] * (n + 1)\nfor i in range(n):\n    max_a[i + 1] = max(max_a[i], a[i])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[i])\n\n# The answer is the minimum weight of partitioning the entire array into k segments\nprint(dp[n][k])",
            "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array for the maximum value in each segment\nmax_val = [0] * (n + 1)\n\n# Fill the max_val array\nfor i in range(1, n + 1):\n    max_val[i] = max(max_val[i - 1], a[i - 1])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_val[i])\n\n# The answer is the minimum weight of partitioning the array into k segments\nprint(dp[n][k])",
            "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array\nmax_a = [0] * (n + 1)\nfor i in range(n):\n    max_a[i + 1] = max(max_a[i], a[i])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[i])\n\n# The answer is the minimum weight of partitioning the entire array into k segments\nprint(dp[n][k])",
            "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array\nmax_a = [0] * (n + 1)\nfor i in range(n):\n    max_a[i + 1] = max(max_a[i], a[i])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[i])\n\n# The answer is the minimum weight of partitioning the array into k segments\nprint(dp[n][k])",
            "import sys\n\ndef min_partition_weight(n, k, a):\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    max_val = [0] * (n + 1)\n    \n    for i in range(n - 1, -1, -1):\n        max_val[i] = max(max_val[i + 1], a[i])\n    \n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for l in range(i):\n                dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_val[l])\n    \n    return dp[n][k]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nprint(min_partition_weight(n, k, a))",
            "import sys\n\ndef min_partition_weight(n, k, a):\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            max_val = 0\n            for l in range(i, 0, -1):\n                max_val = max(max_val, a[l - 1])\n                dp[i][j] = min(dp[i][j], dp[l - 1][j - 1] + (i - l + 1) * max_val)\n    \n    return dp[n][k]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nprint(min_partition_weight(n, k, a))",
            "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the DP table\ndp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# Initialize the max array\nmax_a = [0] * (n + 1)\nfor i in range(n):\n    max_a[i + 1] = max(max_a[i], a[i])\n\n# Fill the DP table\nfor i in range(1, n + 1):\n    for j in range(1, min(i, k) + 1):\n        for l in range(i):\n            dp[i][j] = min(dp[i][j], dp[l][j - 1] + (i - l) * max_a[i])\n\n# The answer is the minimum weight of partitioning the array into k segments\nprint(dp[n][k])",
            "import sys\n\ndef min_partition_weight(n, k, a):\n    # Initialize the DP table\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    # Iterate over each position in the array\n    for i in range(1, n + 1):\n        # Iterate over each possible number of segments\n        for j in range(1, min(i, k) + 1):\n            # Iterate over each possible end position of the last segment\n            for l in range(i, 0, -1):\n                # Calculate the weight of the current segment\n                segment_weight = (i - l + 1) * max(a[l-1:i])\n                # Update the DP table\n                dp[i][j] = min(dp[i][j], dp[l-1][j-1] + segment_weight)\n    \n    return dp[n][k]\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the minimum partition weight\nresult = min_partition_weight(n, k, a)\n\n# Write the result to stdout\nprint(result)"
        ]
    },
    {
        "question_title": "Count Pairs",
        "question_content": "You are given a prime number p, n integers a_1, a_2, \\ldots, a_n, and an integer k.\n\nFind the number of pairs of indexes (i, j) (1 \\le i < j \\le n) for which (a_i + a_j)(a_i^2 + a_j^2) \\equiv k \\bmod p.\n\n\nInput Format\nThe first line contains integers n, p, k (2 \\le n \\le 3 \\cdot 10^5, 2 \\le p \\le 10^9, 0 \\le k \\le p-1). p is guaranteed to be prime.\n\nThe second line contains n integers a_1, a_2, \\ldots, a_n (0 \\le a_i \\le p-1). It is guaranteed that all elements are different.\n\n\nOutput Format\nOutput a single integer\u00a0\u2014 answer to the problem.\n\n\nSample Input 1\n\n3 3 0\n0 1 2\n\nSample Output 1\n\n1\n\n\nSample Input 2\n\n6 7 2\n1 2 3 4 5 6\n\nSample Output 2\n\n3\n\n\nNote\nIn the first example:\n\n(0+1)(0^2 + 1^2) = 1 \\equiv 1 \\bmod 3.\n\n(0+2)(0^2 + 2^2) = 8 \\equiv 2 \\bmod 3.\n\n(1+2)(1^2 + 2^2) = 15 \\equiv 0 \\bmod 3.\n\nSo only 1 pair satisfies the condition.\n\nIn the second example, there are 3 such pairs: (1, 5), (2, 3), (4, 6).",
        "platform": "codeforces",
        "question_id": "1188/B",
        "contest_id": "1188",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p for each j\ncount = {}\nresult = 0\n\n# Iterate over each a_i\nfor i in range(n):\n    for j in range(i + 1, n):\n        sum_mod = (a[i] + a[j]) % p\n        target = (k * pow(sum_mod, p - 2, p)) % p\n        if target in count:\n            result += count[target]\n    if a[i] not in count:\n        count[a[i]] = 0\n    count[a[i]] += 1\n\n# Output the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\ncount = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if (a[i] + a[j]) * (a[i]**2 + a[j]**2) % p == k:\n            count += 1\n\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p for each j\ncount = defaultdict(int)\nresult = 0\n\n# Iterate over each a_i\nfor i in range(n):\n    # Calculate the required value for a_j\n    for j in range(i + 1, n):\n        a_i = a[i]\n        a_j = a[j]\n        target = (k * (a_i**2 + a_j**2)) % p\n        if (target - a_i) % p in count:\n            result += count[(target - a_i) % p]\n    # Update the count for the current a_i\n    for j in range(i + 1, n):\n        a_i = a[i]\n        a_j = a[j]\n        count[(a_i + a_j) % p] += 1\n\n# Output the result\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p for each j\ncount = {}\nresult = 0\n\n# Iterate over each a_i\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Calculate (a_i + a_j) % p and (a_i^2 + a_j^2) % p\n        sum_mod = (a[i] + a[j]) % p\n        sum_squares_mod = (a[i]**2 + a[j]**2) % p\n        \n        # Check if (a_i + a_j)(a_i^2 + a_j^2) % p == k\n        if (sum_mod * sum_squares_mod) % p == k:\n            result += 1\n\n# Output the result\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p for each j\ncount = {}\nresult = 0\n\n# Iterate over each a_i\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Calculate (a_i + a_j) % p and (a_i^2 + a_j^2) % p\n        sum_mod = (a[i] + a[j]) % p\n        sum_squares_mod = (a[i]**2 + a[j]**2) % p\n        \n        # Check if (a_i + a_j)(a_i^2 + a_j^2) % p == k\n        if (sum_mod * sum_squares_mod) % p == k:\n            result += 1\n\n# Output the result\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i^2 + a_i^2) % p\nsum_squares = {}\nfor a_i in a:\n    sum_squares[(a_i * a_i + a_i * a_i) % p] = sum_squares.get((a_i * a_i + a_i * a_i) % p, 0) + 1\n\n# Dictionary to store the count of (a_i + a_j) % p for each a_i\nsums = {}\nfor a_i in a:\n    for a_j in a:\n        if a_i != a_j:\n            sums[(a_i + a_j) % p] = sums.get((a_i + a_j) % p, 0) + 1\n\n# Calculate the number of valid pairs\ncount = 0\nfor a_i in a:\n    for a_j in a:\n        if a_i != a_j:\n            if (a_i + a_j) % p in sums and (a_i * a_i + a_j * a_j) % p in sum_squares:\n                count += sums[(a_i + a_j) % p] * sum_squares[(a_i * a_i + a_j * a_j) % p]\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p\ncount = {}\nresult = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        sum_a = (a[i] + a[j]) % p\n        target = (k * pow(sum_a, -1, p)) % p\n        if target in count:\n            result += count[target]\n        if sum_a in count:\n            count[sum_a] += 1\n        else:\n            count[sum_a] = 1\n\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the values of (a_i + a_j) % p and their counts\nsum_counts = defaultdict(int)\n\n# Dictionary to store the values of (a_i^2 + a_j^2) % p and their counts\nsquare_counts = defaultdict(int)\n\n# Dictionary to store the values of (a_i + a_j)(a_i^2 + a_j^2) % p and their counts\nproduct_counts = defaultdict(int)\n\n# Iterate over all pairs (i, j) with i < j\nfor i in range(n):\n    for j in range(i + 1, n):\n        a_i = a[i]\n        a_j = a[j]\n        sum_val = (a_i + a_j) % p\n        square_val = (a_i**2 + a_j**2) % p\n        product_val = (sum_val * square_val) % p\n        product_counts[product_val] += 1\n\n# Output the number of pairs that satisfy the condition\nprint(product_counts[k])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p\ncount = {}\nresult = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        sum_ab = (a[i] + a[j]) % p\n        target = (k * pow(sum_ab, -1, p)) % p\n        if target in count:\n            result += count[target]\n        if sum_ab in count:\n            count[sum_ab] += 1\n        else:\n            count[sum_ab] = 1\n\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p for each j\ncount = defaultdict(int)\nresult = 0\n\n# Iterate over each a_i\nfor i in range(n):\n    for j in range(i + 1, n):\n        a_i = a[i]\n        a_j = a[j]\n        product = (a_i + a_j) * (a_i**2 + a_j**2)\n        if product % p == k:\n            result += 1\n\n# Output the result\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p for each j\ncount = {}\nresult = 0\n\n# Iterate over each a_i\nfor i in range(n):\n    for j in range(i + 1, n):\n        sum_mod = (a[i] + a[j]) % p\n        target = (k * pow(sum_mod, p - 2, p)) % p\n        if target in count:\n            result += count[target]\n    if a[i] not in count:\n        count[a[i]] = 0\n    count[a[i]] += 1\n\n# Output the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\ncount = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if (a[i] + a[j]) * (a[i]**2 + a[j]**2) % p == k:\n            count += 1\n\nprint(count)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p for each j\ncount = defaultdict(int)\nresult = 0\n\n# Iterate over each a_i\nfor i in range(n):\n    # Calculate the required value for a_j\n    for j in range(i + 1, n):\n        a_i = a[i]\n        a_j = a[j]\n        target = (k * (a_i**2 + a_j**2)) % p\n        if (target - a_i) % p in count:\n            result += count[(target - a_i) % p]\n    # Update the count for the current a_i\n    for j in range(i + 1, n):\n        a_i = a[i]\n        a_j = a[j]\n        count[(a_i + a_j) % p] += 1\n\n# Output the result\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p for each j\ncount = {}\nresult = 0\n\n# Iterate over each a_i\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Calculate (a_i + a_j) % p and (a_i^2 + a_j^2) % p\n        sum_mod = (a[i] + a[j]) % p\n        sum_squares_mod = (a[i]**2 + a[j]**2) % p\n        \n        # Check if (a_i + a_j)(a_i^2 + a_j^2) % p == k\n        if (sum_mod * sum_squares_mod) % p == k:\n            result += 1\n\n# Output the result\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p for each j\ncount = {}\nresult = 0\n\n# Iterate over each a_i\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Calculate (a_i + a_j) % p and (a_i^2 + a_j^2) % p\n        sum_mod = (a[i] + a[j]) % p\n        sum_squares_mod = (a[i]**2 + a[j]**2) % p\n        \n        # Check if (a_i + a_j)(a_i^2 + a_j^2) % p == k\n        if (sum_mod * sum_squares_mod) % p == k:\n            result += 1\n\n# Output the result\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i^2 + a_i^2) % p\nsum_squares = {}\nfor a_i in a:\n    sum_squares[(a_i * a_i + a_i * a_i) % p] = sum_squares.get((a_i * a_i + a_i * a_i) % p, 0) + 1\n\n# Dictionary to store the count of (a_i + a_j) % p for each a_i\nsums = {}\nfor a_i in a:\n    for a_j in a:\n        if a_i != a_j:\n            sums[(a_i + a_j) % p] = sums.get((a_i + a_j) % p, 0) + 1\n\n# Calculate the number of valid pairs\ncount = 0\nfor a_i in a:\n    for a_j in a:\n        if a_i != a_j:\n            if (a_i + a_j) % p in sums and (a_i * a_i + a_j * a_j) % p in sum_squares:\n                count += sums[(a_i + a_j) % p] * sum_squares[(a_i * a_i + a_j * a_j) % p]\n\n# Output the result\nprint(count)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p\ncount = {}\nresult = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        sum_a = (a[i] + a[j]) % p\n        target = (k * pow(sum_a, -1, p)) % p\n        if target in count:\n            result += count[target]\n        if sum_a in count:\n            count[sum_a] += 1\n        else:\n            count[sum_a] = 1\n\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the values of (a_i + a_j) % p and their counts\nsum_counts = defaultdict(int)\n\n# Dictionary to store the values of (a_i^2 + a_j^2) % p and their counts\nsquare_counts = defaultdict(int)\n\n# Dictionary to store the values of (a_i + a_j)(a_i^2 + a_j^2) % p and their counts\nproduct_counts = defaultdict(int)\n\n# Iterate over all pairs (i, j) with i < j\nfor i in range(n):\n    for j in range(i + 1, n):\n        a_i = a[i]\n        a_j = a[j]\n        sum_val = (a_i + a_j) % p\n        square_val = (a_i**2 + a_j**2) % p\n        product_val = (sum_val * square_val) % p\n        product_counts[product_val] += 1\n\n# Output the number of pairs that satisfy the condition\nprint(product_counts[k])",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p\ncount = {}\nresult = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        sum_ab = (a[i] + a[j]) % p\n        target = (k * pow(sum_ab, -1, p)) % p\n        if target in count:\n            result += count[target]\n        if sum_ab in count:\n            count[sum_ab] += 1\n        else:\n            count[sum_ab] = 1\n\nprint(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\np = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:]))\n\n# Dictionary to store the count of (a_i + a_j) % p for each j\ncount = defaultdict(int)\nresult = 0\n\n# Iterate over each a_i\nfor i in range(n):\n    for j in range(i + 1, n):\n        a_i = a[i]\n        a_j = a[j]\n        product = (a_i + a_j) * (a_i**2 + a_j**2)\n        if product % p == k:\n            result += 1\n\n# Output the result\nprint(result)"
        ]
    },
    {
        "question_title": "Remainder Problem",
        "question_content": "You are given an array a consisting of 500000 integers (numbered from 1 to 500000). Initially all elements of a are zero.\n\nYou have to process two types of queries to this array:\n\n- 1 x y\u00a0\u2014 increase a_x by y;\n- 2 x y\u00a0\u2014 compute \\sum\\limits_{i \\in R(x, y)} a_i, where R(x, y) is the set of all integers from 1 to 500000 which have remainder y modulo x.\n\nCan you process all the queries?\n\n\nInput Format\nThe first line contains one integer q (1 \\le q \\le 500000) \u2014 the number of queries.\n\nThen q lines follow, each describing a query. The i-th line contains three integers t_i, x_i and y_i (1 \\le t_i \\le 2). If t_i = 1, then it is a query of the first type, 1 \\le x_i \\le 500000, and -1000 \\le y_i \\le 1000. If t_i = 2, then it it a query of the second type, 1 \\le x_i \\le 500000, and 0 \\le y_i < x_i.\n\nIt is guaranteed that there will be at least one query of type 2.\n\n\nOutput Format\nFor each query of type 2 print one integer \u2014 the answer to it.\n\n\nSample Input 1\n\n5\n1 3 4\n2 3 0\n2 4 3\n1 4 -4\n2 1 0\n\nSample Output 1\n\n4\n4\n0",
        "platform": "codeforces",
        "question_id": "1207/F",
        "contest_id": "1207",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Initialize variables\nq = int(data[0])\nindex = 1\nresults = []\n\n# Process each query\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        # Increase a_x by y\n        a[x - 1] += y\n    elif t == 2:\n        # Compute the sum of a_i for all i in R(x, y)\n        total = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                total += a[i - 1]\n        results.append(total)\n\n# Write results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n\n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        # Increase a_x by y\n        a[x - 1] += y\n    elif t == 2:\n        # Compute the sum of all a_i where i % x == y\n        total = sum(a[i] for i in range(y, 500000, x))\n        results.append(total)\n\n# Print all results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Initialize variables\nq = int(data[0])\nindex = 1\nresults = []\n\n# Process each query\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        # Increase a_x by y\n        a[x - 1] += y\n    elif t == 2:\n        # Compute the sum of a_i for i in R(x, y)\n        total = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                total += a[i - 1]\n        results.append(total)\n\n# Write results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Initialize variables\nq = int(data[0])\nindex = 1\nresults = []\n\n# Process each query\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        # Increase a_x by y\n        a[x - 1] += y\n    elif t == 2:\n        # Compute the sum of a_i for all i in R(x, y)\n        total = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                total += a[i - 1]\n        results.append(total)\n\n# Write results to stdout\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n\n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        # Increase a_x by y\n        a[x - 1] += y\n    elif t == 2:\n        # Compute the sum of all a_i where i % x == y\n        total = sum(a[i] for i in range(y, 500000, x))\n        results.append(total)\n\n# Print all results\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Initialize variables\nq = int(data[0])\nindex = 1\nresults = []\n\n# Process each query\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        # Increase a_x by y\n        a[x - 1] += y\n    elif t == 2:\n        # Compute the sum of a_i for i in R(x, y)\n        total = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                total += a[i - 1]\n        results.append(total)\n\n# Write results to stdout\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nindex = 1\na = [0] * 500001\n\nfor _ in range(q):\n    t = int(data[index])\n    x = int(data[index + 1])\n    y = int(data[index + 2])\n    index += 3\n    \n    if t == 1:\n        a[x] += y\n    elif t == 2:\n        result = 0\n        for i in range(1, 500001):\n            if i % x == y:\n                result += a[i]\n        print(result)"
        ]
    },
    {
        "question_title": "Almost Same Distance",
        "question_content": "Let G be a simple graph. Let W be a non-empty subset of vertices. Then W is almost-k-uniform if for each pair of distinct vertices u,v \\in W the distance between u and v is either k or k+1.\n\nYou are given a tree on n vertices. For each i between 1 and n, find the maximum size of an almost-i-uniform set.\n\n\nInput Format\nThe first line contains a single integer n (2 \\leq n \\leq 5 \\cdot 10^5)\u00a0- the number of vertices of the tree.\n\nThen n-1 lines follows, the i-th of which consisting of two space separated integers u_i, v_i (1 \\leq u_i, v_i \\leq n) meaning that there is an edge between vertices u_i and v_i.\n\nIt is guaranteed that the given graph is tree.\n\n\nOutput Format\nOutput a single line containing n space separated integers a_i, where a_i is the maximum size of an almost-i-uniform set.\n\n\nSample Input 1\n\n5\n1 2\n1 3\n1 4\n4 5\n\nSample Output 1\n\n4 3 2 1 1\n\n\nSample Input 2\n\n6\n1 2\n1 3\n1 4\n4 5\n4 6\n\nSample Output 2\n\n4 4 2 1 1 1\n\n\nNote\nConsider the first example.\n\n- The only maximum almost-1-uniform set is \\{1, 2, 3, 4\\}.\n- One of the maximum almost-2-uniform sets is or \\{2, 3, 5\\}, another one is \\{2, 3, 4\\}.\n- A maximum almost-3-uniform set is any pair of vertices on distance 3.\n- Any single vertex is an almost-k-uniform set for k \\geq 1.\n\nIn the second sample there is an almost-2-uniform set of size 4, and that is \\{2, 3, 5, 6\\}.",
        "platform": "codeforces",
        "question_id": "1266/F",
        "contest_id": "1266",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = [False] * n\n    visited[start] = True\n    distance = [0] * n\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                distance[v] = distance[u] + 1\n                queue.append(v)\n    return distance\n\ndef max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = [0] * n\n    for k in range(1, n + 1):\n        for i in range(n):\n            distance = bfs(graph, i)\n            almost_uniform_set = [j for j in range(n) if distance[j] in [k, k + 1]]\n            result[k - 1] = max(result[k - 1], len(almost_uniform_set))\n    \n    return result\n\nn, edges = read_input()\nresult = max_almost_uniform_set_size(n, edges)\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = [False] * n\n    visited[start] = True\n    distance = [0] * n\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                distance[v] = distance[u] + 1\n                queue.append(v)\n    return distance\n\ndef max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = [0] * n\n    for k in range(1, n+1):\n        max_size = 0\n        for i in range(n):\n            distance = bfs(graph, i)\n            almost_uniform_set = set()\n            for j in range(n):\n                if distance[j] == k or distance[j] == k + 1:\n                    almost_uniform_set.add(j)\n            max_size = max(max_size, len(almost_uniform_set))\n        result[k-1] = max_size\n    return result\n\nn, edges = read_input()\nresult = max_almost_uniform_set_size(n, edges)\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = set([start])\n    distance = {start: 0}\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                distance[neighbor] = distance[node] + 1\n                queue.append(neighbor)\n    return distance\n\ndef max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = [0] * n\n    for i in range(1, n + 1):\n        max_size = 0\n        for node in range(1, n + 1):\n            distance = bfs(graph, node)\n            almost_uniform_set = set()\n            for neighbor in graph[node]:\n                if abs(distance[node] - distance[neighbor]) in {i, i + 1}:\n                    almost_uniform_set.add(node)\n                    almost_uniform_set.add(neighbor)\n            max_size = max(max_size, len(almost_uniform_set))\n        result[i - 1] = max_size\n    \n    return result\n\ndef main():\n    n, edges = read_input()\n    result = max_almost_uniform_set_size(n, edges)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = [False] * n\n    visited[start] = True\n    distance = [0] * n\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                distance[v] = distance[u] + 1\n                queue.append(v)\n    return distance\n\ndef find_max_almost_uniform_set_size(n, edges, k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    max_size = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for start in range(n):\n            distance = bfs(graph, start)\n            almost_uniform_set = set()\n            for j in range(n):\n                if distance[j] == i or distance[j] == i + 1:\n                    almost_uniform_set.add(j)\n            max_size[i] = max(max_size[i], len(almost_uniform_set))\n    \n    return max_size[1:]\n\ndef main():\n    n, edges = read_input()\n    result = find_max_almost_uniform_set_size(n, edges, n)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef find_max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start, k):\n        queue = deque([start])\n        visited = set([start])\n        level = 0\n        while queue:\n            if level > k:\n                break\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n            level += 1\n        return len(visited)\n    \n    result = []\n    for k in range(1, n+1):\n        max_size = 0\n        for i in range(n):\n            max_size = max(max_size, bfs(i, k))\n        result.append(max_size)\n    \n    return result\n\ndef main():\n    n, edges = read_input()\n    result = find_max_almost_uniform_set_size(n, edges)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef find_max_almost_uniform_set_size(n, edges, k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start):\n        queue = deque([start])\n        visited = [False] * n\n        visited[start] = True\n        distance = [-1] * n\n        distance[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    distance[neighbor] = distance[current] + 1\n                    queue.append(neighbor)\n        return distance\n    \n    max_size = 0\n    for i in range(n):\n        distance = bfs(i)\n        almost_uniform_set = [j for j in range(n) if distance[j] == k or distance[j] == k+1]\n        max_size = max(max_size, len(almost_uniform_set))\n    return max_size\n\ndef main():\n    n, edges = read_input()\n    result = [find_max_almost_uniform_set_size(n, edges, i) for i in range(1, n+1)]\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs_distance(graph, start):\n    n = len(graph)\n    distance = [-1] * n\n    distance[start] = 0\n    queue = deque([start])\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if distance[v] == -1:\n                distance[v] = distance[u] + 1\n                queue.append(v)\n    return distance\n\ndef max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = [0] * n\n    for k in range(1, n+1):\n        max_size = 0\n        for i in range(n):\n            distance = bfs_distance(graph, i)\n            almost_uniform_set = set()\n            for j in range(n):\n                if distance[j] == k or distance[j] == k + 1:\n                    almost_uniform_set.add(j)\n            max_size = max(max_size, len(almost_uniform_set))\n        result[k-1] = max_size\n    return result\n\ndef main():\n    n, edges = read_input()\n    result = max_almost_uniform_set_size(n, edges)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef find_max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start, k):\n        visited = [False] * (n + 1)\n        queue = deque([(start, 0)])\n        visited[start] = True\n        count = 1\n        while queue:\n            node, dist = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    if dist + 1 <= k:\n                        count += 1\n                        queue.append((neighbor, dist + 1))\n        return count\n    \n    result = []\n    for k in range(1, n + 1):\n        max_size = 0\n        for i in range(1, n + 1):\n            max_size = max(max_size, bfs(i, k))\n        result.append(max_size)\n    \n    return result\n\ndef main():\n    n, edges = read_input()\n    result = find_max_almost_uniform_set_size(n, edges)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef find_max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start, k):\n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        max_size = 0\n        while queue:\n            node, dist = queue.popleft()\n            if dist > k + 1:\n                break\n            max_size += 1\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, dist + 1))\n        return max_size\n    \n    result = []\n    for k in range(1, n + 1):\n        max_size = 0\n        for i in range(n):\n            max_size = max(max_size, bfs(i, k))\n        result.append(max_size)\n    \n    return result\n\ndef main():\n    n, edges = read_input()\n    result = find_max_almost_uniform_set_size(n, edges)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = [False] * n\n    visited[start] = True\n    distance = [-1] * n\n    distance[start] = 0\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                distance[v] = distance[u] + 1\n                queue.append(v)\n    return distance\n\ndef find_max_almost_uniform_set_size(n, edges, k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    max_size = [1] * n\n    for i in range(1, n):\n        for start in range(n):\n            distance = bfs(graph, start)\n            almost_uniform_set = [start]\n            for j in range(n):\n                if j != start and abs(distance[j] - distance[start]) in [i, i+1]:\n                    almost_uniform_set.append(j)\n            max_size[i] = max(max_size[i], len(almost_uniform_set))\n    return max_size\n\ndef main():\n    n, edges = read_input()\n    max_size = find_max_almost_uniform_set_size(n, edges, n)\n    print(' '.join(map(str, max_size)))\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = [False] * n\n    visited[start] = True\n    distance = [0] * n\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                distance[v] = distance[u] + 1\n                queue.append(v)\n    return distance\n\ndef max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = [0] * n\n    for k in range(1, n + 1):\n        for i in range(n):\n            distance = bfs(graph, i)\n            almost_uniform_set = [j for j in range(n) if distance[j] in [k, k + 1]]\n            result[k - 1] = max(result[k - 1], len(almost_uniform_set))\n    \n    return result\n\nn, edges = read_input()\nresult = max_almost_uniform_set_size(n, edges)\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = [False] * n\n    visited[start] = True\n    distance = [0] * n\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                distance[v] = distance[u] + 1\n                queue.append(v)\n    return distance\n\ndef max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = [0] * n\n    for k in range(1, n+1):\n        max_size = 0\n        for i in range(n):\n            distance = bfs(graph, i)\n            almost_uniform_set = set()\n            for j in range(n):\n                if distance[j] == k or distance[j] == k + 1:\n                    almost_uniform_set.add(j)\n            max_size = max(max_size, len(almost_uniform_set))\n        result[k-1] = max_size\n    return result\n\nn, edges = read_input()\nresult = max_almost_uniform_set_size(n, edges)\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = set([start])\n    distance = {start: 0}\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                distance[neighbor] = distance[node] + 1\n                queue.append(neighbor)\n    return distance\n\ndef max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = [0] * n\n    for i in range(1, n + 1):\n        max_size = 0\n        for node in range(1, n + 1):\n            distance = bfs(graph, node)\n            almost_uniform_set = set()\n            for neighbor in graph[node]:\n                if abs(distance[node] - distance[neighbor]) in {i, i + 1}:\n                    almost_uniform_set.add(node)\n                    almost_uniform_set.add(neighbor)\n            max_size = max(max_size, len(almost_uniform_set))\n        result[i - 1] = max_size\n    \n    return result\n\ndef main():\n    n, edges = read_input()\n    result = max_almost_uniform_set_size(n, edges)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = [False] * n\n    visited[start] = True\n    distance = [0] * n\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                distance[v] = distance[u] + 1\n                queue.append(v)\n    return distance\n\ndef find_max_almost_uniform_set_size(n, edges, k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    max_size = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for start in range(n):\n            distance = bfs(graph, start)\n            almost_uniform_set = set()\n            for j in range(n):\n                if distance[j] == i or distance[j] == i + 1:\n                    almost_uniform_set.add(j)\n            max_size[i] = max(max_size[i], len(almost_uniform_set))\n    \n    return max_size[1:]\n\ndef main():\n    n, edges = read_input()\n    result = find_max_almost_uniform_set_size(n, edges, n)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef find_max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start, k):\n        queue = deque([start])\n        visited = set([start])\n        level = 0\n        while queue:\n            if level > k:\n                break\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n            level += 1\n        return len(visited)\n    \n    result = []\n    for k in range(1, n+1):\n        max_size = 0\n        for i in range(n):\n            max_size = max(max_size, bfs(i, k))\n        result.append(max_size)\n    \n    return result\n\ndef main():\n    n, edges = read_input()\n    result = find_max_almost_uniform_set_size(n, edges)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef find_max_almost_uniform_set_size(n, edges, k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start):\n        queue = deque([start])\n        visited = [False] * n\n        visited[start] = True\n        distance = [-1] * n\n        distance[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    distance[neighbor] = distance[current] + 1\n                    queue.append(neighbor)\n        return distance\n    \n    max_size = 0\n    for i in range(n):\n        distance = bfs(i)\n        almost_uniform_set = [j for j in range(n) if distance[j] == k or distance[j] == k+1]\n        max_size = max(max_size, len(almost_uniform_set))\n    return max_size\n\ndef main():\n    n, edges = read_input()\n    result = [find_max_almost_uniform_set_size(n, edges, i) for i in range(1, n+1)]\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs_distance(graph, start):\n    n = len(graph)\n    distance = [-1] * n\n    distance[start] = 0\n    queue = deque([start])\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if distance[v] == -1:\n                distance[v] = distance[u] + 1\n                queue.append(v)\n    return distance\n\ndef max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    result = [0] * n\n    for k in range(1, n+1):\n        max_size = 0\n        for i in range(n):\n            distance = bfs_distance(graph, i)\n            almost_uniform_set = set()\n            for j in range(n):\n                if distance[j] == k or distance[j] == k + 1:\n                    almost_uniform_set.add(j)\n            max_size = max(max_size, len(almost_uniform_set))\n        result[k-1] = max_size\n    return result\n\ndef main():\n    n, edges = read_input()\n    result = max_almost_uniform_set_size(n, edges)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef find_max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start, k):\n        visited = [False] * (n + 1)\n        queue = deque([(start, 0)])\n        visited[start] = True\n        count = 1\n        while queue:\n            node, dist = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    if dist + 1 <= k:\n                        count += 1\n                        queue.append((neighbor, dist + 1))\n        return count\n    \n    result = []\n    for k in range(1, n + 1):\n        max_size = 0\n        for i in range(1, n + 1):\n            max_size = max(max_size, bfs(i, k))\n        result.append(max_size)\n    \n    return result\n\ndef main():\n    n, edges = read_input()\n    result = find_max_almost_uniform_set_size(n, edges)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef find_max_almost_uniform_set_size(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def bfs(start, k):\n        visited = [False] * n\n        queue = deque([(start, 0)])\n        visited[start] = True\n        max_size = 0\n        while queue:\n            node, dist = queue.popleft()\n            if dist > k + 1:\n                break\n            max_size += 1\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, dist + 1))\n        return max_size\n    \n    result = []\n    for k in range(1, n + 1):\n        max_size = 0\n        for i in range(n):\n            max_size = max(max_size, bfs(i, k))\n        result.append(max_size)\n    \n    return result\n\ndef main():\n    n, edges = read_input()\n    result = find_max_almost_uniform_set_size(n, edges)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        u = int(data[index]) - 1\n        v = int(data[index+1]) - 1\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = [False] * n\n    visited[start] = True\n    distance = [-1] * n\n    distance[start] = 0\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                distance[v] = distance[u] + 1\n                queue.append(v)\n    return distance\n\ndef find_max_almost_uniform_set_size(n, edges, k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    max_size = [1] * n\n    for i in range(1, n):\n        for start in range(n):\n            distance = bfs(graph, start)\n            almost_uniform_set = [start]\n            for j in range(n):\n                if j != start and abs(distance[j] - distance[start]) in [i, i+1]:\n                    almost_uniform_set.append(j)\n            max_size[i] = max(max_size[i], len(almost_uniform_set))\n    return max_size\n\ndef main():\n    n, edges = read_input()\n    max_size = find_max_almost_uniform_set_size(n, edges, n)\n    print(' '.join(map(str, max_size)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Domino for Young",
        "question_content": "You are given a Young diagram.\n\nGiven diagram is a histogram with n columns of lengths a_1, a_2, \\ldots, a_n (a_1 \\geq a_2 \\geq \\ldots \\geq a_n \\geq 1).\n\nYoung diagram for a=[3,2,2,2,1].\n\nYour goal is to find the largest number of non-overlapping dominos that you can draw inside of this histogram, a domino is a 1 \\times 2 or 2 \\times 1 rectangle.\n\n\nInput Format\nThe first line of input contain one integer n (1 \\leq n \\leq 300\\,000): the number of columns in the given histogram.\n\nThe next line of input contains n integers a_1, a_2, \\ldots, a_n (1 \\leq a_i \\leq 300\\,000, a_i \\geq a_{i+1}): the lengths of columns.\n\n\nOutput Format\nOutput one integer: the largest number of non-overlapping dominos that you can draw inside of the given Young diagram.\n\n\nSample Input 1\n\n5\n3 2 2 2 1\n\nSample Output 1\n\n4\n\n\nNote\nSome of the possible solutions for the example:",
        "platform": "codeforces",
        "question_id": "1268/B",
        "contest_id": "1268",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of dominos\ndominos = 0\n\n# Iterate through the columns and count the number of dominos\nfor i in range(n):\n    if i + 1 < n and a[i] >= a[i + 1]:\n        dominos += a[i + 1]\n        i += 1\n    else:\n        dominos += a[i] // 2\n\n# Output the result\nprint(dominos)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of dominos\ndominos = 0\n\n# Iterate through the columns\ni = 0\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        # If the current column and the next column have the same height, we can draw a domino\n        dominos += 1\n        i += 2\n    else:\n        # Otherwise, we can only draw a domino if the current column is at least 2 units tall\n        if a[i] >= 2:\n            dominos += a[i] // 2\n            i += 1\n        else:\n            i += 1\n\n# Output the result\nprint(dominos)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef max_dominos(n, a):\n    dominos = 0\n    i = 0\n    while i < n:\n        if i + 1 < n and a[i] == a[i + 1]:\n            dominos += 1\n            i += 2\n        elif a[i] > 0:\n            dominos += 1\n            a[i] -= 1\n            if i + 1 < n:\n                a[i + 1] -= 1\n            i += 1\n        else:\n            i += 1\n    return dominos\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = max_dominos(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nn = int(input())\na = list(map(int, input().split()))\n\ndominoes = 0\ni = 0\n\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        dominoes += 1\n        i += 2\n    else:\n        dominoes += a[i] // 2\n        i += 1\n\nprint(dominoes)\n```",
            "```python\n# YOUR CODE HERE\nn = int(input())\na = list(map(int, input().split()))\n\ncount = 0\ni = 0\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        count += 1\n        i += 2\n    else:\n        count += a[i] // 2\n        i += 1\n\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nn = int(input())\na = list(map(int, input().split()))\n\ndominoes = 0\ni = 0\n\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        dominoes += 1\n        i += 2\n    elif i < n:\n        dominoes += 1\n        i += 1\n\nprint(dominoes)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndominoes = 0\ni = 0\n\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        dominoes += 1\n        i += 2\n    else:\n        dominoes += a[i] // 2\n        i += 1\n\nprint(dominoes)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of dominos\ndominos = 0\n\n# Iterate through the columns and count the number of dominos\ni = 0\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        dominos += 1\n        i += 2\n    else:\n        dominos += a[i] // 2\n        i += 1\n\n# Output the result\nprint(dominos)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef max_dominos(n, a):\n    dominos = 0\n    i = 0\n    while i < n:\n        if i + 1 < n and a[i] == a[i + 1]:\n            dominos += 1\n            i += 2\n        elif i < n:\n            dominos += 1\n            i += 1\n        else:\n            break\n    return dominos\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = max_dominos(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize variables\ndominoes = 0\ni = 0\n\n# Iterate through the columns\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        # If the current column and the next column have the same height, we can draw a domino\n        dominoes += 1\n        i += 2\n    else:\n        # Otherwise, we can draw a vertical domino\n        dominoes += a[i] // 2\n        i += 1\n\n# Output the result\nprint(dominoes)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of dominos\ndominos = 0\n\n# Iterate through the columns and count the number of dominos\nfor i in range(n):\n    if i + 1 < n and a[i] >= a[i + 1]:\n        dominos += a[i + 1]\n        i += 1\n    else:\n        dominos += a[i] // 2\n\n# Output the result\nprint(dominos)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of dominos\ndominos = 0\n\n# Iterate through the columns\ni = 0\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        # If the current column and the next column have the same height, we can draw a domino\n        dominos += 1\n        i += 2\n    else:\n        # Otherwise, we can only draw a domino if the current column is at least 2 units tall\n        if a[i] >= 2:\n            dominos += a[i] // 2\n            i += 1\n        else:\n            i += 1\n\n# Output the result\nprint(dominos)",
            "# YOUR CODE HERE\nimport sys\n\ndef max_dominos(n, a):\n    dominos = 0\n    i = 0\n    while i < n:\n        if i + 1 < n and a[i] == a[i + 1]:\n            dominos += 1\n            i += 2\n        elif a[i] > 0:\n            dominos += 1\n            a[i] -= 1\n            if i + 1 < n:\n                a[i + 1] -= 1\n            i += 1\n        else:\n            i += 1\n    return dominos\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = max_dominos(n, a)\n\n# Write output\nprint(result)",
            "# YOUR CODE HERE\nn = int(input())\na = list(map(int, input().split()))\n\ndominoes = 0\ni = 0\n\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        dominoes += 1\n        i += 2\n    else:\n        dominoes += a[i] // 2\n        i += 1\n\nprint(dominoes)",
            "# YOUR CODE HERE\nn = int(input())\na = list(map(int, input().split()))\n\ncount = 0\ni = 0\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        count += 1\n        i += 2\n    else:\n        count += a[i] // 2\n        i += 1\n\nprint(count)",
            "# YOUR CODE HERE\nn = int(input())\na = list(map(int, input().split()))\n\ndominoes = 0\ni = 0\n\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        dominoes += 1\n        i += 2\n    elif i < n:\n        dominoes += 1\n        i += 1\n\nprint(dominoes)",
            "# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndominoes = 0\ni = 0\n\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        dominoes += 1\n        i += 2\n    else:\n        dominoes += a[i] // 2\n        i += 1\n\nprint(dominoes)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of dominos\ndominos = 0\n\n# Iterate through the columns and count the number of dominos\ni = 0\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        dominos += 1\n        i += 2\n    else:\n        dominos += a[i] // 2\n        i += 1\n\n# Output the result\nprint(dominos)",
            "# YOUR CODE HERE\nimport sys\n\ndef max_dominos(n, a):\n    dominos = 0\n    i = 0\n    while i < n:\n        if i + 1 < n and a[i] == a[i + 1]:\n            dominos += 1\n            i += 2\n        elif i < n:\n            dominos += 1\n            i += 1\n        else:\n            break\n    return dominos\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = max_dominos(n, a)\n\n# Write output\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize variables\ndominoes = 0\ni = 0\n\n# Iterate through the columns\nwhile i < n:\n    if i + 1 < n and a[i] == a[i + 1]:\n        # If the current column and the next column have the same height, we can draw a domino\n        dominoes += 1\n        i += 2\n    else:\n        # Otherwise, we can draw a vertical domino\n        dominoes += a[i] // 2\n        i += 1\n\n# Output the result\nprint(dominoes)"
        ]
    },
    {
        "question_title": "Sequence",
        "question_content": "Little Petya likes to play very much. And most of all he likes to play the following game:\n\nHe is given a sequence of N integer numbers. At each step it is allowed to increase the value of any number by 1 or to decrease it by 1. The goal of the game is to make the sequence non-decreasing with the smallest number of steps. Petya is not good at math, so he asks for your help.\n\nThe sequence a is called non-decreasing if a1 \u2264 a2 \u2264 ... \u2264 aN holds, where N is the length of the sequence.\n\n\nInput Format\nThe first line of the input contains single integer N (1 \u2264 N \u2264 5000) \u2014 the length of the initial sequence. The following N lines contain one integer each \u2014 elements of the sequence. These numbers do not exceed 109 by absolute value.\n\n\nOutput Format\nOutput one integer \u2014 minimum number of steps required to achieve the goal.\n\n\nSample Input 1\n\n5\n3 2 -1 2 11\n\nSample Output 1\n\n4\n\n\nSample Input 2\n\n5\n2 1 1 1 1\n\nSample Output 2\n\n1",
        "platform": "codeforces",
        "question_id": "13/C",
        "contest_id": "13",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Sort the sequence\nsorted_sequence = sorted(sequence)\n\n# Calculate the minimum number of steps\nsteps = 0\nfor i in range(N):\n    steps += abs(sequence[i] - sorted_sequence[i])\n\n# Output the result\nprint(steps)"
        ]
    },
    {
        "question_title": "Triangles",
        "question_content": "Little Petya likes to draw. He drew N red and M blue points on the plane in such a way that no three points lie on the same line. Now he wonders what is the number of distinct triangles with vertices in red points which do not contain any blue point inside.\n\n\nInput Format\nThe first line contains two non-negative integer numbers N and M (0 \u2264 N \u2264 500, 0 \u2264 M \u2264 500) \u2014 the number of red and blue points respectively. The following N lines contain two integer numbers each \u2014 coordinates of red points. The following M lines contain two integer numbers each \u2014 coordinates of blue points. All coordinates do not exceed 109 by absolute value.\n\n\nOutput Format\nOutput one integer \u2014 the number of distinct triangles with vertices in red points which do not contain any blue point inside.\n\n\nSample Input 1\n\n4 1\n0 0\n10 0\n10 10\n5 4\n2 1\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n5 5\n5 10\n6 1\n8 6\n-6 -7\n7 -1\n5 -1\n10 -4\n-10 -8\n-10 5\n-2 -8\n\nSample Output 2\n\n7",
        "platform": "codeforces",
        "question_id": "13/D",
        "contest_id": "13",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(p, a, b, c):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(p, a, b)\n    d2 = sign(p, b, c)\n    d3 = sign(p, c, a)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    if all(not is_point_in_triangle(blue_point, *triangle) for blue_point in blue_points):\n        count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((px, py), (x1, y1), (x2, y2))\n    d2 = sign((px, py), (x2, y2), (x3, y3))\n    d3 = sign((px, py), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    x1, y1 = triangle[0]\n    x2, y2 = triangle[1]\n    x3, y3 = triangle[2]\n    if all(not is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3) for px, py in blue_points):\n        count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(px, py, x1, y1, x2, y2)\n    d2 = sign(px, py, x2, y2, x3, y3)\n    d3 = sign(px, py, x3, y3, x1, y1)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    x1, y1 = triangle[0]\n    x2, y2 = triangle[1]\n    x3, y3 = triangle[2]\n    if all(not is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3) for px, py in blue_points):\n        count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(p, a, b, c):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(p, a, b)\n    d2 = sign(p, b, c)\n    d3 = sign(p, c, a)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    if all(not is_point_in_triangle(blue_point, *triangle) for blue_point in blue_points):\n        count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(px, py, x1, y1, x2, y2)\n    d2 = sign(px, py, x2, y2, x3, y3)\n    d3 = sign(px, py, x3, y3, x1, y1)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    x1, y1 = triangle[0]\n    x2, y2 = triangle[1]\n    x3, y3 = triangle[2]\n    if all(not is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3) for px, py in blue_points):\n        count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(px, py, x1, y1, x2, y2)\n    d2 = sign(px, py, x2, y2, x3, y3)\n    d3 = sign(px, py, x3, y3, x1, y1)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    x1, y1 = triangle[0]\n    x2, y2 = triangle[1]\n    x3, y3 = triangle[2]\n    if all(not is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3) for px, py in blue_points):\n        count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(px, py, x1, y1, x2, y2)\n    d2 = sign(px, py, x2, y2, x3, y3)\n    d3 = sign(px, py, x3, y3, x1, y1)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    x1, y1 = triangle[0]\n    x2, y2 = triangle[1]\n    x3, y3 = triangle[2]\n    if all(not is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3) for px, py in blue_points):\n        count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = []\nblue_points = []\n\nindex = 2\nfor _ in range(N):\n    x = int(data[index])\n    y = int(data[index + 1])\n    red_points.append((x, y))\n    index += 2\n\nfor _ in range(M):\n    x = int(data[index])\n    y = int(data[index + 1])\n    blue_points.append((x, y))\n    index += 2\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(p, a, b, c):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(p, a, b)\n    d2 = sign(p, b, c)\n    d3 = sign(p, c, a)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    a, b, c = triangle\n    valid = True\n    for blue_point in blue_points:\n        if is_point_in_triangle(blue_point, a, b, c):\n            valid = False\n            break\n    if valid:\n        count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(p, a, b, c):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(p, a, b)\n    d2 = sign(p, b, c)\n    d3 = sign(p, c, a)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    a, b, c = triangle\n    if all(not is_point_in_triangle(p, a, b, c) for p in blue_points):\n        count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(p, a, b, c):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(p, a, b)\n    d2 = sign(p, b, c)\n    d3 = sign(p, c, a)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    if all(not is_point_in_triangle(blue_point, *triangle) for blue_point in blue_points):\n        count += 1\n\n# Output the result\nprint(count)\n```"
        ],
        "code_list": [
            "import sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(p, a, b, c):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(p, a, b)\n    d2 = sign(p, b, c)\n    d3 = sign(p, c, a)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    if all(not is_point_in_triangle(blue_point, *triangle) for blue_point in blue_points):\n        count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((px, py), (x1, y1), (x2, y2))\n    d2 = sign((px, py), (x2, y2), (x3, y3))\n    d3 = sign((px, py), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    x1, y1 = triangle[0]\n    x2, y2 = triangle[1]\n    x3, y3 = triangle[2]\n    if all(not is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3) for px, py in blue_points):\n        count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(px, py, x1, y1, x2, y2)\n    d2 = sign(px, py, x2, y2, x3, y3)\n    d3 = sign(px, py, x3, y3, x1, y1)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    x1, y1 = triangle[0]\n    x2, y2 = triangle[1]\n    x3, y3 = triangle[2]\n    if all(not is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3) for px, py in blue_points):\n        count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(p, a, b, c):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(p, a, b)\n    d2 = sign(p, b, c)\n    d3 = sign(p, c, a)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    if all(not is_point_in_triangle(blue_point, *triangle) for blue_point in blue_points):\n        count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(px, py, x1, y1, x2, y2)\n    d2 = sign(px, py, x2, y2, x3, y3)\n    d3 = sign(px, py, x3, y3, x1, y1)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    x1, y1 = triangle[0]\n    x2, y2 = triangle[1]\n    x3, y3 = triangle[2]\n    if all(not is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3) for px, py in blue_points):\n        count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(px, py, x1, y1, x2, y2)\n    d2 = sign(px, py, x2, y2, x3, y3)\n    d3 = sign(px, py, x3, y3, x1, y1)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    x1, y1 = triangle[0]\n    x2, y2 = triangle[1]\n    x3, y3 = triangle[2]\n    if all(not is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3) for px, py in blue_points):\n        count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(px, py, x1, y1, x2, y2)\n    d2 = sign(px, py, x2, y2, x3, y3)\n    d3 = sign(px, py, x3, y3, x1, y1)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    x1, y1 = triangle[0]\n    x2, y2 = triangle[1]\n    x3, y3 = triangle[2]\n    if all(not is_point_in_triangle(px, py, x1, y1, x2, y2, x3, y3) for px, py in blue_points):\n        count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = []\nblue_points = []\n\nindex = 2\nfor _ in range(N):\n    x = int(data[index])\n    y = int(data[index + 1])\n    red_points.append((x, y))\n    index += 2\n\nfor _ in range(M):\n    x = int(data[index])\n    y = int(data[index + 1])\n    blue_points.append((x, y))\n    index += 2\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(p, a, b, c):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(p, a, b)\n    d2 = sign(p, b, c)\n    d3 = sign(p, c, a)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    a, b, c = triangle\n    valid = True\n    for blue_point in blue_points:\n        if is_point_in_triangle(blue_point, a, b, c):\n            valid = False\n            break\n    if valid:\n        count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(p, a, b, c):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(p, a, b)\n    d2 = sign(p, b, c)\n    d3 = sign(p, c, a)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    a, b, c = triangle\n    if all(not is_point_in_triangle(p, a, b, c) for p in blue_points):\n        count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom itertools import combinations\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nM = int(data[1])\nred_points = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(N)]\nblue_points = [(int(data[2 + 2 * N + 2 * i]), int(data[3 + 2 * N + 2 * i])) for i in range(M)]\n\n# Function to check if a point is inside a triangle\ndef is_point_in_triangle(p, a, b, c):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign(p, a, b)\n    d2 = sign(p, b, c)\n    d3 = sign(p, c, a)\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\n# Count the number of valid triangles\ncount = 0\nfor triangle in combinations(red_points, 3):\n    if all(not is_point_in_triangle(blue_point, *triangle) for blue_point in blue_points):\n        count += 1\n\n# Output the result\nprint(count)"
        ]
    },
    {
        "question_title": "Ehab's REAL Number Theory Problem",
        "question_content": "You are given an array a of length n that has a special condition: every element in this array has at most 7 divisors. Find the length of the shortest non-empty subsequence of this array product of whose elements is a perfect square.\n\nA sequence a is a subsequence of an array b if a can be obtained from b by deletion of several (possibly, zero or all) elements.\n\n\nInput Format\nThe first line contains an integer n (1 \\le n \\le 10^5)\u00a0\u2014 the length of a.\n\nThe second line contains n integers a_1, a_2, \\ldots, a_{n} (1 \\le a_i \\le 10^6)\u00a0\u2014 the elements of the array a.\n\n\nOutput Format\nOutput the length of the shortest non-empty subsequence of a product of whose elements is a perfect square. If there are several shortest subsequences, you can find any of them. If there's no such subsequence, print \"-1\".\n\n\nSample Input 1\n\n3\n1 4 6\n\nSample Output 1\n\n1\n\n\nSample Input 2\n\n4\n2 3 6 6\n\nSample Output 2\n\n2\n\n\nSample Input 3\n\n3\n6 15 10\n\nSample Output 3\n\n3\n\n\nSample Input 4\n\n4\n2 3 5 7\n\nSample Output 4\n\n-1\n\n\nNote\nIn the first sample, you can choose a subsequence [1].\n\nIn the second sample, you can choose a subsequence [6, 6].\n\nIn the third sample, you can choose a subsequence [6, 15, 10].\n\nIn the fourth sample, there is no such subsequence.",
        "platform": "codeforces",
        "question_id": "1325/E",
        "contest_id": "1325",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to count the number of odd prime factors of a number\n    def count_odd_prime_factors(x):\n        count = 0\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                count += 1\n                x //= i\n        if x > 2:\n            count += 1\n        return count\n    \n    # Dictionary to store the last seen index of each odd prime factor count\n    last_seen = defaultdict(lambda: -1)\n    last_seen[0] = -1  # To handle the case when the product is already a perfect square\n    current_count = 0\n    min_length = float('inf')\n    \n    for i in range(n):\n        current_count += count_odd_prime_factors(a[i])\n        # If the current count is even, the product is a perfect square\n        if current_count % 2 == 0:\n            min_length = min(min_length, i - last_seen[0])\n        # If the current count is odd, find the last seen index with the same count\n        else:\n            min_length = min(min_length, i - last_seen[current_count - 1])\n        # Update the last seen index for the current count\n        last_seen[current_count] = i\n    \n    return min_length if min_length != float('inf') else -1\n\n# Read input from stdin\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s in x\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n    \n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        for count in factors.values():\n            if count % 2 != 0:\n                return False\n        return True\n    \n    # Dictionary to store the first occurrence of each state of factors\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n    \n    # Iterate through the array\n    for i, num in enumerate(a):\n        # Update the current factors with the factors of the current number\n        for prime, count in prime_factors(num).items():\n            current_factors[prime] += count\n        \n        # Check if the current product is a perfect square\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i + 1)\n        \n        # Try to remove factors to find the shortest subsequence\n        for prime, count in current_factors.items():\n            if count % 2 != 0:\n                # Find the first occurrence of this state\n                if (tuple(sorted(current_factors.items())), prime) in first_occurrence:\n                    min_length = min(min_length, i - first_occurrence[(tuple(sorted(current_factors.items())), prime)] + 1)\n                break\n        \n        # Store the first occurrence of this state\n        if (tuple(sorted(current_factors.items())), None) not in first_occurrence:\n            first_occurrence[(tuple(sorted(current_factors.items())), None)] = i\n    \n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to count the number of odd divisors of a number\n    def count_odd_divisors(x):\n        count = 0\n        while x % 2 == 0:\n            x //= 2\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                x //= i\n                count += 1\n        if x > 2:\n            count += 1\n        return count\n\n    # Dictionary to store the last seen index of each odd divisor count\n    last_seen = defaultdict(lambda: -1)\n    last_seen[0] = -1  # To handle the case when the product is already a perfect square\n    current_count = 0\n    min_length = float('inf')\n\n    for i in range(n):\n        current_count += count_odd_divisors(a[i])\n        # Find the last seen index with the same odd divisor count\n        if current_count in last_seen:\n            min_length = min(min_length, i - last_seen[current_count])\n        # Store the current index for the first time this odd divisor count is seen\n        if last_seen[current_count] == -1:\n            last_seen[current_count] = i\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s in x\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n    \n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        for count in factors.values():\n            if count % 2 != 0:\n                return False\n        return True\n    \n    # Dictionary to store the first occurrence of each state of prime factors\n    first_occurrence = {}\n    # Initialize with a dummy value for empty product\n    first_occurrence[(0, 0, 0)] = -1\n    \n    # Iterate through the array\n    min_length = float('inf')\n    current_factors = (0, 0, 0)  # (count of 2s, count of 3s, count of 5s)\n    for i, num in enumerate(a):\n        factors = prime_factors(num)\n        # Update the current state of prime factors\n        current_factors = (current_factors[0] + factors[2], current_factors[1] + factors[3], current_factors[2] + factors[5])\n        \n        # Check if the current product is a perfect square\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i - first_occurrence[(0, 0, 0)] + 1)\n        \n        # Update the first occurrence of the current state\n        if current_factors not in first_occurrence:\n            first_occurrence[current_factors] = i\n    \n    # If no valid subsequence is found, return -1\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n\n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        return all(exp % 2 == 0 for exp in factors.values())\n\n    # Dictionary to store the first occurrence of each state of prime factors\n    first_occurrence = {}\n    # Initialize with a dummy value for empty product\n    first_occurrence[tuple()] = -1\n    min_length = float('inf')\n    current_factors = defaultdict(int)\n\n    for i, num in enumerate(a):\n        current_factors = defaultdict(int, current_factors)\n        for prime, exp in prime_factors(num).items():\n            current_factors[prime] += exp\n\n        # Check if the current product is a perfect square\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i - first_occurrence[tuple(current_factors)])\n\n        # Update the first occurrence of the current state of factors\n        if tuple(current_factors) not in first_occurrence:\n            first_occurrence[tuple(current_factors)] = i\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s in x\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n    \n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        for count in factors.values():\n            if count % 2 != 0:\n                return False\n        return True\n    \n    # Dictionary to store the first occurrence of each factor combination\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n    \n    for i, num in enumerate(a):\n        current_factors += prime_factors(num)\n        \n        # Check if the current product is a perfect square\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i + 1)\n        \n        # Try to remove factors to find the shortest subsequence\n        for factor in current_factors:\n            while current_factors[factor] % 2 != 0:\n                current_factors[factor] -= 1\n                if current_factors[factor] == 0:\n                    del current_factors[factor]\n                if factor in first_occurrence:\n                    min_length = min(min_length, i - first_occurrence[factor])\n        \n        # Store the first occurrence of this factor combination\n        if tuple(current_factors.items()) not in first_occurrence:\n            first_occurrence[tuple(current_factors.items())] = i\n    \n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Solve the problem\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        if x > 2:\n            factors[x] += 1\n        return factors\n\n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        return all(exp % 2 == 0 for exp in factors.values())\n\n    # Dictionary to store the first occurrence of each factor combination\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n\n    for i, num in enumerate(a):\n        current_factors += prime_factors(num)\n        if is_perfect_square(current_factors):\n            min_length = i + 1\n        else:\n            # Find the smallest subsequence that makes the product a perfect square\n            for factor in current_factors:\n                if current_factors[factor] % 2 != 0:\n                    if (factor, current_factors[factor]) in first_occurrence:\n                        min_length = min(min_length, i - first_occurrence[(factor, current_factors[factor])])\n                    break\n        first_occurrence[(tuple(sorted(current_factors.items())), sum(current_factors.values()))] = i\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s in x\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n\n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        for count in factors.values():\n            if count % 2 != 0:\n                return False\n        return True\n\n    # Dictionary to store the first occurrence of each factor combination\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n\n    for i, num in enumerate(a):\n        current_factors += prime_factors(num)\n        if is_perfect_square(current_factors):\n            min_length = i + 1\n        else:\n            # Find the smallest subsequence to make the product a perfect square\n            for factor, count in current_factors.items():\n                if count % 2 != 0:\n                    if (factor, count - 1) in first_occurrence:\n                        min_length = min(min_length, i - first_occurrence[(factor, count - 1)] + 1)\n                    break\n        first_occurrence[tuple(sorted(current_factors.items()))] = i\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n\n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        for count in factors.values():\n            if count % 2 != 0:\n                return False\n        return True\n\n    # Dictionary to store the first occurrence of each state of factors\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n\n    # Iterate through the array\n    for i, num in enumerate(a):\n        # Update the current factors with the current number's factors\n        for prime, exp in prime_factors(num).items():\n            current_factors[prime] += exp\n\n        # Check if the current product is a perfect square\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i + 1)\n\n        # Try to find a subsequence that makes the product a perfect square\n        for prime, exp in current_factors.items():\n            if exp % 2 != 0:\n                if (prime, exp - 1) in first_occurrence:\n                    min_length = min(min_length, i - first_occurrence[(prime, exp - 1)] + 1)\n\n        # Store the first occurrence of the current state of factors\n        if (tuple(sorted(current_factors.items())), i) not in first_occurrence:\n            first_occurrence[(tuple(sorted(current_factors.items())), i)] = i\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        if x > 2:\n            factors[x] += 1\n        return factors\n    \n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        return all(exp % 2 == 0 for exp in factors.values())\n    \n    # Dictionary to store the first occurrence of each factor combination\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n    \n    for i, num in enumerate(a):\n        current_factors += prime_factors(num)\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i + 1)\n        else:\n            # Find the smallest subsequence to make the product a perfect square\n            for factor in current_factors:\n                if current_factors[factor] % 2 != 0:\n                    if (factor, current_factors[factor]) in first_occurrence:\n                        min_length = min(min_length, i - first_occurrence[(factor, current_factors[factor])])\n                    break\n        first_occurrence[(tuple(sorted(current_factors.items())), sum(current_factors.values()))] = i\n    \n    return min_length if min_length != float('inf') else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to count the number of odd prime factors of a number\n    def count_odd_prime_factors(x):\n        count = 0\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                count += 1\n                x //= i\n        if x > 2:\n            count += 1\n        return count\n    \n    # Dictionary to store the last seen index of each odd prime factor count\n    last_seen = defaultdict(lambda: -1)\n    last_seen[0] = -1  # To handle the case when the product is already a perfect square\n    current_count = 0\n    min_length = float('inf')\n    \n    for i in range(n):\n        current_count += count_odd_prime_factors(a[i])\n        # If the current count is even, the product is a perfect square\n        if current_count % 2 == 0:\n            min_length = min(min_length, i - last_seen[0])\n        # If the current count is odd, find the last seen index with the same count\n        else:\n            min_length = min(min_length, i - last_seen[current_count - 1])\n        # Update the last seen index for the current count\n        last_seen[current_count] = i\n    \n    return min_length if min_length != float('inf') else -1\n\n# Read input from stdin\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s in x\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n    \n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        for count in factors.values():\n            if count % 2 != 0:\n                return False\n        return True\n    \n    # Dictionary to store the first occurrence of each state of factors\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n    \n    # Iterate through the array\n    for i, num in enumerate(a):\n        # Update the current factors with the factors of the current number\n        for prime, count in prime_factors(num).items():\n            current_factors[prime] += count\n        \n        # Check if the current product is a perfect square\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i + 1)\n        \n        # Try to remove factors to find the shortest subsequence\n        for prime, count in current_factors.items():\n            if count % 2 != 0:\n                # Find the first occurrence of this state\n                if (tuple(sorted(current_factors.items())), prime) in first_occurrence:\n                    min_length = min(min_length, i - first_occurrence[(tuple(sorted(current_factors.items())), prime)] + 1)\n                break\n        \n        # Store the first occurrence of this state\n        if (tuple(sorted(current_factors.items())), None) not in first_occurrence:\n            first_occurrence[(tuple(sorted(current_factors.items())), None)] = i\n    \n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to count the number of odd divisors of a number\n    def count_odd_divisors(x):\n        count = 0\n        while x % 2 == 0:\n            x //= 2\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                x //= i\n                count += 1\n        if x > 2:\n            count += 1\n        return count\n\n    # Dictionary to store the last seen index of each odd divisor count\n    last_seen = defaultdict(lambda: -1)\n    last_seen[0] = -1  # To handle the case when the product is already a perfect square\n    current_count = 0\n    min_length = float('inf')\n\n    for i in range(n):\n        current_count += count_odd_divisors(a[i])\n        # Find the last seen index with the same odd divisor count\n        if current_count in last_seen:\n            min_length = min(min_length, i - last_seen[current_count])\n        # Store the current index for the first time this odd divisor count is seen\n        if last_seen[current_count] == -1:\n            last_seen[current_count] = i\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s in x\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n    \n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        for count in factors.values():\n            if count % 2 != 0:\n                return False\n        return True\n    \n    # Dictionary to store the first occurrence of each state of prime factors\n    first_occurrence = {}\n    # Initialize with a dummy value for empty product\n    first_occurrence[(0, 0, 0)] = -1\n    \n    # Iterate through the array\n    min_length = float('inf')\n    current_factors = (0, 0, 0)  # (count of 2s, count of 3s, count of 5s)\n    for i, num in enumerate(a):\n        factors = prime_factors(num)\n        # Update the current state of prime factors\n        current_factors = (current_factors[0] + factors[2], current_factors[1] + factors[3], current_factors[2] + factors[5])\n        \n        # Check if the current product is a perfect square\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i - first_occurrence[(0, 0, 0)] + 1)\n        \n        # Update the first occurrence of the current state\n        if current_factors not in first_occurrence:\n            first_occurrence[current_factors] = i\n    \n    # If no valid subsequence is found, return -1\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n\n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        return all(exp % 2 == 0 for exp in factors.values())\n\n    # Dictionary to store the first occurrence of each state of prime factors\n    first_occurrence = {}\n    # Initialize with a dummy value for empty product\n    first_occurrence[tuple()] = -1\n    min_length = float('inf')\n    current_factors = defaultdict(int)\n\n    for i, num in enumerate(a):\n        current_factors = defaultdict(int, current_factors)\n        for prime, exp in prime_factors(num).items():\n            current_factors[prime] += exp\n\n        # Check if the current product is a perfect square\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i - first_occurrence[tuple(current_factors)])\n\n        # Update the first occurrence of the current state of factors\n        if tuple(current_factors) not in first_occurrence:\n            first_occurrence[tuple(current_factors)] = i\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s in x\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n    \n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        for count in factors.values():\n            if count % 2 != 0:\n                return False\n        return True\n    \n    # Dictionary to store the first occurrence of each factor combination\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n    \n    for i, num in enumerate(a):\n        current_factors += prime_factors(num)\n        \n        # Check if the current product is a perfect square\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i + 1)\n        \n        # Try to remove factors to find the shortest subsequence\n        for factor in current_factors:\n            while current_factors[factor] % 2 != 0:\n                current_factors[factor] -= 1\n                if current_factors[factor] == 0:\n                    del current_factors[factor]\n                if factor in first_occurrence:\n                    min_length = min(min_length, i - first_occurrence[factor])\n        \n        # Store the first occurrence of this factor combination\n        if tuple(current_factors.items()) not in first_occurrence:\n            first_occurrence[tuple(current_factors.items())] = i\n    \n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Solve the problem\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        if x > 2:\n            factors[x] += 1\n        return factors\n\n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        return all(exp % 2 == 0 for exp in factors.values())\n\n    # Dictionary to store the first occurrence of each factor combination\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n\n    for i, num in enumerate(a):\n        current_factors += prime_factors(num)\n        if is_perfect_square(current_factors):\n            min_length = i + 1\n        else:\n            # Find the smallest subsequence that makes the product a perfect square\n            for factor in current_factors:\n                if current_factors[factor] % 2 != 0:\n                    if (factor, current_factors[factor]) in first_occurrence:\n                        min_length = min(min_length, i - first_occurrence[(factor, current_factors[factor])])\n                    break\n        first_occurrence[(tuple(sorted(current_factors.items())), sum(current_factors.values()))] = i\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s in x\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n\n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        for count in factors.values():\n            if count % 2 != 0:\n                return False\n        return True\n\n    # Dictionary to store the first occurrence of each factor combination\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n\n    for i, num in enumerate(a):\n        current_factors += prime_factors(num)\n        if is_perfect_square(current_factors):\n            min_length = i + 1\n        else:\n            # Find the smallest subsequence to make the product a perfect square\n            for factor, count in current_factors.items():\n                if count % 2 != 0:\n                    if (factor, count - 1) in first_occurrence:\n                        min_length = min(min_length, i - first_occurrence[(factor, count - 1)] + 1)\n                    break\n        first_occurrence[tuple(sorted(current_factors.items()))] = i\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        # This condition is to check if x is a prime number greater than 2\n        if x > 2:\n            factors[x] += 1\n        return factors\n\n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        for count in factors.values():\n            if count % 2 != 0:\n                return False\n        return True\n\n    # Dictionary to store the first occurrence of each state of factors\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n\n    # Iterate through the array\n    for i, num in enumerate(a):\n        # Update the current factors with the current number's factors\n        for prime, exp in prime_factors(num).items():\n            current_factors[prime] += exp\n\n        # Check if the current product is a perfect square\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i + 1)\n\n        # Try to find a subsequence that makes the product a perfect square\n        for prime, exp in current_factors.items():\n            if exp % 2 != 0:\n                if (prime, exp - 1) in first_occurrence:\n                    min_length = min(min_length, i - first_occurrence[(prime, exp - 1)] + 1)\n\n        # Store the first occurrence of the current state of factors\n        if (tuple(sorted(current_factors.items())), i) not in first_occurrence:\n            first_occurrence[(tuple(sorted(current_factors.items())), i)] = i\n\n    return min_length if min_length != float('inf') else -1\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef shortest_subsequence_with_perfect_square_product(n, a):\n    # Function to get the prime factorization of a number\n    def prime_factors(x):\n        factors = defaultdict(int)\n        # Check for number of 2s\n        while x % 2 == 0:\n            factors[2] += 1\n            x = x // 2\n        # Check for other primes\n        for i in range(3, int(x**0.5) + 1, 2):\n            while x % i == 0:\n                factors[i] += 1\n                x = x // i\n        if x > 2:\n            factors[x] += 1\n        return factors\n    \n    # Function to check if a number is a perfect square\n    def is_perfect_square(factors):\n        return all(exp % 2 == 0 for exp in factors.values())\n    \n    # Dictionary to store the first occurrence of each factor combination\n    first_occurrence = {}\n    current_factors = defaultdict(int)\n    min_length = float('inf')\n    \n    for i, num in enumerate(a):\n        current_factors += prime_factors(num)\n        if is_perfect_square(current_factors):\n            min_length = min(min_length, i + 1)\n        else:\n            # Find the smallest subsequence to make the product a perfect square\n            for factor in current_factors:\n                if current_factors[factor] % 2 != 0:\n                    if (factor, current_factors[factor]) in first_occurrence:\n                        min_length = min(min_length, i - first_occurrence[(factor, current_factors[factor])])\n                    break\n        first_occurrence[(tuple(sorted(current_factors.items())), sum(current_factors.values()))] = i\n    \n    return min_length if min_length != float('inf') else -1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Get the result\nresult = shortest_subsequence_with_perfect_square_product(n, a)\n\n# Print the result\nprint(result)"
        ]
    },
    {
        "question_title": "Sum of Digits",
        "question_content": "Let f(x) be the sum of digits of a decimal number x.\n\nFind the smallest non-negative integer x such that f(x) + f(x + 1) + \\dots + f(x + k) = n.\n\n\nInput Format\nThe first line contains one integer t (1 \\le t \\le 150) \u2014 the number of test cases.\n\nEach test case consists of one line containing two integers n and k (1 \\le n \\le 150, 0 \\le k \\le 9).\n\n\nOutput Format\nFor each test case, print one integer without leading zeroes. If there is no such x that f(x) + f(x + 1) + \\dots + f(x + k) = n, print -1; otherwise, print the minimum x meeting that constraint.\n\n\nSample Input 1\n\n7\n1 0\n1 1\n42 7\n13 7\n99 1\n99 0\n99 2\n\nSample Output 1\n\n1\n0\n4\n-1\n599998\n99999999999\n7997",
        "platform": "codeforces",
        "question_id": "1373/E",
        "contest_id": "1373",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):  # Arbitrarily large upper bound\n        total_sum = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total_sum == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):\n        total = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total == n:\n            return x\n        if total > n:\n            break\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):\n        total_sum = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total_sum == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    if k == 0:\n        return n if n <= 9 else -1\n    \n    for x in range(10**18):\n        total_sum = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total_sum == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):  # Arbitrarily large upper bound\n        total = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**10):  # Arbitrarily large upper limit\n        total = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**10):  # Arbitrarily large upper limit\n        total = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):  # Arbitrarily large upper limit\n        total = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):\n        total_sum = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total_sum == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    if k == 0:\n        return n if n <= 9 else -1\n    \n    for x in range(10**18):\n        total_sum = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total_sum == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):  # Arbitrarily large upper bound\n        total_sum = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total_sum == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):\n        total = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total == n:\n            return x\n        if total > n:\n            break\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):\n        total_sum = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total_sum == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    if k == 0:\n        return n if n <= 9 else -1\n    \n    for x in range(10**18):\n        total_sum = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total_sum == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):  # Arbitrarily large upper bound\n        total = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**10):  # Arbitrarily large upper limit\n        total = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**10):  # Arbitrarily large upper limit\n        total = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):  # Arbitrarily large upper limit\n        total = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    for x in range(10**18):\n        total_sum = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total_sum == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_min_x(n, k):\n    if k == 0:\n        return n if n <= 9 else -1\n    \n    for x in range(10**18):\n        total_sum = sum(sum_of_digits(x + i) for i in range(k + 1))\n        if total_sum == n:\n            return x\n    return -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        result = find_min_x(n, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Calendar Ambiguity",
        "question_content": "Berland year consists of m months with d days each. Months are numbered from 1 to m. Berland week consists of w days. The first day of the year is also the first day of the week. Note that the last week of the year might be shorter than w days.\n\nA pair (x, y) such that x < y is ambiguous if day x of month y is the same day of the week as day y of month x.\n\nCount the number of ambiguous pairs.\n\n\nInput Format\nThe first line contains a single integer t (1 \\le t \\le 1000)\u00a0\u2014 the number of testcases.\n\nEach of the next t lines contains three integers m, d and w (1 \\le m, d, w \\le 10^9)\u00a0\u2014 the number of months in a year, the number of days in a month and the number of days in a week.\n\n\nOutput Format\nPrint t integers\u00a0\u2014 for each testcase output the number of pairs (x, y) such that x < y and day x of month y is the same day of the week as day y of month x.\n\n\nSample Input 1\n\n5\n6 7 4\n10 7 12\n12 30 7\n1 1 1\n3247834 10298779 625324\n\nSample Output 1\n\n6\n9\n5\n0\n116461800\n\n\nNote\nHere are the pairs for the first test case:",
        "platform": "codeforces",
        "question_id": "1389/E",
        "contest_id": "1389",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        ambiguous_pairs = (m * d // w) * (m * d // w - 1) // 2\n    else:\n        ambiguous_pairs = 0\n    \n    results.append(ambiguous_pairs)\n\n# Write the results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        pairs = (m * d // w) * (m * d // w - 1) // 2\n    else:\n        pairs = 0\n    \n    results.append(pairs)\n\n# Write the results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        results.append(m * d // w - 1)\n    else:\n        results.append(m * d // w)\n\n# Write the results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    lcm = (d * w) // gcd(d, w)\n    days_in_year = m * d\n    weeks_in_year = days_in_year // w\n    \n    if days_in_year % w == 0:\n        ambiguous_pairs = weeks_in_year * (weeks_in_year - 1) // 2\n    else:\n        ambiguous_pairs = weeks_in_year * (weeks_in_year - 1) // 2 + (days_in_year % w)\n    \n    results.append(ambiguous_pairs)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        results.append(m * d // w - 1)\n    else:\n        results.append(m * d // w)\n\n# Write the results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        results.append(m * d // w - 1)\n    else:\n        results.append(0)\n\n# Write the results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        count = (m * d // w) * (m * d // w - 1) // 2\n    else:\n        count = 0\n    \n    results.append(count)\n\n# Print the results\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of days in the year\n    total_days = m * d\n    \n    # Calculate the number of weeks in the year\n    weeks_in_year = total_days // w\n    \n    # Calculate the number of days in the last week\n    last_week_days = total_days % w\n    \n    # Calculate the number of ambiguous pairs\n    ambiguous_pairs = 0\n    \n    # Pairs where both days are in the same week\n    for i in range(1, weeks_in_year + 1):\n        ambiguous_pairs += i\n    \n    # Pairs where the first day is in the last week and the second day is in the first week\n    if last_week_days > 0:\n        ambiguous_pairs += weeks_in_year\n    \n    results.append(ambiguous_pairs)\n\n# Print the results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        result = (m * d // w) * (m * d // w - 1) // 2\n    else:\n        result = 0\n    \n    results.append(result)\n\n# Write the results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        results.append(m * d // w - 1)\n    else:\n        results.append(0)\n\n# Print the results\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        ambiguous_pairs = (m * d // w) * (m * d // w - 1) // 2\n    else:\n        ambiguous_pairs = 0\n    \n    results.append(ambiguous_pairs)\n\n# Write the results to stdout\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        pairs = (m * d // w) * (m * d // w - 1) // 2\n    else:\n        pairs = 0\n    \n    results.append(pairs)\n\n# Write the results to stdout\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        results.append(m * d // w - 1)\n    else:\n        results.append(m * d // w)\n\n# Write the results to stdout\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    lcm = (d * w) // gcd(d, w)\n    days_in_year = m * d\n    weeks_in_year = days_in_year // w\n    \n    if days_in_year % w == 0:\n        ambiguous_pairs = weeks_in_year * (weeks_in_year - 1) // 2\n    else:\n        ambiguous_pairs = weeks_in_year * (weeks_in_year - 1) // 2 + (days_in_year % w)\n    \n    results.append(ambiguous_pairs)\n\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        results.append(m * d // w - 1)\n    else:\n        results.append(m * d // w)\n\n# Write the results to stdout\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        results.append(m * d // w - 1)\n    else:\n        results.append(0)\n\n# Write the results to stdout\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        count = (m * d // w) * (m * d // w - 1) // 2\n    else:\n        count = 0\n    \n    results.append(count)\n\n# Print the results\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of days in the year\n    total_days = m * d\n    \n    # Calculate the number of weeks in the year\n    weeks_in_year = total_days // w\n    \n    # Calculate the number of days in the last week\n    last_week_days = total_days % w\n    \n    # Calculate the number of ambiguous pairs\n    ambiguous_pairs = 0\n    \n    # Pairs where both days are in the same week\n    for i in range(1, weeks_in_year + 1):\n        ambiguous_pairs += i\n    \n    # Pairs where the first day is in the last week and the second day is in the first week\n    if last_week_days > 0:\n        ambiguous_pairs += weeks_in_year\n    \n    results.append(ambiguous_pairs)\n\n# Print the results\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        result = (m * d // w) * (m * d // w - 1) // 2\n    else:\n        result = 0\n    \n    results.append(result)\n\n# Write the results to stdout\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data\nindex = 1\n\n# Process each test case\nresults = []\nfor _ in range(t):\n    m = int(data[index])\n    d = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    \n    # Calculate the number of ambiguous pairs\n    if m * d % w == 0:\n        results.append(m * d // w - 1)\n    else:\n        results.append(0)\n\n# Print the results\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "505",
        "question_content": "A binary matrix is called good if every even length square sub-matrix has an odd number of ones.\n\nGiven a binary matrix a consisting of n rows and m columns, determine the minimum number of cells you need to change to make it good, or report that there is no way to make it good at all.\n\nAll the terms above have their usual meanings\u00a0\u2014 refer to the Notes section for their formal definitions.\n\n\nInput Format\nThe first line of input contains two integers n and m (1 \\leq n \\leq m \\leq 10^6 and n\\cdot m \\leq 10^6) \u00a0\u2014 the number of rows and columns in a, respectively.\n\nThe following n lines each contain m characters, each of which is one of 0 and 1. If the j-th character on the i-th line is 1, then a_{i,j} = 1. Similarly, if the j-th character on the i-th line is 0, then a_{i,j} = 0.\n\n\nOutput Format\nOutput the minimum number of cells you need to change to make a good, or output -1 if it's not possible at all.\n\n\nSample Input 1\n\n3 3\n101\n001\n110\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n7 15\n000100001010010\n100111010110001\n101101111100100\n010000111111010\n111010010100001\n000011001111101\n111111011010011\n\nSample Output 2\n\n-1\n\n\nNote\nIn the first case, changing a_{1,1} to 0 and a_{2,2} to 1 is enough.\n\nYou can verify that there is no way to make the matrix in the second case good.\n\nSome definitions\u00a0\u2014\n\n- A binary matrix is one in which every element is either 1 or 0.\n- A sub-matrix is described by 4 parameters\u00a0\u2014 r_1, r_2, c_1, and c_2; here, 1 \\leq r_1 \\leq r_2 \\leq n and 1 \\leq c_1 \\leq c_2 \\leq m.\n- This sub-matrix contains all elements a_{i,j} that satisfy both r_1 \\leq i \\leq r_2 and c_1 \\leq j \\leq c_2.\n- A sub-matrix is, further, called an even length square if r_2-r_1 = c_2-c_1 and r_2-r_1+1 is divisible by 2.",
        "platform": "codeforces",
        "question_id": "1391/D",
        "contest_id": "1391",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = [list(map(int, data[2+i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(matrix[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        return False\n    return True\n\nif not is_good(a):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(a[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        a[i+k//2][j+k//2] = 1 - a[i+k//2][j+k//2]\n                        changes += 1\n    print(changes)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = [list(map(int, data[2 + i * m:2 + (i + 1) * m])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(a):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(a[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    a[i + k][j + k] = 1 - a[i + k][j + k]\n                    changes += 1\n    print(changes)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = [list(map(int, data[2+i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(matrix[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        return False\n    return True\n\nif not is_good(a):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(a[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        a[i][j] = 1 - a[i][j]\n                        changes += 1\n    print(changes)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = [list(map(int, data[2 + i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(matrix[x][y] for x in range(i, i + k + 1) for y in range(j, j + k + 1))\n                    if submatrix_sum % 2 == 0:\n                        return False\n    return True\n\nif not is_good(a):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(a[x][y] for x in range(i, i + k + 1) for y in range(j, j + k + 1))\n                    if submatrix_sum % 2 == 0:\n                        a[i + k // 2][j + k // 2] = 1 - a[i + k // 2][j + k // 2]\n                        changes += 1\n    print(changes)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = [list(map(int, data[2+i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(2, min(n-i, m-j)+1, 2):\n                if sum(matrix[x][y] for x in range(i, i+k) for y in range(j, j+k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(a):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(2, min(n-i, m-j)+1, 2):\n                if sum(a[x][y] for x in range(i, i+k) for y in range(j, j+k)) % 2 == 0:\n                    a[i+k//2][j+k//2] = 1 - a[i+k//2][j+k//2]\n                    changes += 1\n    print(changes)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = [list(map(int, data[2 + i * m: 2 + (i + 1) * m])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(matrix):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    matrix[i + k][j + k] = 1 - matrix[i + k][j + k]\n                    changes += 1\n    print(changes)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = [list(map(int, data[2+i*m:2+(i+1)*m])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(matrix[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        return False\n    return True\n\nif not is_good(matrix):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(matrix[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        matrix[i+k//2][j+k//2] = 1 - matrix[i+k//2][j+k//2]\n                        changes += 1\n    print(changes)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = [list(map(int, data[2 + i * m:2 + (i + 1) * m])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(matrix):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    changes += 1\n                    matrix[i + k][j + k] = 1 - matrix[i + k][j + k]\n    print(changes)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = [list(map(int, data[2 + i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(matrix):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    changes += 1\n                    matrix[i + k][j + k] = 1 - matrix[i + k][j + k]\n    print(changes)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = [list(map(int, data[2 + i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(matrix):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    changes += 1\n                    matrix[i + k][j + k] = 1 - matrix[i + k][j + k]\n    print(changes)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = [list(map(int, data[2+i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(matrix[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        return False\n    return True\n\nif not is_good(a):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(a[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        a[i+k//2][j+k//2] = 1 - a[i+k//2][j+k//2]\n                        changes += 1\n    print(changes)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = [list(map(int, data[2 + i * m:2 + (i + 1) * m])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(a):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(a[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    a[i + k][j + k] = 1 - a[i + k][j + k]\n                    changes += 1\n    print(changes)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = [list(map(int, data[2+i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(matrix[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        return False\n    return True\n\nif not is_good(a):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(a[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        a[i][j] = 1 - a[i][j]\n                        changes += 1\n    print(changes)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = [list(map(int, data[2 + i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(matrix[x][y] for x in range(i, i + k + 1) for y in range(j, j + k + 1))\n                    if submatrix_sum % 2 == 0:\n                        return False\n    return True\n\nif not is_good(a):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(a[x][y] for x in range(i, i + k + 1) for y in range(j, j + k + 1))\n                    if submatrix_sum % 2 == 0:\n                        a[i + k // 2][j + k // 2] = 1 - a[i + k // 2][j + k // 2]\n                        changes += 1\n    print(changes)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = [list(map(int, data[2+i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(2, min(n-i, m-j)+1, 2):\n                if sum(matrix[x][y] for x in range(i, i+k) for y in range(j, j+k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(a):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(2, min(n-i, m-j)+1, 2):\n                if sum(a[x][y] for x in range(i, i+k) for y in range(j, j+k)) % 2 == 0:\n                    a[i+k//2][j+k//2] = 1 - a[i+k//2][j+k//2]\n                    changes += 1\n    print(changes)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = [list(map(int, data[2 + i * m: 2 + (i + 1) * m])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(matrix):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    matrix[i + k][j + k] = 1 - matrix[i + k][j + k]\n                    changes += 1\n    print(changes)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = [list(map(int, data[2+i*m:2+(i+1)*m])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(matrix[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        return False\n    return True\n\nif not is_good(matrix):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n-i, m-j)):\n                if k % 2 == 0:\n                    submatrix_sum = sum(matrix[x][y] for x in range(i, i+k) for y in range(j, j+k))\n                    if submatrix_sum % 2 == 0:\n                        matrix[i+k//2][j+k//2] = 1 - matrix[i+k//2][j+k//2]\n                        changes += 1\n    print(changes)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = [list(map(int, data[2 + i * m:2 + (i + 1) * m])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(matrix):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    changes += 1\n                    matrix[i + k][j + k] = 1 - matrix[i + k][j + k]\n    print(changes)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = [list(map(int, data[2 + i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(matrix):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    changes += 1\n                    matrix[i + k][j + k] = 1 - matrix[i + k][j + k]\n    print(changes)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = [list(map(int, data[2 + i])) for i in range(n)]\n\ndef is_good(matrix):\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    return False\n    return True\n\nif not is_good(matrix):\n    print(-1)\nelse:\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(1, min(n - i, m - j) // 2 + 1):\n                if sum(matrix[x][y] for x in range(i, i + 2 * k) for y in range(j, j + 2 * k)) % 2 == 0:\n                    changes += 1\n                    matrix[i + k][j + k] = 1 - matrix[i + k][j + k]\n    print(changes)"
        ]
    },
    {
        "question_title": "Divide Square",
        "question_content": "There is a square of size 10^6 \\times 10^6 on the coordinate plane with four points (0, 0), (0, 10^6), (10^6, 0), and (10^6, 10^6) as its vertices.\n\nYou are going to draw segments on the plane. All segments are either horizontal or vertical and intersect with at least one side of the square.\n\nNow you are wondering how many pieces this square divides into after drawing all segments. Write a program calculating the number of pieces of the square.\n\n\nInput Format\nThe first line contains two integers n and m (0 \\le n, m \\le 10^5)\u00a0\u2014 the number of horizontal segments and the number of vertical segments.\n\nThe next n lines contain descriptions of the horizontal segments. The i-th line contains three integers y_i, lx_i and rx_i (0 < y_i < 10^6; 0 \\le lx_i < rx_i \\le 10^6), which means the segment connects (lx_i, y_i) and (rx_i, y_i).\n\nThe next m lines contain descriptions of the vertical segments. The i-th line contains three integers x_i, ly_i and ry_i (0 < x_i < 10^6; 0 \\le ly_i < ry_i \\le 10^6), which means the segment connects (x_i, ly_i) and (x_i, ry_i).\n\nIt's guaranteed that there are no two segments on the same line, and each segment intersects with at least one of square's sides.\n\n\nOutput Format\nPrint the number of pieces the square is divided into after drawing all the segments.\n\n\nSample Input 1\n\n3 3\n2 3 1000000\n4 0 4\n3 0 1000000\n4 0 1\n2 0 5\n3 1 1000000\n\nSample Output 1\n\n7\n\n\nNote\nThe sample is like this:",
        "platform": "codeforces",
        "question_id": "1401/E",
        "contest_id": "1401",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nnum_pieces = (len(horizontal_lines) + 1) * (len(vertical_lines) + 1)\n\nprint(num_pieces)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\n# Sort segments\nhorizontal_segments.sort()\nvertical_segments.sort()\n\n# Initialize variables\nhorizontal_lines = set()\nvertical_lines = set()\n\n# Add initial lines\nhorizontal_lines.add(0)\nhorizontal_lines.add(1000000)\nvertical_lines.add(0)\nvertical_lines.add(1000000)\n\n# Add horizontal lines from segments\nfor _, lx, rx in horizontal_segments:\n    horizontal_lines.add(lx)\n    horizontal_lines.add(rx)\n\n# Add vertical lines from segments\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(ly)\n    vertical_lines.add(ry)\n\n# Calculate the number of pieces\nnum_pieces = 1\nfor i in range(1, len(horizontal_lines)):\n    for j in range(1, len(vertical_lines)):\n        if (horizontal_lines[i], vertical_lines[j]) not in [(0, 0), (0, 1000000), (1000000, 0), (1000000, 1000000)]:\n            num_pieces += 1\n\n# Output the result\nprint(num_pieces)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nhorizontal_lines = sorted(horizontal_lines)\nvertical_lines = sorted(vertical_lines)\n\nnum_pieces = 1\n\nfor i in range(1, len(horizontal_lines)):\n    num_pieces *= (horizontal_lines[i] - horizontal_lines[i - 1])\n\nfor i in range(1, len(vertical_lines)):\n    num_pieces *= (vertical_lines[i] - vertical_lines[i - 1])\n\nprint(num_pieces)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nhorizontal_count = len(horizontal_lines)\nvertical_count = len(vertical_lines)\n\nresult = (horizontal_count + 1) * (vertical_count + 1)\n\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\n# Sort segments\nhorizontal_segments.sort()\nvertical_segments.sort()\n\n# Initialize variables\nhorizontal_lines = set()\nvertical_lines = set()\n\n# Add the boundaries of the square\nhorizontal_lines.add(0)\nhorizontal_lines.add(10**6)\nvertical_lines.add(0)\nvertical_lines.add(10**6)\n\n# Add horizontal segment lines\nfor _, lx, rx in horizontal_segments:\n    horizontal_lines.add(lx)\n    horizontal_lines.add(rx)\n\n# Add vertical segment lines\nfor x, _, _ in vertical_segments:\n    vertical_lines.add(x)\n\n# Calculate the number of pieces\nnum_pieces = 1\nfor i in range(1, len(horizontal_lines)):\n    for j in range(1, len(vertical_lines)):\n        if (horizontal_lines[i], vertical_lines[j]) not in horizontal_segments and (vertical_lines[j], horizontal_lines[i]) not in vertical_segments:\n            num_pieces += 1\n\n# Output the result\nprint(num_pieces)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nhorizontal_count = len(horizontal_lines)\nvertical_count = len(vertical_lines)\n\nresult = (horizontal_count + 1) * (vertical_count + 1)\n\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_count = 0\nvertical_count = 0\n\nfor i in range(n):\n    if i == 0 or horizontal_segments[i][0] != horizontal_segments[i - 1][0]:\n        horizontal_count += 1\n\nfor i in range(m):\n    if i == 0 or vertical_segments[i][0] != vertical_segments[i - 1][0]:\n        vertical_count += 1\n\nresult = (horizontal_count + 1) * (vertical_count + 1)\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nhorizontal_count = len(horizontal_lines)\nvertical_count = len(vertical_lines)\n\nresult = (horizontal_count + 1) * (vertical_count + 1)\n\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nhorizontal_lines = sorted(horizontal_lines)\nvertical_lines = sorted(vertical_lines)\n\nnum_pieces = 1\n\nfor i in range(1, len(horizontal_lines)):\n    num_pieces += horizontal_lines[i] - horizontal_lines[i - 1]\n\nfor i in range(1, len(vertical_lines)):\n    num_pieces += vertical_lines[i] - vertical_lines[i - 1]\n\nprint(num_pieces)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    horizontal_segments = []\n    for _ in range(n):\n        y = int(data[index])\n        lx = int(data[index + 1])\n        rx = int(data[index + 2])\n        index += 3\n        horizontal_segments.append((y, lx, rx))\n    \n    vertical_segments = []\n    for _ in range(m):\n        x = int(data[index])\n        ly = int(data[index + 1])\n        ry = int(data[index + 2])\n        index += 3\n        vertical_segments.append((x, ly, ry))\n    \n    horizontal_segments.sort()\n    vertical_segments.sort()\n    \n    horizontal_lines = set()\n    vertical_lines = set()\n    \n    for y, lx, rx in horizontal_segments:\n        horizontal_lines.add(y)\n    \n    for x, ly, ry in vertical_segments:\n        vertical_lines.add(x)\n    \n    num_pieces = 1 + len(horizontal_lines) * len(vertical_lines)\n    \n    print(num_pieces)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nnum_pieces = (len(horizontal_lines) + 1) * (len(vertical_lines) + 1)\n\nprint(num_pieces)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\n# Sort segments\nhorizontal_segments.sort()\nvertical_segments.sort()\n\n# Initialize variables\nhorizontal_lines = set()\nvertical_lines = set()\n\n# Add initial lines\nhorizontal_lines.add(0)\nhorizontal_lines.add(1000000)\nvertical_lines.add(0)\nvertical_lines.add(1000000)\n\n# Add horizontal lines from segments\nfor _, lx, rx in horizontal_segments:\n    horizontal_lines.add(lx)\n    horizontal_lines.add(rx)\n\n# Add vertical lines from segments\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(ly)\n    vertical_lines.add(ry)\n\n# Calculate the number of pieces\nnum_pieces = 1\nfor i in range(1, len(horizontal_lines)):\n    for j in range(1, len(vertical_lines)):\n        if (horizontal_lines[i], vertical_lines[j]) not in [(0, 0), (0, 1000000), (1000000, 0), (1000000, 1000000)]:\n            num_pieces += 1\n\n# Output the result\nprint(num_pieces)",
            "# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nhorizontal_lines = sorted(horizontal_lines)\nvertical_lines = sorted(vertical_lines)\n\nnum_pieces = 1\n\nfor i in range(1, len(horizontal_lines)):\n    num_pieces *= (horizontal_lines[i] - horizontal_lines[i - 1])\n\nfor i in range(1, len(vertical_lines)):\n    num_pieces *= (vertical_lines[i] - vertical_lines[i - 1])\n\nprint(num_pieces)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nhorizontal_count = len(horizontal_lines)\nvertical_count = len(vertical_lines)\n\nresult = (horizontal_count + 1) * (vertical_count + 1)\n\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\n# Sort segments\nhorizontal_segments.sort()\nvertical_segments.sort()\n\n# Initialize variables\nhorizontal_lines = set()\nvertical_lines = set()\n\n# Add the boundaries of the square\nhorizontal_lines.add(0)\nhorizontal_lines.add(10**6)\nvertical_lines.add(0)\nvertical_lines.add(10**6)\n\n# Add horizontal segment lines\nfor _, lx, rx in horizontal_segments:\n    horizontal_lines.add(lx)\n    horizontal_lines.add(rx)\n\n# Add vertical segment lines\nfor x, _, _ in vertical_segments:\n    vertical_lines.add(x)\n\n# Calculate the number of pieces\nnum_pieces = 1\nfor i in range(1, len(horizontal_lines)):\n    for j in range(1, len(vertical_lines)):\n        if (horizontal_lines[i], vertical_lines[j]) not in horizontal_segments and (vertical_lines[j], horizontal_lines[i]) not in vertical_segments:\n            num_pieces += 1\n\n# Output the result\nprint(num_pieces)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nhorizontal_count = len(horizontal_lines)\nvertical_count = len(vertical_lines)\n\nresult = (horizontal_count + 1) * (vertical_count + 1)\n\nprint(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_count = 0\nvertical_count = 0\n\nfor i in range(n):\n    if i == 0 or horizontal_segments[i][0] != horizontal_segments[i - 1][0]:\n        horizontal_count += 1\n\nfor i in range(m):\n    if i == 0 or vertical_segments[i][0] != vertical_segments[i - 1][0]:\n        vertical_count += 1\n\nresult = (horizontal_count + 1) * (vertical_count + 1)\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nhorizontal_count = len(horizontal_lines)\nvertical_count = len(vertical_lines)\n\nresult = (horizontal_count + 1) * (vertical_count + 1)\n\nprint(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nhorizontal_segments = []\nvertical_segments = []\n\nindex = 2\nfor _ in range(n):\n    y = int(data[index])\n    lx = int(data[index + 1])\n    rx = int(data[index + 2])\n    horizontal_segments.append((y, lx, rx))\n    index += 3\n\nfor _ in range(m):\n    x = int(data[index])\n    ly = int(data[index + 1])\n    ry = int(data[index + 2])\n    vertical_segments.append((x, ly, ry))\n    index += 3\n\nhorizontal_segments.sort()\nvertical_segments.sort()\n\nhorizontal_lines = set()\nvertical_lines = set()\n\nfor y, lx, rx in horizontal_segments:\n    horizontal_lines.add(y)\n\nfor x, ly, ry in vertical_segments:\n    vertical_lines.add(x)\n\nhorizontal_lines = sorted(horizontal_lines)\nvertical_lines = sorted(vertical_lines)\n\nnum_pieces = 1\n\nfor i in range(1, len(horizontal_lines)):\n    num_pieces += horizontal_lines[i] - horizontal_lines[i - 1]\n\nfor i in range(1, len(vertical_lines)):\n    num_pieces += vertical_lines[i] - vertical_lines[i - 1]\n\nprint(num_pieces)",
            "# YOUR CODE HERE\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    \n    horizontal_segments = []\n    for _ in range(n):\n        y = int(data[index])\n        lx = int(data[index + 1])\n        rx = int(data[index + 2])\n        index += 3\n        horizontal_segments.append((y, lx, rx))\n    \n    vertical_segments = []\n    for _ in range(m):\n        x = int(data[index])\n        ly = int(data[index + 1])\n        ry = int(data[index + 2])\n        index += 3\n        vertical_segments.append((x, ly, ry))\n    \n    horizontal_segments.sort()\n    vertical_segments.sort()\n    \n    horizontal_lines = set()\n    vertical_lines = set()\n    \n    for y, lx, rx in horizontal_segments:\n        horizontal_lines.add(y)\n    \n    for x, ly, ry in vertical_segments:\n        vertical_lines.add(x)\n    \n    num_pieces = 1 + len(horizontal_lines) * len(vertical_lines)\n    \n    print(num_pieces)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Bubble Cup hypothesis",
        "question_content": "The Bubble Cup hypothesis stood unsolved for 130 years. Who ever proves the hypothesis will be regarded as one of the greatest mathematicians of our time! A famous mathematician Jerry Mao managed to reduce the hypothesis to this problem:\n\nGiven a number m, how many polynomials P with coefficients in set {\\{0,1,2,3,4,5,6,7\\}} have: P(2)=m?\n\nHelp Jerry Mao solve the long standing problem!\n\n\nInput Format\nThe first line contains a single integer t (1 \\leq t \\leq 5\\cdot 10^5) - number of test cases.\n\nOn next line there are t numbers, m_i (1 \\leq m_i \\leq 10^{18}) - meaning that in case i you should solve for number m_i.\n\n\nOutput Format\nFor each test case i, print the answer on separate lines: number of polynomials P as described in statement such that P(2)=m_i, modulo 10^9 + 7.\n\n\nSample Input 1\n\n2\n2 4\n\nSample Output 1\n\n2\n4\n\n\nNote\nIn first case, for m=2, polynomials that satisfy the constraint are x and 2.\n\nIn second case, for m=4, polynomials that satisfy the constraint are x^2, x + 2, 2x and 4.",
        "platform": "codeforces",
        "question_id": "1423/J",
        "contest_id": "1423",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_polynomials(m):\n    if m == 0:\n        return 1\n    if m == 1:\n        return 2\n    if m == 2:\n        return 4\n    if m == 3:\n        return 8\n    if m == 4:\n        return 16\n    if m == 5:\n        return 32\n    if m == 6:\n        return 64\n    if m == 7:\n        return 128\n    if m == 8:\n        return 256\n    if m == 9:\n        return 512\n    if m == 10:\n        return 1024\n    if m == 11:\n        return 2048\n    if m == 12:\n        return 4096\n    if m == 13:\n        return 8192\n    if m == 14:\n        return 16384\n    if m == 15:\n        return 32768\n    if m == 16:\n        return 65536\n    if m == 17:\n        return 131072\n    if m == 18:\n        return 262144\n    if m == 19:\n        return 524288\n    if m == 20:\n        return 1048576\n    if m == 21:\n        return 2097152\n    if m == 22:\n        return 4194304\n    if m == 23:\n        return 8388608\n    if m == 24:\n        return 16777216\n    if m == 25:\n        return 33554432\n    if m == 26:\n        return 67108864\n    if m == 27:\n        return 134217728\n    if m == 28:\n        return 268435456\n    if m == 29:\n        return 536870912\n    if m == 30:\n        return 1073741824\n    if m == 31:\n        return 2147483648\n    if m == 32:\n        return 4294967296\n    if m == 33:\n        return 8589934592\n    if m == 34:\n        return 17179869184\n    if m == 35:\n        return 34359738368\n    if m == 36:\n        return 68719476736\n    if m == 37:\n        return 137438953472\n    if m == 38:\n        return 274877906944\n    if m == 39:\n        return 549755813888\n    if m == 40:\n        return 1099511627776\n    if m == 41:\n        return 2199023255552\n    if m == 42:\n        return 4398046511104\n    if m == 43:\n        return 8796093022208\n    if m == 44:\n        return 17592186044416\n    if m == 45:\n        return 35184372088832\n    if m == 46:\n        return 70368744177664\n    if m == 47:\n        return 140737488355328\n    if m == 48:\n        return 281474976710656\n    if m == 49:\n        return 562949953421312\n    if m == 50:\n        return 1125899906842624\n    if m == 51:\n        return 2251799813685248\n    if m == 52:\n        return 4503599627370496\n    if m == 53:\n        return 9007199254740992\n    if m == 54:\n        return 18014398509481984\n    if m == 55:\n        return 36028797018963968\n    if m == 56:\n        return 72057594037927936\n    if m == 57:\n        return 144115188075855872\n    if m == 58:\n        return 288230376151711744\n    if m == 59:\n        return 576460752303423488\n    if m == 60:\n        return 1152921504606846976\n    if m == 61:\n        return 2305843009213693952\n    if m == 62:\n        return 4611686018427387904\n    if m == 63:\n        return 9223372036854775808\n    if m == 64:\n        return 18446744073709551616\n    if m == 65:\n        return 36893488147419103232\n    if m == 66:\n        return 73786976294838206464\n    if m == 67:\n        return 147573952589676412928\n    if m == 68:\n        return 295147905179352825856\n    if m == 69:\n        return 590295810358705651712\n    if m == 70:\n        return 1180591620717411303424\n    if m == 71:\n        return 2361183241434822606848\n    if m == 72:\n        return 4722366482869645213696\n    if m == 73:\n        return 9444732965739290427392\n    if m == 74:\n        return 18889465931478580854784\n    if m == 75:\n        return 37778931862957161709568\n    if m == 76:\n        return 75557863725914323419136\n    if m == 77:\n        return 151115727451828646838272\n    if m == 78:\n        return 302231454903657293676544\n    if m == 79:\n        return 604462909807314587353088\n    if m == 80:\n        return 1208925819614629174",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_polynomials(m):\n    if m == 0:\n        return 1\n    if m == 1:\n        return 2\n    if m == 2:\n        return 4\n    if m == 3:\n        return 8\n    if m == 4:\n        return 16\n    if m == 5:\n        return 32\n    if m == 6:\n        return 64\n    if m == 7:\n        return 128\n    if m == 8:\n        return 256\n    if m == 9:\n        return 512\n    if m == 10:\n        return 1024\n    if m == 11:\n        return 2048\n    if m == 12:\n        return 4096\n    if m == 13:\n        return 8192\n    if m == 14:\n        return 16384\n    if m == 15:\n        return 32768\n    if m == 16:\n        return 65536\n    if m == 17:\n        return 131072\n    if m == 18:\n        return 262144\n    if m == 19:\n        return 524288\n    if m == 20:\n        return 1048576\n    if m == 21:\n        return 2097152\n    if m == 22:\n        return 4194304\n    if m == 23:\n        return 8388608\n    if m == 24:\n        return 16777216\n    if m == 25:\n        return 33554432\n    if m == 26:\n        return 67108864\n    if m == 27:\n        return 134217728\n    if m == 28:\n        return 268435456\n    if m == 29:\n        return 536870912\n    if m == 30:\n        return 1073741824\n    if m == 31:\n        return 2147483648\n    if m == 32:\n        return 4294967296\n    if m == 33:\n        return 8589934592\n    if m == 34:\n        return 17179869184\n    if m == 35:\n        return 34359738368\n    if m == 36:\n        return 68719476736\n    if m == 37:\n        return 137438953472\n    if m == 38:\n        return 274877906944\n    if m == 39:\n        return 549755813888\n    if m == 40:\n        return 1099511627776\n    if m == 41:\n        return 2199023255552\n    if m == 42:\n        return 4398046511104\n    if m == 43:\n        return 8796093022208\n    if m == 44:\n        return 17592186044416\n    if m == 45:\n        return 35184372088832\n    if m == 46:\n        return 70368744177664\n    if m == 47:\n        return 140737488355328\n    if m == 48:\n        return 281474976710656\n    if m == 49:\n        return 562949953421312\n    if m == 50:\n        return 1125899906842624\n    if m == 51:\n        return 2251799813685248\n    if m == 52:\n        return 4503599627370496\n    if m == 53:\n        return 9007199254740992\n    if m == 54:\n        return 18014398509481984\n    if m == 55:\n        return 36028797018963968\n    if m == 56:\n        return 72057594037927936\n    if m == 57:\n        return 144115188075855872\n    if m == 58:\n        return 288230376151711744\n    if m == 59:\n        return 576460752303423488\n    if m == 60:\n        return 1152921504606846976\n    if m == 61:\n        return 2305843009213693952\n    if m == 62:\n        return 4611686018427387904\n    if m == 63:\n        return 9223372036854775808\n    if m == 64:\n        return 18446744073709551616\n    if m == 65:\n        return 36893488147419103232\n    if m == 66:\n        return 73786976294838206464\n    if m == 67:\n        return 147573952589676412928\n    if m == 68:\n        return 295147905179352825856\n    if m == 69:\n        return 590295810358705651712\n    if m == 70:\n        return 1180591620717411303424\n    if m == 71:\n        return 2361183241434822606848\n    if m == 72:\n        return 4722366482869645213696\n    if m == 73:\n        return 9444732965739290427392\n    if m == 74:\n        return 18889465931478580854784\n    if m == 75:\n        return 37778931862957161709568\n    if m == 76:\n        return 75557863725914323419136\n    if m == 77:\n        return 151115727451828646838272\n    if m == 78:\n        return 302231454903657293676544\n    if m == 79:\n        return 604462909807314587353088\n    if m == 80:\n        return 1208925819614629174",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# List to store results\nresults = []\n\n# Iterate over each test case\nfor i in range(t):\n    m = int(data[i + 1])\n    \n    # Calculate the number of polynomials P such that P(2) = m\n    # P(2) = a0 + a1 * 2 + a2 * 2^2 + ... + ak * 2^k = m\n    # This is equivalent to finding the number of ways to represent m in base 2 using digits from {0, 1, 2, 3, 4, 5, 6, 7}\n    \n    # Initialize the result\n    result = 0\n    \n    # Iterate over each bit position\n    for k in range(60):  # 2^60 is greater than 10^18\n        # Calculate the contribution of the current bit position\n        if m >= 2**k:\n            result += (m // 2**k) % 8\n            m %= 2**k\n    \n    # Store the result modulo 10^9 + 7\n    results.append(result % (10**9 + 7))\n\n# Write the results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_polynomials(m):\n    if m == 0:\n        return 1\n    if m == 1:\n        return 2\n    if m == 2:\n        return 4\n    if m == 3:\n        return 8\n    if m == 4:\n        return 16\n    if m == 5:\n        return 32\n    if m == 6:\n        return 64\n    if m == 7:\n        return 128\n    if m == 8:\n        return 256\n    if m == 9:\n        return 512\n    if m == 10:\n        return 1024\n    if m == 11:\n        return 2048\n    if m == 12:\n        return 4096\n    if m == 13:\n        return 8192\n    if m == 14:\n        return 16384\n    if m == 15:\n        return 32768\n    if m == 16:\n        return 65536\n    if m == 17:\n        return 131072\n    if m == 18:\n        return 262144\n    if m == 19:\n        return 524288\n    if m == 20:\n        return 1048576\n    if m == 21:\n        return 2097152\n    if m == 22:\n        return 4194304\n    if m == 23:\n        return 8388608\n    if m == 24:\n        return 16777216\n    if m == 25:\n        return 33554432\n    if m == 26:\n        return 67108864\n    if m == 27:\n        return 134217728\n    if m == 28:\n        return 268435456\n    if m == 29:\n        return 536870912\n    if m == 30:\n        return 1073741824\n    if m == 31:\n        return 2147483648\n    if m == 32:\n        return 4294967296\n    if m == 33:\n        return 8589934592\n    if m == 34:\n        return 17179869184\n    if m == 35:\n        return 34359738368\n    if m == 36:\n        return 68719476736\n    if m == 37:\n        return 137438953472\n    if m == 38:\n        return 274877906944\n    if m == 39:\n        return 549755813888\n    if m == 40:\n        return 1099511627776\n    if m == 41:\n        return 2199023255552\n    if m == 42:\n        return 4398046511104\n    if m == 43:\n        return 8796093022208\n    if m == 44:\n        return 17592186044416\n    if m == 45:\n        return 35184372088832\n    if m == 46:\n        return 70368744177664\n    if m == 47:\n        return 140737488355328\n    if m == 48:\n        return 281474976710656\n    if m == 49:\n        return 562949953421312\n    if m == 50:\n        return 1125899906842624\n    if m == 51:\n        return 2251799813685248\n    if m == 52:\n        return 4503599627370496\n    if m == 53:\n        return 9007199254740992\n    if m == 54:\n        return 18014398509481984\n    if m == 55:\n        return 36028797018963968\n    if m == 56:\n        return 72057594037927936\n    if m == 57:\n        return 144115188075855872\n    if m == 58:\n        return 288230376151711744\n    if m == 59:\n        return 576460752303423488\n    if m == 60:\n        return 1152921504606846976\n    if m == 61:\n        return 2305843009213693952\n    if m == 62:\n        return 4611686018427387904\n    if m == 63:\n        return 9223372036854775808\n    if m == 64:\n        return 18446744073709551616\n    if m == 65:\n        return 36893488147419103232\n    if m == 66:\n        return 73786976294838206464\n    if m == 67:\n        return 147573952589676412928\n    if m == 68:\n        return 295147905179352825856\n    if m == 69:\n        return 590295810358705651712\n    if m == 70:\n        return 1180591620717411303424\n    if m == 71:\n        return 2361183241434822606848\n    if m == 72:\n        return 4722366482869645213696\n    if m == 73:\n        return 9444732965739290427392\n    if m == 74:\n        return 18889465931478580854784\n    if m == 75:\n        return 37778931862957161709568\n    if m == 76:\n        return 75557863725914323419136\n    if m == 77:\n        return 151115727451828646838272\n    if m == 78:\n        return 302231454903657293676544\n    if m == 79:\n        return 604462909807314587353088\n    if m == 80:\n        return 1208925819614629174",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_polynomials(m):\n    if m == 0:\n        return 1\n    if m == 1:\n        return 2\n    if m == 2:\n        return 4\n    if m == 3:\n        return 8\n    if m == 4:\n        return 16\n    if m == 5:\n        return 32\n    if m == 6:\n        return 64\n    if m == 7:\n        return 128\n    if m == 8:\n        return 256\n    if m == 9:\n        return 512\n    if m == 10:\n        return 1024\n    if m == 11:\n        return 2048\n    if m == 12:\n        return 4096\n    if m == 13:\n        return 8192\n    if m == 14:\n        return 16384\n    if m == 15:\n        return 32768\n    if m == 16:\n        return 65536\n    if m == 17:\n        return 131072\n    if m == 18:\n        return 262144\n    if m == 19:\n        return 524288\n    if m == 20:\n        return 1048576\n    if m == 21:\n        return 2097152\n    if m == 22:\n        return 4194304\n    if m == 23:\n        return 8388608\n    if m == 24:\n        return 16777216\n    if m == 25:\n        return 33554432\n    if m == 26:\n        return 67108864\n    if m == 27:\n        return 134217728\n    if m == 28:\n        return 268435456\n    if m == 29:\n        return 536870912\n    if m == 30:\n        return 1073741824\n    if m == 31:\n        return 2147483648\n    if m == 32:\n        return 4294967296\n    if m == 33:\n        return 8589934592\n    if m == 34:\n        return 17179869184\n    if m == 35:\n        return 34359738368\n    if m == 36:\n        return 68719476736\n    if m == 37:\n        return 137438953472\n    if m == 38:\n        return 274877906944\n    if m == 39:\n        return 549755813888\n    if m == 40:\n        return 1099511627776\n    if m == 41:\n        return 2199023255552\n    if m == 42:\n        return 4398046511104\n    if m == 43:\n        return 8796093022208\n    if m == 44:\n        return 17592186044416\n    if m == 45:\n        return 35184372088832\n    if m == 46:\n        return 70368744177664\n    if m == 47:\n        return 140737488355328\n    if m == 48:\n        return 281474976710656\n    if m == 49:\n        return 562949953421312\n    if m == 50:\n        return 1125899906842624\n    if m == 51:\n        return 2251799813685248\n    if m == 52:\n        return 4503599627370496\n    if m == 53:\n        return 9007199254740992\n    if m == 54:\n        return 18014398509481984\n    if m == 55:\n        return 36028797018963968\n    if m == 56:\n        return 72057594037927936\n    if m == 57:\n        return 144115188075855872\n    if m == 58:\n        return 288230376151711744\n    if m == 59:\n        return 576460752303423488\n    if m == 60:\n        return 1152921504606846976\n    if m == 61:\n        return 2305843009213693952\n    if m == 62:\n        return 4611686018427387904\n    if m == 63:\n        return 9223372036854775808\n    if m == 64:\n        return 18446744073709551616\n    if m == 65:\n        return 36893488147419103232\n    if m == 66:\n        return 73786976294838206464\n    if m == 67:\n        return 147573952589676412928\n    if m == 68:\n        return 295147905179352825856\n    if m == 69:\n        return 590295810358705651712\n    if m == 70:\n        return 1180591620717411303424\n    if m == 71:\n        return 2361183241434822606848\n    if m == 72:\n        return 4722366482869645213696\n    if m == 73:\n        return 9444732965739290427392\n    if m == 74:\n        return 18889465931478580854784\n    if m == 75:\n        return 37778931862957161709568\n    if m == 76:\n        return 75557863725914323419136\n    if m == 77:\n        return 151115727451828646838272\n    if m == 78:\n        return 302231454903657293676544\n    if m == 79:\n        return 604462909807314587353088\n    if m == 80:\n        return 1208925819614629174",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_polynomials(m):\n    if m == 0:\n        return 1\n    if m == 1:\n        return 2\n    if m == 2:\n        return 4\n    if m == 3:\n        return 8\n    if m == 4:\n        return 16\n    if m == 5:\n        return 32\n    if m == 6:\n        return 64\n    if m == 7:\n        return 128\n    if m == 8:\n        return 256\n    if m == 9:\n        return 512\n    if m == 10:\n        return 1024\n    if m == 11:\n        return 2048\n    if m == 12:\n        return 4096\n    if m == 13:\n        return 8192\n    if m == 14:\n        return 16384\n    if m == 15:\n        return 32768\n    if m == 16:\n        return 65536\n    if m == 17:\n        return 131072\n    if m == 18:\n        return 262144\n    if m == 19:\n        return 524288\n    if m == 20:\n        return 1048576\n    if m == 21:\n        return 2097152\n    if m == 22:\n        return 4194304\n    if m == 23:\n        return 8388608\n    if m == 24:\n        return 16777216\n    if m == 25:\n        return 33554432\n    if m == 26:\n        return 67108864\n    if m == 27:\n        return 134217728\n    if m == 28:\n        return 268435456\n    if m == 29:\n        return 536870912\n    if m == 30:\n        return 1073741824\n    if m == 31:\n        return 2147483648\n    if m == 32:\n        return 4294967296\n    if m == 33:\n        return 8589934592\n    if m == 34:\n        return 17179869184\n    if m == 35:\n        return 34359738368\n    if m == 36:\n        return 68719476736\n    if m == 37:\n        return 137438953472\n    if m == 38:\n        return 274877906944\n    if m == 39:\n        return 549755813888\n    if m == 40:\n        return 1099511627776\n    if m == 41:\n        return 2199023255552\n    if m == 42:\n        return 4398046511104\n    if m == 43:\n        return 8796093022208\n    if m == 44:\n        return 17592186044416\n    if m == 45:\n        return 35184372088832\n    if m == 46:\n        return 70368744177664\n    if m == 47:\n        return 140737488355328\n    if m == 48:\n        return 281474976710656\n    if m == 49:\n        return 562949953421312\n    if m == 50:\n        return 1125899906842624\n    if m == 51:\n        return 2251799813685248\n    if m == 52:\n        return 4503599627370496\n    if m == 53:\n        return 9007199254740992\n    if m == 54:\n        return 18014398509481984\n    if m == 55:\n        return 36028797018963968\n    if m == 56:\n        return 72057594037927936\n    if m == 57:\n        return 144115188075855872\n    if m == 58:\n        return 288230376151711744\n    if m == 59:\n        return 576460752303423488\n    if m == 60:\n        return 1152921504606846976\n    if m == 61:\n        return 2305843009213693952\n    if m == 62:\n        return 4611686018427387904\n    if m == 63:\n        return 9223372036854775808\n    if m == 64:\n        return 18446744073709551616\n    if m == 65:\n        return 36893488147419103232\n    if m == 66:\n        return 73786976294838206464\n    if m == 67:\n        return 147573952589676412928\n    if m == 68:\n        return 295147905179352825856\n    if m == 69:\n        return 590295810358705651712\n    if m == 70:\n        return 1180591620717411303424\n    if m == 71:\n        return 2361183241434822606848\n    if m == 72:\n        return 4722366482869645213696\n    if m == 73:\n        return 9444732965739290427392\n    if m == 74:\n        return 18889465931478580854784\n    if m == 75:\n        return 37778931862957161709568\n    if m == 76:\n        return 75557863725914323419136\n    if m == 77:\n        return 151115727451828646838272\n    if m == 78:\n        return 302231454903657293676544\n    if m == 79:\n        return 604462909807314587353088\n    if m == 80:\n        return 1208925819614629174",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_polynomials(m):\n    if m == 0:\n        return 1\n    if m == 1:\n        return 2\n    if m == 2:\n        return 4\n    if m == 3:\n        return 8\n    if m == 4:\n        return 16\n    if m == 5:\n        return 32\n    if m == 6:\n        return 64\n    if m == 7:\n        return 128\n    if m == 8:\n        return 256\n    if m == 9:\n        return 512\n    if m == 10:\n        return 1024\n    if m == 11:\n        return 2048\n    if m == 12:\n        return 4096\n    if m == 13:\n        return 8192\n    if m == 14:\n        return 16384\n    if m == 15:\n        return 32768\n    if m == 16:\n        return 65536\n    if m == 17:\n        return 131072\n    if m == 18:\n        return 262144\n    if m == 19:\n        return 524288\n    if m == 20:\n        return 1048576\n    if m == 21:\n        return 2097152\n    if m == 22:\n        return 4194304\n    if m == 23:\n        return 8388608\n    if m == 24:\n        return 16777216\n    if m == 25:\n        return 33554432\n    if m == 26:\n        return 67108864\n    if m == 27:\n        return 134217728\n    if m == 28:\n        return 268435456\n    if m == 29:\n        return 536870912\n    if m == 30:\n        return 1073741824\n    if m == 31:\n        return 2147483648\n    if m == 32:\n        return 4294967296\n    if m == 33:\n        return 8589934592\n    if m == 34:\n        return 17179869184\n    if m == 35:\n        return 34359738368\n    if m == 36:\n        return 68719476736\n    if m == 37:\n        return 137438953472\n    if m == 38:\n        return 274877906944\n    if m == 39:\n        return 549755813888\n    if m == 40:\n        return 1099511627776\n    if m == 41:\n        return 2199023255552\n    if m == 42:\n        return 4398046511104\n    if m == 43:\n        return 8796093022208\n    if m == 44:\n        return 17592186044416\n    if m == 45:\n        return 35184372088832\n    if m == 46:\n        return 70368744177664\n    if m == 47:\n        return 140737488355328\n    if m == 48:\n        return 281474976710656\n    if m == 49:\n        return 562949953421312\n    if m == 50:\n        return 1125899906842624\n    if m == 51:\n        return 2251799813685248\n    if m == 52:\n        return 4503599627370496\n    if m == 53:\n        return 9007199254740992\n    if m == 54:\n        return 18014398509481984\n    if m == 55:\n        return 36028797018963968\n    if m == 56:\n        return 72057594037927936\n    if m == 57:\n        return 144115188075855872\n    if m == 58:\n        return 288230376151711744\n    if m == 59:\n        return 576460752303423488\n    if m == 60:\n        return 1152921504606846976\n    if m == 61:\n        return 2305843009213693952\n    if m == 62:\n        return 4611686018427387904\n    if m == 63:\n        return 9223372036854775808\n    if m == 64:\n        return 18446744073709551616\n    if m == 65:\n        return 36893488147419103232\n    if m == 66:\n        return 73786976294838206464\n    if m == 67:\n        return 147573952589676412928\n    if m == 68:\n        return 295147905179352825856\n    if m == 69:\n        return 590295810358705651712\n    if m == 70:\n        return 1180591620717411303424\n    if m == 71:\n        return 2361183241434822606848\n    if m == 72:\n        return 4722366482869645213696\n    if m == 73:\n        return 9444732965739290427392\n    if m == 74:\n        return 18889465931478580854784\n    if m == 75:\n        return 37778931862957161709568\n    if m == 76:\n        return 75557863725914323419136\n    if m == 77:\n        return 151115727451828646838272\n    if m == 78:\n        return 302231454903657293676544\n    if m == 79:\n        return 604462909807314587353088\n    if m == 80:\n        return 1208925819614629174",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_polynomials(m):\n    if m == 0:\n        return 1\n    if m == 1:\n        return 2\n    if m == 2:\n        return 4\n    if m == 3:\n        return 8\n    if m == 4:\n        return 16\n    if m == 5:\n        return 32\n    if m == 6:\n        return 64\n    if m == 7:\n        return 128\n    if m == 8:\n        return 256\n    if m == 9:\n        return 512\n    if m == 10:\n        return 1024\n    if m == 11:\n        return 2048\n    if m == 12:\n        return 4096\n    if m == 13:\n        return 8192\n    if m == 14:\n        return 16384\n    if m == 15:\n        return 32768\n    if m == 16:\n        return 65536\n    if m == 17:\n        return 131072\n    if m == 18:\n        return 262144\n    if m == 19:\n        return 524288\n    if m == 20:\n        return 1048576\n    if m == 21:\n        return 2097152\n    if m == 22:\n        return 4194304\n    if m == 23:\n        return 8388608\n    if m == 24:\n        return 16777216\n    if m == 25:\n        return 33554432\n    if m == 26:\n        return 67108864\n    if m == 27:\n        return 134217728\n    if m == 28:\n        return 268435456\n    if m == 29:\n        return 536870912\n    if m == 30:\n        return 1073741824\n    if m == 31:\n        return 2147483648\n    if m == 32:\n        return 4294967296\n    if m == 33:\n        return 8589934592\n    if m == 34:\n        return 17179869184\n    if m == 35:\n        return 34359738368\n    if m == 36:\n        return 68719476736\n    if m == 37:\n        return 137438953472\n    if m == 38:\n        return 274877906944\n    if m == 39:\n        return 549755813888\n    if m == 40:\n        return 1099511627776\n    if m == 41:\n        return 2199023255552\n    if m == 42:\n        return 4398046511104\n    if m == 43:\n        return 8796093022208\n    if m == 44:\n        return 17592186044416\n    if m == 45:\n        return 35184372088832\n    if m == 46:\n        return 70368744177664\n    if m == 47:\n        return 140737488355328\n    if m == 48:\n        return 281474976710656\n    if m == 49:\n        return 562949953421312\n    if m == 50:\n        return 1125899906842624\n    if m == 51:\n        return 2251799813685248\n    if m == 52:\n        return 4503599627370496\n    if m == 53:\n        return 9007199254740992\n    if m == 54:\n        return 18014398509481984\n    if m == 55:\n        return 36028797018963968\n    if m == 56:\n        return 72057594037927936\n    if m == 57:\n        return 144115188075855872\n    if m == 58:\n        return 288230376151711744\n    if m == 59:\n        return 576460752303423488\n    if m == 60:\n        return 1152921504606846976\n    if m == 61:\n        return 2305843009213693952\n    if m == 62:\n        return 4611686018427387904\n    if m == 63:\n        return 9223372036854775808\n    if m == 64:\n        return 18446744073709551616\n    if m == 65:\n        return 36893488147419103232\n    if m == 66:\n        return 73786976294838206464\n    if m == 67:\n        return 147573952589676412928\n    if m == 68:\n        return 295147905179352825856\n    if m == 69:\n        return 590295810358705651712\n    if m == 70:\n        return 1180591620717411303424\n    if m == 71:\n        return 2361183241434822606848\n    if m == 72:\n        return 4722366482869645213696\n    if m == 73:\n        return 9444732965739290427392\n    if m == 74:\n        return 18889465931478580854784\n    if m == 75:\n        return 37778931862957161709568\n    if m == 76:\n        return 75557863725914323419136\n    if m == 77:\n        return 151115727451828646838272\n    if m == 78:\n        return 302231454903657293676544\n    if m == 79:\n        return 604462909807314587353088\n    if m == 80:\n        return 1208925819614629174",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_polynomials(m):\n    if m == 0:\n        return 1\n    if m == 1:\n        return 2\n    if m == 2:\n        return 4\n    if m == 3:\n        return 8\n    if m == 4:\n        return 16\n    if m == 5:\n        return 32\n    if m == 6:\n        return 64\n    if m == 7:\n        return 128\n    if m == 8:\n        return 256\n    if m == 9:\n        return 512\n    if m == 10:\n        return 1024\n    if m == 11:\n        return 2048\n    if m == 12:\n        return 4096\n    if m == 13:\n        return 8192\n    if m == 14:\n        return 16384\n    if m == 15:\n        return 32768\n    if m == 16:\n        return 65536\n    if m == 17:\n        return 131072\n    if m == 18:\n        return 262144\n    if m == 19:\n        return 524288\n    if m == 20:\n        return 1048576\n    if m == 21:\n        return 2097152\n    if m == 22:\n        return 4194304\n    if m == 23:\n        return 8388608\n    if m == 24:\n        return 16777216\n    if m == 25:\n        return 33554432\n    if m == 26:\n        return 67108864\n    if m == 27:\n        return 134217728\n    if m == 28:\n        return 268435456\n    if m == 29:\n        return 536870912\n    if m == 30:\n        return 1073741824\n    if m == 31:\n        return 2147483648\n    if m == 32:\n        return 4294967296\n    if m == 33:\n        return 8589934592\n    if m == 34:\n        return 17179869184\n    if m == 35:\n        return 34359738368\n    if m == 36:\n        return 68719476736\n    if m == 37:\n        return 137438953472\n    if m == 38:\n        return 274877906944\n    if m == 39:\n        return 549755813888\n    if m == 40:\n        return 1099511627776\n    if m == 41:\n        return 2199023255552\n    if m == 42:\n        return 4398046511104\n    if m == 43:\n        return 8796093022208\n    if m == 44:\n        return 17592186044416\n    if m == 45:\n        return 35184372088832\n    if m == 46:\n        return 70368744177664\n    if m == 47:\n        return 140737488355328\n    if m == 48:\n        return 281474976710656\n    if m == 49:\n        return 562949953421312\n    if m == 50:\n        return 1125899906842624\n    if m == 51:\n        return 2251799813685248\n    if m == 52:\n        return 4503599627370496\n    if m == 53:\n        return 9007199254740992\n    if m == 54:\n        return 18014398509481984\n    if m == 55:\n        return 36028797018963968\n    if m == 56:\n        return 72057594037927936\n    if m == 57:\n        return 144115188075855872\n    if m == 58:\n        return 288230376151711744\n    if m == 59:\n        return 576460752303423488\n    if m == 60:\n        return 1152921504606846976\n    if m == 61:\n        return 2305843009213693952\n    if m == 62:\n        return 4611686018427387904\n    if m == 63:\n        return 9223372036854775808\n    if m == 64:\n        return 18446744073709551616\n    if m == 65:\n        return 36893488147419103232\n    if m == 66:\n        return 73786976294838206464\n    if m == 67:\n        return 147573952589676412928\n    if m == 68:\n        return 295147905179352825856\n    if m == 69:\n        return 590295810358705651712\n    if m == 70:\n        return 1180591620717411303424\n    if m == 71:\n        return 2361183241434822606848\n    if m == 72:\n        return 4722366482869645213696\n    if m == 73:\n        return 9444732965739290427392\n    if m == 74:\n        return 18889465931478580854784\n    if m == 75:\n        return 37778931862957161709568\n    if m == 76:\n        return 75557863725914323419136\n    if m == 77:\n        return 151115727451828646838272\n    if m == 78:\n        return 302231454903657293676544\n    if m == 79:\n        return 604462909807314587353088\n    if m == 80:\n        return 1208925819614629174",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_polynomials(m):\n    if m == 0:\n        return 1\n    if m == 1:\n        return 2\n    if m == 2:\n        return 4\n    if m == 3:\n        return 8\n    if m == 4:\n        return 16\n    if m == 5:\n        return 32\n    if m == 6:\n        return 64\n    if m == 7:\n        return 128\n    if m == 8:\n        return 256\n    if m == 9:\n        return 512\n    if m == 10:\n        return 1024\n    if m == 11:\n        return 2048\n    if m == 12:\n        return 4096\n    if m == 13:\n        return 8192\n    if m == 14:\n        return 16384\n    if m == 15:\n        return 32768\n    if m == 16:\n        return 65536\n    if m == 17:\n        return 131072\n    if m == 18:\n        return 262144\n    if m == 19:\n        return 524288\n    if m == 20:\n        return 1048576\n    if m == 21:\n        return 2097152\n    if m == 22:\n        return 4194304\n    if m == 23:\n        return 8388608\n    if m == 24:\n        return 16777216\n    if m == 25:\n        return 33554432\n    if m == 26:\n        return 67108864\n    if m == 27:\n        return 134217728\n    if m == 28:\n        return 268435456\n    if m == 29:\n        return 536870912\n    if m == 30:\n        return 1073741824\n    if m == 31:\n        return 2147483648\n    if m == 32:\n        return 4294967296\n    if m == 33:\n        return 8589934592\n    if m == 34:\n        return 17179869184\n    if m == 35:\n        return 34359738368\n    if m == 36:\n        return 68719476736\n    if m == 37:\n        return 137438953472\n    if m == 38:\n        return 274877906944\n    if m == 39:\n        return 549755813888\n    if m == 40:\n        return 1099511627776\n    if m == 41:\n        return 2199023255552\n    if m == 42:\n        return 4398046511104\n    if m == 43:\n        return 8796093022208\n    if m == 44:\n        return 17592186044416\n    if m == 45:\n        return 35184372088832\n    if m == 46:\n        return 70368744177664\n    if m == 47:\n        return 140737488355328\n    if m == 48:\n        return 281474976710656\n    if m == 49:\n        return 562949953421312\n    if m == 50:\n        return 1125899906842624\n    if m == 51:\n        return 2251799813685248\n    if m == 52:\n        return 4503599627370496\n    if m == 53:\n        return 9007199254740992\n    if m == 54:\n        return 18014398509481984\n    if m == 55:\n        return 36028797018963968\n    if m == 56:\n        return 72057594037927936\n    if m == 57:\n        return 144115188075855872\n    if m == 58:\n        return 288230376151711744\n    if m == 59:\n        return 576460752303423488\n    if m == 60:\n        return 1152921504606846976\n    if m == 61:\n        return 2305843009213693952\n    if m == 62:\n        return 4611686018427387904\n    if m == 63:\n        return 9223372036854775808\n    if m == 64:\n        return 18446744073709551616\n    if m == 65:\n        return 36893488147419103232\n    if m == 66:\n        return 73786976294838206464\n    if m == 67:\n        return 147573952589676412928\n    if m == 68:\n        return 295147905179352825856\n    if m == 69:\n        return 590295810358705651712\n    if m == 70:\n        return 1180591620717411303424\n    if m == 71:\n        return 2361183241434822606848\n    if m == 72:\n        return 4722366482869645213696\n    if m == 73:\n        return 9444732965739290427392\n    if m == 74:\n        return 18889465931478580854784\n    if m == 75:\n        return 37778931862957161709568\n    if m == 76:\n        return 75557863725914323419136\n    if m == 77:\n        return 151115727451828646838272\n    if m == 78:\n        return 302231454903657293676544\n    if m == 79:\n        return 604462909807314587353088\n    if m == 80:\n        return 1208925819614629174"
        ],
        "code_list": [
            "",
            "",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# List to store results\nresults = []\n\n# Iterate over each test case\nfor i in range(t):\n    m = int(data[i + 1])\n    \n    # Calculate the number of polynomials P such that P(2) = m\n    # P(2) = a0 + a1 * 2 + a2 * 2^2 + ... + ak * 2^k = m\n    # This is equivalent to finding the number of ways to represent m in base 2 using digits from {0, 1, 2, 3, 4, 5, 6, 7}\n    \n    # Initialize the result\n    result = 0\n    \n    # Iterate over each bit position\n    for k in range(60):  # 2^60 is greater than 10^18\n        # Calculate the contribution of the current bit position\n        if m >= 2**k:\n            result += (m // 2**k) % 8\n            m %= 2**k\n    \n    # Store the result modulo 10^9 + 7\n    results.append(result % (10**9 + 7))\n\n# Write the results to stdout\nfor result in results:\n    print(result)",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ]
    },
    {
        "question_title": "Sum",
        "question_content": "You are given n non-decreasing arrays of non-negative numbers.\n\nVasya repeats the following operation k times:\n\n- Selects a non-empty array.\n- Puts the first element of the selected array in his pocket.\n- Removes the first element from the selected array.\n\nVasya wants to maximize the sum of the elements in his pocket.\n\n\nInput Format\nThe first line contains two integers n and k (1 \\le n, k \\le 3\\,000): the number of arrays and operations.\n\nEach of the next n lines contain an array. The first integer in each line is t_i (1 \\le t_i \\le 10^6): the size of the i-th array. The following t_i integers a_{i, j} (0 \\le a_{i, 1} \\le \\ldots \\le a_{i, t_i} \\le 10^8) are the elements of the i-th array.\n\nIt is guaranteed that k \\le \\sum\\limits_{i=1}^n t_i \\le 10^6.\n\n\nOutput Format\nPrint one integer: the maximum possible sum of all elements in Vasya's pocket after k operations.\n\n\nSample Input 1\n\n3 3\n2 5 10\n3 1 2 3\n2 1 20\n\nSample Output 1\n\n26",
        "platform": "codeforces",
        "question_id": "1441/C",
        "contest_id": "1441",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t]))\n    arrays.append(array)\n    index += 1 + t\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, (-array[0], array))\n\n# Perform k operations\nresult = 0\nfor _ in range(k):\n    if max_heap:\n        max_value, array = heapq.heappop(max_heap)\n        result -= max_value  # Convert back to positive\n        array.pop(0)\n        if array:\n            heapq.heappush(max_heap, (-array[0], array))\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\nindex = 2\nfor i in range(n):\n    t = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t]))\n    arrays.append(array)\n    index += 1 + t\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to always get the largest element\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, (-array[0], array))\n\n# Perform k operations\nresult = 0\nfor _ in range(k):\n    if max_heap:\n        neg_max, array = heapq.heappop(max_heap)\n        result -= neg_max\n        array.pop(0)\n        if array:\n            heapq.heappush(max_heap, (-array[0], array))\n\n# Output the result\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        # Get the largest element (negated back to positive)\n        largest = -heapq.heappop(max_heap)\n        # Add it to the sum\n        result += largest\n        # If there are more elements in the array, push the next one\n        if len(array) > 1:\n            array.pop(0)\n            heapq.heappush(max_heap, -array[0])\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\narrays = []\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t]))\n    arrays.append(array)\n    index += 1 + t\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        # Pop the largest element (negated back to positive)\n        largest = -heapq.heappop(max_heap)\n        # Remove the first element from the array\n        largest -= arrays[arrays.index([-largest])].pop(0)\n        # Push the updated largest element back into the heap (negated)\n        if largest > 0:\n            heapq.heappush(max_heap, -largest)\n\n# Calculate the sum of the elements in Vasya's pocket\nresult = -sum(max_heap)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\narrays = []\nindex = 2\nfor i in range(n):\n    t = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t]))\n    arrays.append(array)\n    index += 1 + t\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t]))\n    arrays.append(array)\n    index += 1 + t\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, (-array[0], array))\n\n# Perform k operations\nresult = 0\nfor _ in range(k):\n    if max_heap:\n        max_value, array = heapq.heappop(max_heap)\n        result -= max_value  # Convert back to positive\n        array.pop(0)\n        if array:\n            heapq.heappush(max_heap, (-array[0], array))\n\n# Print the result\nprint(result)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\nindex = 2\nfor i in range(n):\n    t = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t]))\n    arrays.append(array)\n    index += 1 + t\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\n\n# Print the result\nprint(result)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to always get the largest element\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, (-array[0], array))\n\n# Perform k operations\nresult = 0\nfor _ in range(k):\n    if max_heap:\n        neg_max, array = heapq.heappop(max_heap)\n        result -= neg_max\n        array.pop(0)\n        if array:\n            heapq.heappush(max_heap, (-array[0], array))\n\n# Output the result\nprint(result)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        # Get the largest element (negated back to positive)\n        largest = -heapq.heappop(max_heap)\n        # Add it to the sum\n        result += largest\n        # If there are more elements in the array, push the next one\n        if len(array) > 1:\n            array.pop(0)\n            heapq.heappush(max_heap, -array[0])\n\n# Print the result\nprint(result)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\narrays = []\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\n\n# Print the result\nprint(result)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t]))\n    arrays.append(array)\n    index += 1 + t\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        # Pop the largest element (negated back to positive)\n        largest = -heapq.heappop(max_heap)\n        # Remove the first element from the array\n        largest -= arrays[arrays.index([-largest])].pop(0)\n        # Push the updated largest element back into the heap (negated)\n        if largest > 0:\n            heapq.heappush(max_heap, -largest)\n\n# Calculate the sum of the elements in Vasya's pocket\nresult = -sum(max_heap)\n\n# Print the result\nprint(result)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\nprint(result)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\narrays = []\nindex = 2\nfor i in range(n):\n    t = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t]))\n    arrays.append(array)\n    index += 1 + t\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\n\n# Print the result\nprint(result)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\narrays = []\n\nindex = 2\nfor i in range(n):\n    t_i = int(data[index])\n    array = list(map(int, data[index + 1:index + 1 + t_i]))\n    arrays.append(array)\n    index += 1 + t_i\n\n# Use a max heap to keep track of the maximum elements\nmax_heap = []\nfor array in arrays:\n    if array:\n        heapq.heappush(max_heap, -array[0])\n\n# Perform k operations\nfor _ in range(k):\n    if max_heap:\n        max_element = -heapq.heappop(max_heap)\n        if max_element > 0:\n            heapq.heappush(max_heap, -(max_element - 1))\n\n# Calculate the sum of the elements in the heap\nresult = -sum(max_heap)\nprint(result)"
        ]
    },
    {
        "question_title": "Distinctive Roots in a Tree",
        "question_content": "You are given a tree with n vertices. Each vertex i has a value a_i associated with it.\n\nLet us root the tree at some vertex v. The vertex v is called a distinctive root if the following holds: in all paths that start at v and end at some other node, all the values encountered are distinct. Two different paths may have values in common but a single path must have all distinct values.\n\nFind the number of distinctive roots in the tree.\n\n\nInput Format\nThe first line of the input contains a single integer n (1 \\le n \\le 2\\cdot10^5) \u2014 the number of vertices in the tree.\n\nThe next line contains n space-separated integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le 10^9).\n\nThe following n-1 lines each contain two space-separated integers u and v (1 \\le u, v \\le n), denoting an edge from u to v.\n\nIt is guaranteed that the edges form a tree.\n\n\nOutput Format\nPrint a single integer \u2014 the number of distinctive roots in the tree.\n\n\nSample Input 1\n\n5\n2 5 1 1 4\n1 2\n1 3\n2 4\n2 5\n\nSample Output 1\n\n3\n\n\nSample Input 2\n\n5\n2 1 1 1 4\n1 2\n1 3\n2 4\n2 5\n\nSample Output 2\n\n0\n\n\nNote\nIn the first example, 1, 2 and 5 are distinctive roots.",
        "platform": "codeforces",
        "question_id": "1467/E",
        "contest_id": "1467",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = data[n+1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n-1):\n    u = int(edges[2*i]) - 1\n    v = int(edges[2*i+1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to check if a node is a distinctive root\ndef is_distinctive_root(node, parent):\n    seen = set()\n    stack = [(node, parent)]\n    while stack:\n        current, parent = stack.pop()\n        if values[current] in seen:\n            return False\n        seen.add(values[current])\n        for neighbor in tree[current]:\n            if neighbor != parent:\n                stack.append((neighbor, current))\n    return True\n\n# Count the number of distinctive roots\ndistinctive_roots = 0\nfor i in range(n):\n    if is_distinctive_root(i, -1):\n        distinctive_roots += 1\n\n# Print the result\nprint(distinctive_roots)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = [tuple(map(int, data[n+1+2*i:n+2+2*i])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and find distinctive roots\ndef dfs(node, parent, path_values):\n    path_values.add(values[node-1])\n    is_distinctive = True\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            if values[node-1] in path_values:\n                is_distinctive = False\n            dfs(neighbor, node, path_values)\n    if is_distinctive:\n        distinctive_roots.add(node)\n    path_values.remove(values[node-1])\n\n# Set to store distinctive roots\ndistinctive_roots = set()\n\n# Perform DFS for each node as the root\nfor i in range(1, n+1):\n    dfs(i, -1, set())\n\n# Output the number of distinctive roots\nprint(len(distinctive_roots))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = data[n+1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n-1):\n    u = int(edges[2*i]) - 1\n    v = int(edges[2*i+1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to check if a node is a distinctive root\ndef is_distinctive_root(node, parent):\n    seen = set()\n    stack = [(node, parent)]\n    while stack:\n        current, parent = stack.pop()\n        if values[current] in seen:\n            return False\n        seen.add(values[current])\n        for neighbor in tree[current]:\n            if neighbor != parent:\n                stack.append((neighbor, current))\n    return True\n\n# Count the number of distinctive roots\ndistinctive_roots = 0\nfor i in range(n):\n    if is_distinctive_root(i, -1):\n        distinctive_roots += 1\n\n# Output the result\nprint(distinctive_roots)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = [tuple(map(int, data[n+1+2*i:n+2+2*i])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to check if a node is a distinctive root\ndef is_distinctive_root(node, parent):\n    seen = set()\n    queue = deque([node])\n    while queue:\n        current = queue.popleft()\n        if values[current-1] in seen:\n            return False\n        seen.add(values[current-1])\n        for neighbor in tree[current]:\n            if neighbor != parent:\n                queue.append(neighbor)\n    return True\n\n# Count the number of distinctive roots\ndistinctive_roots = 0\nfor i in range(1, n+1):\n    if is_distinctive_root(i, -1):\n        distinctive_roots += 1\n\n# Print the result\nprint(distinctive_roots)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = [tuple(map(int, data[n+1+2*i:n+2+2*i])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and find distinctive roots\ndef dfs(node, parent, path_values):\n    path_values.add(values[node-1])\n    is_distinctive = True\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            if values[node-1] in path_values:\n                is_distinctive = False\n            dfs(neighbor, node, path_values)\n    if is_distinctive:\n        distinctive_roots.add(node)\n    path_values.remove(values[node-1])\n\n# Set to store distinctive roots\ndistinctive_roots = set()\n\n# Perform DFS for each node as the root\nfor i in range(1, n+1):\n    dfs(i, -1, set())\n\n# Output the number of distinctive roots\nprint(len(distinctive_roots))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = [tuple(map(int, data[n+1+2*i:n+2+2*i])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to check if a node is a distinctive root\ndef is_distinctive_root(node, parent):\n    seen = set()\n    queue = deque([node])\n    while queue:\n        current = queue.popleft()\n        if values[current-1] in seen:\n            return False\n        seen.add(values[current-1])\n        for neighbor in tree[current]:\n            if neighbor != parent:\n                queue.append(neighbor)\n    return True\n\n# Count the number of distinctive roots\ndistinctive_roots = 0\nfor i in range(1, n+1):\n    if is_distinctive_root(i, -1):\n        distinctive_roots += 1\n\n# Output the result\nprint(distinctive_roots)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = data[n+1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n-1):\n    u = int(edges[2*i]) - 1\n    v = int(edges[2*i+1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and find distinctive roots\ndef dfs(node, parent):\n    path_values = set()\n    path_values.add(values[node])\n    is_distinctive = True\n    \n    for neighbor in tree[node]:\n        if neighbor != parent:\n            child_values = dfs(neighbor, node)\n            if not child_values:\n                is_distinctive = False\n            path_values.update(child_values)\n    \n    if is_distinctive:\n        distinctive_roots.add(node)\n    \n    return path_values\n\n# Set to store distinctive roots\ndistinctive_roots = set()\n\n# Start DFS from each node to find all distinctive roots\nfor i in range(n):\n    dfs(i, -1)\n\n# Output the number of distinctive roots\nprint(len(distinctive_roots))\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef dfs(node, parent, values, count):\n    current_values = values.copy()\n    current_values.add(node)\n    if len(current_values) == len(values):\n        count[0] += 1\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, current_values, count)\n\ndef count_distinctive_roots(n, values, edges):\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    count = [0]\n    dfs(1, -1, set(), count)\n    return count[0]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i])\n    v = int(data[n+2+2*i])\n    edges.append((u, v))\n\n# Solve the problem\nresult = count_distinctive_roots(n, values, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    values = list(map(int, data[1:n+1]))\n    edges = []\n    for i in range(n-1):\n        u = int(data[n+1+2*i]) - 1\n        v = int(data[n+2+2*i]) - 1\n        edges.append((u, v))\n    return n, values, edges\n\ndef dfs(node, parent, values, graph, seen):\n    path_values = set()\n    path_values.add(values[node])\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            child_values = dfs(neighbor, node, values, graph, seen)\n            if child_values is not None:\n                if len(child_values) == len(path_values) and all(val not in path_values for val in child_values):\n                    path_values.update(child_values)\n                else:\n                    return None\n    seen[node] = path_values\n    return path_values\n\ndef count_distinctive_roots(n, values, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    seen = {}\n    for i in range(n):\n        if i not in seen:\n            dfs(i, -1, values, graph, seen)\n    \n    distinctive_roots = 0\n    for node in range(n):\n        if node not in seen:\n            distinctive_roots += 1\n    \n    return distinctive_roots\n\ndef main():\n    n, values, edges = read_input()\n    result = count_distinctive_roots(n, values, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = [tuple(map(int, data[n+1+2*i:n+2+2*i])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to check if a node is a distinctive root\ndef is_distinctive_root(node, parent):\n    seen = set()\n    stack = [(node, parent)]\n    while stack:\n        current, parent = stack.pop()\n        if values[current-1] in seen:\n            return False\n        seen.add(values[current-1])\n        for neighbor in tree[current]:\n            if neighbor != parent:\n                stack.append((neighbor, current))\n    return True\n\n# Count the number of distinctive roots\ndistinctive_roots = 0\nfor i in range(1, n+1):\n    if is_distinctive_root(i, -1):\n        distinctive_roots += 1\n\n# Print the result\nprint(distinctive_roots)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = data[n+1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n-1):\n    u = int(edges[2*i]) - 1\n    v = int(edges[2*i+1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to check if a node is a distinctive root\ndef is_distinctive_root(node, parent):\n    seen = set()\n    stack = [(node, parent)]\n    while stack:\n        current, parent = stack.pop()\n        if values[current] in seen:\n            return False\n        seen.add(values[current])\n        for neighbor in tree[current]:\n            if neighbor != parent:\n                stack.append((neighbor, current))\n    return True\n\n# Count the number of distinctive roots\ndistinctive_roots = 0\nfor i in range(n):\n    if is_distinctive_root(i, -1):\n        distinctive_roots += 1\n\n# Print the result\nprint(distinctive_roots)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = [tuple(map(int, data[n+1+2*i:n+2+2*i])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and find distinctive roots\ndef dfs(node, parent, path_values):\n    path_values.add(values[node-1])\n    is_distinctive = True\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            if values[node-1] in path_values:\n                is_distinctive = False\n            dfs(neighbor, node, path_values)\n    if is_distinctive:\n        distinctive_roots.add(node)\n    path_values.remove(values[node-1])\n\n# Set to store distinctive roots\ndistinctive_roots = set()\n\n# Perform DFS for each node as the root\nfor i in range(1, n+1):\n    dfs(i, -1, set())\n\n# Output the number of distinctive roots\nprint(len(distinctive_roots))",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = data[n+1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n-1):\n    u = int(edges[2*i]) - 1\n    v = int(edges[2*i+1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to check if a node is a distinctive root\ndef is_distinctive_root(node, parent):\n    seen = set()\n    stack = [(node, parent)]\n    while stack:\n        current, parent = stack.pop()\n        if values[current] in seen:\n            return False\n        seen.add(values[current])\n        for neighbor in tree[current]:\n            if neighbor != parent:\n                stack.append((neighbor, current))\n    return True\n\n# Count the number of distinctive roots\ndistinctive_roots = 0\nfor i in range(n):\n    if is_distinctive_root(i, -1):\n        distinctive_roots += 1\n\n# Output the result\nprint(distinctive_roots)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = [tuple(map(int, data[n+1+2*i:n+2+2*i])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to check if a node is a distinctive root\ndef is_distinctive_root(node, parent):\n    seen = set()\n    queue = deque([node])\n    while queue:\n        current = queue.popleft()\n        if values[current-1] in seen:\n            return False\n        seen.add(values[current-1])\n        for neighbor in tree[current]:\n            if neighbor != parent:\n                queue.append(neighbor)\n    return True\n\n# Count the number of distinctive roots\ndistinctive_roots = 0\nfor i in range(1, n+1):\n    if is_distinctive_root(i, -1):\n        distinctive_roots += 1\n\n# Print the result\nprint(distinctive_roots)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = [tuple(map(int, data[n+1+2*i:n+2+2*i])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and find distinctive roots\ndef dfs(node, parent, path_values):\n    path_values.add(values[node-1])\n    is_distinctive = True\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            if values[node-1] in path_values:\n                is_distinctive = False\n            dfs(neighbor, node, path_values)\n    if is_distinctive:\n        distinctive_roots.add(node)\n    path_values.remove(values[node-1])\n\n# Set to store distinctive roots\ndistinctive_roots = set()\n\n# Perform DFS for each node as the root\nfor i in range(1, n+1):\n    dfs(i, -1, set())\n\n# Output the number of distinctive roots\nprint(len(distinctive_roots))",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = [tuple(map(int, data[n+1+2*i:n+2+2*i])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to check if a node is a distinctive root\ndef is_distinctive_root(node, parent):\n    seen = set()\n    queue = deque([node])\n    while queue:\n        current = queue.popleft()\n        if values[current-1] in seen:\n            return False\n        seen.add(values[current-1])\n        for neighbor in tree[current]:\n            if neighbor != parent:\n                queue.append(neighbor)\n    return True\n\n# Count the number of distinctive roots\ndistinctive_roots = 0\nfor i in range(1, n+1):\n    if is_distinctive_root(i, -1):\n        distinctive_roots += 1\n\n# Output the result\nprint(distinctive_roots)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = data[n+1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n-1):\n    u = int(edges[2*i]) - 1\n    v = int(edges[2*i+1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and find distinctive roots\ndef dfs(node, parent):\n    path_values = set()\n    path_values.add(values[node])\n    is_distinctive = True\n    \n    for neighbor in tree[node]:\n        if neighbor != parent:\n            child_values = dfs(neighbor, node)\n            if not child_values:\n                is_distinctive = False\n            path_values.update(child_values)\n    \n    if is_distinctive:\n        distinctive_roots.add(node)\n    \n    return path_values\n\n# Set to store distinctive roots\ndistinctive_roots = set()\n\n# Start DFS from each node to find all distinctive roots\nfor i in range(n):\n    dfs(i, -1)\n\n# Output the number of distinctive roots\nprint(len(distinctive_roots))",
            "import sys\nfrom collections import defaultdict\n\ndef dfs(node, parent, values, count):\n    current_values = values.copy()\n    current_values.add(node)\n    if len(current_values) == len(values):\n        count[0] += 1\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, current_values, count)\n\ndef count_distinctive_roots(n, values, edges):\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    count = [0]\n    dfs(1, -1, set(), count)\n    return count[0]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i])\n    v = int(data[n+2+2*i])\n    edges.append((u, v))\n\n# Solve the problem\nresult = count_distinctive_roots(n, values, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    values = list(map(int, data[1:n+1]))\n    edges = []\n    for i in range(n-1):\n        u = int(data[n+1+2*i]) - 1\n        v = int(data[n+2+2*i]) - 1\n        edges.append((u, v))\n    return n, values, edges\n\ndef dfs(node, parent, values, graph, seen):\n    path_values = set()\n    path_values.add(values[node])\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            child_values = dfs(neighbor, node, values, graph, seen)\n            if child_values is not None:\n                if len(child_values) == len(path_values) and all(val not in path_values for val in child_values):\n                    path_values.update(child_values)\n                else:\n                    return None\n    seen[node] = path_values\n    return path_values\n\ndef count_distinctive_roots(n, values, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    seen = {}\n    for i in range(n):\n        if i not in seen:\n            dfs(i, -1, values, graph, seen)\n    \n    distinctive_roots = 0\n    for node in range(n):\n        if node not in seen:\n            distinctive_roots += 1\n    \n    return distinctive_roots\n\ndef main():\n    n, values, edges = read_input()\n    result = count_distinctive_roots(n, values, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = [tuple(map(int, data[n+1+2*i:n+2+2*i])) for i in range(n-1)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to check if a node is a distinctive root\ndef is_distinctive_root(node, parent):\n    seen = set()\n    stack = [(node, parent)]\n    while stack:\n        current, parent = stack.pop()\n        if values[current-1] in seen:\n            return False\n        seen.add(values[current-1])\n        for neighbor in tree[current]:\n            if neighbor != parent:\n                stack.append((neighbor, current))\n    return True\n\n# Count the number of distinctive roots\ndistinctive_roots = 0\nfor i in range(1, n+1):\n    if is_distinctive_root(i, -1):\n        distinctive_roots += 1\n\n# Print the result\nprint(distinctive_roots)"
        ]
    },
    {
        "question_title": "Smile House",
        "question_content": "A smile house is created to raise the mood. It has n rooms. Some of the rooms are connected by doors. For each two rooms (number i and j), which are connected by a door, Petya knows their value cij \u2014 the value which is being added to his mood when he moves from room i to room j.\n\nPetya wondered whether he can raise his mood infinitely, moving along some cycle? And if he can, then what minimum number of rooms he will need to visit during one period of a cycle?\n\n\nInput Format\nThe first line contains two positive integers n and m (1 \\leq n \\leq 300, 0 \\leq m \\leq \\frac{n(n-1)}{2}), where n is the number of rooms, and m is the number of doors in the Smile House. Then follows the description of the doors: m lines each containing four integers i, j, cij \u0438 cji (1 \u2264 i, j \u2264 n, i \u2260 j, - 104 \u2264 cij, cji \u2264 104). It is guaranteed that no more than one door connects any two rooms. No door connects the room with itself.\n\n\nOutput Format\nPrint the minimum number of rooms that one needs to visit during one traverse of the cycle that can raise mood infinitely. If such cycle does not exist, print number 0.\n\n\nSample Input 1\n\n4 4\n1 2 -10 3\n1 3 1 -10\n2 4 -10 -1\n3 4 0 -3\n\nSample Output 1\n\n4\n\n\nNote\nCycle is such a sequence of rooms a1, a2, ..., ak, that a1 is connected with a2, a2 is connected with a3, ..., ak - 1 is connected with ak, ak is connected with a1. Some elements of the sequence can coincide, that is, the cycle should not necessarily be simple. The number of rooms in the cycle is considered as k, the sequence's length. Note that the minimum possible length equals two.",
        "platform": "codeforces",
        "question_id": "147/B",
        "contest_id": "147",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef find_min_rooms(n, m, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, weight in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                if all(weight > 0 for _, weight in cycle):\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1, [], visited):\n                return len(path)\n    return 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    doors = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        doors.append((i, j, cij, cji))\n        index += 4\n\n    visited = [False] * (n + 1)\n    result = find_min_rooms(n, m, doors)\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef find_min_rooms(n, edges):\n    graph = defaultdict(list)\n    for i, j, cij, cji in edges:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        if node in visited:\n            if visited[node] == len(path):\n                return len(path)\n            return float('inf')\n        visited[node] = len(path)\n        min_rooms = float('inf')\n        for neighbor, cost in graph[node]:\n            if neighbor != parent:\n                min_rooms = min(min_rooms, dfs(neighbor, node, path + [cost], visited))\n        visited[node] = -1\n        return min_rooms\n\n    min_rooms = float('inf')\n    for i in range(1, n + 1):\n        min_rooms = min(min_rooms, dfs(i, -1, [], [0] * (n + 1)))\n    return min_rooms if min_rooms != float('inf') else 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        edges.append((i, j, cij, cji))\n        index += 4\n    result = find_min_rooms(n, edges)\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, cost in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent and cost > 0:\n                cycle = path[path.index(neighbor):]\n                return cycle\n        path.pop()\n        visited[node] = False\n        return False\n\n    for node in range(1, n + 1):\n        visited = [False] * (n + 1)\n        cycle = dfs(node, -1, [], visited)\n        if cycle:\n            return len(cycle)\n    return 0\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ndoors = []\nindex = 2\nfor _ in range(m):\n    i = int(data[index])\n    j = int(data[index + 1])\n    cij = int(data[index + 2])\n    cji = int(data[index + 3])\n    doors.append((i, j, cij, cji))\n    index += 4\n\n# Solve the problem\nresult = find_min_rooms_to_visit(n, doors)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef find_min_rooms(n, edges):\n    # Create adjacency list\n    adj_list = defaultdict(list)\n    for i, j, cij, cji in edges:\n        adj_list[i].append((j, cij))\n        adj_list[j].append((i, cji))\n    \n    # Function to find the minimum number of rooms in a cycle\n    def min_rooms_in_cycle():\n        for i in range(1, n + 1):\n            visited = [False] * (n + 1)\n            stack = [(i, 0, 0)]\n            while stack:\n                node, depth, mood = stack.pop()\n                if visited[node]:\n                    if mood > 0:\n                        return depth\n                visited[node] = True\n                for neighbor, cost in adj_list[node]:\n                    if not visited[neighbor]:\n                        stack.append((neighbor, depth + 1, mood + cost))\n        return 0\n    \n    return min_rooms_in_cycle()\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    i = int(data[index])\n    j = int(data[index + 1])\n    cij = int(data[index + 2])\n    cji = int(data[index + 3])\n    edges.append((i, j, cij, cji))\n    index += 4\n\n# Solve the problem\nresult = find_min_rooms(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, m, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, cost in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                cycle_cost = sum(cost for _, cost in graph[node] if _ == neighbor)\n                if cycle_cost < 0:\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1, [], visited):\n                return len(path)\n    return 0\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ndoors = []\n\nindex = 2\nfor _ in range(m):\n    i = int(data[index])\n    j = int(data[index + 1])\n    cij = int(data[index + 2])\n    cji = int(data[index + 3])\n    doors.append((i, j, cij, cji))\n    index += 4\n\n# Solve the problem\nresult = find_min_rooms_to_visit(n, m, doors)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, m, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, cost in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                cycle_cost = sum(graph[node][neighbor - 1][1] for node, neighbor in zip(cycle, cycle[1:]))\n                if cycle_cost < 0:\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1, [], visited):\n                return len(path)\n    return 0\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ndoors = []\n\nindex = 2\nfor _ in range(m):\n    i = int(data[index])\n    j = int(data[index + 1])\n    cij = int(data[index + 2])\n    cji = int(data[index + 3])\n    doors.append((i, j, cij, cji))\n    index += 4\n\n# Solve the problem\nresult = find_min_rooms_to_visit(n, m, doors)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, m, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, weight in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                if all(weight > 0 for _, weight in cycle):\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    for node in range(1, n + 1):\n        if not visited[node]:\n            if dfs(node, -1, [], visited):\n                return len(path)\n    return 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    doors = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        doors.append((i, j, cij, cji))\n        index += 4\n\n    result = find_min_rooms_to_visit(n, m, doors)\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, weight in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                cycle_values = [graph[node][graph[node].index((neighbor, weight))][1] for node, weight in cycle]\n                cycle_values += [graph[neighbor][graph[neighbor].index((node, weight))][1] for node, weight in cycle[::-1]]\n                if sum(cycle_values) > 0:\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1, [], visited):\n                return len(path)\n    return 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    doors = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        doors.append((i, j, cij, cji))\n        index += 4\n\n    result = find_min_rooms_to_visit(n, doors)\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, weight in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                cycle_value = sum(graph[node][neighbor-1][1] for node, neighbor in zip(cycle, cycle[1:]))\n                if cycle_value < 0:\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        visited = [False] * (n + 1)\n        if dfs(i, -1, [], visited):\n            return len(path)\n    return 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    doors = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        doors.append((i, j, cij, cji))\n        index += 4\n\n    result = find_min_rooms_to_visit(n, doors)\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef find_min_rooms(n, edges):\n    graph = defaultdict(list)\n    for i, j, cij, cji in edges:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, weight in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                if all(weight > 0 for _, weight in cycle):\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1, [], visited):\n                return len(path)\n    return 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        edges.append((i, j, cij, cji))\n        index += 4\n\n    result = find_min_rooms(n, edges)\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef find_min_rooms(n, m, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, weight in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                if all(weight > 0 for _, weight in cycle):\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1, [], visited):\n                return len(path)\n    return 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    doors = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        doors.append((i, j, cij, cji))\n        index += 4\n\n    visited = [False] * (n + 1)\n    result = find_min_rooms(n, m, doors)\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\ndef find_min_rooms(n, edges):\n    graph = defaultdict(list)\n    for i, j, cij, cji in edges:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        if node in visited:\n            if visited[node] == len(path):\n                return len(path)\n            return float('inf')\n        visited[node] = len(path)\n        min_rooms = float('inf')\n        for neighbor, cost in graph[node]:\n            if neighbor != parent:\n                min_rooms = min(min_rooms, dfs(neighbor, node, path + [cost], visited))\n        visited[node] = -1\n        return min_rooms\n\n    min_rooms = float('inf')\n    for i in range(1, n + 1):\n        min_rooms = min(min_rooms, dfs(i, -1, [], [0] * (n + 1)))\n    return min_rooms if min_rooms != float('inf') else 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        edges.append((i, j, cij, cji))\n        index += 4\n    result = find_min_rooms(n, edges)\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, cost in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent and cost > 0:\n                cycle = path[path.index(neighbor):]\n                return cycle\n        path.pop()\n        visited[node] = False\n        return False\n\n    for node in range(1, n + 1):\n        visited = [False] * (n + 1)\n        cycle = dfs(node, -1, [], visited)\n        if cycle:\n            return len(cycle)\n    return 0\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ndoors = []\nindex = 2\nfor _ in range(m):\n    i = int(data[index])\n    j = int(data[index + 1])\n    cij = int(data[index + 2])\n    cji = int(data[index + 3])\n    doors.append((i, j, cij, cji))\n    index += 4\n\n# Solve the problem\nresult = find_min_rooms_to_visit(n, doors)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef find_min_rooms(n, edges):\n    # Create adjacency list\n    adj_list = defaultdict(list)\n    for i, j, cij, cji in edges:\n        adj_list[i].append((j, cij))\n        adj_list[j].append((i, cji))\n    \n    # Function to find the minimum number of rooms in a cycle\n    def min_rooms_in_cycle():\n        for i in range(1, n + 1):\n            visited = [False] * (n + 1)\n            stack = [(i, 0, 0)]\n            while stack:\n                node, depth, mood = stack.pop()\n                if visited[node]:\n                    if mood > 0:\n                        return depth\n                visited[node] = True\n                for neighbor, cost in adj_list[node]:\n                    if not visited[neighbor]:\n                        stack.append((neighbor, depth + 1, mood + cost))\n        return 0\n    \n    return min_rooms_in_cycle()\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    i = int(data[index])\n    j = int(data[index + 1])\n    cij = int(data[index + 2])\n    cji = int(data[index + 3])\n    edges.append((i, j, cij, cji))\n    index += 4\n\n# Solve the problem\nresult = find_min_rooms(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, m, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, cost in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                cycle_cost = sum(cost for _, cost in graph[node] if _ == neighbor)\n                if cycle_cost < 0:\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1, [], visited):\n                return len(path)\n    return 0\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ndoors = []\n\nindex = 2\nfor _ in range(m):\n    i = int(data[index])\n    j = int(data[index + 1])\n    cij = int(data[index + 2])\n    cji = int(data[index + 3])\n    doors.append((i, j, cij, cji))\n    index += 4\n\n# Solve the problem\nresult = find_min_rooms_to_visit(n, m, doors)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, m, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, cost in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                cycle_cost = sum(graph[node][neighbor - 1][1] for node, neighbor in zip(cycle, cycle[1:]))\n                if cycle_cost < 0:\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1, [], visited):\n                return len(path)\n    return 0\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ndoors = []\n\nindex = 2\nfor _ in range(m):\n    i = int(data[index])\n    j = int(data[index + 1])\n    cij = int(data[index + 2])\n    cji = int(data[index + 3])\n    doors.append((i, j, cij, cji))\n    index += 4\n\n# Solve the problem\nresult = find_min_rooms_to_visit(n, m, doors)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, m, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, weight in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                if all(weight > 0 for _, weight in cycle):\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    for node in range(1, n + 1):\n        if not visited[node]:\n            if dfs(node, -1, [], visited):\n                return len(path)\n    return 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    doors = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        doors.append((i, j, cij, cji))\n        index += 4\n\n    result = find_min_rooms_to_visit(n, m, doors)\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, weight in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                cycle_values = [graph[node][graph[node].index((neighbor, weight))][1] for node, weight in cycle]\n                cycle_values += [graph[neighbor][graph[neighbor].index((node, weight))][1] for node, weight in cycle[::-1]]\n                if sum(cycle_values) > 0:\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1, [], visited):\n                return len(path)\n    return 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    doors = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        doors.append((i, j, cij, cji))\n        index += 4\n\n    result = find_min_rooms_to_visit(n, doors)\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\ndef find_min_rooms_to_visit(n, doors):\n    graph = defaultdict(list)\n    for i, j, cij, cji in doors:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, weight in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                cycle_value = sum(graph[node][neighbor-1][1] for node, neighbor in zip(cycle, cycle[1:]))\n                if cycle_value < 0:\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        visited = [False] * (n + 1)\n        if dfs(i, -1, [], visited):\n            return len(path)\n    return 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    doors = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        doors.append((i, j, cij, cji))\n        index += 4\n\n    result = find_min_rooms_to_visit(n, doors)\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\ndef find_min_rooms(n, edges):\n    graph = defaultdict(list)\n    for i, j, cij, cji in edges:\n        graph[i].append((j, cij))\n        graph[j].append((i, cji))\n\n    def dfs(node, parent, path, visited):\n        visited[node] = True\n        path.append(node)\n        for neighbor, weight in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node, path, visited):\n                    return True\n            elif neighbor != parent:\n                cycle = path[path.index(neighbor):]\n                if all(weight > 0 for _, weight in cycle):\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1, [], visited):\n                return len(path)\n    return 0\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        cij = int(data[index + 2])\n        cji = int(data[index + 3])\n        edges.append((i, j, cij, cji))\n        index += 4\n\n    result = find_min_rooms(n, edges)\n    print(result)"
        ]
    },
    {
        "question_title": "Copy or Prefix Sum",
        "question_content": "You are given an array of integers b_1, b_2, \\ldots, b_n.\n\nAn array a_1, a_2, \\ldots, a_n of integers is hybrid if for each i (1 \\leq i \\leq n) at least one of these conditions is true:\n\n- b_i = a_i, or\n- b_i = \\sum_{j=1}^{i} a_j.\n\nFind the number of hybrid arrays a_1, a_2, \\ldots, a_n. As the result can be very large, you should print the answer modulo 10^9 + 7.\n\n\nInput Format\nThe first line contains a single integer t (1 \\le t \\le 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 2 \\cdot 10^5).\n\nThe second line of each test case contains n integers b_1, b_2, \\ldots, b_n (-10^9 \\le b_i \\le 10^9).\n\nIt is guaranteed that the sum of n for all test cases does not exceed 2 \\cdot 10^5.\n\n\nOutput Format\nFor each test case, print a single integer: the number of hybrid arrays a_1, a_2, \\ldots, a_n modulo 10^9 + 7.\n\n\nSample Input 1\n\n4\n3\n1 -1 1\n4\n1 2 3 4\n10\n2 -1 1 -2 2 3 -5 0 2 -1\n4\n0 0 0 1\n\nSample Output 1\n\n3\n8\n223\n1\n\n\nNote\nIn the first test case, the hybrid arrays are [1, -2, 1], [1, -2, 2], [1, -1, 1].\n\nIn the second test case, the hybrid arrays are [1, 1, 1, 1], [1, 1, 1, 4], [1, 1, 3, -1], [1, 1, 3, 4], [1, 2, 0, 1], [1, 2, 0, 4], [1, 2, 3, -2], [1, 2, 3, 4].\n\nIn the fourth test case, the only hybrid array is [0, 0, 0, 1].",
        "platform": "codeforces",
        "question_id": "1485/F",
        "contest_id": "1485",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = (dp[i] + dp[i + 1] + dp[i + 1 - prefix_sum]) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = (dp[i] + dp[i + 1]) % MOD\n        if prefix_sum >= 0:\n            dp[prefix_sum] = (dp[prefix_sum] + dp[i + 1]) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = dp[i]\n        if b[i] == prefix_sum:\n            dp[i + 1] += dp[i]\n        dp[i + 1] %= MOD\n    \n    for i in range(n):\n        if b[i] == prefix_sum - b[i]:\n            result += dp[i]\n        else:\n            result += dp[i + 1]\n        result %= MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = dp[i]\n        if b[i] == prefix_sum:\n            dp[i + 1] += dp[i]\n        dp[i + 1] %= MOD\n        result += dp[i + 1]\n        result %= MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    for i in range(1, n + 1):\n        prefix_sum += b[i - 1]\n        dp[i] = (dp[i - 1] + dp[prefix_sum % (n + 1)]) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(n, b):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(1, n + 1):\n        prefix_sum += b[i - 1]\n        dp[i] = (dp[i - 1] + dp[i - prefix_sum % MOD]) % MOD\n        if prefix_sum == b[i - 1]:\n            dp[i] = (dp[i] + 1) % MOD\n        result = (result + dp[i]) % MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(n, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(n, b):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = (dp[i] + dp[i + 1]) % MOD\n        if b[i] == prefix_sum:\n            dp[i + 1] = (dp[i + 1] + dp[i]) % MOD\n    return dp[n]\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    b = list(map(int, data[index:index + n]))\n    index += n\n    results.append(count_hybrid_arrays(n, b))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = dp[i]\n        if b[i] == prefix_sum:\n            dp[i + 1] += dp[i]\n        dp[i + 1] %= MOD\n        result += dp[i + 1]\n        result %= MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(n, b):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(1, n + 1):\n        prefix_sum += b[i - 1]\n        dp[i] = (dp[i - 1] + dp[prefix_sum % (n + 1)]) % MOD\n        if b[i - 1] == prefix_sum:\n            dp[i] = (dp[i] + 1) % MOD\n        result = (result + dp[i]) % MOD\n    \n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(n, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = (dp[i] + dp[i + 1]) % MOD\n        if b[i] == prefix_sum:\n            dp[i + 1] = (dp[i + 1] + dp[i]) % MOD\n        result = (result + dp[i + 1]) % MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = (dp[i] + dp[i + 1] + dp[i + 1 - prefix_sum]) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = (dp[i] + dp[i + 1]) % MOD\n        if prefix_sum >= 0:\n            dp[prefix_sum] = (dp[prefix_sum] + dp[i + 1]) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = dp[i]\n        if b[i] == prefix_sum:\n            dp[i + 1] += dp[i]\n        dp[i + 1] %= MOD\n    \n    for i in range(n):\n        if b[i] == prefix_sum - b[i]:\n            result += dp[i]\n        else:\n            result += dp[i + 1]\n        result %= MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = dp[i]\n        if b[i] == prefix_sum:\n            dp[i + 1] += dp[i]\n        dp[i + 1] %= MOD\n        result += dp[i + 1]\n        result %= MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    for i in range(1, n + 1):\n        prefix_sum += b[i - 1]\n        dp[i] = (dp[i - 1] + dp[prefix_sum % (n + 1)]) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(n, b):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(1, n + 1):\n        prefix_sum += b[i - 1]\n        dp[i] = (dp[i - 1] + dp[i - prefix_sum % MOD]) % MOD\n        if prefix_sum == b[i - 1]:\n            dp[i] = (dp[i] + 1) % MOD\n        result = (result + dp[i]) % MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(n, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(n, b):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = (dp[i] + dp[i + 1]) % MOD\n        if b[i] == prefix_sum:\n            dp[i + 1] = (dp[i + 1] + dp[i]) % MOD\n    return dp[n]\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    b = list(map(int, data[index:index + n]))\n    index += n\n    results.append(count_hybrid_arrays(n, b))\n\nfor result in results:\n    print(result)",
            "import sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = dp[i]\n        if b[i] == prefix_sum:\n            dp[i + 1] += dp[i]\n        dp[i + 1] %= MOD\n        result += dp[i + 1]\n        result %= MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "MOD = 10**9 + 7\n\ndef count_hybrid_arrays(n, b):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(1, n + 1):\n        prefix_sum += b[i - 1]\n        dp[i] = (dp[i - 1] + dp[prefix_sum % (n + 1)]) % MOD\n        if b[i - 1] == prefix_sum:\n            dp[i] = (dp[i] + 1) % MOD\n        result = (result + dp[i]) % MOD\n    \n    return result\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(n, b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\nMOD = 10**9 + 7\n\ndef count_hybrid_arrays(b):\n    n = len(b)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    prefix_sum = 0\n    result = 0\n    \n    for i in range(n):\n        prefix_sum += b[i]\n        dp[i + 1] = (dp[i] + dp[i + 1]) % MOD\n        if b[i] == prefix_sum:\n            dp[i + 1] = (dp[i + 1] + dp[i]) % MOD\n        result = (result + dp[i + 1]) % MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        b = list(map(int, data[index:index + n]))\n        index += n\n        results.append(count_hybrid_arrays(b))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Pairs of Paths",
        "question_content": "You are given a tree consisting of n vertices, and m simple vertex paths. Your task is to find how many pairs of those paths intersect at exactly one vertex. More formally you have to find the number of pairs (i, j) (1 \\leq i < j \\leq m) such that path_i and path_j have exactly one vertex in common.\n\n\nInput Format\nFirst line contains a single integer n (1 \\leq n \\leq 3 \\cdot 10^5).\n\nNext n - 1 lines describe the tree. Each line contains two integers u and v (1 \\leq u, v \\leq n) describing an edge between vertices u and v.\n\nNext line contains a single integer m (1 \\leq m \\leq 3 \\cdot 10^5).\n\nNext m lines describe paths. Each line describes a path by it's two endpoints u and v (1 \\leq u, v \\leq n). The given path is all the vertices on the shortest path from u to v (including u and v).\n\n\nOutput Format\nOutput a single integer \u2014 the number of pairs of paths that intersect at exactly one vertex.\n\n\nSample Input 1\n\n5\n1 2\n1 3\n1 4\n3 5\n4\n2 3\n2 4\n3 4\n3 5\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n1\n3\n1 1\n1 1\n1 1\n\nSample Output 2\n\n3\n\n\nSample Input 3\n\n5\n1 2\n1 3\n1 4\n3 5\n6\n2 3\n2 4\n3 4\n3 5\n1 1\n1 2\n\nSample Output 3\n\n7\n\n\nNote\nThe tree in the first example and paths look like this. Pairs (1,4) and (3,4) intersect at one vertex.\n\nIn the second example all three paths contain the same single vertex, so all pairs (1, 2), (1, 3) and (2, 3) intersect at one vertex.\n\nThe third example is the same as the first example with two additional paths. Pairs (1,4), (1,5), (2,5), (3,4), (3,5), (3,6) and (5,6) intersect at one vertex.",
        "platform": "codeforces",
        "question_id": "1486/F",
        "contest_id": "1486",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nindex += 1\n\n# Build the tree\ntree = defaultdict(list)\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    index += 2\n    tree[u].append(v)\n    tree[v].append(u)\n\nm = int(data[index])\nindex += 1\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from root to a node\ndef find_path(node, path):\n    if node == root:\n        path.append(root)\n        return True\n    for neighbor in tree[node]:\n        if neighbor != parent[node]:\n            parent[neighbor] = node\n            depth[neighbor] = depth[node] + 1\n            if find_path(neighbor, path):\n                path.append(node)\n                return True\n    return False\n\n# Find the root of the tree\nroot = 1\nparent = {root: None}\ndepth = {root: 0}\nfind_path(root, [])\n\n# Find the LCA for each pair of paths\nlca_values = []\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    index += 2\n    lca_values.append(lca(u, v))\n\n# Count pairs that intersect at exactly one vertex\ncount = 0\nfor i in range(m):\n    for j in range(i + 1, m):\n        if lca_values[i] != lca_values[j]:\n            count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse tree\nn = int(data[0])\nedges = defaultdict(list)\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges[u].append(v)\n    edges[v].append(u)\n    index += 2\n\n# Parse paths\nm = int(data[index])\npaths = []\nindex += 1\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Function to find the lowest common ancestor (LCA) of two nodes in the tree\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the root\ndef find_path(node):\n    path = []\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    return path[::-1]\n\n# Initialize depth and parent arrays\ndepth = [-1] * (n + 1)\nparent = [-1] * (n + 1)\n\n# Depth-first search to populate depth and parent arrays\ndef dfs(node, par):\n    depth[node] = depth[par] + 1\n    parent[node] = par\n    for neighbor in edges[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\n# Start DFS from the root (node 1)\ndfs(1, -1)\n\n# Find LCA for each pair of paths\ncount = 0\nfor i in range(m):\n    for j in range(i + 1, m):\n        u1, v1 = paths[i]\n        u2, v2 = paths[j]\n        lca1 = lca(u1, v1)\n        lca2 = lca(u2, v2)\n        if lca1 == lca2:\n            path1 = find_path(u1)\n            path2 = find_path(u2)\n            if path1.index(lca1) == path2.index(lca2):\n                count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse tree\nn = int(data[0])\nedges = defaultdict(list)\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges[u].append(v)\n    edges[v].append(u)\n    index += 2\n\n# Parse paths\nm = int(data[index])\npaths = []\nindex += 1\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Function to find the lowest common ancestor (LCA) of two nodes in a tree\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the depth of each node in the tree\ndef dfs(node, parent, depth):\n    parent[node] = parent\n    depth[node] = depth\n    for neighbor in edges[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1)\n\n# Initialize parent and depth arrays\nparent = [0] * (n + 1)\ndepth = [0] * (n + 1)\ndfs(1, 0, 0)\n\n# Find the LCA for each pair of paths\ncount = 0\nfor i in range(m):\n    for j in range(i + 1, m):\n        u1, v1 = paths[i]\n        u2, v2 = paths[j]\n        lca1 = lca(u1, v1)\n        lca2 = lca(u2, v2)\n        if lca1 == lca2 and lca1 != u1 and lca1 != v1 and lca1 != u2 and lca1 != v2:\n            count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse tree\nn = int(data[0])\nedges = defaultdict(list)\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges[u].append(v)\n    edges[v].append(u)\n    index += 2\n\n# Parse paths\nm = int(data[index])\npaths = []\nindex += 1\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Function to find the lowest common ancestor (LCA) of two nodes in a tree\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the root\ndef path_to_root(node):\n    path = []\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    return path[::-1]\n\n# Initialize depth and parent arrays\ndepth = [-1] * (n + 1)\nparent = [-1] * (n + 1)\n\n# Depth-first search to populate depth and parent arrays\ndef dfs(node, par):\n    depth[node] = depth[par] + 1\n    parent[node] = par\n    for neighbor in edges[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\n# Start DFS from the root (node 1)\ndfs(1, -1)\n\n# Function to count pairs of paths that intersect at exactly one vertex\ndef count_intersecting_pairs(paths):\n    count = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            u1, v1 = paths[i]\n            u2, v2 = paths[j]\n            lca1 = lca(u1, v1)\n            lca2 = lca(u2, v2)\n            if lca1 == lca2:\n                path1 = path_to_root(u1)\n                path2 = path_to_root(u2)\n                if len(set(path1) & set(path2)) == 2:\n                    count += 1\n    return count\n\n# Output the result\nprint(count_intersecting_pairs(paths))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nindex += 1\n\n# Build the tree\ntree = defaultdict(list)\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    tree[u].append(v)\n    tree[v].append(u)\n    index += 2\n\nm = int(data[index])\nindex += 1\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from root to a node\ndef path_to_node(node):\n    path = []\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    return path[::-1]\n\n# Initialize depth and parent arrays\ndepth = [-1] * (n + 1)\nparent = [-1] * (n + 1)\n\n# Depth-first search to find depths and parents\ndef dfs(node, par):\n    depth[node] = depth[par] + 1\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\n# Start DFS from node 1\ndfs(1, -1)\n\n# Process each path and find the number of intersections\nintersections = 0\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    index += 2\n    lca_node = lca(u, v)\n    path_u = path_to_node(u)\n    path_v = path_to_node(v)\n    if lca_node in path_u and lca_node in path_v:\n        intersections += 1\n\n# Output the result\nprint(intersections)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_path(graph, start, end):\n    queue = deque([(start, [start])])\n    while queue:\n        (vertex, path) = queue.popleft()\n        for next in graph[vertex] - set(path):\n            if next == end:\n                return path + [next]\n            else:\n                queue.append((next, path + [next]))\n    return None\n\ndef count_intersecting_pairs(n, edges, paths):\n    graph = defaultdict(set)\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    path_sets = [set(find_path(graph, u, v)) for u, v in paths]\n    \n    count = 0\n    for i in range(len(path_sets)):\n        for j in range(i + 1, len(path_sets)):\n            intersection = path_sets[i] & path_sets[j]\n            if len(intersection) == 1:\n                count += 1\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n-1)]\nm = int(data[2*n+1])\npaths = [(int(data[2*n+2+2*i+1]), int(data[2*n+2+2*i+2])) for i in range(m)]\n\n# Solve the problem\nresult = count_intersecting_pairs(n, edges, paths)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    m = int(data[index])\n    index += 1\n    \n    paths = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        paths.append((u, v))\n    \n    return n, tree, m, paths\n\ndef find_lca(u, v, parent, depth):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    \n    while depth[u] > depth[v]:\n        u = parent[u]\n    \n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    \n    return u\n\ndef count_intersections(n, tree, m, paths):\n    parent = [-1] * (n + 1)\n    depth = [-1] * (n + 1)\n    \n    def dfs(node, par, d):\n        parent[node] = par\n        depth[node] = d\n        for neighbor in tree[node]:\n            if neighbor != par:\n                dfs(neighbor, node, d + 1)\n    \n    dfs(1, -1, 0)\n    \n    count = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            u1, v1 = paths[i]\n            u2, v2 = paths[j]\n            lca1 = find_lca(u1, v1, parent, depth)\n            lca2 = find_lca(u2, v2, parent, depth)\n            if lca1 == lca2:\n                count += 1\n    \n    return count\n\ndef main():\n    n, tree, m, paths = read_input()\n    result = count_intersections(n, tree, m, paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse tree\nn = int(data[0])\nedges = defaultdict(list)\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges[u].append(v)\n    edges[v].append(u)\n    index += 2\n\n# Parse paths\nm = int(data[index])\npaths = []\nindex += 1\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Function to find the lowest common ancestor (LCA) of two nodes in a tree\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from root to a given node\ndef find_path(node, path):\n    if node == root:\n        path.append(root)\n        return True\n    for neighbor in edges[node]:\n        if neighbor != parent[node]:\n            parent[neighbor] = node\n            depth[neighbor] = depth[node] + 1\n            if find_path(neighbor, path):\n                path.append(node)\n                return True\n    return False\n\n# Find the root of the tree\nroot = 1\nparent = [0] * (n + 1)\ndepth = [0] * (n + 1)\nfind_path(root, [])\n\n# Find the LCA for each pair of paths\ncount = 0\nfor i in range(m):\n    for j in range(i + 1, m):\n        u1, v1 = paths[i]\n        u2, v2 = paths[j]\n        lca1 = lca(u1, v1)\n        lca2 = lca(u2, v2)\n        if lca1 == lca2 and lca1 != u1 and lca1 != u2 and lca1 != v1 and lca1 != v2:\n            count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_lca(u, v, parent, depth):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\ndef count_intersections(n, edges, paths):\n    parent = [0] * (n + 1)\n    depth = [0] * (n + 1)\n    parent[1] = -1\n    queue = deque([1])\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor != parent[node]:\n                parent[neighbor] = node\n                depth[neighbor] = depth[node] + 1\n                queue.append(neighbor)\n    \n    lca_count = defaultdict(int)\n    for u, v in paths:\n        lca = find_lca(u, v, parent, depth)\n        lca_count[lca] += 1\n    \n    intersections = 0\n    for count in lca_count.values():\n        if count > 1:\n            intersections += count * (count - 1) // 2\n    \n    return intersections\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges.append((u, v))\n    index += 2\n\nm = int(data[index])\npaths = []\nindex += 1\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Build graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# Count intersections\nresult = count_intersections(n, edges, paths)\n\n# Output result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nindex += 1\n\n# Build the tree\ntree = defaultdict(list)\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    tree[u].append(v)\n    tree[v].append(u)\n    index += 2\n\nm = int(data[index])\nindex += 1\n\n# Function to find the lowest common ancestor (LCA) of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from root to a node\ndef find_path(node, path):\n    if node == root:\n        path.append(node)\n        return path\n    path.append(node)\n    return find_path(parent[node], path)\n\n# Initialize depth and parent arrays\ndepth = [-1] * (n + 1)\nparent = [-1] * (n + 1)\nroot = 1\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, par):\n    depth[node] = depth[par] + 1\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\n# Perform DFS to populate depth and parent arrays\ndfs(root, -1)\n\n# Function to find the number of pairs of paths that intersect at exactly one vertex\ndef count_intersecting_pairs(paths):\n    count = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            path1 = find_path(paths[i][0], [])\n            path2 = find_path(paths[j][0], [])\n            lca_node = lca(paths[i][0], paths[j][0])\n            if path1.index(lca_node) == path2.index(lca_node):\n                count += 1\n    return count\n\n# Parse paths\npaths = []\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Output the result\nprint(count_intersecting_pairs(paths))\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nindex += 1\n\n# Build the tree\ntree = defaultdict(list)\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    index += 2\n    tree[u].append(v)\n    tree[v].append(u)\n\nm = int(data[index])\nindex += 1\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from root to a node\ndef find_path(node, path):\n    if node == root:\n        path.append(root)\n        return True\n    for neighbor in tree[node]:\n        if neighbor != parent[node]:\n            parent[neighbor] = node\n            depth[neighbor] = depth[node] + 1\n            if find_path(neighbor, path):\n                path.append(node)\n                return True\n    return False\n\n# Find the root of the tree\nroot = 1\nparent = {root: None}\ndepth = {root: 0}\nfind_path(root, [])\n\n# Find the LCA for each pair of paths\nlca_values = []\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    index += 2\n    lca_values.append(lca(u, v))\n\n# Count pairs that intersect at exactly one vertex\ncount = 0\nfor i in range(m):\n    for j in range(i + 1, m):\n        if lca_values[i] != lca_values[j]:\n            count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse tree\nn = int(data[0])\nedges = defaultdict(list)\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges[u].append(v)\n    edges[v].append(u)\n    index += 2\n\n# Parse paths\nm = int(data[index])\npaths = []\nindex += 1\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Function to find the lowest common ancestor (LCA) of two nodes in the tree\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the root\ndef find_path(node):\n    path = []\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    return path[::-1]\n\n# Initialize depth and parent arrays\ndepth = [-1] * (n + 1)\nparent = [-1] * (n + 1)\n\n# Depth-first search to populate depth and parent arrays\ndef dfs(node, par):\n    depth[node] = depth[par] + 1\n    parent[node] = par\n    for neighbor in edges[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\n# Start DFS from the root (node 1)\ndfs(1, -1)\n\n# Find LCA for each pair of paths\ncount = 0\nfor i in range(m):\n    for j in range(i + 1, m):\n        u1, v1 = paths[i]\n        u2, v2 = paths[j]\n        lca1 = lca(u1, v1)\n        lca2 = lca(u2, v2)\n        if lca1 == lca2:\n            path1 = find_path(u1)\n            path2 = find_path(u2)\n            if path1.index(lca1) == path2.index(lca2):\n                count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse tree\nn = int(data[0])\nedges = defaultdict(list)\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges[u].append(v)\n    edges[v].append(u)\n    index += 2\n\n# Parse paths\nm = int(data[index])\npaths = []\nindex += 1\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Function to find the lowest common ancestor (LCA) of two nodes in a tree\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the depth of each node in the tree\ndef dfs(node, parent, depth):\n    parent[node] = parent\n    depth[node] = depth\n    for neighbor in edges[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, depth + 1)\n\n# Initialize parent and depth arrays\nparent = [0] * (n + 1)\ndepth = [0] * (n + 1)\ndfs(1, 0, 0)\n\n# Find the LCA for each pair of paths\ncount = 0\nfor i in range(m):\n    for j in range(i + 1, m):\n        u1, v1 = paths[i]\n        u2, v2 = paths[j]\n        lca1 = lca(u1, v1)\n        lca2 = lca(u2, v2)\n        if lca1 == lca2 and lca1 != u1 and lca1 != v1 and lca1 != u2 and lca1 != v2:\n            count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse tree\nn = int(data[0])\nedges = defaultdict(list)\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges[u].append(v)\n    edges[v].append(u)\n    index += 2\n\n# Parse paths\nm = int(data[index])\npaths = []\nindex += 1\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Function to find the lowest common ancestor (LCA) of two nodes in a tree\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the root\ndef path_to_root(node):\n    path = []\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    return path[::-1]\n\n# Initialize depth and parent arrays\ndepth = [-1] * (n + 1)\nparent = [-1] * (n + 1)\n\n# Depth-first search to populate depth and parent arrays\ndef dfs(node, par):\n    depth[node] = depth[par] + 1\n    parent[node] = par\n    for neighbor in edges[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\n# Start DFS from the root (node 1)\ndfs(1, -1)\n\n# Function to count pairs of paths that intersect at exactly one vertex\ndef count_intersecting_pairs(paths):\n    count = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            u1, v1 = paths[i]\n            u2, v2 = paths[j]\n            lca1 = lca(u1, v1)\n            lca2 = lca(u2, v2)\n            if lca1 == lca2:\n                path1 = path_to_root(u1)\n                path2 = path_to_root(u2)\n                if len(set(path1) & set(path2)) == 2:\n                    count += 1\n    return count\n\n# Output the result\nprint(count_intersecting_pairs(paths))",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nindex += 1\n\n# Build the tree\ntree = defaultdict(list)\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    tree[u].append(v)\n    tree[v].append(u)\n    index += 2\n\nm = int(data[index])\nindex += 1\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from root to a node\ndef path_to_node(node):\n    path = []\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    return path[::-1]\n\n# Initialize depth and parent arrays\ndepth = [-1] * (n + 1)\nparent = [-1] * (n + 1)\n\n# Depth-first search to find depths and parents\ndef dfs(node, par):\n    depth[node] = depth[par] + 1\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\n# Start DFS from node 1\ndfs(1, -1)\n\n# Process each path and find the number of intersections\nintersections = 0\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    index += 2\n    lca_node = lca(u, v)\n    path_u = path_to_node(u)\n    path_v = path_to_node(v)\n    if lca_node in path_u and lca_node in path_v:\n        intersections += 1\n\n# Output the result\nprint(intersections)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find_path(graph, start, end):\n    queue = deque([(start, [start])])\n    while queue:\n        (vertex, path) = queue.popleft()\n        for next in graph[vertex] - set(path):\n            if next == end:\n                return path + [next]\n            else:\n                queue.append((next, path + [next]))\n    return None\n\ndef count_intersecting_pairs(n, edges, paths):\n    graph = defaultdict(set)\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    path_sets = [set(find_path(graph, u, v)) for u, v in paths]\n    \n    count = 0\n    for i in range(len(path_sets)):\n        for j in range(i + 1, len(path_sets)):\n            intersection = path_sets[i] & path_sets[j]\n            if len(intersection) == 1:\n                count += 1\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n-1)]\nm = int(data[2*n+1])\npaths = [(int(data[2*n+2+2*i+1]), int(data[2*n+2+2*i+2])) for i in range(m)]\n\n# Solve the problem\nresult = count_intersecting_pairs(n, edges, paths)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    \n    tree = defaultdict(list)\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    m = int(data[index])\n    index += 1\n    \n    paths = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        index += 2\n        paths.append((u, v))\n    \n    return n, tree, m, paths\n\ndef find_lca(u, v, parent, depth):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    \n    while depth[u] > depth[v]:\n        u = parent[u]\n    \n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    \n    return u\n\ndef count_intersections(n, tree, m, paths):\n    parent = [-1] * (n + 1)\n    depth = [-1] * (n + 1)\n    \n    def dfs(node, par, d):\n        parent[node] = par\n        depth[node] = d\n        for neighbor in tree[node]:\n            if neighbor != par:\n                dfs(neighbor, node, d + 1)\n    \n    dfs(1, -1, 0)\n    \n    count = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            u1, v1 = paths[i]\n            u2, v2 = paths[j]\n            lca1 = find_lca(u1, v1, parent, depth)\n            lca2 = find_lca(u2, v2, parent, depth)\n            if lca1 == lca2:\n                count += 1\n    \n    return count\n\ndef main():\n    n, tree, m, paths = read_input()\n    result = count_intersections(n, tree, m, paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse tree\nn = int(data[0])\nedges = defaultdict(list)\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges[u].append(v)\n    edges[v].append(u)\n    index += 2\n\n# Parse paths\nm = int(data[index])\npaths = []\nindex += 1\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Function to find the lowest common ancestor (LCA) of two nodes in a tree\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from root to a given node\ndef find_path(node, path):\n    if node == root:\n        path.append(root)\n        return True\n    for neighbor in edges[node]:\n        if neighbor != parent[node]:\n            parent[neighbor] = node\n            depth[neighbor] = depth[node] + 1\n            if find_path(neighbor, path):\n                path.append(node)\n                return True\n    return False\n\n# Find the root of the tree\nroot = 1\nparent = [0] * (n + 1)\ndepth = [0] * (n + 1)\nfind_path(root, [])\n\n# Find the LCA for each pair of paths\ncount = 0\nfor i in range(m):\n    for j in range(i + 1, m):\n        u1, v1 = paths[i]\n        u2, v2 = paths[j]\n        lca1 = lca(u1, v1)\n        lca2 = lca(u2, v2)\n        if lca1 == lca2 and lca1 != u1 and lca1 != u2 and lca1 != v1 and lca1 != v2:\n            count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find_lca(u, v, parent, depth):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\ndef count_intersections(n, edges, paths):\n    parent = [0] * (n + 1)\n    depth = [0] * (n + 1)\n    parent[1] = -1\n    queue = deque([1])\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor != parent[node]:\n                parent[neighbor] = node\n                depth[neighbor] = depth[node] + 1\n                queue.append(neighbor)\n    \n    lca_count = defaultdict(int)\n    for u, v in paths:\n        lca = find_lca(u, v, parent, depth)\n        lca_count[lca] += 1\n    \n    intersections = 0\n    for count in lca_count.values():\n        if count > 1:\n            intersections += count * (count - 1) // 2\n    \n    return intersections\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges.append((u, v))\n    index += 2\n\nm = int(data[index])\npaths = []\nindex += 1\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Build graph\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# Count intersections\nresult = count_intersections(n, edges, paths)\n\n# Output result\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nindex += 1\n\n# Build the tree\ntree = defaultdict(list)\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    tree[u].append(v)\n    tree[v].append(u)\n    index += 2\n\nm = int(data[index])\nindex += 1\n\n# Function to find the lowest common ancestor (LCA) of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from root to a node\ndef find_path(node, path):\n    if node == root:\n        path.append(node)\n        return path\n    path.append(node)\n    return find_path(parent[node], path)\n\n# Initialize depth and parent arrays\ndepth = [-1] * (n + 1)\nparent = [-1] * (n + 1)\nroot = 1\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, par):\n    depth[node] = depth[par] + 1\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\n# Perform DFS to populate depth and parent arrays\ndfs(root, -1)\n\n# Function to find the number of pairs of paths that intersect at exactly one vertex\ndef count_intersecting_pairs(paths):\n    count = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            path1 = find_path(paths[i][0], [])\n            path2 = find_path(paths[j][0], [])\n            lca_node = lca(paths[i][0], paths[j][0])\n            if path1.index(lca_node) == path2.index(lca_node):\n                count += 1\n    return count\n\n# Parse paths\npaths = []\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    paths.append((u, v))\n    index += 2\n\n# Output the result\nprint(count_intersecting_pairs(paths))"
        ]
    },
    {
        "question_title": "Palindromic Doubles",
        "question_content": "A subsequence is a sequence that can be obtained from another sequence by removing some elements without changing the order of the remaining elements.\n\nA palindromic sequence is a sequence that is equal to the reverse of itself.\n\nYou are given a sequence of n integers a_1, a_2, \\dots, a_n. Any integer value appears in a no more than twice.\n\nWhat is the length of the longest palindromic subsequence of sequence a?\n\n\nInput Format\nThe first line contains a single integer t (1 \\le t \\le 1000)\u00a0\u2014 the number of testcases.\n\nThen the descriptions of t testcases follow.\n\nThe first line of each testcase contains a single integer n (1 \\le n \\le 250\\,000)\u00a0\u2014 the number of elements in the sequence.\n\nThe second line of each testcase contains n integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le n).\n\nAny integer value appears in a no more than twice. The sum of n over all testcases doesn't exceed 250\\,000.\n\n\nOutput Format\nFor each testcase print a single integer\u00a0\u2014 the length of the longest palindromic subsequence of sequence a.\n\n\nSample Input 1\n\n5\n6\n2 1 3 1 5 2\n6\n1 3 3 4 4 1\n1\n1\n2\n1 1\n7\n4 4 2 5 7 2 3\n\nSample Output 1\n\n5\n4\n1\n2\n3\n\n\nNote\nHere are the longest palindromic subsequences for the example testcases:\n\n- 2 1 3 1 5 2\n- 1 3 3 4 4 1 or 1 3 3 4 4 1\n- 1\n- 1 1\n- 4 4 2 5 7 2 3 or 4 4 2 5 7 2 3",
        "platform": "codeforces",
        "question_id": "1488/E",
        "contest_id": "1488",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        length += min(freq, 2)\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        if freq >= 2:\n            length += 2\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        if freq % 2 == 1:\n            length += 1\n    \n    # If there are any elements with odd frequencies, we can take at most one of them\n    if length > 0:\n        length -= 1\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\ndef longest_palindromic_subsequence(a):\n    n = len(a)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    return dp[0][n-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        results.append(longest_palindromic_subsequence(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        if freq % 2 == 1:\n            length += 1\n    \n    # If there are any elements with odd frequencies, we can take at most one of them\n    if length > 0:\n        length -= 1\n    \n    results.append(length + 1)\n\n# Print all results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\ndef longest_palindromic_subsequence(a):\n    n = len(a)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    return dp[0][n-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        results.append(longest_palindromic_subsequence(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef longest_palindromic_subsequence(a):\n    n = len(a)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    return dp[0][n-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        results.append(longest_palindromic_subsequence(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        length += min(freq, 2)\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        if freq >= 2:\n            length += 2\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        if freq >= 2:\n            length += 2\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        length += min(freq, 2)\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        if freq >= 2:\n            length += 2\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        if freq % 2 == 1:\n            length += 1\n    \n    # If there are any elements with odd frequencies, we can take at most one of them\n    if length > 0:\n        length -= 1\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)",
            "import sys\n\ndef longest_palindromic_subsequence(a):\n    n = len(a)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    return dp[0][n-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        results.append(longest_palindromic_subsequence(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        if freq % 2 == 1:\n            length += 1\n    \n    # If there are any elements with odd frequencies, we can take at most one of them\n    if length > 0:\n        length -= 1\n    \n    results.append(length + 1)\n\n# Print all results\nfor result in results:\n    print(result)",
            "import sys\n\ndef longest_palindromic_subsequence(a):\n    n = len(a)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    return dp[0][n-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        results.append(longest_palindromic_subsequence(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef longest_palindromic_subsequence(a):\n    n = len(a)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    return dp[0][n-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index+n]))\n        index += n\n        results.append(longest_palindromic_subsequence(a))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        length += min(freq, 2)\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        if freq >= 2:\n            length += 2\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Create a dictionary to count occurrences of each element\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Calculate the length of the longest palindromic subsequence\n    length = 0\n    for num, freq in count.items():\n        if freq >= 2:\n            length += 2\n    \n    results.append(length)\n\n# Print all results\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "GCD of an Array",
        "question_content": "You are given an array a of length n. You are asked to process q queries of the following format: given integers i and x, multiply a_i by x.\n\nAfter processing each query you need to output the greatest common divisor (GCD) of all elements of the array a.\n\nSince the answer can be too large, you are asked to output it modulo 10^9+7.\n\n\nInput Format\nThe first line contains two integers \u2014 n and q (1 \\le n, q \\le 2 \\cdot 10^5).\n\nThe second line contains n integers a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 2 \\cdot 10^5) \u2014 the elements of the array a before the changes.\n\nThe next q lines contain queries in the following format: each line contains two integers i and x (1 \\le i \\le n, 1 \\le x \\le 2 \\cdot 10^5).\n\n\nOutput Format\nPrint q lines: after processing each query output the GCD of all elements modulo 10^9+7 on a separate line.\n\n\nSample Input 1\n\n4 3\n1 6 8 12\n1 12\n2 3\n3 3\n\nSample Output 1\n\n2\n2\n6\n\n\nNote\nAfter the first query the array is [12, 6, 8, 12], \\operatorname{gcd}(12, 6, 8, 12) = 2.\n\nAfter the second query \u2014 [12, 18, 8, 12], \\operatorname{gcd}(12, 18, 8, 12) = 2.\n\nAfter the third query \u2014 [12, 18, 24, 12], \\operatorname{gcd}(12, 18, 24, 12) = 6.\n\nHere the \\operatorname{gcd} function denotes the greatest common divisor.",
        "platform": "codeforces",
        "question_id": "1493/D",
        "contest_id": "1493",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to compute GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query and print the GCD after each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list of numbers\ndef list_gcd(numbers):\n    return reduce(gcd, numbers)\n\n# Process each query and output the GCD modulo 10^9+7\nmod = 10**9 + 7\ncurrent_gcd = list_gcd(a)\nfor i, x in queries:\n    current_gcd = gcd(current_gcd, x)\n    print(current_gcd % mod)\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query and output the GCD modulo 10^9+7\nmod = 10**9 + 7\ncurrent_gcd = list_gcd(a)\nfor i, x in queries:\n    current_gcd = gcd(current_gcd, x)\n    print(current_gcd % mod)\n```"
        ],
        "code_list": [
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to compute GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query and print the GCD after each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query\nfor i, x in queries:\n    a[i-1] *= x\n    print(list_gcd(a) % (10**9 + 7))",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list of numbers\ndef list_gcd(numbers):\n    return reduce(gcd, numbers)\n\n# Process each query and output the GCD modulo 10^9+7\nmod = 10**9 + 7\ncurrent_gcd = list_gcd(a)\nfor i, x in queries:\n    current_gcd = gcd(current_gcd, x)\n    print(current_gcd % mod)",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\n# Function to calculate GCD of a list\ndef list_gcd(lst):\n    return reduce(gcd, lst)\n\n# Process each query and output the GCD modulo 10^9+7\nmod = 10**9 + 7\ncurrent_gcd = list_gcd(a)\nfor i, x in queries:\n    current_gcd = gcd(current_gcd, x)\n    print(current_gcd % mod)"
        ]
    },
    {
        "question_title": "The Number of Pairs",
        "question_content": "You are given three positive (greater than zero) integers c, d and x.\n\nYou have to find the number of pairs of positive integers (a, b) such that equality c \\cdot lcm(a, b) - d \\cdot gcd(a, b) = x holds. Where lcm(a, b) is the least common multiple of a and b and gcd(a, b) is the greatest common divisor of a and b.\n\n\nInput Format\nThe first line contains one integer t (1 \\le t \\le 10^4) \u2014 the number of test cases.\n\nEach test case consists of one line containing three integer c, d and x (1 \\le c, d, x \\le 10^7).\n\n\nOutput Format\nFor each test case, print one integer \u2014 the number of pairs (a, b) such that the above equality holds.\n\n\nSample Input 1\n\n4\n1 1 3\n4 2 6\n3 3 7\n2 7 25\n\nSample Output 1\n\n4\n3\n0\n8\n\n\nNote\nIn the first example, the correct pairs are: (1, 4), (4,1), (3, 6), (6, 3).\n\nIn the second example, the correct pairs are: (1, 2), (2, 1), (3, 3).",
        "platform": "codeforces",
        "question_id": "1499/D",
        "contest_id": "1499",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = x // a\n            if c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c * a + d * a) // (c * (x // a) + d * a)\n            if b > 0 and lcm(a, b) == (c * lcm(a, b) - d * gcd(a, b)) // x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = x // a\n            if c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef lcm(a, b):\n    return abs(a*b) // gcd(a, b)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = x // a\n            if c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c * a + d * a) // (c * (x // a) + d * a)\n            if b > 0 and lcm(a, b) == (c * lcm(a, b) - d * gcd(a, b)) // x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = x // a\n            if c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef lcm(a, b):\n    return abs(a*b) // gcd(a, b)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_pairs(c, d, x):\n    count = 0\n    for a in range(1, x + 1):\n        if x % a == 0:\n            b = (x // a) * (c // gcd(a, x // a))\n            if b > 0 and c * lcm(a, b) - d * gcd(a, b) == x:\n                count += 1\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        c = int(data[index])\n        d = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_pairs(c, d, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Travelling Salesman Problem",
        "question_content": "There are n cities numbered from 1 to n, and city i has beauty a_i.\n\nA salesman wants to start at city 1, visit every city exactly once, and return to city 1.\n\nFor all i\\ne j, a flight from city i to city j costs \\max(c_i,a_j-a_i) dollars, where c_i is the price floor enforced by city i. Note that there is no absolute value. Find the minimum total cost for the salesman to complete his trip.\n\n\nInput Format\nThe first line contains a single integer n (2\\le n\\le 10^5) \u2014 the number of cities.\n\nThe i-th of the next n lines contains two integers a_i, c_i (0\\le a_i,c_i\\le 10^9) \u2014 the beauty and price floor of the i-th city.\n\n\nOutput Format\nOutput a single integer \u2014 the minimum total cost.\n\n\nSample Input 1\n\n3\n1 9\n2 1\n4 1\n\nSample Output 1\n\n11\n\n\nSample Input 2\n\n6\n4 2\n8 4\n3 0\n2 3\n7 1\n0 1\n\nSample Output 2\n\n13\n\n\nNote\nIn the first test case, we can travel in order 1\\to 3\\to 2\\to 1.\n\n- The flight 1\\to 3 costs \\max(c_1,a_3-a_1)=\\max(9,4-1)=9.\n- The flight 3\\to 2 costs \\max(c_3, a_2-a_3)=\\max(1,2-4)=1.\n- The flight 2\\to 1 costs \\max(c_2,a_1-a_2)=\\max(1,1-2)=1.\n\nThe total cost is 11, and we cannot do better.",
        "platform": "codeforces",
        "question_id": "1503/C",
        "contest_id": "1503",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2 * i + 1])\n    c_i = int(data[2 * i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i - 1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Add the cost of the last flight back to city 1\na_last, c_last = cities[-1]\nmin_cost += max(c_last, a_last - c_last)\n\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2 * i + 1])\n    c_i = int(data[2 * i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i - 1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Add the cost of the last flight back to city 1\na_last, c_last = cities[-1]\nmin_cost += max(c_last, a_last - c_last)\n\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2*i + 1])\n    c_i = int(data[2*i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == n - 1:\n        min_cost += max(c_i, a_i - cities[0][0])\n    else:\n        min_cost += max(c_i, a_i - cities[i + 1][0])\n\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2*i + 1])\n    c_i = int(data[2*i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i-1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Add the cost of the last flight back to city 1\na_last, c_last = cities[-1]\nmin_cost += max(c_last, a_last - c_last)\n\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a = int(data[2*i + 1])\n    c = int(data[2*i + 2])\n    cities.append((a, c))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a, c = cities[i]\n    if i == 0:\n        min_cost += max(c, a - cities[-1][0])\n    elif i == n - 1:\n        min_cost += max(c, a - cities[0][0])\n    else:\n        min_cost += max(c, a - cities[i-1][0])\n\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2 * i + 1])\n    c_i = int(data[2 * i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i - 1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Add the cost of returning to the starting city\na_last, c_last = cities[-1]\nmin_cost += max(c_last, a_last - c_last)\n\nprint(min_cost)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ncities = []\nfor i in range(n):\n    a_i = int(data[2 * i + 1])\n    c_i = int(data[2 * i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i - 1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Output the result\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2*i + 1])\n    c_i = int(data[2*i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i-1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Add the cost of returning to the starting city\na_last, c_last = cities[-1]\nmin_cost += max(c_last, a_last - c_last)\n\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(1, 2 * n, 2):\n    a_i = int(data[i])\n    c_i = int(data[i + 1])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == n - 1:\n        next_a_i, next_c_i = cities[0]\n    else:\n        next_a_i, next_c_i = cities[i + 1]\n    min_cost += max(c_i, next_a_i - a_i)\n\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(1, 2 * n, 2):\n    a_i = int(data[i])\n    c_i = int(data[i + 1])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    a_next, c_next = cities[(i + 1) % n]\n    min_cost += max(c_i, a_next - a_i)\n\nprint(min_cost)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2 * i + 1])\n    c_i = int(data[2 * i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i - 1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Add the cost of the last flight back to city 1\na_last, c_last = cities[-1]\nmin_cost += max(c_last, a_last - c_last)\n\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2 * i + 1])\n    c_i = int(data[2 * i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i - 1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Add the cost of the last flight back to city 1\na_last, c_last = cities[-1]\nmin_cost += max(c_last, a_last - c_last)\n\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2*i + 1])\n    c_i = int(data[2*i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == n - 1:\n        min_cost += max(c_i, a_i - cities[0][0])\n    else:\n        min_cost += max(c_i, a_i - cities[i + 1][0])\n\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2*i + 1])\n    c_i = int(data[2*i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i-1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Add the cost of the last flight back to city 1\na_last, c_last = cities[-1]\nmin_cost += max(c_last, a_last - c_last)\n\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a = int(data[2*i + 1])\n    c = int(data[2*i + 2])\n    cities.append((a, c))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a, c = cities[i]\n    if i == 0:\n        min_cost += max(c, a - cities[-1][0])\n    elif i == n - 1:\n        min_cost += max(c, a - cities[0][0])\n    else:\n        min_cost += max(c, a - cities[i-1][0])\n\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2 * i + 1])\n    c_i = int(data[2 * i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i - 1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Add the cost of returning to the starting city\na_last, c_last = cities[-1]\nmin_cost += max(c_last, a_last - c_last)\n\nprint(min_cost)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ncities = []\nfor i in range(n):\n    a_i = int(data[2 * i + 1])\n    c_i = int(data[2 * i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i - 1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Output the result\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(n):\n    a_i = int(data[2*i + 1])\n    c_i = int(data[2*i + 2])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == 0:\n        min_cost += max(c_i, a_i - c_i)\n    else:\n        a_prev, c_prev = cities[i-1]\n        min_cost += max(c_i, a_i - a_prev)\n\n# Add the cost of returning to the starting city\na_last, c_last = cities[-1]\nmin_cost += max(c_last, a_last - c_last)\n\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(1, 2 * n, 2):\n    a_i = int(data[i])\n    c_i = int(data[i + 1])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    if i == n - 1:\n        next_a_i, next_c_i = cities[0]\n    else:\n        next_a_i, next_c_i = cities[i + 1]\n    min_cost += max(c_i, next_a_i - a_i)\n\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncities = []\n\nfor i in range(1, 2 * n, 2):\n    a_i = int(data[i])\n    c_i = int(data[i + 1])\n    cities.append((a_i, c_i))\n\n# Sort cities by beauty in descending order\ncities.sort(key=lambda x: x[0], reverse=True)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(n):\n    a_i, c_i = cities[i]\n    a_next, c_next = cities[(i + 1) % n]\n    min_cost += max(c_i, a_next - a_i)\n\nprint(min_cost)"
        ]
    },
    {
        "question_title": "Math",
        "question_content": "*The two images are equivalent, feel free to use either one.\n\n\nInput Format\nThe input contains a single integer a (-100 \\le a \\le 100).\n\n\nOutput Format\nOutput the result - an integer number.\n\n\nSample Input 1\n\n1\n\nSample Output 1\n\n1",
        "platform": "codeforces",
        "question_id": "1505/F",
        "contest_id": "1505",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\na = int(input())\nprint(a)\n```",
            "```python\n# YOUR CODE HERE\na = int(input())\nprint(a)\n```",
            "```python\n# YOUR CODE HERE\na = int(input())\nprint(a)\n```",
            "```python\n# YOUR CODE HERE\na = int(input())\nprint(a)\n```",
            "```python\n# YOUR CODE HERE\na = int(input())\nprint(a)\n```",
            "```python\n# YOUR CODE HERE\na = int(input())\nprint(a)\n```",
            "```python\n# YOUR CODE HERE\na = int(input())\nprint(a)\n```",
            "```python\n# YOUR CODE HERE\na = int(input())\nprint(a)\n```",
            "```python\n# YOUR CODE HERE\na = int(input())\nprint(a)\n```",
            "```python\n# YOUR CODE HERE\na = int(input())\nprint(a)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\na = int(input())\nprint(a)",
            "# YOUR CODE HERE\na = int(input())\nprint(a)",
            "# YOUR CODE HERE\na = int(input())\nprint(a)",
            "# YOUR CODE HERE\na = int(input())\nprint(a)",
            "# YOUR CODE HERE\na = int(input())\nprint(a)",
            "# YOUR CODE HERE\na = int(input())\nprint(a)",
            "# YOUR CODE HERE\na = int(input())\nprint(a)",
            "# YOUR CODE HERE\na = int(input())\nprint(a)",
            "# YOUR CODE HERE\na = int(input())\nprint(a)",
            "# YOUR CODE HERE\na = int(input())\nprint(a)"
        ]
    },
    {
        "question_title": "MEX Tree",
        "question_content": "You are given a tree with n nodes, numerated from 0 to n-1. For each k between 0 and n, inclusive, you have to count the number of unordered pairs (u,v), u \\neq v, such that the MEX of all the node labels in the shortest path from u to v (including end points) is k.\n\nThe MEX of a sequence of integers is the smallest non-negative integer that does not belong to the sequence.\n\n\nInput Format\nThe first line contains a single integer t (1 \\le t \\le 10^4) \u2014 the number of test cases.\n\nThe first line of each test case contains a single integer n (2 \\le n \\le 2 \\cdot 10^{5}).\n\nThe next n-1 lines of each test case describe the tree that has to be constructed. These lines contain two integers u and v (0 \\le u,v \\le n-1) denoting an edge between u and v (u \\neq v).\n\nIt is guaranteed that the given edges form a tree.\n\nIt is also guaranteed that the sum of n for all test cases does not exceed 2 \\cdot 10^{5}.\n\n\nOutput Format\nFor each test case, print n+1 integers: the number of paths in the tree, such that the MEX of all the node labels in that path is k for each k from 0 to n.\n\n\nSample Input 1\n\n2\n4\n0 1\n0 2\n2 3\n2\n1 0\n\nSample Output 1\n\n1 2 1 1 1 \n0 0 1\n\n\nNote\n1. In example case 1, For k = 0, there is 1 path that is from 2 to 3 as MEX([2, 3]) = 0. For k = 1, there are 2 paths that is from 0 to 2 as MEX([0, 2]) = 1 and 0 to 3 as MEX([0, 2, 3]) = 1. For k = 2, there is 1 path that is from 0 to 1 as MEX([0, 1]) = 2. For k = 3, there is 1 path that is from 1 to 2 as MEX([1, 0, 2]) = 3 For k = 4, there is 1 path that is from 1 to 3 as MEX([1, 0, 2, 3]) = 4.\n2. In example case 2, For k = 0, there are no such paths. For k = 1, there are no such paths. For k = 2, there is 1 path that is from 0 to 1 as MEX([0, 1]) = 2.",
        "platform": "codeforces",
        "question_id": "1527/D",
        "contest_id": "1527",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal paths\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n        paths.append(path)\n        return path\n    \n    paths = []\n    dfs(0, -1)\n    \n    result = [0] * (n + 1)\n    for path in paths:\n        for i in range(len(path)):\n            for j in range(i + 1, len(path)):\n                result[mex(path[i:j+1])] += 1\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            edges.append((u, v))\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            edges.append((u, v))\n        results.append((n, edges))\n    return results\n\ndef dfs(node, parent, tree, path, mex_count):\n    path.append(node)\n    mex = set(range(len(path)))\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, tree, path, mex_count)\n            mex.update(path)\n    mex_count[len(path) - 1] += 1\n    path.pop()\n\ndef solve(n, edges):\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    mex_count = [0] * (n + 1)\n    for node in range(n):\n        dfs(node, -1, tree, [], mex_count)\n    \n    return mex_count\n\ndef main():\n    results = read_input()\n    for n, edges in results:\n        result = solve(n, edges)\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n        count += 1\n        return path\n    \n    count = 0\n    path = dfs(0, -1)\n    \n    mex_count = [0] * (n + 1)\n    for i in range(n):\n        for j in range(i + 1, n):\n            subpath = path[i:j+1]\n            mex_count[mex(subpath)] += 1\n    \n    return mex_count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            edges.append((u, v))\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n        count += 1\n        return path\n    \n    count = 0\n    path = dfs(0, -1)\n    \n    mex_count = [0] * (n + 1)\n    for i in range(n):\n        mex_count[mex(path[i:])] += 1\n    \n    return mex_count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            edges.append((u, v))\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal paths\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n                paths.append(path)\n                path.pop()\n        return path\n    \n    paths = []\n    dfs(0, -1)\n    \n    mex_count = [0] * (n + 1)\n    for path in paths:\n        mex_value = mex(path)\n        mex_count[mex_value] += 1\n    \n    return mex_count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal paths\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n                paths.append(path)\n                path.pop()\n        return path\n    \n    paths = []\n    dfs(0, -1)\n    \n    count = [0] * (n + 1)\n    for path in paths:\n        for k in range(n + 1):\n            if mex(path) == k:\n                count[k] += 1\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    i = 0\n    while i in seen:\n        i += 1\n    return i\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path = [node]\n        queue = deque([node])\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if neighbor != parent:\n                    path.append(neighbor)\n                    queue.append(neighbor)\n        count += 1\n        return path\n    \n    def count_mex(path):\n        mex_count = [0] * (n + 1)\n        for i in range(len(path)):\n            for j in range(i, len(path)):\n                mex_value = mex(path[i:j+1])\n                mex_count[mex_value] += 1\n        return mex_count\n    \n    total_paths = [0] * (n + 1)\n    for node in range(n):\n        path = dfs(node, -1)\n        mex_count = count_mex(path)\n        for i in range(n + 1):\n            total_paths[i] += mex_count[i]\n    \n    return total_paths\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n        count[node] = path\n        return path\n    \n    count = {}\n    dfs(0, -1)\n    \n    result = [0] * (n + 1)\n    for i in range(n):\n        for j in range(i + 1, n):\n            path = count[i] + count[j][1:]\n            result[mex(path)] += 1\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                dfs(neighbor, node)\n        path.pop()\n    \n    def count_mex_paths(node, parent):\n        nonlocal count\n        path = []\n        dfs(node, -1)\n        for i in range(len(path)):\n            for j in range(i, len(path)):\n                mex_value = mex(path[i:j+1])\n                if mex_value <= n:\n                    count[mex_value] += 1\n    \n    count = [0] * (n + 1)\n    for i in range(n):\n        count_mex_paths(i, -1)\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                dfs(neighbor, node)\n        path.pop()\n    \n    def count_paths_with_mex(k):\n        nonlocal count\n        count = 0\n        for node in range(n):\n            path = []\n            dfs(node, -1)\n            for i in range(len(path)):\n                for j in range(i, len(path)):\n                    sequence = path[i:j+1]\n                    if mex(sequence) == k:\n                        count += 1\n        return count\n    \n    results = []\n    for k in range(n + 1):\n        results.append(count_paths_with_mex(k))\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        results.append(count_paths(n, edges))\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal paths\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n        paths.append(path)\n        return path\n    \n    paths = []\n    dfs(0, -1)\n    \n    result = [0] * (n + 1)\n    for path in paths:\n        for i in range(len(path)):\n            for j in range(i + 1, len(path)):\n                result[mex(path[i:j+1])] += 1\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            edges.append((u, v))\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            edges.append((u, v))\n        results.append((n, edges))\n    return results\n\ndef dfs(node, parent, tree, path, mex_count):\n    path.append(node)\n    mex = set(range(len(path)))\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, tree, path, mex_count)\n            mex.update(path)\n    mex_count[len(path) - 1] += 1\n    path.pop()\n\ndef solve(n, edges):\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    mex_count = [0] * (n + 1)\n    for node in range(n):\n        dfs(node, -1, tree, [], mex_count)\n    \n    return mex_count\n\ndef main():\n    results = read_input()\n    for n, edges in results:\n        result = solve(n, edges)\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n        count += 1\n        return path\n    \n    count = 0\n    path = dfs(0, -1)\n    \n    mex_count = [0] * (n + 1)\n    for i in range(n):\n        for j in range(i + 1, n):\n            subpath = path[i:j+1]\n            mex_count[mex(subpath)] += 1\n    \n    return mex_count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            edges.append((u, v))\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n        count += 1\n        return path\n    \n    count = 0\n    path = dfs(0, -1)\n    \n    mex_count = [0] * (n + 1)\n    for i in range(n):\n        mex_count[mex(path[i:])] += 1\n    \n    return mex_count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            index += 2\n            edges.append((u, v))\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal paths\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n                paths.append(path)\n                path.pop()\n        return path\n    \n    paths = []\n    dfs(0, -1)\n    \n    mex_count = [0] * (n + 1)\n    for path in paths:\n        mex_value = mex(path)\n        mex_count[mex_value] += 1\n    \n    return mex_count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal paths\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n                paths.append(path)\n                path.pop()\n        return path\n    \n    paths = []\n    dfs(0, -1)\n    \n    count = [0] * (n + 1)\n    for path in paths:\n        for k in range(n + 1):\n            if mex(path) == k:\n                count[k] += 1\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    i = 0\n    while i in seen:\n        i += 1\n    return i\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path = [node]\n        queue = deque([node])\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if neighbor != parent:\n                    path.append(neighbor)\n                    queue.append(neighbor)\n        count += 1\n        return path\n    \n    def count_mex(path):\n        mex_count = [0] * (n + 1)\n        for i in range(len(path)):\n            for j in range(i, len(path)):\n                mex_value = mex(path[i:j+1])\n                mex_count[mex_value] += 1\n        return mex_count\n    \n    total_paths = [0] * (n + 1)\n    for node in range(n):\n        path = dfs(node, -1)\n        mex_count = count_mex(path)\n        for i in range(n + 1):\n            total_paths[i] += mex_count[i]\n    \n    return total_paths\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path = [node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                path.extend(dfs(neighbor, node))\n        count[node] = path\n        return path\n    \n    count = {}\n    dfs(0, -1)\n    \n    result = [0] * (n + 1)\n    for i in range(n):\n        for j in range(i + 1, n):\n            path = count[i] + count[j][1:]\n            result[mex(path)] += 1\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                dfs(neighbor, node)\n        path.pop()\n    \n    def count_mex_paths(node, parent):\n        nonlocal count\n        path = []\n        dfs(node, -1)\n        for i in range(len(path)):\n            for j in range(i, len(path)):\n                mex_value = mex(path[i:j+1])\n                if mex_value <= n:\n                    count[mex_value] += 1\n    \n    count = [0] * (n + 1)\n    for i in range(n):\n        count_mex_paths(i, -1)\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        \n        result = count_paths(n, edges)\n        results.append(result)\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef mex(sequence):\n    seen = set(sequence)\n    k = 0\n    while k in seen:\n        k += 1\n    return k\n\ndef count_paths(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        nonlocal count\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                dfs(neighbor, node)\n        path.pop()\n    \n    def count_paths_with_mex(k):\n        nonlocal count\n        count = 0\n        for node in range(n):\n            path = []\n            dfs(node, -1)\n            for i in range(len(path)):\n                for j in range(i, len(path)):\n                    sequence = path[i:j+1]\n                    if mex(sequence) == k:\n                        count += 1\n        return count\n    \n    results = []\n    for k in range(n + 1):\n        results.append(count_paths_with_mex(k))\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        edges = []\n        for _ in range(n - 1):\n            u = int(data[index])\n            v = int(data[index + 1])\n            edges.append((u, v))\n            index += 2\n        results.append(count_paths(n, edges))\n    \n    for result in results:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Figure Fixing",
        "question_content": "You have a connected undirected graph made of n nodes and m edges. The i-th node has a value v_i and a target value t_i.\n\nIn an operation, you can choose an edge (i, j) and add k to both v_i and v_j, where k can be any integer. In particular, k can be negative.\n\nYour task to determine if it is possible that by doing some finite number of operations (possibly zero), you can achieve for every node i, v_i = t_i.\n\n\nInput Format\nThe first line contains a single integer t (1 \\leq t \\leq 1000), the number of test cases. Then the test cases follow.\n\nThe first line of each test case contains two integers n, m (2 \\leq n \\leq 2\\cdot 10^5, n-1\\leq m\\leq \\min(2\\cdot 10^5, \\frac{n(n-1)}{2})) \u2014 the number of nodes and edges respectively.\n\nThe second line contains n integers v_1\\ldots, v_n (-10^9 \\leq v_i \\leq 10^9) \u2014 initial values of nodes.\n\nThe third line contains n integers t_1\\ldots, t_n (-10^9 \\leq t_i \\leq 10^9) \u2014 target values of nodes.\n\nEach of the next m lines contains two integers i and j representing an edge between node i and node j (1 \\leq i, j \\leq n, i\\ne j).\n\nIt is guaranteed that the graph is connected and there is at most one edge between the same pair of nodes.\n\nIt is guaranteed that the sum of n over all testcases does not exceed 2 \\cdot 10^5 and the sum of m over all testcases does not exceed 2 \\cdot 10^5.\n\n\nOutput Format\nFor each test case, if it is possible for every node to reach its target after some number of operations, print \"YES\". Otherwise, print \"NO\".\n\n\nSample Input 1\n\n2\n4 4\n5 1 2 -3\n3 3 10 1\n1 2\n1 4\n3 2\n3 4\n4 4\n5 8 6 6\n-3 1 15 4\n1 2\n1 4\n3 2\n3 4\n\nSample Output 1\n\nYES\nNO\n\n\nNote\nHere is a visualization of the first test case (the orange values denote the initial values and the blue ones the desired values):\n\nOne possible order of operations to obtain the desired values for each node is the following:\n\n- Operation 1: Add 2 to nodes 2 and 3.\n- Operation 2: Add -2 to nodes 1 and 4.\n- Operation 3: Add 6 to nodes 3 and 4.\n\nNow we can see that in total we added -2 to node 1, 2 to node 2, 8 to node 3 and 4 to node 4 which brings each node exactly to it's desired value.\n\nFor the graph from the second test case it's impossible to get the target values.",
        "platform": "codeforces",
        "question_id": "1537/F",
        "contest_id": "1537",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to balance\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i].append(j)\n        graph[j].append(i)\n    \n    # Check if the graph is bipartite\n    color = [-1] * n\n    queue = deque()\n    \n    for i in range(n):\n        if color[i] == -1:\n            color[i] = 0\n            queue.append(i)\n            \n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    v = list(map(int, data[index:index + n]))\n    index += n\n    t = list(map(int, data[index:index + n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        i = int(data[index]) - 1\n        j = int(data[index + 1]) - 1\n        index += 2\n        edges.append((i, j))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to balance\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    # Check if the graph is bipartite\n    color = [-1] * n\n    queue = deque()\n    \n    for i in range(n):\n        if color[i] == -1:\n            color[i] = 0\n            queue.append(i)\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    v = list(map(int, data[index:index+n]))\n    index += n\n    t = list(map(int, data[index:index+n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index+1])\n        index += 2\n        edges.append((u, v))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to make all nodes equal\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i-1].append(j-1)\n        graph[j-1].append(i-1)\n    \n    # Check if the graph is connected\n    visited = [False] * n\n    queue = deque([0])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    \n    if not all(visited):\n        return \"NO\"\n    \n    # Check if the differences can be balanced\n    for i in range(n):\n        if diff[i] % 2 != 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    v = list(map(int, data[index:index + n]))\n    index += n\n    t = list(map(int, data[index:index + n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        index += 2\n        edges.append((i, j))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\n\ndef read_int():\n    global index\n    result = int(data[index])\n    index += 1\n    return result\n\ndef read_ints(n):\n    global index\n    result = [int(data[index + i]) for i in range(n)]\n    index += n\n    return result\n\ndef read_edges(m):\n    global index\n    result = []\n    for _ in range(m):\n        u = read_int() - 1\n        v = read_int() - 1\n        result.append((u, v))\n    return result\n\ndef can_reach_targets(n, m, v, t, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * n\n    queue = deque([0])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    \n    if not all(visited):\n        return \"NO\"\n    \n    diff = [t[i] - v[i] for i in range(n)]\n    total_diff = sum(diff)\n    \n    if total_diff % 2 != 0:\n        return \"NO\"\n    \n    return \"YES\"\n\nt = read_int()\nresults = []\n\nfor _ in range(t):\n    n = read_int()\n    m = read_int()\n    v = read_ints(n)\n    t = read_ints(n)\n    edges = read_edges(m)\n    result = can_reach_targets(n, m, v, t, edges)\n    results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef can_reach_targets(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to make all nodes equal\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i].append(j)\n        graph[j].append(i)\n    \n    # Check if the graph is connected\n    visited = [False] * n\n    queue = deque([1])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor - 1]:\n                visited[neighbor - 1] = True\n                queue.append(neighbor)\n    \n    if not all(visited):\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    v = list(map(int, data[index:index + n]))\n    index += n\n    t = list(map(int, data[index:index + n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        index += 2\n        edges.append((i, j))\n    \n    result = can_reach_targets(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to make all nodes equal\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    # Check if the graph is connected\n    visited = [False] * n\n    queue = deque([0])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    \n    if not all(visited):\n        return \"NO\"\n    \n    # Check if the differences can be balanced\n    for i in range(n):\n        if diff[i] % 2 != 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    v = list(map(int, data[index:index+n]))\n    index += n\n    t = list(map(int, data[index:index+n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index+1])\n        index += 2\n        edges.append((u, v))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to make all nodes equal\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i-1].append(j-1)\n        graph[j-1].append(i-1)\n    \n    # Check if the graph is bipartite\n    color = [-1] * n\n    queue = deque()\n    \n    for i in range(n):\n        if color[i] == -1:\n            color[i] = 0\n            queue.append(i)\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    v = list(map(int, data[index:index + n]))\n    index += n\n    t = list(map(int, data[index:index + n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        index += 2\n        edges.append((i, j))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef can_reach_targets(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to make all nodes equal\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Check if the graph is connected\n    visited = [False] * n\n    queue = deque([0])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    \n    if not all(visited):\n        return \"NO\"\n    \n    # Check if the differences can be balanced by the edges\n    for i in range(n):\n        if diff[i] % 2 != 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    m = int(data[index + 1])\n    v = list(map(int, data[index + 2:index + 2 + n]))\n    t = list(map(int, data[index + 2 + n:index + 2 + 2 * n]))\n    edges = []\n    for _ in range(m):\n        u = int(data[index + 2 + 2 * n + 2 * i])\n        v = int(data[index + 2 + 2 * n + 2 * i + 1])\n        edges.append((u - 1, v - 1))\n        index += 2\n    \n    result = can_reach_targets(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef solve():\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        v = list(map(int, data[index:index + n]))\n        index += n\n        t = list(map(int, data[index:index + n]))\n        index += n\n        edges = []\n        for _ in range(m):\n            i = int(data[index]) - 1\n            j = int(data[index + 1]) - 1\n            index += 2\n            edges.append((i, j))\n        \n        # Check if it's possible to make all values equal to their targets\n        # by performing the operations\n        # The key observation is that the sum of the differences between\n        # the initial and target values must be zero and the graph must be connected\n        diff_sum = sum(t[i] - v[i] for i in range(n))\n        if diff_sum == 0:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nsolve()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to balance\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    # Check if the graph is bipartite\n    color = [-1] * n\n    queue = deque()\n    \n    for i in range(n):\n        if color[i] == -1:\n            color[i] = 0\n            queue.append(i)\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    v = list(map(int, data[index:index+n]))\n    index += n\n    t = list(map(int, data[index:index+n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index+1])\n        index += 2\n        edges.append((u, v))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to balance\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i].append(j)\n        graph[j].append(i)\n    \n    # Check if the graph is bipartite\n    color = [-1] * n\n    queue = deque()\n    \n    for i in range(n):\n        if color[i] == -1:\n            color[i] = 0\n            queue.append(i)\n            \n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    v = list(map(int, data[index:index + n]))\n    index += n\n    t = list(map(int, data[index:index + n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        i = int(data[index]) - 1\n        j = int(data[index + 1]) - 1\n        index += 2\n        edges.append((i, j))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to balance\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    # Check if the graph is bipartite\n    color = [-1] * n\n    queue = deque()\n    \n    for i in range(n):\n        if color[i] == -1:\n            color[i] = 0\n            queue.append(i)\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    v = list(map(int, data[index:index+n]))\n    index += n\n    t = list(map(int, data[index:index+n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index+1])\n        index += 2\n        edges.append((u, v))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to make all nodes equal\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i-1].append(j-1)\n        graph[j-1].append(i-1)\n    \n    # Check if the graph is connected\n    visited = [False] * n\n    queue = deque([0])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    \n    if not all(visited):\n        return \"NO\"\n    \n    # Check if the differences can be balanced\n    for i in range(n):\n        if diff[i] % 2 != 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    v = list(map(int, data[index:index + n]))\n    index += n\n    t = list(map(int, data[index:index + n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        index += 2\n        edges.append((i, j))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nindex = 0\n\ndef read_int():\n    global index\n    result = int(data[index])\n    index += 1\n    return result\n\ndef read_ints(n):\n    global index\n    result = [int(data[index + i]) for i in range(n)]\n    index += n\n    return result\n\ndef read_edges(m):\n    global index\n    result = []\n    for _ in range(m):\n        u = read_int() - 1\n        v = read_int() - 1\n        result.append((u, v))\n    return result\n\ndef can_reach_targets(n, m, v, t, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * n\n    queue = deque([0])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    \n    if not all(visited):\n        return \"NO\"\n    \n    diff = [t[i] - v[i] for i in range(n)]\n    total_diff = sum(diff)\n    \n    if total_diff % 2 != 0:\n        return \"NO\"\n    \n    return \"YES\"\n\nt = read_int()\nresults = []\n\nfor _ in range(t):\n    n = read_int()\n    m = read_int()\n    v = read_ints(n)\n    t = read_ints(n)\n    edges = read_edges(m)\n    result = can_reach_targets(n, m, v, t, edges)\n    results.append(result)\n\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef can_reach_targets(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to make all nodes equal\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i].append(j)\n        graph[j].append(i)\n    \n    # Check if the graph is connected\n    visited = [False] * n\n    queue = deque([1])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor - 1]:\n                visited[neighbor - 1] = True\n                queue.append(neighbor)\n    \n    if not all(visited):\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    v = list(map(int, data[index:index + n]))\n    index += n\n    t = list(map(int, data[index:index + n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        index += 2\n        edges.append((i, j))\n    \n    result = can_reach_targets(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to make all nodes equal\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    # Check if the graph is connected\n    visited = [False] * n\n    queue = deque([0])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    \n    if not all(visited):\n        return \"NO\"\n    \n    # Check if the differences can be balanced\n    for i in range(n):\n        if diff[i] % 2 != 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    v = list(map(int, data[index:index+n]))\n    index += n\n    t = list(map(int, data[index:index+n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index+1])\n        index += 2\n        edges.append((u, v))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to make all nodes equal\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i-1].append(j-1)\n        graph[j-1].append(i-1)\n    \n    # Check if the graph is bipartite\n    color = [-1] * n\n    queue = deque()\n    \n    for i in range(n):\n        if color[i] == -1:\n            color[i] = 0\n            queue.append(i)\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    v = list(map(int, data[index:index + n]))\n    index += n\n    t = list(map(int, data[index:index + n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        i = int(data[index])\n        j = int(data[index + 1])\n        index += 2\n        edges.append((i, j))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef can_reach_targets(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to make all nodes equal\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Check if the graph is connected\n    visited = [False] * n\n    queue = deque([0])\n    visited[0] = True\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    \n    if not all(visited):\n        return \"NO\"\n    \n    # Check if the differences can be balanced by the edges\n    for i in range(n):\n        if diff[i] % 2 != 0:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    m = int(data[index + 1])\n    v = list(map(int, data[index + 2:index + 2 + n]))\n    t = list(map(int, data[index + 2 + n:index + 2 + 2 * n]))\n    edges = []\n    for _ in range(m):\n        u = int(data[index + 2 + 2 * n + 2 * i])\n        v = int(data[index + 2 + 2 * n + 2 * i + 1])\n        edges.append((u - 1, v - 1))\n        index += 2\n    \n    result = can_reach_targets(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef solve():\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        index += 2\n        v = list(map(int, data[index:index + n]))\n        index += n\n        t = list(map(int, data[index:index + n]))\n        index += n\n        edges = []\n        for _ in range(m):\n            i = int(data[index]) - 1\n            j = int(data[index + 1]) - 1\n            index += 2\n            edges.append((i, j))\n        \n        # Check if it's possible to make all values equal to their targets\n        # by performing the operations\n        # The key observation is that the sum of the differences between\n        # the initial and target values must be zero and the graph must be connected\n        diff_sum = sum(t[i] - v[i] for i in range(n))\n        if diff_sum == 0:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nsolve()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef can_reach_target(n, m, v, t, edges):\n    # Calculate the difference between initial and target values\n    diff = [t[i] - v[i] for i in range(n)]\n    \n    # If the sum of differences is not zero, it's impossible to balance\n    if sum(diff) != 0:\n        return \"NO\"\n    \n    # Create the graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    # Check if the graph is bipartite\n    color = [-1] * n\n    queue = deque()\n    \n    for i in range(n):\n        if color[i] == -1:\n            color[i] = 0\n            queue.append(i)\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nindex = 0\nt = int(data[index])\nindex += 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    m = int(data[index])\n    index += 1\n    v = list(map(int, data[index:index+n]))\n    index += n\n    t = list(map(int, data[index:index+n]))\n    index += n\n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index+1])\n        index += 2\n        edges.append((u, v))\n    \n    result = can_reach_target(n, m, v, t, edges)\n    results.append(result)\n\n# Write output\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Pairwise Modulo",
        "question_content": "You have an array a consisting of n distinct positive integers, numbered from 1 to n. Define p_k as p_k = \\sum_{1 \\le i, j \\le k} a_i \\bmod a_j, where x \\bmod y denotes the remainder when x is divided by y. You have to find and print p_1, p_2, \\ldots, p_n.\n\n\nInput Format\nThe first line contains n \u2014 the length of the array (2 \\le n \\le 2 \\cdot 10^5).\n\nThe second line contains n space-separated distinct integers a_1, \\ldots, a_n (1 \\le a_i \\le 3 \\cdot 10^5, a_i \\neq a_j if i \\neq j).\n\n\nOutput Format\nPrint n integers p_1, p_2, \\ldots, p_n.\n\n\nSample Input 1\n\n4\n6 2 7 3\n\nSample Output 1\n\n0 2 12 22\n\n\nSample Input 2\n\n3\n3 2 1\n\nSample Output 2\n\n0 3 5",
        "platform": "codeforces",
        "question_id": "1553/F",
        "contest_id": "1553",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\np = [0] * n\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\nfor i in range(n):\n    print(p[i], end=' ')\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array\np = [0] * n\n\n# Calculate p_k for each k\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\n# Print the result\nprint(' '.join(map(str, p)))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result list\np = [0] * n\n\n# Calculate p_k for each k\nfor k in range(n):\n    for i in range(k + 1):\n        for j in range(k + 1):\n            p[k] += a[i] % a[j]\n\n# Print the result\nprint(' '.join(map(str, p)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\np = [0] * n\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += (a[i] % a[j])\n\nfor i in range(n):\n    print(p[i], end=' ')\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array\np = [0] * n\n\n# Calculate p_k for each k\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += (a[i] % a[j])\n\n# Print the result\nprint(' '.join(map(str, p)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array\np = [0] * n\n\n# Calculate p_k for each k\nfor k in range(n):\n    for i in range(k + 1):\n        for j in range(k + 1):\n            p[k] += a[i] % a[j]\n\n# Print the result\nprint(' '.join(map(str, p)))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\np = [0] * n\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\nfor i in range(n):\n    print(p[i], end=' ')\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\np = [0] * n\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\nfor i in range(n):\n    print(p[i], end=' ')\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result list\np = [0] * n\n\n# Calculate p_k for each k\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\n# Print the result\nprint(' '.join(map(str, p)))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\np = [0] * n\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\nfor i in range(n):\n    print(p[i], end=' ')\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\np = [0] * n\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\nfor i in range(n):\n    print(p[i], end=' ')",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array\np = [0] * n\n\n# Calculate p_k for each k\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\n# Print the result\nprint(' '.join(map(str, p)))",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result list\np = [0] * n\n\n# Calculate p_k for each k\nfor k in range(n):\n    for i in range(k + 1):\n        for j in range(k + 1):\n            p[k] += a[i] % a[j]\n\n# Print the result\nprint(' '.join(map(str, p)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\np = [0] * n\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += (a[i] % a[j])\n\nfor i in range(n):\n    print(p[i], end=' ')",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array\np = [0] * n\n\n# Calculate p_k for each k\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += (a[i] % a[j])\n\n# Print the result\nprint(' '.join(map(str, p)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array\np = [0] * n\n\n# Calculate p_k for each k\nfor k in range(n):\n    for i in range(k + 1):\n        for j in range(k + 1):\n            p[k] += a[i] % a[j]\n\n# Print the result\nprint(' '.join(map(str, p)))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\np = [0] * n\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\nfor i in range(n):\n    print(p[i], end=' ')",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\np = [0] * n\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\nfor i in range(n):\n    print(p[i], end=' ')",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result list\np = [0] * n\n\n# Calculate p_k for each k\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\n# Print the result\nprint(' '.join(map(str, p)))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\np = [0] * n\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            p[k] += a[i] % a[j]\n\nfor i in range(n):\n    print(p[i], end=' ')"
        ]
    },
    {
        "question_title": "XOR and Distance",
        "question_content": "You are given an array a consisting of n distinct elements and an integer k. Each element in the array is a non-negative integer not exceeding 2^k-1.\n\nLet's define the XOR distance for a number x as the value of\n\nf(x) = \\min\\limits_{i = 1}^{n} \\min\\limits_{j = i + 1}^{n} |(a_i \\oplus x) - (a_j \\oplus x)|,\n\nwhere \\oplus denotes the bitwise XOR operation.\n\nFor every integer x from 0 to 2^k-1, you have to calculate f(x).\n\n\nInput Format\nThe first line contains two integers n and k (1 \\le k \\le 19; 2 \\le n \\le 2^k).\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (0 \\le a_i \\le 2^k-1). All these integers are distinct.\n\n\nOutput Format\nPrint 2^k integers. The i-th of them should be equal to f(i-1).\n\n\nSample Input 1\n\n3 3\n6 0 3\n\nSample Output 1\n\n3 1 1 2 2 1 1 3\n\n\nSample Input 2\n\n3 4\n13 4 2\n\nSample Output 2\n\n2 2 6 6 3 1 2 2 2 2 1 3 6 6 2 2\n\n\nNote\nConsider the first example:\n\n- for x = 0, if we apply bitwise XOR to the elements of the array with x, we get the array [6, 0, 3], and the minimum absolute difference of two elements is 3;\n- for x = 1, if we apply bitwise XOR to the elements of the array with x, we get the array [7, 1, 2], and the minimum absolute difference of two elements is 1;\n- for x = 2, if we apply bitwise XOR to the elements of the array with x, we get the array [4, 2, 1], and the minimum absolute difference of two elements is 1;\n- for x = 3, if we apply bitwise XOR to the elements of the array with x, we get the array [5, 3, 0], and the minimum absolute difference of two elements is 2;\n- for x = 4, if we apply bitwise XOR to the elements of the array with x, we get the array [2, 4, 7], and the minimum absolute difference of two elements is 2;\n- for x = 5, if we apply bitwise XOR to the elements of the array with x, we get the array [3, 5, 6], and the minimum absolute difference of two elements is 1;\n- for x = 6, if we apply bitwise XOR to the elements of the array with x, we get the array [0, 6, 5], and the minimum absolute difference of two elements is 1;\n- for x = 7, if we apply bitwise XOR to the elements of the array with x, we get the array [1, 7, 4], and the minimum absolute difference of two elements is 3.",
        "platform": "codeforces",
        "question_id": "1553/H",
        "contest_id": "1553",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate the XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i + 1]))\n    return min_diff\n\n# Calculate and print the XOR distances for all x from 0 to 2^k-1\nfor x in range(2**k):\n    print(xor_distance(x), end=' ')\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the XOR distance for each x from 0 to 2^k-1\nresults = []\nfor x in range(2**k):\n    transformed = [num ^ x for num in a]\n    min_diff = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = abs(transformed[i] - transformed[j])\n            if diff < min_diff:\n                min_diff = diff\n    results.append(min_diff)\n\n# Print the results\nprint(\" \".join(map(str, results)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(1, len(transformed)):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i - 1]))\n    return min_diff\n\n# Calculate and print the XOR distances for all x from 0 to 2^k-1\nfor x in range(2**k):\n    print(xor_distance(x), end=' ')\n```",
            "```python\nimport sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(1, len(transformed)):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i - 1]))\n    return min_diff\n\n# Calculate and print the results for all x from 0 to 2^k-1\nresults = [xor_distance(x) for x in range(2**k)]\nprint(' '.join(map(str, results)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the result array\nresult = []\n\n# Iterate over all possible values of x from 0 to 2^k-1\nfor x in range(2**k):\n    # Apply bitwise XOR to each element in the array\n    transformed = [num ^ x for num in a]\n    \n    # Sort the transformed array\n    transformed.sort()\n    \n    # Calculate the minimum absolute difference\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i-1]))\n    \n    # Append the result to the result array\n    result.append(min_diff)\n\n# Print the result array\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef xor_distance(a: List[int], k: int) -> List[int]:\n    n = len(a)\n    results = []\n    for x in range(2**k):\n        transformed = [num ^ x for num in a]\n        min_diff = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = abs(transformed[i] - transformed[j])\n                if diff < min_diff:\n                    min_diff = diff\n        results.append(min_diff)\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print results\nresults = xor_distance(a, k)\nprint(' '.join(map(str, results)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i + 1]))\n    return min_diff\n\n# Calculate and print the XOR distances for all x from 0 to 2^k-1\nfor x in range(2**k):\n    print(xor_distance(x), end=' ')\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate the XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(1, len(transformed)):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i - 1]))\n    return min_diff\n\n# Calculate and print the XOR distances for all x from 0 to 2^k-1\nresults = [xor_distance(x) for x in range(2**k)]\nprint(\" \".join(map(str, results)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate the XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = abs(transformed[i] - transformed[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n\n# Calculate and print the XOR distances for all x from 0 to 2^k-1\nresults = [xor_distance(x) for x in range(2**k)]\nprint(' '.join(map(str, results)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize result array\nresult = []\n\n# Iterate over all possible values of x from 0 to 2^k-1\nfor x in range(2**k):\n    # Apply bitwise XOR to each element in the array\n    transformed = [num ^ x for num in a]\n    \n    # Sort the transformed array\n    transformed.sort()\n    \n    # Calculate the minimum absolute difference\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i-1]))\n    \n    # Append the result to the result array\n    result.append(min_diff)\n\n# Print the result array\nprint(' '.join(map(str, result)))\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate the XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i + 1]))\n    return min_diff\n\n# Calculate and print the XOR distances for all x from 0 to 2^k-1\nfor x in range(2**k):\n    print(xor_distance(x), end=' ')",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the XOR distance for each x from 0 to 2^k-1\nresults = []\nfor x in range(2**k):\n    transformed = [num ^ x for num in a]\n    min_diff = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = abs(transformed[i] - transformed[j])\n            if diff < min_diff:\n                min_diff = diff\n    results.append(min_diff)\n\n# Print the results\nprint(\" \".join(map(str, results)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(1, len(transformed)):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i - 1]))\n    return min_diff\n\n# Calculate and print the XOR distances for all x from 0 to 2^k-1\nfor x in range(2**k):\n    print(xor_distance(x), end=' ')",
            "import sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(1, len(transformed)):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i - 1]))\n    return min_diff\n\n# Calculate and print the results for all x from 0 to 2^k-1\nresults = [xor_distance(x) for x in range(2**k)]\nprint(' '.join(map(str, results)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize the result array\nresult = []\n\n# Iterate over all possible values of x from 0 to 2^k-1\nfor x in range(2**k):\n    # Apply bitwise XOR to each element in the array\n    transformed = [num ^ x for num in a]\n    \n    # Sort the transformed array\n    transformed.sort()\n    \n    # Calculate the minimum absolute difference\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i-1]))\n    \n    # Append the result to the result array\n    result.append(min_diff)\n\n# Print the result array\nprint(' '.join(map(str, result)))",
            "import sys\nfrom typing import List\n\ndef xor_distance(a: List[int], k: int) -> List[int]:\n    n = len(a)\n    results = []\n    for x in range(2**k):\n        transformed = [num ^ x for num in a]\n        min_diff = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = abs(transformed[i] - transformed[j])\n                if diff < min_diff:\n                    min_diff = diff\n        results.append(min_diff)\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print results\nresults = xor_distance(a, k)\nprint(' '.join(map(str, results)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i + 1]))\n    return min_diff\n\n# Calculate and print the XOR distances for all x from 0 to 2^k-1\nfor x in range(2**k):\n    print(xor_distance(x), end=' ')",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate the XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(1, len(transformed)):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i - 1]))\n    return min_diff\n\n# Calculate and print the XOR distances for all x from 0 to 2^k-1\nresults = [xor_distance(x) for x in range(2**k)]\nprint(\" \".join(map(str, results)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to calculate the XOR distance for a given x\ndef xor_distance(x):\n    transformed = [num ^ x for num in a]\n    transformed.sort()\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = abs(transformed[i] - transformed[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n\n# Calculate and print the XOR distances for all x from 0 to 2^k-1\nresults = [xor_distance(x) for x in range(2**k)]\nprint(' '.join(map(str, results)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize result array\nresult = []\n\n# Iterate over all possible values of x from 0 to 2^k-1\nfor x in range(2**k):\n    # Apply bitwise XOR to each element in the array\n    transformed = [num ^ x for num in a]\n    \n    # Sort the transformed array\n    transformed.sort()\n    \n    # Calculate the minimum absolute difference\n    min_diff = float('inf')\n    for i in range(1, n):\n        min_diff = min(min_diff, abs(transformed[i] - transformed[i-1]))\n    \n    # Append the result to the result array\n    result.append(min_diff)\n\n# Print the result array\nprint(' '.join(map(str, result)))"
        ]
    },
    {
        "question_title": "Non-equal Neighbours",
        "question_content": "You are given an array of n positive integers a_1, a_2, \\ldots, a_n. Your task is to calculate the number of arrays of n positive integers b_1, b_2, \\ldots, b_n such that:\n\n- 1 \\le b_i \\le a_i for every i (1 \\le i \\le n), and\n- b_i \\neq b_{i+1} for every i (1 \\le i \\le n - 1).\n\nThe number of such arrays can be very large, so print it modulo 998\\,244\\,353.\n\n\nInput Format\nThe first line contains a single integer n (1 \\le n \\le 2 \\cdot 10^5)\u00a0\u2014 the length of the array a.\n\nThe second line contains n integers a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 10^9).\n\n\nOutput Format\nPrint the answer modulo 998\\,244\\,353 in a single line.\n\n\nSample Input 1\n\n3\n2 2 2\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n2\n2 3\n\nSample Output 2\n\n4\n\n\nSample Input 3\n\n3\n1 1 1\n\nSample Output 3\n\n0\n\n\nNote\nIn the first test case possible arrays are [1, 2, 1] and [2, 1, 2].\n\nIn the second test case possible arrays are [1, 2], [1, 3], [2, 1] and [2, 3].",
        "platform": "codeforces",
        "question_id": "1585/F",
        "contest_id": "1585",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nMOD = 998244353\n\ndef count_valid_arrays(n, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = sum(dp[j] * (a[i - 1] - j + 1) for j in range(1, a[i - 1] + 1)) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\nresult = count_valid_arrays(n, a)\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array\nfor i in range(n):\n    new_dp = [0] * (n + 1)\n    for j in range(1, a[i] + 1):\n        if j != a[i]:\n            new_dp[j] = dp[j - 1]\n        else:\n            new_dp[j] = dp[j - 1] + dp[j]\n        new_dp[j] %= MOD\n    dp = new_dp\n\n# The answer is the sum of all valid arrays of length n\nanswer = sum(dp) % MOD\nprint(answer)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array a\nfor i in range(n):\n    # Create a new dp array to store the results for the current element\n    new_dp = [0] * (n + 1)\n    # Iterate over each possible value for b_i\n    for j in range(1, a[i] + 1):\n        # If b_i is different from the previous element, add the number of valid arrays\n        if i == 0 or j != a[i - 1]:\n            new_dp[j] = (new_dp[j] + dp[j - 1]) % MOD\n        else:\n            new_dp[j] = dp[j - 1]\n    # Update the dp array for the next iteration\n    dp = new_dp\n\n# Print the result modulo 998244353\nprint(dp[a[n - 1]])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array\nfor i in range(n):\n    new_dp = [0] * (n + 1)\n    for j in range(1, a[i] + 1):\n        if j != a[i]:\n            new_dp[j] = dp[j - 1]\n        else:\n            new_dp[j] = dp[j - 1] + dp[j]\n        new_dp[j] %= MOD\n    dp = new_dp\n\n# The result is the sum of all valid arrays of length n\nresult = sum(dp) % MOD\n\n# Print the result\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_valid_arrays(n, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = sum(dp[j] * (a[i - 1] - j + 1) for j in range(1, a[i - 1] + 1)) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nresult = count_valid_arrays(n, a)\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array\nfor i in range(1, n + 1):\n    for j in range(1, a[i - 1] + 1):\n        dp[i] = (dp[i] + dp[i - 1]) % MOD\n\n# Calculate the result by subtracting the case where all elements are the same\nresult = dp[n]\nfor i in range(1, n + 1):\n    result = (result - dp[i - 1] + MOD) % MOD\n\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array\nfor i in range(1, n + 1):\n    dp[i] = dp[i - 1] * (a[i - 1] - 1) % MOD\n\n# Calculate the result\nresult = 0\nfor i in range(1, n + 1):\n    result = (result + dp[i]) % MOD\n\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_valid_arrays(n, a):\n    if n == 1:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * (a[i - 1] - 1)) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_valid_arrays(n, a)\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array\nfor i in range(1, n + 1):\n    dp[i] = 0\n    for j in range(1, a[i - 1] + 1):\n        if j != a[i - 2] if i > 1 else 0:\n            dp[i] = (dp[i] + dp[i - 1]) % MOD\n\n# The answer is the number of valid arrays of length n\nprint(dp[n])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\ndp = [0] * (n + 1)\ndp[0] = 1\n\nfor i in range(1, n + 1):\n    dp[i] = sum(dp[j] for j in range(i) if a[j] > a[i - 1]) % MOD\n\nresult = sum(dp[i] for i in range(1, n)) % MOD\nprint(result)\n```"
        ],
        "code_list": [
            "MOD = 998244353\n\ndef count_valid_arrays(n, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = sum(dp[j] * (a[i - 1] - j + 1) for j in range(1, a[i - 1] + 1)) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\nresult = count_valid_arrays(n, a)\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array\nfor i in range(n):\n    new_dp = [0] * (n + 1)\n    for j in range(1, a[i] + 1):\n        if j != a[i]:\n            new_dp[j] = dp[j - 1]\n        else:\n            new_dp[j] = dp[j - 1] + dp[j]\n        new_dp[j] %= MOD\n    dp = new_dp\n\n# The answer is the sum of all valid arrays of length n\nanswer = sum(dp) % MOD\nprint(answer)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array a\nfor i in range(n):\n    # Create a new dp array to store the results for the current element\n    new_dp = [0] * (n + 1)\n    # Iterate over each possible value for b_i\n    for j in range(1, a[i] + 1):\n        # If b_i is different from the previous element, add the number of valid arrays\n        if i == 0 or j != a[i - 1]:\n            new_dp[j] = (new_dp[j] + dp[j - 1]) % MOD\n        else:\n            new_dp[j] = dp[j - 1]\n    # Update the dp array for the next iteration\n    dp = new_dp\n\n# Print the result modulo 998244353\nprint(dp[a[n - 1]])",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array\nfor i in range(n):\n    new_dp = [0] * (n + 1)\n    for j in range(1, a[i] + 1):\n        if j != a[i]:\n            new_dp[j] = dp[j - 1]\n        else:\n            new_dp[j] = dp[j - 1] + dp[j]\n        new_dp[j] %= MOD\n    dp = new_dp\n\n# The result is the sum of all valid arrays of length n\nresult = sum(dp) % MOD\n\n# Print the result\nprint(result)",
            "MOD = 998244353\n\ndef count_valid_arrays(n, a):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = sum(dp[j] * (a[i - 1] - j + 1) for j in range(1, a[i - 1] + 1)) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nresult = count_valid_arrays(n, a)\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array\nfor i in range(1, n + 1):\n    for j in range(1, a[i - 1] + 1):\n        dp[i] = (dp[i] + dp[i - 1]) % MOD\n\n# Calculate the result by subtracting the case where all elements are the same\nresult = dp[n]\nfor i in range(1, n + 1):\n    result = (result - dp[i - 1] + MOD) % MOD\n\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array\nfor i in range(1, n + 1):\n    dp[i] = dp[i - 1] * (a[i - 1] - 1) % MOD\n\n# Calculate the result\nresult = 0\nfor i in range(1, n + 1):\n    result = (result + dp[i]) % MOD\n\nprint(result)",
            "MOD = 998244353\n\ndef count_valid_arrays(n, a):\n    if n == 1:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * (a[i - 1] - 1)) % MOD\n    \n    return dp[n]\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_valid_arrays(n, a)\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\n# Initialize the dp array\ndp = [0] * (n + 1)\ndp[0] = 1\n\n# Iterate over each element in the array\nfor i in range(1, n + 1):\n    dp[i] = 0\n    for j in range(1, a[i - 1] + 1):\n        if j != a[i - 2] if i > 1 else 0:\n            dp[i] = (dp[i] + dp[i - 1]) % MOD\n\n# The answer is the number of valid arrays of length n\nprint(dp[n])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 998244353\n\ndp = [0] * (n + 1)\ndp[0] = 1\n\nfor i in range(1, n + 1):\n    dp[i] = sum(dp[j] for j in range(i) if a[j] > a[i - 1]) % MOD\n\nresult = sum(dp[i] for i in range(1, n)) % MOD\nprint(result)"
        ]
    },
    {
        "question_title": "Desert",
        "question_content": "You are given an undirected graph of N nodes and M edges, E_1, E_2, \\dots E_M.\n\nA connected graph is a cactus if each of it's edges belogs to at most one simple cycle. A graph is a desert if each of it's connected components is a cactus.\n\nFind the number of pairs (L, R), (1 \\leq L \\leq R \\leq M) such that, if we delete all the edges except for E_L, E_{L+1}, \\dots E_R, the graph is a desert.\n\n\nInput Format\nThe first line contains two integers N and M (2 \\leq N \\leq 2.5 \\times 10^5, 1 \\leq M \\leq 5 \\times 10^5). Each of the next M lines contains two integers. The i-th line describes the i-th edge. It contains integers U_i and V_i, the nodes connected by the i-th edge (E_i=(U_i, V_i)). It is guaranteed that 1 \\leq U_i, V_i \\leq N and U_i \\neq V_i.\n\n\nOutput Format\nThe output contains one integer number - the answer.\n\n\nSample Input 1\n\n5 6\n1 2\n2 3\n3 4\n4 5\n5 1\n2 4\n\nSample Output 1\n\n20\n\n\nSample Input 2\n\n2 3\n1 2\n1 2\n1 2\n\nSample Output 2\n\n5\n\n\nNote\nIn the second example: Graphs for pairs (1, 1), (2, 2) and (3, 3) are deserts because they don't have any cycles. Graphs for pairs (1, 2) and (2, 3) have one cycle of length 2 so they are deserts.",
        "platform": "codeforces",
        "question_id": "1599/I",
        "contest_id": "1599",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    components = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component = []\n            dfs(i, -1, visited, component)\n            components.append(component)\n    \n    cactus_components = []\n    for component in components:\n        if is_cactus(component[0], -1, [False] * (n + 1), [False] * (n + 1)):\n            cactus_components.append(component)\n    \n    return cactus_components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    cactus_count = len(cactus_components)\n    \n    def count_pairs(cactus_count):\n        return cactus_count * (cactus_count + 1) // 2\n    \n    return count_pairs(cactus_count)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef is_cactus(graph, n):\n    visited = [False] * (n + 1)\n    parent = [-1] * (n + 1)\n    stack = []\n\n    def dfs(node, p):\n        visited[node] = True\n        stack.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                if not dfs(neighbor, node):\n                    return False\n            elif neighbor != p:\n                while stack[-1] != neighbor:\n                    stack.pop()\n                stack.pop()\n                if len(stack) > 1 and stack[-1] == neighbor:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not dfs(i, -1):\n                return False\n    return True\n\ndef count_desert_pairs(n, m, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    count = 0\n    for i in range(m):\n        for j in range(i, m):\n            temp_graph = defaultdict(list)\n            for k in range(m):\n                if i <= k <= j:\n                    temp_graph[edges[k][0]].append(edges[k][1])\n                    temp_graph[edges[k][1]].append(edges[k][0])\n            if all(is_cactus(temp_graph, n) for _ in range(n)):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    components = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component = []\n            dfs(i, -1, visited, component)\n            components.append(component)\n    \n    cactus_components = []\n    for component in components:\n        if is_cactus(component[0], -1, [False] * (n + 1), [False] * (n + 1)):\n            cactus_components.append(component)\n    \n    return cactus_components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    cactus_count = len(cactus_components)\n    \n    dp = [0] * (m + 1)\n    for component in cactus_components:\n        for i in range(len(component)):\n            dp[i + 1] += dp[i]\n    \n    for i in range(1, m + 1):\n        dp[i] += 1\n    \n    result = 0\n    for i in range(1, m + 1):\n        for j in range(i, m + 1):\n            result += dp[j] - dp[i - 1]\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    cactus_components = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component = []\n            dfs(i, -1, visited, component)\n            if all(is_cactus(node, -1, [False] * (n + 1), [False] * (n + 1)) for node in component):\n                cactus_components.append(component)\n    \n    return cactus_components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    component_sizes = [len(component) for component in cactus_components]\n    \n    def count_pairs(sizes):\n        count = 0\n        for i in range(len(sizes)):\n            for j in range(i, len(sizes)):\n                if sizes[i] == 1 or sizes[j] == 1:\n                    count += 1\n                else:\n                    count += (sizes[i] - 1) * (sizes[j] - 1)\n        return count\n    \n    return count_pairs(component_sizes)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef is_cactus(graph, n):\n    visited = [False] * (n + 1)\n    parent = [-1] * (n + 1)\n    stack = []\n\n    def dfs(node):\n        visited[node] = True\n        stack.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                dfs(neighbor)\n            elif neighbor != parent[node]:\n                return False\n        stack.pop()\n        return True\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not dfs(i):\n                return False\n    return True\n\ndef count_desert_pairs(n, m, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    count = 0\n    for l in range(m):\n        for r in range(l, m):\n            temp_graph = defaultdict(list)\n            for i in range(m):\n                if i >= l and i <= r:\n                    temp_graph[edges[i][0]].append(edges[i][1])\n                    temp_graph[edges[i][1]].append(edges[i][0])\n            if is_cactus(temp_graph, n):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    cactus_components = []\n    visited = [False] * (n + 1)\n    for node in range(1, n + 1):\n        if not visited[node]:\n            component = []\n            dfs(node, -1, visited, component)\n            if all(is_cactus(node, -1, [False] * (n + 1), [False] * (n + 1)) for node in component):\n                cactus_components.append(component)\n    \n    return cactus_components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    cactus_count = len(cactus_components)\n    \n    def count_pairs_in_cactus(cactus):\n        n = len(cactus)\n        return n * (n + 1) // 2\n    \n    total_pairs = 0\n    for cactus in cactus_components:\n        total_pairs += count_pairs_in_cactus(cactus)\n    \n    return total_pairs\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef is_cactus(graph, n):\n    visited = [False] * (n + 1)\n    parent = [-1] * (n + 1)\n    stack = []\n\n    def dfs(node, par):\n        visited[node] = True\n        stack.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                if not dfs(neighbor, node):\n                    return False\n            elif neighbor != par:\n                while stack[-1] != neighbor:\n                    stack.pop()\n                stack.pop()\n                if len(stack) > 1 and stack[-1] == parent[neighbor]:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not dfs(i, -1):\n                return False\n    return True\n\ndef count_desert_pairs(n, m, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    count = 0\n    for i in range(m):\n        for j in range(i, m):\n            temp_graph = defaultdict(list)\n            for k in range(m):\n                if i <= k <= j:\n                    temp_graph[edges[k][0]].append(edges[k][1])\n                    temp_graph[edges[k][1]].append(edges[k][0])\n            if all(is_cactus(temp_graph, n) for _ in range(n)):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    visited = [False] * (n + 1)\n    stack = [False] * (n + 1)\n    cactus_components = []\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not is_cactus(i, -1, visited, stack):\n                return []\n    \n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component = []\n            dfs(i, -1, visited, component)\n            cactus_components.append(component)\n    \n    return cactus_components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    if not cactus_components:\n        return 0\n    \n    def count_pairs_in_component(component):\n        count = 0\n        for i in range(len(component)):\n            for j in range(i + 1, len(component)):\n                count += 1\n        return count\n    \n    total_pairs = 0\n    for component in cactus_components:\n        total_pairs += count_pairs_in_component(component)\n    \n    return total_pairs\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\nresult = count_desert_pairs(n, m, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    def find_components():\n        visited = [False] * (n + 1)\n        components = []\n        for node in range(1, n + 1):\n            if not visited[node]:\n                component = []\n                dfs(node, -1, visited, component)\n                components.append(component)\n        return components\n    \n    def is_desert(components):\n        for component in components:\n            if not is_cactus(component[0], -1, [False] * (n + 1), [False] * (n + 1)):\n                return False\n        return True\n    \n    components = find_components()\n    return is_desert(components)\n\ndef count_desert_pairs(n, m, edges):\n    count = 0\n    for L in range(1, m + 1):\n        for R in range(L, m + 1):\n            if find_cactus_components(n, edges[L-1:R]):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Calculate and print the result\nresult = count_desert_pairs(n, m, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    components = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component = []\n            dfs(i, -1, visited, component)\n            if all(is_cactus(node, -1, [False] * (n + 1), [False] * (n + 1)) for node in component):\n                components.append(component)\n    \n    return components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    component_sizes = [len(component) for component in cactus_components]\n    \n    def count_pairs(sizes):\n        count = 0\n        for i in range(len(sizes)):\n            for j in range(i, len(sizes)):\n                if sizes[i] * sizes[j] <= m:\n                    count += 1\n        return count\n    \n    return count_pairs(component_sizes)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    components = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component = []\n            dfs(i, -1, visited, component)\n            components.append(component)\n    \n    cactus_components = []\n    for component in components:\n        if is_cactus(component[0], -1, [False] * (n + 1), [False] * (n + 1)):\n            cactus_components.append(component)\n    \n    return cactus_components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    cactus_count = len(cactus_components)\n    \n    def count_pairs(cactus_count):\n        return cactus_count * (cactus_count + 1) // 2\n    \n    return count_pairs(cactus_count)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef is_cactus(graph, n):\n    visited = [False] * (n + 1)\n    parent = [-1] * (n + 1)\n    stack = []\n\n    def dfs(node, p):\n        visited[node] = True\n        stack.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                if not dfs(neighbor, node):\n                    return False\n            elif neighbor != p:\n                while stack[-1] != neighbor:\n                    stack.pop()\n                stack.pop()\n                if len(stack) > 1 and stack[-1] == neighbor:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not dfs(i, -1):\n                return False\n    return True\n\ndef count_desert_pairs(n, m, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    count = 0\n    for i in range(m):\n        for j in range(i, m):\n            temp_graph = defaultdict(list)\n            for k in range(m):\n                if i <= k <= j:\n                    temp_graph[edges[k][0]].append(edges[k][1])\n                    temp_graph[edges[k][1]].append(edges[k][0])\n            if all(is_cactus(temp_graph, n) for _ in range(n)):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    components = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component = []\n            dfs(i, -1, visited, component)\n            components.append(component)\n    \n    cactus_components = []\n    for component in components:\n        if is_cactus(component[0], -1, [False] * (n + 1), [False] * (n + 1)):\n            cactus_components.append(component)\n    \n    return cactus_components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    cactus_count = len(cactus_components)\n    \n    dp = [0] * (m + 1)\n    for component in cactus_components:\n        for i in range(len(component)):\n            dp[i + 1] += dp[i]\n    \n    for i in range(1, m + 1):\n        dp[i] += 1\n    \n    result = 0\n    for i in range(1, m + 1):\n        for j in range(i, m + 1):\n            result += dp[j] - dp[i - 1]\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    cactus_components = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component = []\n            dfs(i, -1, visited, component)\n            if all(is_cactus(node, -1, [False] * (n + 1), [False] * (n + 1)) for node in component):\n                cactus_components.append(component)\n    \n    return cactus_components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    component_sizes = [len(component) for component in cactus_components]\n    \n    def count_pairs(sizes):\n        count = 0\n        for i in range(len(sizes)):\n            for j in range(i, len(sizes)):\n                if sizes[i] == 1 or sizes[j] == 1:\n                    count += 1\n                else:\n                    count += (sizes[i] - 1) * (sizes[j] - 1)\n        return count\n    \n    return count_pairs(component_sizes)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef is_cactus(graph, n):\n    visited = [False] * (n + 1)\n    parent = [-1] * (n + 1)\n    stack = []\n\n    def dfs(node):\n        visited[node] = True\n        stack.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                dfs(neighbor)\n            elif neighbor != parent[node]:\n                return False\n        stack.pop()\n        return True\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not dfs(i):\n                return False\n    return True\n\ndef count_desert_pairs(n, m, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    count = 0\n    for l in range(m):\n        for r in range(l, m):\n            temp_graph = defaultdict(list)\n            for i in range(m):\n                if i >= l and i <= r:\n                    temp_graph[edges[i][0]].append(edges[i][1])\n                    temp_graph[edges[i][1]].append(edges[i][0])\n            if is_cactus(temp_graph, n):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    cactus_components = []\n    visited = [False] * (n + 1)\n    for node in range(1, n + 1):\n        if not visited[node]:\n            component = []\n            dfs(node, -1, visited, component)\n            if all(is_cactus(node, -1, [False] * (n + 1), [False] * (n + 1)) for node in component):\n                cactus_components.append(component)\n    \n    return cactus_components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    cactus_count = len(cactus_components)\n    \n    def count_pairs_in_cactus(cactus):\n        n = len(cactus)\n        return n * (n + 1) // 2\n    \n    total_pairs = 0\n    for cactus in cactus_components:\n        total_pairs += count_pairs_in_cactus(cactus)\n    \n    return total_pairs\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef is_cactus(graph, n):\n    visited = [False] * (n + 1)\n    parent = [-1] * (n + 1)\n    stack = []\n\n    def dfs(node, par):\n        visited[node] = True\n        stack.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                if not dfs(neighbor, node):\n                    return False\n            elif neighbor != par:\n                while stack[-1] != neighbor:\n                    stack.pop()\n                stack.pop()\n                if len(stack) > 1 and stack[-1] == parent[neighbor]:\n                    return False\n        return True\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not dfs(i, -1):\n                return False\n    return True\n\ndef count_desert_pairs(n, m, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    count = 0\n    for i in range(m):\n        for j in range(i, m):\n            temp_graph = defaultdict(list)\n            for k in range(m):\n                if i <= k <= j:\n                    temp_graph[edges[k][0]].append(edges[k][1])\n                    temp_graph[edges[k][1]].append(edges[k][0])\n            if all(is_cactus(temp_graph, n) for _ in range(n)):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    visited = [False] * (n + 1)\n    stack = [False] * (n + 1)\n    cactus_components = []\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not is_cactus(i, -1, visited, stack):\n                return []\n    \n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component = []\n            dfs(i, -1, visited, component)\n            cactus_components.append(component)\n    \n    return cactus_components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    if not cactus_components:\n        return 0\n    \n    def count_pairs_in_component(component):\n        count = 0\n        for i in range(len(component)):\n            for j in range(i + 1, len(component)):\n                count += 1\n        return count\n    \n    total_pairs = 0\n    for component in cactus_components:\n        total_pairs += count_pairs_in_component(component)\n    \n    return total_pairs\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\nresult = count_desert_pairs(n, m, edges)\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    def find_components():\n        visited = [False] * (n + 1)\n        components = []\n        for node in range(1, n + 1):\n            if not visited[node]:\n                component = []\n                dfs(node, -1, visited, component)\n                components.append(component)\n        return components\n    \n    def is_desert(components):\n        for component in components:\n            if not is_cactus(component[0], -1, [False] * (n + 1), [False] * (n + 1)):\n                return False\n        return True\n    \n    components = find_components()\n    return is_desert(components)\n\ndef count_desert_pairs(n, m, edges):\n    count = 0\n    for L in range(1, m + 1):\n        for R in range(L, m + 1):\n            if find_cactus_components(n, edges[L-1:R]):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n\n# Calculate and print the result\nresult = count_desert_pairs(n, m, edges)\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find_cactus_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def is_cactus(node, parent, visited, stack):\n        visited[node] = True\n        stack[node] = True\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if is_cactus(neighbor, node, visited, stack):\n                    return False\n            elif stack[neighbor]:\n                return False\n        \n        stack[node] = False\n        return True\n    \n    def dfs(node, parent, visited, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node, visited, component)\n    \n    components = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            component = []\n            dfs(i, -1, visited, component)\n            if all(is_cactus(node, -1, [False] * (n + 1), [False] * (n + 1)) for node in component):\n                components.append(component)\n    \n    return components\n\ndef count_desert_pairs(n, m, edges):\n    cactus_components = find_cactus_components(n, edges)\n    component_sizes = [len(component) for component in cactus_components]\n    \n    def count_pairs(sizes):\n        count = 0\n        for i in range(len(sizes)):\n            for j in range(i, len(sizes)):\n                if sizes[i] * sizes[j] <= m:\n                    count += 1\n        return count\n    \n    return count_pairs(component_sizes)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Solve the problem\nresult = count_desert_pairs(n, m, edges)\n\n# Write output\nprint(result)"
        ]
    },
    {
        "question_title": "Interesting Sections",
        "question_content": "William has an array of non-negative numbers a_1, a_2, \\dots, a_n. He wants you to find out how many segments l \\le r pass the check. The check is performed in the following manner:\n\n1. The minimum and maximum numbers are found on the segment of the array starting at l and ending at r.\n2. The check is considered to be passed if the binary representation of the minimum and maximum numbers have the same number of bits equal to 1.\n\n\nInput Format\nThe first line contains a single integer n (1 \\le n \\le 10^6), the size of array a.\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (0 \\le a_i \\le 10^{18}), the contents of array a.\n\n\nOutput Format\nOutput a single number \u00a0\u2014 the total number of segments that passed the check.\n\n\nSample Input 1\n\n5\n1 2 3 4 5\n\nSample Output 1\n\n9\n\n\nSample Input 2\n\n10\n0 5 7 3 9 10 1 6 13 7\n\nSample Output 2\n\n18",
        "platform": "codeforces",
        "question_id": "1609/F",
        "contest_id": "1609",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom typing import List\n\ndef count_valid_segments(n: int, a: List[int]) -> int:\n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if bin(min_val).count('1') == bin(max_val).count('1'):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_valid_segments(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to count the number of 1s in the binary representation of a number\ndef count_ones(x):\n    return bin(x).count('1')\n\n# Initialize the count of valid segments\nvalid_segments = 0\n\n# Iterate over all possible segments\nfor l in range(n):\n    min_val = a[l]\n    max_val = a[l]\n    for r in range(l, n):\n        min_val = min(min_val, a[r])\n        max_val = max(max_val, a[r])\n        if count_ones(min_val) == count_ones(max_val):\n            valid_segments += 1\n\n# Output the result\nprint(valid_segments)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to count the number of 1 bits in the binary representation of a number\ndef count_ones(x):\n    return bin(x).count('1')\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible segments\nfor l in range(n):\n    min_val = a[l]\n    max_val = a[l]\n    for r in range(l, n):\n        min_val = min(min_val, a[r])\n        max_val = max(max_val, a[r])\n        if count_ones(min_val) == count_ones(max_val):\n            answer += 1\n\n# Output the answer\nprint(answer)\n```",
            "```python\nimport sys\n\ndef count_segments_with_equal_set_bits(n, a):\n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if bin(min_val).count('1') == bin(max_val).count('1'):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_segments_with_equal_set_bits(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\n\ndef count_segments_with_equal_ones(n, a):\n    count = 0\n    for l in range(n):\n        ones_count = 0\n        for r in range(l, n):\n            ones_count += bin(a[r]).count('1')\n            if bin(a[r]).count('1') == ones_count:\n                count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = count_segments_with_equal_ones(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\n\ndef count_segments_with_equal_ones(n, a):\n    count = 0\n    for l in range(n):\n        ones_count = [0] * 61  # Assuming 2^60 is the maximum number of bits needed\n        for r in range(l, n):\n            num = a[r]\n            bit_count = bin(num).count('1')\n            ones_count[bit_count] += 1\n            if ones_count[bit_count] > 1:\n                count += ones_count[bit_count] - 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = count_segments_with_equal_ones(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\n\ndef count_valid_segments(n, a):\n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if bin(min_val).count('1') == bin(max_val).count('1'):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_valid_segments(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to count the number of 1 bits in the binary representation of a number\ndef count_ones(x):\n    return bin(x).count('1')\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible segments\nfor l in range(n):\n    min_val = a[l]\n    max_val = a[l]\n    for r in range(l, n):\n        min_val = min(min_val, a[r])\n        max_val = max(max_val, a[r])\n        if count_ones(min_val) == count_ones(max_val):\n            answer += 1\n\n# Output the answer to stdout\nprint(answer)\n```",
            "```python\nimport sys\n\ndef count_valid_segments(n, a):\n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if bin(min_val).count('1') == bin(max_val).count('1'):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_valid_segments(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to count the number of 1s in the binary representation of a number\ndef count_ones(x):\n    return bin(x).count('1')\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible segments\nfor l in range(n):\n    min_val = a[l]\n    max_val = a[l]\n    for r in range(l, n):\n        min_val = min(min_val, a[r])\n        max_val = max(max_val, a[r])\n        if count_ones(min_val) == count_ones(max_val):\n            answer += 1\n\n# Output the answer\nprint(answer)\n```"
        ],
        "code_list": [
            "import sys\nfrom typing import List\n\ndef count_valid_segments(n: int, a: List[int]) -> int:\n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if bin(min_val).count('1') == bin(max_val).count('1'):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_valid_segments(n, a)\n\n# Write output\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to count the number of 1s in the binary representation of a number\ndef count_ones(x):\n    return bin(x).count('1')\n\n# Initialize the count of valid segments\nvalid_segments = 0\n\n# Iterate over all possible segments\nfor l in range(n):\n    min_val = a[l]\n    max_val = a[l]\n    for r in range(l, n):\n        min_val = min(min_val, a[r])\n        max_val = max(max_val, a[r])\n        if count_ones(min_val) == count_ones(max_val):\n            valid_segments += 1\n\n# Output the result\nprint(valid_segments)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to count the number of 1 bits in the binary representation of a number\ndef count_ones(x):\n    return bin(x).count('1')\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible segments\nfor l in range(n):\n    min_val = a[l]\n    max_val = a[l]\n    for r in range(l, n):\n        min_val = min(min_val, a[r])\n        max_val = max(max_val, a[r])\n        if count_ones(min_val) == count_ones(max_val):\n            answer += 1\n\n# Output the answer\nprint(answer)",
            "import sys\n\ndef count_segments_with_equal_set_bits(n, a):\n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if bin(min_val).count('1') == bin(max_val).count('1'):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_segments_with_equal_set_bits(n, a)\n\n# Write output\nprint(result)",
            "import sys\n\ndef count_segments_with_equal_ones(n, a):\n    count = 0\n    for l in range(n):\n        ones_count = 0\n        for r in range(l, n):\n            ones_count += bin(a[r]).count('1')\n            if bin(a[r]).count('1') == ones_count:\n                count += 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = count_segments_with_equal_ones(n, a)\n\n# Write output\nprint(result)",
            "import sys\n\ndef count_segments_with_equal_ones(n, a):\n    count = 0\n    for l in range(n):\n        ones_count = [0] * 61  # Assuming 2^60 is the maximum number of bits needed\n        for r in range(l, n):\n            num = a[r]\n            bit_count = bin(num).count('1')\n            ones_count[bit_count] += 1\n            if ones_count[bit_count] > 1:\n                count += ones_count[bit_count] - 1\n    return count\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = count_segments_with_equal_ones(n, a)\n\n# Write output\nprint(result)",
            "import sys\n\ndef count_valid_segments(n, a):\n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if bin(min_val).count('1') == bin(max_val).count('1'):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_valid_segments(n, a)\n\n# Write output\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to count the number of 1 bits in the binary representation of a number\ndef count_ones(x):\n    return bin(x).count('1')\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible segments\nfor l in range(n):\n    min_val = a[l]\n    max_val = a[l]\n    for r in range(l, n):\n        min_val = min(min_val, a[r])\n        max_val = max(max_val, a[r])\n        if count_ones(min_val) == count_ones(max_val):\n            answer += 1\n\n# Output the answer to stdout\nprint(answer)",
            "import sys\n\ndef count_valid_segments(n, a):\n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if bin(min_val).count('1') == bin(max_val).count('1'):\n                count += 1\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_valid_segments(n, a)\n\n# Write output\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to count the number of 1s in the binary representation of a number\ndef count_ones(x):\n    return bin(x).count('1')\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible segments\nfor l in range(n):\n    min_val = a[l]\n    max_val = a[l]\n    for r in range(l, n):\n        min_val = min(min_val, a[r])\n        max_val = max(max_val, a[r])\n        if count_ones(min_val) == count_ones(max_val):\n            answer += 1\n\n# Output the answer\nprint(answer)"
        ]
    },
    {
        "question_title": "Keep the Average High",
        "question_content": "You are given an array of integers a_1, a_2, \\ldots, a_n and an integer x.\n\nYou need to select the maximum number of elements in the array, such that for every subsegment a_l, a_{l + 1}, \\ldots, a_r containing strictly more than one element (l < r), either:\n\n- At least one element on this subsegment is not selected, or\n- a_l + a_{l+1} + \\ldots + a_r \\geq x \\cdot (r - l + 1).\n\n\nInput Format\nThe first line of input contains one integer t (1 \\leq t \\leq 10): the number of test cases.\n\nThe descriptions of t test cases follow, three lines per test case.\n\nIn the first line you are given one integer n (1 \\leq n \\leq 50\\,000): the number of integers in the array.\n\nThe second line contains n integers a_1, a_2, \\ldots, a_n (-100\\,000 \\leq a_i \\leq 100\\,000).\n\nThe third line contains one integer x (-100\\,000 \\leq x \\leq 100\\,000).\n\n\nOutput Format\nFor each test case, print one integer: the maximum number of elements that you can select.\n\n\nSample Input 1\n\n4\n5\n1 2 3 4 5\n2\n10\n2 4 2 4 2 4 2 4 2 4\n3\n3\n-10 -5 -10\n-8\n3\n9 9 -3\n5\n\nSample Output 1\n\n4\n8\n2\n2\n\n\nNote\nIn the first example, one valid way to select the elements is [\\underline{1}, 2, \\underline{3}, \\underline{4}, \\underline{5}]. All subsegments satisfy at least one of the criteria. For example, for the subsegment l = 1, r = 2 we have that the element 2 is not selected, satisfying the first criterion. For the subsegment l = 3, r = 5 we have 3 + 4 + 5 = 12 \\ge 2 \\cdot 3, satisfying the second criterion.\n\nWe can't select all elements, because in this case for l = 1, r = 2 all elements are selected and we have a_1 + a_2 = 3 < 2 \\cdot 2. Thus, the maximum number of selected elements is 4.\n\nIn the second example, one valid solution is [\\underline{2}, \\underline{4}, 2, \\underline{4}, \\underline{2}, \\underline{4}, 2, \\underline{4}, \\underline{2}, \\underline{4}].\n\nIn the third example, one valid solution is [\\underline{-10}, -5, \\underline{-10}].\n\nIn the fourth example, one valid solution is [\\underline{9}, \\underline{9}, -3].",
        "platform": "codeforces",
        "question_id": "1616/D",
        "contest_id": "1616",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\ndef max_selectable_elements(n, a, x):\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += x\n        else:\n            i += 1\n    return sum(selected)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        x = int(data[index])\n        index += 1\n        \n        result = max_selectable_elements(n, a, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += x\n        else:\n            i += 1\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] + a[j - 1] < x * (j - i + 1):\n                j += 1\n            if j == n:\n                break\n            for k in range(i, j):\n                selected[k] = True\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            selected[i:j] = [True] * (j - i)\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            selected[i:j] = [True] * (j - i)\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            for k in range(i, j):\n                selected[k] = True\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            for k in range(i, j):\n                selected[k] = True\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            for k in range(i, j):\n                selected[k] = True\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            for k in range(i, j):\n                selected[k] = True\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            selected[i:j] = [True] * (j - i)\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\n\ndef max_selectable_elements(n, a, x):\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += x\n        else:\n            i += 1\n    return sum(selected)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        x = int(data[index])\n        index += 1\n        \n        result = max_selectable_elements(n, a, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += x\n        else:\n            i += 1\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] + a[j - 1] < x * (j - i + 1):\n                j += 1\n            if j == n:\n                break\n            for k in range(i, j):\n                selected[k] = True\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            selected[i:j] = [True] * (j - i)\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            selected[i:j] = [True] * (j - i)\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            for k in range(i, j):\n                selected[k] = True\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            for k in range(i, j):\n                selected[k] = True\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            for k in range(i, j):\n                selected[k] = True\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            for k in range(i, j):\n                selected[k] = True\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    x = int(data[index])\n    index += 1\n\n    selected = [False] * n\n    i = 0\n    while i < n:\n        if a[i] >= x:\n            selected[i] = True\n            i += 1\n        else:\n            j = i + 1\n            while j < n and a[j] < x:\n                j += 1\n            if j == n:\n                break\n            selected[i:j] = [True] * (j - i)\n            i = j\n\n    results.append(sum(selected))\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Keep XOR Low",
        "question_content": "You are given an array a_1, a_2, \\ldots, a_n and an integer x.\n\nFind the number of non-empty subsets of indices of this array 1 \\leq b_1 < b_2 < \\ldots < b_k \\leq n, such that for all pairs (i, j) where 1 \\leq i < j \\leq k, the inequality a_{b_i} \\oplus a_{b_j} \\leq x is held. Here, \\oplus denotes the bitwise XOR operation. As the answer may be very large, output it modulo 998\\,244\\,353.\n\n\nInput Format\nThe first line of the input contains two integers n and x (1 \\leq n \\leq 150\\,000, 0 \\leq x < 2^{30}). Here, n is the size of the array.\n\nThe next line contains n integers a_1, a_2, \\ldots, a_n (0 \\leq a_i < 2^{30}): the array itself.\n\n\nOutput Format\nPrint one integer: the number of non-empty subsets such that the bitwise XOR of every pair of elements is at most x, modulo 998\\,244\\,353.\n\n\nSample Input 1\n\n4 2\n0 1 2 3\n\nSample Output 1\n\n8\n\n\nSample Input 2\n\n3 6\n4 2 2\n\nSample Output 2\n\n7\n\n\nSample Input 3\n\n4 0\n1 1 2 2\n\nSample Output 3\n\n6",
        "platform": "codeforces",
        "question_id": "1616/H",
        "contest_id": "1616",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    total = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n        total = (total + dp[num]) % MOD\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    count = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n        count = (count + dp[num]) % MOD\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    result = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n    \n    for i in range(1, x + 1):\n        result = (result + dp[i]) % MOD\n    \n    return result\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\nprint(count_subsets(n, x, a))\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = defaultdict(int)\n    dp[0] = 1\n    count = 0\n    \n    for num in a:\n        for key in list(dp.keys()):\n            if key ^ num <= x:\n                dp[key ^ num] = (dp[key ^ num] + dp[key]) % MOD\n            else:\n                break\n        count = (count + dp[num]) % MOD\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    count = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n    \n    for i in range(1, x + 1):\n        count = (count + dp[i]) % MOD\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = defaultdict(int)\n    dp[0] = 1\n    total = 0\n    \n    for num in a:\n        for key in list(dp.keys()):\n            if key ^ num <= x:\n                dp[key ^ num] = (dp[key ^ num] + dp[key]) % MOD\n            else:\n                break\n        total = (total + dp[num]) % MOD\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    result = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n    \n    for i in range(1, x + 1):\n        result = (result + dp[i]) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    total = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n        total = (total + dp[num]) % MOD\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    count = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n    \n    for i in range(1, x + 1):\n        count = (count + dp[i]) % MOD\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    count = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n    \n    for i in range(1, x + 1):\n        count = (count + dp[i]) % MOD\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Write output\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    total = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n        total = (total + dp[num]) % MOD\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    count = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n        count = (count + dp[num]) % MOD\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Print the result\nprint(result)",
            "MOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    result = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n    \n    for i in range(1, x + 1):\n        result = (result + dp[i]) % MOD\n    \n    return result\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\nprint(count_subsets(n, x, a))",
            "import sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = defaultdict(int)\n    dp[0] = 1\n    count = 0\n    \n    for num in a:\n        for key in list(dp.keys()):\n            if key ^ num <= x:\n                dp[key ^ num] = (dp[key ^ num] + dp[key]) % MOD\n            else:\n                break\n        count = (count + dp[num]) % MOD\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    count = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n    \n    for i in range(1, x + 1):\n        count = (count + dp[i]) % MOD\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = defaultdict(int)\n    dp[0] = 1\n    total = 0\n    \n    for num in a:\n        for key in list(dp.keys()):\n            if key ^ num <= x:\n                dp[key ^ num] = (dp[key ^ num] + dp[key]) % MOD\n            else:\n                break\n        total = (total + dp[num]) % MOD\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    result = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n    \n    for i in range(1, x + 1):\n        result = (result + dp[i]) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    total = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n        total = (total + dp[num]) % MOD\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    count = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n    \n    for i in range(1, x + 1):\n        count = (count + dp[i]) % MOD\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef count_subsets(n, x, a):\n    dp = [0] * (x + 1)\n    dp[0] = 1\n    count = 0\n    \n    for num in a:\n        for j in range(x, num - 1, -1):\n            dp[j] = (dp[j] + dp[j ^ num]) % MOD\n    \n    for i in range(1, x + 1):\n        count = (count + dp[i]) % MOD\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = int(data[1])\na = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_subsets(n, x, a)\n\n# Write output\nprint(result)"
        ]
    },
    {
        "question_title": "Shuffle",
        "question_content": "You are given a binary string (i. e. a string consisting of characters 0 and/or 1) s of length n. You can perform the following operation with the string s at most once: choose a substring (a contiguous subsequence) of s having exactly k characters 1 in it, and shuffle it (reorder the characters in the substring as you wish).\n\nCalculate the number of different strings which can be obtained from s by performing this operation at most once.\n\n\nInput Format\nThe first line contains two integers n and k (2 \\le n \\le 5000; 0 \\le k \\le n).\n\nThe second line contains the string s of length n, consisting of characters 0 and/or 1.\n\n\nOutput Format\nPrint one integer \u2014 the number of different strings which can be obtained from s by performing the described operation at most once. Since the answer can be large, output it modulo 998244353.\n\n\nSample Input 1\n\n7 2\n1100110\n\nSample Output 1\n\n16\n\n\nSample Input 2\n\n5 0\n10010\n\nSample Output 2\n\n1\n\n\nSample Input 3\n\n8 1\n10001000\n\nSample Output 3\n\n10\n\n\nSample Input 4\n\n10 8\n0010011000\n\nSample Output 4\n\n1\n\n\nNote\nSome strings you can obtain in the first example:\n\n- to obtain 0110110, you can take the substring from the 1-st character to the 4-th character, which is 1100, and reorder its characters to get 0110;\n- to obtain 1111000, you can take the substring from the 3-rd character to the 7-th character, which is 00110, and reorder its characters to get 11000;\n- to obtain 1100101, you can take the substring from the 5-th character to the 7-th character, which is 110, and reorder its characters to get 101.\n\nIn the second example, k = 0 so you can only choose the substrings consisting only of 0 characters. Reordering them doesn't change the string at all, so the only string you can obtain is 10010.",
        "platform": "codeforces",
        "question_id": "1622/D",
        "contest_id": "1622",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\nn, k = map(int, sys.stdin.readline().split())\ns = sys.stdin.readline().strip()\n\n# Calculate the number of different strings\nresult = 0\nmod = 998244353\n\n# Count the number of 1's in the string\ncount_ones = s.count('1')\n\n# If k is 0, we can only shuffle the 0's\nif k == 0:\n    # Count the number of 0's in the string\n    count_zeros = s.count('0')\n    # The number of different strings is the number of ways to choose k positions out of count_zeros\n    result = 1\n    for i in range(1, k + 1):\n        result = (result * (count_zeros - i + 1)) % mod\n        result = (result * pow(i, mod - 2, mod)) % mod\nelse:\n    # If k is not 0, we can shuffle the k 1's and the remaining 0's\n    # The number of different strings is the number of ways to choose k positions out of n\n    result = 1\n    for i in range(1, k + 1):\n        result = (result * (n - i + 1)) % mod\n        result = (result * pow(i, mod - 2, mod)) % mod\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\nMOD = 998244353\n\ndef count_distinct_strings(n, k, s):\n    # Count the number of 1s in the string\n    total_ones = s.count('1')\n    \n    # If there are no 1s, we can only get the original string\n    if total_ones == 0:\n        return 1\n    \n    # If there are exactly k 1s, we can get all permutations of these k 1s\n    if total_ones == k:\n        return (1 << k) % MOD\n    \n    # If there are more than k 1s, we need to consider all possible substrings of length k with exactly k 1s\n    count = 0\n    for i in range(n - k + 1):\n        if s[i:i+k].count('1') == k:\n            count += 1\n    \n    # Each valid substring can be permuted in (k!) ways\n    from math import factorial\n    return (count * factorial(k)) % MOD\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate and print the result\nresult = count_distinct_strings(n, k, s)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings that can be obtained\nresult = 0\nmod = 998244353\n\n# Count the number of 1's in the string\ncount_ones = s.count('1')\n\n# If there are no 1's, we can only obtain the same string\nif count_ones == 0:\n    result = 1\nelse:\n    # Calculate the number of different substrings with exactly k 1's\n    substring_count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if s[i:j].count('1') == k:\n                substring_count += 1\n    \n    # Calculate the number of different strings that can be obtained by shuffling the substring\n    result = (1 + substring_count) % mod\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings that can be obtained\nresult = 0\nmod = 998244353\n\n# Count the number of 1's in the string\ncount_ones = s.count('1')\n\n# If k is 0, we can only shuffle the 0's\nif k == 0:\n    # Count the number of 0's in the string\n    count_zeros = s.count('0')\n    # The number of different strings is the number of ways to arrange the 0's\n    result = 1\n    for i in range(1, count_zeros + 1):\n        result = (result * i) % mod\n\n# If k is not 0, we can shuffle the k 1's\nelse:\n    # Count the number of substrings of length k that contain exactly k 1's\n    count_substrings = 0\n    for i in range(n - k + 1):\n        if s[i:i+k].count('1') == k:\n            count_substrings += 1\n    # The number of different strings is the number of ways to arrange the k 1's\n    result = 1\n    for i in range(1, k + 1):\n        result = (result * i) % mod\n    # Add the number of different strings that can be obtained by shuffling the k 1's\n    result = (result * count_substrings) % mod\n\n# Print the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import Counter\n\n# Read input\nn, k = map(int, sys.stdin.readline().split())\ns = sys.stdin.readline().strip()\n\n# Calculate the number of different strings\ncount = 0\nmod = 998244353\n\n# Count the number of 1's in the string\nones = s.count('1')\n\n# If there are no 1's, the only string we can get is the original string\nif ones == 0:\n    count = 1\nelse:\n    # Calculate the number of different strings we can get by shuffling the substrings\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if substring.count('1') == k:\n                count += len(set(Counter(substring).values()))\n                count %= mod\n\n# Print the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings that can be obtained\n# by performing the operation at most once\ncount = 0\nfor i in range(n):\n    for j in range(i, n):\n        substring = s[i:j+1]\n        if substring.count('1') == k:\n            count += len(set(Counter(substring).values()))\n            count %= 998244353\n\n# Print the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings that can be obtained\n# by performing the operation at most once\nresult = 0\nmod = 998244353\n\n# Count the number of 1's in the string\ncount_ones = s.count('1')\n\n# If k is 0, we can only choose substrings consisting of 0 characters\nif k == 0:\n    result = 1\nelse:\n    # Calculate the number of different strings that can be obtained\n    # by shuffling a substring of exactly k characters 1\n    result = 1\n    for i in range(n - k + 1):\n        if s[i:i+k].count('1') == k:\n            result += 1\n\n# Output the result modulo 998244353\nprint(result % mod)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings\ncount = Counter(s)\nresult = count['1'] ** k\n\n# Output the result modulo 998244353\nprint(result % 998244353)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\nMOD = 998244353\n\ndef count_unique_strings(n, k, s):\n    # Count the number of 1's in the string\n    total_ones = s.count('1')\n    \n    # If there are no 1's, we can only get the same string\n    if total_ones == 0:\n        return 1\n    \n    # If there are exactly k 1's, we can shuffle them in k! ways\n    if total_ones == k:\n        return factorial(k) % MOD\n    \n    # If there are more than k 1's, we need to consider all possible substrings of length k\n    # and count the number of unique strings we can get by shuffling them\n    unique_strings = set()\n    for i in range(n - k + 1):\n        substring = s[i:i+k]\n        # Count the number of 1's in the substring\n        ones_in_substring = substring.count('1')\n        # If the number of 1's in the substring is exactly k, we can shuffle them\n        if ones_in_substring == k:\n            # Generate all unique permutations of the substring\n            permutations = set()\n            for perm in set(permutations_of(substring)):\n                permutations.add(perm)\n            unique_strings.update(permutations)\n    \n    # Add the original string to the set of unique strings\n    unique_strings.add(s)\n    \n    return len(unique_strings) % MOD\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef permutations_of(s):\n    if len(s) == 1:\n        return [s]\n    result = set()\n    for i in range(len(s)):\n        char = s[i]\n        remaining = s[:i] + s[i+1:]\n        for perm in permutations_of(remaining):\n            result.add(char + perm)\n    return result\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of unique strings\nresult = count_unique_strings(n, k, s)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings that can be obtained\n# by performing the operation at most once\nresult = 0\nmod = 998244353\n\n# Count the number of 1's in the string\ncount_ones = s.count('1')\n\n# If there are no 1's, we can only obtain the same string\nif count_ones == 0:\n    result = 1\nelse:\n    # Calculate the number of different strings that can be obtained\n    # by shuffling a substring with exactly k 1's\n    for i in range(n - k + 1):\n        substring = s[i:i+k]\n        count = Counter(substring)\n        if count['1'] == k:\n            result += 1\n\n# Output the result modulo 998244353\nprint(result % mod)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import Counter\n\n# Read input\nn, k = map(int, sys.stdin.readline().split())\ns = sys.stdin.readline().strip()\n\n# Calculate the number of different strings\nresult = 0\nmod = 998244353\n\n# Count the number of 1's in the string\ncount_ones = s.count('1')\n\n# If k is 0, we can only shuffle the 0's\nif k == 0:\n    # Count the number of 0's in the string\n    count_zeros = s.count('0')\n    # The number of different strings is the number of ways to choose k positions out of count_zeros\n    result = 1\n    for i in range(1, k + 1):\n        result = (result * (count_zeros - i + 1)) % mod\n        result = (result * pow(i, mod - 2, mod)) % mod\nelse:\n    # If k is not 0, we can shuffle the k 1's and the remaining 0's\n    # The number of different strings is the number of ways to choose k positions out of n\n    result = 1\n    for i in range(1, k + 1):\n        result = (result * (n - i + 1)) % mod\n        result = (result * pow(i, mod - 2, mod)) % mod\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import Counter\n\nMOD = 998244353\n\ndef count_distinct_strings(n, k, s):\n    # Count the number of 1s in the string\n    total_ones = s.count('1')\n    \n    # If there are no 1s, we can only get the original string\n    if total_ones == 0:\n        return 1\n    \n    # If there are exactly k 1s, we can get all permutations of these k 1s\n    if total_ones == k:\n        return (1 << k) % MOD\n    \n    # If there are more than k 1s, we need to consider all possible substrings of length k with exactly k 1s\n    count = 0\n    for i in range(n - k + 1):\n        if s[i:i+k].count('1') == k:\n            count += 1\n    \n    # Each valid substring can be permuted in (k!) ways\n    from math import factorial\n    return (count * factorial(k)) % MOD\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate and print the result\nresult = count_distinct_strings(n, k, s)\nprint(result)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings that can be obtained\nresult = 0\nmod = 998244353\n\n# Count the number of 1's in the string\ncount_ones = s.count('1')\n\n# If there are no 1's, we can only obtain the same string\nif count_ones == 0:\n    result = 1\nelse:\n    # Calculate the number of different substrings with exactly k 1's\n    substring_count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if s[i:j].count('1') == k:\n                substring_count += 1\n    \n    # Calculate the number of different strings that can be obtained by shuffling the substring\n    result = (1 + substring_count) % mod\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings that can be obtained\nresult = 0\nmod = 998244353\n\n# Count the number of 1's in the string\ncount_ones = s.count('1')\n\n# If k is 0, we can only shuffle the 0's\nif k == 0:\n    # Count the number of 0's in the string\n    count_zeros = s.count('0')\n    # The number of different strings is the number of ways to arrange the 0's\n    result = 1\n    for i in range(1, count_zeros + 1):\n        result = (result * i) % mod\n\n# If k is not 0, we can shuffle the k 1's\nelse:\n    # Count the number of substrings of length k that contain exactly k 1's\n    count_substrings = 0\n    for i in range(n - k + 1):\n        if s[i:i+k].count('1') == k:\n            count_substrings += 1\n    # The number of different strings is the number of ways to arrange the k 1's\n    result = 1\n    for i in range(1, k + 1):\n        result = (result * i) % mod\n    # Add the number of different strings that can be obtained by shuffling the k 1's\n    result = (result * count_substrings) % mod\n\n# Print the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import Counter\n\n# Read input\nn, k = map(int, sys.stdin.readline().split())\ns = sys.stdin.readline().strip()\n\n# Calculate the number of different strings\ncount = 0\nmod = 998244353\n\n# Count the number of 1's in the string\nones = s.count('1')\n\n# If there are no 1's, the only string we can get is the original string\nif ones == 0:\n    count = 1\nelse:\n    # Calculate the number of different strings we can get by shuffling the substrings\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if substring.count('1') == k:\n                count += len(set(Counter(substring).values()))\n                count %= mod\n\n# Print the result\nprint(count)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings that can be obtained\n# by performing the operation at most once\ncount = 0\nfor i in range(n):\n    for j in range(i, n):\n        substring = s[i:j+1]\n        if substring.count('1') == k:\n            count += len(set(Counter(substring).values()))\n            count %= 998244353\n\n# Print the result\nprint(count)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings that can be obtained\n# by performing the operation at most once\nresult = 0\nmod = 998244353\n\n# Count the number of 1's in the string\ncount_ones = s.count('1')\n\n# If k is 0, we can only choose substrings consisting of 0 characters\nif k == 0:\n    result = 1\nelse:\n    # Calculate the number of different strings that can be obtained\n    # by shuffling a substring of exactly k characters 1\n    result = 1\n    for i in range(n - k + 1):\n        if s[i:i+k].count('1') == k:\n            result += 1\n\n# Output the result modulo 998244353\nprint(result % mod)",
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings\ncount = Counter(s)\nresult = count['1'] ** k\n\n# Output the result modulo 998244353\nprint(result % 998244353)",
            "import sys\nfrom collections import Counter\n\nMOD = 998244353\n\ndef count_unique_strings(n, k, s):\n    # Count the number of 1's in the string\n    total_ones = s.count('1')\n    \n    # If there are no 1's, we can only get the same string\n    if total_ones == 0:\n        return 1\n    \n    # If there are exactly k 1's, we can shuffle them in k! ways\n    if total_ones == k:\n        return factorial(k) % MOD\n    \n    # If there are more than k 1's, we need to consider all possible substrings of length k\n    # and count the number of unique strings we can get by shuffling them\n    unique_strings = set()\n    for i in range(n - k + 1):\n        substring = s[i:i+k]\n        # Count the number of 1's in the substring\n        ones_in_substring = substring.count('1')\n        # If the number of 1's in the substring is exactly k, we can shuffle them\n        if ones_in_substring == k:\n            # Generate all unique permutations of the substring\n            permutations = set()\n            for perm in set(permutations_of(substring)):\n                permutations.add(perm)\n            unique_strings.update(permutations)\n    \n    # Add the original string to the set of unique strings\n    unique_strings.add(s)\n    \n    return len(unique_strings) % MOD\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef permutations_of(s):\n    if len(s) == 1:\n        return [s]\n    result = set()\n    for i in range(len(s)):\n        char = s[i]\n        remaining = s[:i] + s[i+1:]\n        for perm in permutations_of(remaining):\n            result.add(char + perm)\n    return result\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of unique strings\nresult = count_unique_strings(n, k, s)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\ns = data[2]\n\n# Calculate the number of different strings that can be obtained\n# by performing the operation at most once\nresult = 0\nmod = 998244353\n\n# Count the number of 1's in the string\ncount_ones = s.count('1')\n\n# If there are no 1's, we can only obtain the same string\nif count_ones == 0:\n    result = 1\nelse:\n    # Calculate the number of different strings that can be obtained\n    # by shuffling a substring with exactly k 1's\n    for i in range(n - k + 1):\n        substring = s[i:i+k]\n        count = Counter(substring)\n        if count['1'] == k:\n            result += 1\n\n# Output the result modulo 998244353\nprint(result % mod)"
        ]
    },
    {
        "question_title": "A Random Code Problem",
        "question_content": "You are given an integer array a_0, a_1, \\dots, a_{n - 1}, and an integer k. You perform the following code with it:\n\nYour task is to calculate the expected value of the variable ans after performing this code.\n\nNote that the input is generated according to special rules (see the input format section).\n\n\nInput Format\nThe only line contains six integers n, a_0, x, y, k and M (1 \\le n \\le 10^7; 1 \\le a_0, x, y < M \\le 998244353; 1 \\le k \\le 17).\n\nThe array a in the input is constructed as follows:\n\n- a_0 is given in the input;\n- for every i from 1 to n - 1, the value of a_i can be calculated as a_i = (a_{i - 1} \\cdot x + y) \\bmod M.\n\n\nOutput Format\nLet the expected value of the variable ans after performing the code be E. It can be shown that E \\cdot n^k is an integer. You have to output this integer modulo 998244353.\n\n\nSample Input 1\n\n3 10 3 5 13 88\n\nSample Output 1\n\n382842030\n\n\nSample Input 2\n\n2 15363 270880 34698 17 2357023\n\nSample Output 2\n\n319392398\n\n\nNote\nThe array in the first example test is [10, 35, 22]. In the second example, it is [15363, 1418543].",
        "platform": "codeforces",
        "question_id": "1626/F",
        "contest_id": "1626",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i]\nexpected_value *= pow(n, k, M)\nexpected_value %= M\n\n# Output the result\nprint(expected_value)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nans = 0\nfor i in range(n):\n    ans += a[i]\nans = ans * pow(n, k, M) % M\n\n# Output the result\nprint(ans)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nans = 0\nfor i in range(n):\n    ans += a[i]\nans *= pow(n, k, M)\n\n# Output the result\nprint(ans % M)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i]\nexpected_value *= pow(n, k, M)\nexpected_value %= M\n\n# Output the result\nprint(expected_value)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i]\nexpected_value *= pow(n, k, M)\nexpected_value %= M\n\n# Output the result\nprint(expected_value)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i]\nexpected_value *= pow(n, k, M)\nexpected_value %= M\n\n# Output the result\nprint(expected_value)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i] * (n - i) ** k\nexpected_value %= M\n\n# Output the result\nprint(expected_value)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Initialize the array a\na = [a0]\n\n# Generate the array a\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nans = 0\nfor i in range(n):\n    ans += a[i] * (n - i) * (i + 1)\n\n# Output the result modulo 998244353\nprint(ans % 998244353)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nans = 0\nfor i in range(n):\n    ans += a[i]\nans *= pow(n, k, M)\nans %= M\n\n# Output the result\nprint(ans)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i]\nexpected_value *= pow(n, k, M)\nexpected_value %= M\n\n# Output the result\nprint(expected_value)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i]\nexpected_value *= pow(n, k, M)\nexpected_value %= M\n\n# Output the result\nprint(expected_value)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nans = 0\nfor i in range(n):\n    ans += a[i]\nans = ans * pow(n, k, M) % M\n\n# Output the result\nprint(ans)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nans = 0\nfor i in range(n):\n    ans += a[i]\nans *= pow(n, k, M)\n\n# Output the result\nprint(ans % M)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i]\nexpected_value *= pow(n, k, M)\nexpected_value %= M\n\n# Output the result\nprint(expected_value)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i]\nexpected_value *= pow(n, k, M)\nexpected_value %= M\n\n# Output the result\nprint(expected_value)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i]\nexpected_value *= pow(n, k, M)\nexpected_value %= M\n\n# Output the result\nprint(expected_value)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i] * (n - i) ** k\nexpected_value %= M\n\n# Output the result\nprint(expected_value)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Initialize the array a\na = [a0]\n\n# Generate the array a\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nans = 0\nfor i in range(n):\n    ans += a[i] * (n - i) * (i + 1)\n\n# Output the result modulo 998244353\nprint(ans % 998244353)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nans = 0\nfor i in range(n):\n    ans += a[i]\nans *= pow(n, k, M)\nans %= M\n\n# Output the result\nprint(ans)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na0 = int(data[1])\nx = int(data[2])\ny = int(data[3])\nk = int(data[4])\nM = int(data[5])\n\n# Calculate the array a\na = [a0]\nfor i in range(1, n):\n    a.append((a[-1] * x + y) % M)\n\n# Calculate the expected value of ans\nexpected_value = 0\nfor i in range(n):\n    expected_value += a[i]\nexpected_value *= pow(n, k, M)\nexpected_value %= M\n\n# Output the result\nprint(expected_value)"
        ]
    },
    {
        "question_title": "MinimizOR",
        "question_content": "You are given an array a of n non-negative integers, numbered from 1 to n.\n\nLet's define the cost of the array a as \\displaystyle \\min_{i \\neq j} a_i | a_j, where | denotes the bitwise OR operation.\n\nThere are q queries. For each query you are given two integers l and r (l < r). For each query you should find the cost of the subarray a_{l}, a_{l + 1}, \\ldots, a_{r}.\n\n\nInput Format\nEach test case consists of several test cases. The first line contains a single integer t (1 \\le t \\le 10^4)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains an integer n (2 \\le n \\le 10^5)\u00a0\u2014 the length array a.\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (0 \\le a_i < 2^{30})\u00a0\u2014 the elements of a.\n\nThe third line of each test case contains an integer q (1 \\le q \\le 10^5)\u00a0\u2014 the number of queries.\n\nEach of the next q lines contains two integers l_j, r_j (1 \\le l_j < r_j \\le n)\u00a0\u2014 the description of the j-th query.\n\nIt is guaranteed that the sum of n and the sum of q over all test cases do not exceed 10^5.\n\n\nOutput Format\nFor each test case print q numbers, where the j-th number is the cost of array a_{l_j}, a_{l_j + 1}, \\ldots, a_{r_j}.\n\n\nSample Input 1\n\n2\n5\n6 1 3 2 1\n4\n1 2\n2 3\n2 4\n2 5\n4\n0 2 1 1073741823\n4\n1 2\n2 3\n1 3\n3 4\n\nSample Output 1\n\n7\n3\n3\n1\n2\n3\n1\n1073741823\n\n\nNote\nIn the first test case the array a is\n\n110_2, 001_2, 011_2, 010_2, 001_2.\n\nThat's why the answers for the queries are:\n\n- [1; 2]: a_1 | a_2 = 110_2 | 001_2 = 111_2 = 7;\n- [2; 3]: a_2 | a_3 = 001_2 | 011_2 = 011_2 = 3;\n- [2; 4]: a_2 | a_3 = a_3 | a_4 = a_2 | a_4 = 011_2 = 3;\n- [2; 5]: a_2 | a_5 = 001_2 = 1.\n\nIn the second test case the array a is\n\n00_2, 10_2, 01_2, \\underbrace{11\\ldots 1_2}_{30} (a_4 = 2^{30} - 1).\n\nThat's why the answers for the queries are:\n\n- [1; 2]: a_1 | a_2 = 10_2 = 2;\n- [2; 3]: a_2 | a_3 = 11_2 = 3;\n- [1; 3]: a_1 | a_3 = 01_2 = 1;\n- [3; 4]: a_3 | a_4 = 01_2 | \\underbrace{11\\ldots 1_2}_{30} = 2^{30} - 1 = 1073741823.",
        "platform": "codeforces",
        "question_id": "1665/E",
        "contest_id": "1665",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] | prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] ^ prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] ^ prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] | prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] | prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] ^ prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        cost = prefix_or[r + 1] ^ prefix_or[l]\n        results.append(cost)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    max_value = max(a)\n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    result = []\n    for l, r in queries:\n        if l == 0:\n            result.append(prefix_or[r + 1])\n        else:\n            result.append(prefix_or[r + 1] | prefix_or[l] ^ prefix_or[l + 1])\n    \n    results.extend(result)\n\nprint('\\n'.join(map(str, results)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    for l, r in queries:\n        cost = float('inf')\n        for i in range(l, r + 1):\n            for j in range(i + 1, r + 1):\n                cost = min(cost, (a[i] | a[j]))\n        results.append(cost)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] ^ prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] | prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] ^ prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] ^ prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] | prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] | prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] ^ prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        cost = prefix_or[r + 1] ^ prefix_or[l]\n        results.append(cost)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    max_value = max(a)\n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    result = []\n    for l, r in queries:\n        if l == 0:\n            result.append(prefix_or[r + 1])\n        else:\n            result.append(prefix_or[r + 1] | prefix_or[l] ^ prefix_or[l + 1])\n    \n    results.extend(result)\n\nprint('\\n'.join(map(str, results)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    for l, r in queries:\n        cost = float('inf')\n        for i in range(l, r + 1):\n            for j in range(i + 1, r + 1):\n                cost = min(cost, (a[i] | a[j]))\n        results.append(cost)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    q = int(data[index])\n    index += 1\n    queries = []\n    for _ in range(q):\n        l = int(data[index]) - 1\n        r = int(data[index + 1]) - 1\n        index += 2\n        queries.append((l, r))\n    \n    prefix_or = [0] * (n + 1)\n    for i in range(n):\n        prefix_or[i + 1] = prefix_or[i] | a[i]\n    \n    for l, r in queries:\n        result = prefix_or[r + 1] ^ prefix_or[l]\n        results.append(result)\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Permutation Counting",
        "question_content": "Calculate the number of permutations p of size n with exactly k inversions (pairs of indices (i, j) such that i < j and p_i > p_j) and exactly x indices i such that p_i > p_{i+1}.\n\nYep, that's the whole problem. Good luck!\n\n\nInput Format\nThe first line contains one integer t (1 \\le t \\le 3 \\cdot 10^4) \u2014 the number of test cases.\n\nEach test case consists of one line which contains three integers n, k and x (1 \\le n \\le 998244352; 1 \\le k \\le 11; 1 \\le x \\le 11).\n\n\nOutput Format\nFor each test case, print one integer \u2014 the answer to the problem, taken modulo 998244353.\n\n\nSample Input 1\n\n5\n10 6 4\n7 3 1\n163316 11 7\n136373 11 1\n325902 11 11\n\nSample Output 1\n\n465\n12\n986128624\n7636394\n57118194",
        "platform": "codeforces",
        "question_id": "1671/F",
        "contest_id": "1671",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (x + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, k + 1):\n        for j in range(x + 1):\n            dp[i][j] = dp[i - 1][j] * (n - i + 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i][j - 1] * (n - i) % MOD) % MOD\n    \n    return dp[k][x]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_permutations(n, k, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(x + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, x + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % MOD\n    \n    return dp[x][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(x + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, x + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j] * (n - i + 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * i) % MOD\n    \n    return dp[x][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k < x:\n        return 0\n    if k == x:\n        return comb(n, x) % MOD\n    if k == x + 1:\n        return comb(n, x) * (n - x) % MOD\n    return 0\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k < x or k > n - 1:\n        return 0\n    \n    # Calculate the number of ways to choose x positions for the inversions\n    ways_to_choose_positions = comb(n, x)\n    \n    # Calculate the number of ways to arrange the remaining elements such that the remaining inversions are exactly k - x\n    remaining_inversions = k - x\n    remaining_elements = n - x\n    \n    # Use the inclusion-exclusion principle to count the number of valid permutations\n    valid_permutations = 0\n    for i in range(remaining_inversions + 1):\n        if (remaining_inversions - i) % 2 == 0:\n            valid_permutations += comb(remaining_elements, i) * (-1) ** i\n        else:\n            valid_permutations -= comb(remaining_elements, i) * (-1) ** i\n    \n    return (ways_to_choose_positions * valid_permutations) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_permutations(n, k, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (x + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, k + 1):\n        for j in range(x + 1):\n            dp[i][j] = dp[i - 1][j] * (n - i + 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * i) % MOD\n    \n    return dp[k][x]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_permutations(n, k, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (x + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, k + 1):\n        for j in range(min(i, x) + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n                dp[i][j] %= MOD\n    \n    return dp[k][x]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(x + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, x + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i][j - 1]) % MOD\n    \n    return dp[x][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(x + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, x + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % MOD\n    \n    return dp[x][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(x + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, x + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n    \n    return dp[x][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_permutations(n, k, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (x + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, k + 1):\n        for j in range(x + 1):\n            dp[i][j] = dp[i - 1][j] * (n - i + 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i][j - 1] * (n - i) % MOD) % MOD\n    \n    return dp[k][x]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_permutations(n, k, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(x + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, x + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % MOD\n    \n    return dp[x][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(x + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, x + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j] * (n - i + 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * i) % MOD\n    \n    return dp[x][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k < x:\n        return 0\n    if k == x:\n        return comb(n, x) % MOD\n    if k == x + 1:\n        return comb(n, x) * (n - x) % MOD\n    return 0\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k < x or k > n - 1:\n        return 0\n    \n    # Calculate the number of ways to choose x positions for the inversions\n    ways_to_choose_positions = comb(n, x)\n    \n    # Calculate the number of ways to arrange the remaining elements such that the remaining inversions are exactly k - x\n    remaining_inversions = k - x\n    remaining_elements = n - x\n    \n    # Use the inclusion-exclusion principle to count the number of valid permutations\n    valid_permutations = 0\n    for i in range(remaining_inversions + 1):\n        if (remaining_inversions - i) % 2 == 0:\n            valid_permutations += comb(remaining_elements, i) * (-1) ** i\n        else:\n            valid_permutations -= comb(remaining_elements, i) * (-1) ** i\n    \n    return (ways_to_choose_positions * valid_permutations) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_permutations(n, k, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (x + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, k + 1):\n        for j in range(x + 1):\n            dp[i][j] = dp[i - 1][j] * (n - i + 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * i) % MOD\n    \n    return dp[k][x]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_permutations(n, k, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (x + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, k + 1):\n        for j in range(min(i, x) + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n                dp[i][j] %= MOD\n    \n    return dp[k][x]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(x + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, x + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i][j - 1]) % MOD\n    \n    return dp[x][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(x + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, x + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i-1][j-1] + dp[i][j-1]) % MOD\n    \n    return dp[x][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        result = count_permutations(n, k, x)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import comb\n\nMOD = 998244353\n\ndef count_permutations(n, k, x):\n    if k == 0 and x == 0:\n        return 1\n    if k == 0 or x == 0:\n        return 0\n    \n    dp = [[0] * (k + 1) for _ in range(x + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, x + 1):\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n    \n    return dp[x][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        x = int(data[index + 2])\n        index += 3\n        results.append(count_permutations(n, k, x))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Tokitsukaze and Beautiful Subsegments",
        "question_content": "Tokitsukaze has a permutation p of length n.\n\nLet's call a segment [l,r] beautiful if there exist i and j satisfying p_i \\cdot p_j = \\max\\{p_l, p_{l+1}, \\ldots, p_r \\}, where l \\leq i < j \\leq r.\n\nNow Tokitsukaze has q queries, in the i-th query she wants to know how many beautiful subsegments [x,y] there are in the segment [l_i,r_i] (i.\u00a0e. l_i \\leq x \\leq y \\leq r_i).\n\n\nInput Format\nThe first line contains two integers n and q (1\\leq n \\leq 2 \\cdot 10^5; 1 \\leq q \\leq 10^6)\u00a0\u2014 the length of permutation p and the number of queries.\n\nThe second line contains n distinct integers p_1, p_2, \\ldots, p_n (1 \\leq p_i \\leq n)\u00a0\u2014 the permutation p.\n\nEach of the next q lines contains two integers l_i and r_i (1 \\leq l_i \\leq r_i \\leq n)\u00a0\u2014 the segment [l_i,r_i] of this query.\n\n\nOutput Format\nFor each query, print one integer\u00a0\u2014 the numbers of beautiful subsegments in the segment [l_i,r_i].\n\n\nSample Input 1\n\n8 3\n1 3 5 2 4 7 6 8\n1 3\n1 1\n1 8\n\nSample Output 1\n\n2\n0\n10\n\n\nSample Input 2\n\n10 10\n6 1 3 2 5 8 4 10 7 9\n1 8\n1 10\n1 2\n1 4\n2 4\n5 8\n4 10\n4 7\n8 10\n5 9\n\nSample Output 2\n\n17\n25\n1\n5\n2\n0\n4\n1\n0\n0\n\n\nNote\nIn the first example, for the first query, there are 2 beautiful subsegments\u00a0\u2014 [1,2] and [1,3].",
        "platform": "codeforces",
        "question_id": "1677/E",
        "contest_id": "1677",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    beautiful_count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                beautiful_count += 1\n    return beautiful_count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                count += 1\n    return count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l:r+1])\n    beautiful_count = 0\n    for i in range(l, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                beautiful_count += 1\n    return beautiful_count\n\nresults = [count_beautiful_subsegments(l-1, r-1) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                count += 1\n    return count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    beautiful_count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                beautiful_count += 1\n    return beautiful_count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                count += 1\n    return count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l:r+1])\n    count = 0\n    for i in range(l, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                count += 1\n    return count\n\nresults = [count_beautiful_subsegments(l-1, r-1) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l:r+1])\n    count = 0\n    for i in range(l, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                count += 1\n    return count\n\nresults = [count_beautiful_subsegments(l-1, r-1) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    beautiful_count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                beautiful_count += 1\n    return beautiful_count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    beautiful_count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                beautiful_count += 1\n    return beautiful_count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    beautiful_count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                beautiful_count += 1\n    return beautiful_count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                count += 1\n    return count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l:r+1])\n    beautiful_count = 0\n    for i in range(l, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                beautiful_count += 1\n    return beautiful_count\n\nresults = [count_beautiful_subsegments(l-1, r-1) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                count += 1\n    return count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    beautiful_count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                beautiful_count += 1\n    return beautiful_count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                count += 1\n    return count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l:r+1])\n    count = 0\n    for i in range(l, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                count += 1\n    return count\n\nresults = [count_beautiful_subsegments(l-1, r-1) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l:r+1])\n    count = 0\n    for i in range(l, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                count += 1\n    return count\n\nresults = [count_beautiful_subsegments(l-1, r-1) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    beautiful_count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                beautiful_count += 1\n    return beautiful_count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(q)]\n\ndef count_beautiful_subsegments(l, r):\n    max_val = max(p[l-1:r])\n    beautiful_count = 0\n    for i in range(l-1, r):\n        for j in range(i+1, r+1):\n            if p[i] * p[j] == max_val:\n                beautiful_count += 1\n    return beautiful_count\n\nresults = [count_beautiful_subsegments(l, r) for l, r in queries]\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Unique Occurrences",
        "question_content": "You are given a tree, consisting of n vertices. Each edge has an integer value written on it.\n\nLet f(v, u) be the number of values that appear exactly once on the edges of a simple path between vertices v and u.\n\nCalculate the sum of f(v, u) over all pairs of vertices v and u such that 1 \\le v < u \\le n.\n\n\nInput Format\nThe first line contains a single integer n (2 \\le n \\le 5 \\cdot 10^5)\u00a0\u2014 the number of vertices in the tree.\n\nEach of the next n-1 lines contains three integers v, u and x (1 \\le v, u, x \\le n)\u00a0\u2014 the description of an edge: the vertices it connects and the value written on it.\n\nThe given edges form a tree.\n\n\nOutput Format\nPrint a single integer\u00a0\u2014 the sum of f(v, u) over all pairs of vertices v and u such that v < u.\n\n\nSample Input 1\n\n3\n1 2 1\n1 3 2\n\nSample Output 1\n\n4\n\n\nSample Input 2\n\n3\n1 2 2\n1 3 2\n\nSample Output 2\n\n2\n\n\nSample Input 3\n\n5\n1 4 4\n1 2 3\n3 4 4\n4 5 5\n\nSample Output 3\n\n14\n\n\nSample Input 4\n\n2\n2 1 1\n\nSample Output 4\n\n1\n\n\nSample Input 5\n\n10\n10 2 3\n3 8 8\n4 8 9\n5 8 5\n3 10 7\n7 8 2\n5 6 6\n9 3 4\n1 6 3\n\nSample Output 5\n\n120",
        "platform": "codeforces",
        "question_id": "1681/F",
        "contest_id": "1681",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        x = int(data[index + 2])\n        edges.append((v, u, x))\n        index += 3\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for v, u, x in edges:\n        tree[v].append((u, x))\n        tree[u].append((v, x))\n    \n    # Function to count unique edge values in the path from root to node\n    def count_unique_edges(node, parent):\n        count = defaultdict(int)\n        for neighbor, value in tree[node]:\n            if neighbor != parent:\n                count[value] += 1\n                count.update(count_unique_edges(neighbor, node))\n        return count\n    \n    # Calculate the sum of f(v, u) for all pairs (v, u) with v < u\n    total_sum = 0\n    for v in range(1, n + 1):\n        count = count_unique_edges(v, -1)\n        for value in count.values():\n            if value == 1:\n                total_sum += count[value]\n    \n    print(total_sum)\n\n# Call the solve function\nsolve()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nindex = 1\nfor _ in range(n - 1):\n    v = int(data[index])\n    u = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, x in edges:\n    tree[v].append((u, x))\n    tree[u].append((v, x))\n\n# Function to count unique values on the path from root to node\ndef count_unique_values(node, parent, path):\n    count = defaultdict(int)\n    for neighbor, value in tree[node]:\n        if neighbor != parent:\n            count[value] += 1\n            path.append(value)\n            count_unique_values(neighbor, node, path)\n            path.pop()\n    return count\n\n# Calculate the sum of f(v, u) for all pairs (v, u) such that v < u\ntotal_sum = 0\nfor v in range(1, n + 1):\n    for u in range(v + 1, n + 1):\n        path = []\n        count_v = count_unique_values(v, -1, path)\n        count_u = count_unique_values(u, -1, path)\n        for value in count_v:\n            if count_v[value] == 1:\n                total_sum += count_u[value]\n\n# Output the result\nprint(total_sum)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nedges = []\nindex = 1\nfor _ in range(n - 1):\n    v = int(data[index])\n    u = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, x in edges:\n    tree[v].append((u, x))\n    tree[u].append((v, x))\n\n# Function to count unique edge values on the path from root to node\ndef count_unique_values(node, parent):\n    count = defaultdict(int)\n    for neighbor, value in tree[node]:\n        if neighbor != parent:\n            count[value] += 1\n            for k, v in count_unique_values(neighbor, node).items():\n                count[k] += v\n    return count\n\n# Calculate the sum of f(v, u) for all pairs (v, u) such that v < u\ntotal_sum = 0\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        count = count_unique_values(i, -1)\n        total_sum += count[j]\n\n# Output the result\nprint(total_sum)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nedges = []\nindex = 1\nfor _ in range(n-1):\n    v = int(data[index]) - 1\n    u = int(data[index+1]) - 1\n    x = int(data[index+2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, _ in edges:\n    tree[v].append(u)\n    tree[u].append(v)\n\n# Function to count unique edge values in the path from root to node\ndef count_unique_edges(root, node, parent):\n    count = defaultdict(int)\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            count += count_unique_edges(root, neighbor, node)\n    count[edges[node][2]] += 1\n    return count\n\n# Calculate the sum of f(v, u) for all pairs (v, u) with v < u\ntotal_sum = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if edges[i][0] == edges[j][0] or edges[i][1] == edges[j][1]:\n            total_sum += 1\n\n# Output the result\nprint(total_sum)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        v = int(data[index])\n        u = int(data[index+1])\n        x = int(data[index+2])\n        edges.append((v, u, x))\n        index += 3\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for v, u, _ in edges:\n        tree[v].append(u)\n        tree[u].append(v)\n    \n    # Function to count unique edge values in the path from root to node\n    def count_unique_edges(node, parent):\n        count = defaultdict(int)\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                neighbor_count = count_unique_edges(neighbor, node)\n                for value, freq in neighbor_count.items():\n                    count[value] += freq\n                count[edges[(node-1)*2+1]] += 1\n        return count\n    \n    # Calculate the sum of f(v, u) for all pairs (v, u) with v < u\n    total_sum = 0\n    for i in range(1, n+1):\n        count = count_unique_edges(i, -1)\n        for value, freq in count.items():\n            if freq == 1:\n                total_sum += freq\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nedges = []\nindex = 1\nfor _ in range(n - 1):\n    v = int(data[index])\n    u = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, x in edges:\n    tree[v].append((u, x))\n    tree[u].append((v, x))\n\n# Function to count unique values on the path from root to node\ndef count_unique_values(node, parent, path_values):\n    count = 0\n    for value in path_values:\n        if path_values.count(value) == 1:\n            count += 1\n    return count\n\n# Function to calculate the sum of f(v, u) for all pairs (v, u)\ndef calculate_sum_of_f(n, tree):\n    total_sum = 0\n    for root in range(1, n + 1):\n        path_values = []\n        stack = [(root, None)]\n        while stack:\n            node, parent = stack.pop()\n            if node != root:\n                path_values.append(tree[node][0][1])\n            for neighbor, value in tree[node]:\n                if neighbor != parent:\n                    stack.append((neighbor, node))\n        total_sum += count_unique_values(root, None, path_values)\n    return total_sum\n\n# Calculate and print the result\nresult = calculate_sum_of_f(n, tree)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        v = int(data[index])\n        u = int(data[index+1])\n        x = int(data[index+2])\n        edges.append((v, u, x))\n        index += 3\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for v, u, _ in edges:\n        tree[v].append(u)\n        tree[u].append(v)\n    \n    # Function to count unique edge values on the path from root to node\n    def count_unique_edges(node, parent):\n        count = defaultdict(int)\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                count += count_unique_edges(neighbor, node)\n        count[edges[node-1][2]] += 1\n        return count\n    \n    # Calculate the sum of f(v, u) for all pairs (v, u) with v < u\n    total_sum = 0\n    for i in range(1, n+1):\n        count = count_unique_edges(i, -1)\n        for value in count.values():\n            if value == 1:\n                total_sum += count_unique_edges(i, -1)[value]\n    \n    print(total_sum)\n\n# Call the solve function\nsolve()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nedges = []\nindex = 1\nfor _ in range(n-1):\n    v = int(data[index]) - 1\n    u = int(data[index+1]) - 1\n    x = int(data[index+2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, _ in edges:\n    tree[v].append(u)\n    tree[u].append(v)\n\n# Function to perform DFS and count unique edge values\ndef dfs(node, parent, path):\n    path.append(node)\n    unique_count = defaultdict(int)\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            unique_count[neighbor] += 1\n            dfs(neighbor, node, path)\n    path.pop()\n    return unique_count\n\n# Calculate the sum of f(v, u)\ntotal_sum = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        path = []\n        unique_count = dfs(i, -1, path)\n        for k in range(len(path)):\n            if unique_count[path[k]] == 1:\n                total_sum += 1\n\n# Output the result\nprint(total_sum)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        v = int(data[index])\n        u = int(data[index+1])\n        x = int(data[index+2])\n        edges.append((v, u, x))\n        index += 3\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for v, u, x in edges:\n        tree[v].append((u, x))\n        tree[u].append((v, x))\n    \n    # Function to count unique values on the path from root to node\n    def count_unique_values(node, parent):\n        count = defaultdict(int)\n        for neighbor, value in tree[node]:\n            if neighbor != parent:\n                count[value] += 1\n                count.update(count_unique_values(neighbor, node))\n        return count\n    \n    # Calculate the sum of f(v, u) for all pairs (v, u)\n    total_sum = 0\n    for node in range(1, n+1):\n        count = count_unique_values(node, -1)\n        for value in count.values():\n            if value == 1:\n                total_sum += count[value]\n    \n    print(total_sum)\n\n# Call the solve function\nsolve()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nindex = 1\nfor _ in range(n - 1):\n    v = int(data[index])\n    u = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, x in edges:\n    tree[v].append((u, x))\n    tree[u].append((v, x))\n\n# Function to count unique edge values in the path from root to node\ndef count_unique_edges(node, parent):\n    count = defaultdict(int)\n    for neighbor, value in tree[node]:\n        if neighbor != parent:\n            count[value] += 1\n            count.update(count_unique_edges(neighbor, node))\n    return count\n\n# Calculate the sum of f(v, u) for all pairs (v, u) such that v < u\ntotal_sum = 0\nfor v in range(1, n + 1):\n    count = count_unique_edges(v, -1)\n    for value in count.values():\n        if value == 1:\n            total_sum += count[value]\n\n# Output the result\nprint(total_sum)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        v = int(data[index])\n        u = int(data[index + 1])\n        x = int(data[index + 2])\n        edges.append((v, u, x))\n        index += 3\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for v, u, x in edges:\n        tree[v].append((u, x))\n        tree[u].append((v, x))\n    \n    # Function to count unique edge values in the path from root to node\n    def count_unique_edges(node, parent):\n        count = defaultdict(int)\n        for neighbor, value in tree[node]:\n            if neighbor != parent:\n                count[value] += 1\n                count.update(count_unique_edges(neighbor, node))\n        return count\n    \n    # Calculate the sum of f(v, u) for all pairs (v, u) with v < u\n    total_sum = 0\n    for v in range(1, n + 1):\n        count = count_unique_edges(v, -1)\n        for value in count.values():\n            if value == 1:\n                total_sum += count[value]\n    \n    print(total_sum)\n\n# Call the solve function\nsolve()",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nindex = 1\nfor _ in range(n - 1):\n    v = int(data[index])\n    u = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, x in edges:\n    tree[v].append((u, x))\n    tree[u].append((v, x))\n\n# Function to count unique values on the path from root to node\ndef count_unique_values(node, parent, path):\n    count = defaultdict(int)\n    for neighbor, value in tree[node]:\n        if neighbor != parent:\n            count[value] += 1\n            path.append(value)\n            count_unique_values(neighbor, node, path)\n            path.pop()\n    return count\n\n# Calculate the sum of f(v, u) for all pairs (v, u) such that v < u\ntotal_sum = 0\nfor v in range(1, n + 1):\n    for u in range(v + 1, n + 1):\n        path = []\n        count_v = count_unique_values(v, -1, path)\n        count_u = count_unique_values(u, -1, path)\n        for value in count_v:\n            if count_v[value] == 1:\n                total_sum += count_u[value]\n\n# Output the result\nprint(total_sum)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nedges = []\nindex = 1\nfor _ in range(n - 1):\n    v = int(data[index])\n    u = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, x in edges:\n    tree[v].append((u, x))\n    tree[u].append((v, x))\n\n# Function to count unique edge values on the path from root to node\ndef count_unique_values(node, parent):\n    count = defaultdict(int)\n    for neighbor, value in tree[node]:\n        if neighbor != parent:\n            count[value] += 1\n            for k, v in count_unique_values(neighbor, node).items():\n                count[k] += v\n    return count\n\n# Calculate the sum of f(v, u) for all pairs (v, u) such that v < u\ntotal_sum = 0\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        count = count_unique_values(i, -1)\n        total_sum += count[j]\n\n# Output the result\nprint(total_sum)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nedges = []\nindex = 1\nfor _ in range(n-1):\n    v = int(data[index]) - 1\n    u = int(data[index+1]) - 1\n    x = int(data[index+2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, _ in edges:\n    tree[v].append(u)\n    tree[u].append(v)\n\n# Function to count unique edge values in the path from root to node\ndef count_unique_edges(root, node, parent):\n    count = defaultdict(int)\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            count += count_unique_edges(root, neighbor, node)\n    count[edges[node][2]] += 1\n    return count\n\n# Calculate the sum of f(v, u) for all pairs (v, u) with v < u\ntotal_sum = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if edges[i][0] == edges[j][0] or edges[i][1] == edges[j][1]:\n            total_sum += 1\n\n# Output the result\nprint(total_sum)",
            "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        v = int(data[index])\n        u = int(data[index+1])\n        x = int(data[index+2])\n        edges.append((v, u, x))\n        index += 3\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for v, u, _ in edges:\n        tree[v].append(u)\n        tree[u].append(v)\n    \n    # Function to count unique edge values in the path from root to node\n    def count_unique_edges(node, parent):\n        count = defaultdict(int)\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                neighbor_count = count_unique_edges(neighbor, node)\n                for value, freq in neighbor_count.items():\n                    count[value] += freq\n                count[edges[(node-1)*2+1]] += 1\n        return count\n    \n    # Calculate the sum of f(v, u) for all pairs (v, u) with v < u\n    total_sum = 0\n    for i in range(1, n+1):\n        count = count_unique_edges(i, -1)\n        for value, freq in count.items():\n            if freq == 1:\n                total_sum += freq\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nedges = []\nindex = 1\nfor _ in range(n - 1):\n    v = int(data[index])\n    u = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, x in edges:\n    tree[v].append((u, x))\n    tree[u].append((v, x))\n\n# Function to count unique values on the path from root to node\ndef count_unique_values(node, parent, path_values):\n    count = 0\n    for value in path_values:\n        if path_values.count(value) == 1:\n            count += 1\n    return count\n\n# Function to calculate the sum of f(v, u) for all pairs (v, u)\ndef calculate_sum_of_f(n, tree):\n    total_sum = 0\n    for root in range(1, n + 1):\n        path_values = []\n        stack = [(root, None)]\n        while stack:\n            node, parent = stack.pop()\n            if node != root:\n                path_values.append(tree[node][0][1])\n            for neighbor, value in tree[node]:\n                if neighbor != parent:\n                    stack.append((neighbor, node))\n        total_sum += count_unique_values(root, None, path_values)\n    return total_sum\n\n# Calculate and print the result\nresult = calculate_sum_of_f(n, tree)\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        v = int(data[index])\n        u = int(data[index+1])\n        x = int(data[index+2])\n        edges.append((v, u, x))\n        index += 3\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for v, u, _ in edges:\n        tree[v].append(u)\n        tree[u].append(v)\n    \n    # Function to count unique edge values on the path from root to node\n    def count_unique_edges(node, parent):\n        count = defaultdict(int)\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                count += count_unique_edges(neighbor, node)\n        count[edges[node-1][2]] += 1\n        return count\n    \n    # Calculate the sum of f(v, u) for all pairs (v, u) with v < u\n    total_sum = 0\n    for i in range(1, n+1):\n        count = count_unique_edges(i, -1)\n        for value in count.values():\n            if value == 1:\n                total_sum += count_unique_edges(i, -1)[value]\n    \n    print(total_sum)\n\n# Call the solve function\nsolve()",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nedges = []\nindex = 1\nfor _ in range(n-1):\n    v = int(data[index]) - 1\n    u = int(data[index+1]) - 1\n    x = int(data[index+2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, _ in edges:\n    tree[v].append(u)\n    tree[u].append(v)\n\n# Function to perform DFS and count unique edge values\ndef dfs(node, parent, path):\n    path.append(node)\n    unique_count = defaultdict(int)\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            unique_count[neighbor] += 1\n            dfs(neighbor, node, path)\n    path.pop()\n    return unique_count\n\n# Calculate the sum of f(v, u)\ntotal_sum = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        path = []\n        unique_count = dfs(i, -1, path)\n        for k in range(len(path)):\n            if unique_count[path[k]] == 1:\n                total_sum += 1\n\n# Output the result\nprint(total_sum)",
            "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n-1):\n        v = int(data[index])\n        u = int(data[index+1])\n        x = int(data[index+2])\n        edges.append((v, u, x))\n        index += 3\n    \n    # Build the tree\n    tree = defaultdict(list)\n    for v, u, x in edges:\n        tree[v].append((u, x))\n        tree[u].append((v, x))\n    \n    # Function to count unique values on the path from root to node\n    def count_unique_values(node, parent):\n        count = defaultdict(int)\n        for neighbor, value in tree[node]:\n            if neighbor != parent:\n                count[value] += 1\n                count.update(count_unique_values(neighbor, node))\n        return count\n    \n    # Calculate the sum of f(v, u) for all pairs (v, u)\n    total_sum = 0\n    for node in range(1, n+1):\n        count = count_unique_values(node, -1)\n        for value in count.values():\n            if value == 1:\n                total_sum += count[value]\n    \n    print(total_sum)\n\n# Call the solve function\nsolve()",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nindex = 1\nfor _ in range(n - 1):\n    v = int(data[index])\n    u = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((v, u, x))\n    index += 3\n\n# Build the tree\ntree = defaultdict(list)\nfor v, u, x in edges:\n    tree[v].append((u, x))\n    tree[u].append((v, x))\n\n# Function to count unique edge values in the path from root to node\ndef count_unique_edges(node, parent):\n    count = defaultdict(int)\n    for neighbor, value in tree[node]:\n        if neighbor != parent:\n            count[value] += 1\n            count.update(count_unique_edges(neighbor, node))\n    return count\n\n# Calculate the sum of f(v, u) for all pairs (v, u) such that v < u\ntotal_sum = 0\nfor v in range(1, n + 1):\n    count = count_unique_edges(v, -1)\n    for value in count.values():\n        if value == 1:\n            total_sum += count[value]\n\n# Output the result\nprint(total_sum)"
        ]
    },
    {
        "question_title": "Points",
        "question_content": "A triple of points i, j and k on a coordinate line is called beautiful if i < j < k and k - i \\le d.\n\nYou are given a set of points on a coordinate line, initially empty. You have to process queries of three types:\n\n- add a point;\n- remove a point;\n- calculate the number of beautiful triples consisting of points belonging to the set.\n\n\nInput Format\nThe first line contains two integers q and d (1 \\le q, d \\le 2 \\cdot 10^5) \u2014 the number of queries and the parameter for defining if a triple is beautiful, respectively.\n\nThe second line contains q integers a_1, a_2, \\dots, a_q (1 \\le a_i \\le 2 \\cdot 10^5) denoting the queries. The integer a_i denotes the i-th query in the following way:\n\n- if the point a_i belongs to the set, remove it; otherwise, add it;\n- after adding or removing the point, print the number of beautiful triples.\n\n\nOutput Format\nFor each query, print one integer \u2014 the number of beautiful triples after processing the respective query.\n\n\nSample Input 1\n\n7 5\n8 5 3 2 1 5 6\n\nSample Output 1\n\n0\n0\n1\n2\n5\n1\n5",
        "platform": "codeforces",
        "question_id": "1701/F",
        "contest_id": "1701",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nfrom sortedcontainers import SortedList\n\ndef beautiful_triples(q, d, queries):\n    points = SortedList()\n    result = []\n    \n    for query in queries:\n        if query in points:\n            points.remove(query)\n        else:\n            points.add(query)\n        \n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                k = points.bisect_right(points[j] + d)\n                if k > j:\n                    count += k - j - 1\n        \n        result.append(count)\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nd = int(data[1])\nqueries = list(map(int, data[2:]))\n\n# Get the result\nresult = beautiful_triples(q, d, queries)\n\n# Print the result\nfor count in result:\n    print(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    queries = list(map(int, data[2:]))\n    \n    points = SortedList()\n    beautiful_triples = 0\n    \n    for query in queries:\n        if query in points:\n            points.remove(query)\n            # Recalculate beautiful triples after removal\n            beautiful_triples = 0\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    for k in range(j + 1, len(points)):\n                        if points[k] - points[i] <= d:\n                            beautiful_triples += 1\n        else:\n            points.add(query)\n            # Recalculate beautiful triples after addition\n            beautiful_triples = 0\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    for k in range(j + 1, len(points)):\n                        if points[k] - points[i] <= d:\n                            beautiful_triples += 1\n        \n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nfrom sortedcontainers import SortedList\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    points = []\n    for i in range(q):\n        points.append(int(data[2 + i]))\n    \n    sl = SortedList()\n    beautiful_triples = 0\n    \n    for point in points:\n        # Remove the point if it already exists\n        if point in sl:\n            index = sl.index(point)\n            left = index - 1\n            right = index + 1\n            while left >= 0 and sl[left] + d >= point:\n                left -= 1\n            while right < len(sl) and sl[right] - d <= point:\n                right += 1\n            beautiful_triples -= (index - left - 1) * (right - index - 1)\n            sl.remove(point)\n        else:\n            # Add the point and count new beautiful triples\n            index = sl.bisect_left(point)\n            left = index - 1\n            right = index\n            while left >= 0 and sl[left] + d >= point:\n                left -= 1\n            while right < len(sl) and sl[right] - d <= point:\n                right += 1\n            beautiful_triples += (index - left - 1) * (right - index)\n            sl.add(point)\n        \n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    queries = data[2:]\n    \n    points = SortedList()\n    beautiful_triples = 0\n    \n    for i in range(q):\n        a = int(queries[i])\n        \n        if a in points:\n            points.remove(a)\n            # Recalculate beautiful triples after removal\n            beautiful_triples = 0\n            for j in range(len(points)):\n                for k in range(j + 1, len(points)):\n                    if points[k] - points[j] <= d:\n                        beautiful_triples += 1\n        else:\n            points.add(a)\n            # Recalculate beautiful triples after addition\n            beautiful_triples = 0\n            for j in range(len(points)):\n                for k in range(j + 1, len(points)):\n                    if points[k] - points[j] <= d:\n                        beautiful_triples += 1\n        \n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    queries = data[2:]\n    \n    points = SortedList()\n    beautiful_triples = 0\n    \n    for i in range(q):\n        point = int(queries[i])\n        \n        # Remove the point if it exists\n        if point in points:\n            points.remove(point)\n            # Recalculate beautiful triples after removal\n            beautiful_triples -= points.bisect_right(point - d) * (len(points) - points.bisect_left(point + 1))\n        else:\n            # Add the point\n            points.add(point)\n            # Recalculate beautiful triples after addition\n            beautiful_triples += points.bisect_right(point - d) * (len(points) - points.bisect_left(point + 1))\n        \n        # Print the number of beautiful triples\n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nfrom sortedcontainers import SortedList\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    queries = list(map(int, data[2:]))\n    \n    points = SortedList()\n    result = []\n    \n    for query in queries:\n        if query in points:\n            points.remove(query)\n        else:\n            points.add(query)\n        \n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                k = points.bisect_right(points[j] + d)\n                if k > j:\n                    count += k - j - 1\n        \n        result.append(count)\n    \n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    queries = list(map(int, data[2:]))\n    \n    points = SortedList()\n    beautiful_triples = 0\n    \n    for a in queries:\n        if a in points:\n            points.remove(a)\n            # Recalculate beautiful triples after removal\n            beautiful_triples = 0\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    for k in range(j + 1, len(points)):\n                        if points[k] - points[i] <= d:\n                            beautiful_triples += 1\n        else:\n            points.add(a)\n            # Recalculate beautiful triples after addition\n            beautiful_triples = 0\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    for k in range(j + 1, len(points)):\n                        if points[k] - points[i] <= d:\n                            beautiful_triples += 1\n        \n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\n# YOUR CODE HERE\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    points = SortedList()\n    beautiful_triples = 0\n    \n    for i in range(q):\n        point = int(data[2 + i])\n        \n        # Remove the point if it exists\n        if point in points:\n            points.remove(point)\n            # Recalculate beautiful triples after removal\n            beautiful_triples -= points.bisect_right(point - d) * (len(points) - points.bisect_left(point + 1))\n        else:\n            # Add the point\n            points.add(point)\n            # Recalculate beautiful triples after addition\n            beautiful_triples += points.bisect_right(point - d) * (len(points) - points.bisect_left(point + 1))\n        \n        # Print the number of beautiful triples\n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of queries and the parameter d\nq = int(data[0])\nd = int(data[1])\n\n# Parse the queries\nqueries = list(map(int, data[2:]))\n\n# Initialize the set of points and the sorted list of points\npoints = set()\nsorted_points = SortedList()\n\n# Initialize the number of beautiful triples\nbeautiful_triples = 0\n\n# Process each query\nfor a in queries:\n    if a in points:\n        # Remove the point\n        points.remove(a)\n        sorted_points.remove(a)\n        # Recalculate the number of beautiful triples\n        i = sorted_points.bisect_left(a - d)\n        j = sorted_points.bisect_right(a)\n        beautiful_triples -= i * (j - i - 1) // 2\n    else:\n        # Add the point\n        points.add(a)\n        sorted_points.add(a)\n        # Recalculate the number of beautiful triples\n        i = sorted_points.bisect_left(a - d)\n        j = sorted_points.bisect_right(a)\n        beautiful_triples += i * (j - i - 1) // 2\n\n    # Print the number of beautiful triples\n    print(beautiful_triples)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nd = int(data[1])\npoints = set()\nresult = []\n\nfor i in range(q):\n    a = int(data[2 + i])\n    if a in points:\n        points.remove(a)\n    else:\n        points.add(a)\n        for j in points:\n            if j <= a:\n                continue\n            for k in points:\n                if k <= j:\n                    continue\n                if k - j <= d:\n                    result.append(1)\n\n    print(sum(result))\n    result = []\n```"
        ],
        "code_list": [
            "from sortedcontainers import SortedList\n\ndef beautiful_triples(q, d, queries):\n    points = SortedList()\n    result = []\n    \n    for query in queries:\n        if query in points:\n            points.remove(query)\n        else:\n            points.add(query)\n        \n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                k = points.bisect_right(points[j] + d)\n                if k > j:\n                    count += k - j - 1\n        \n        result.append(count)\n    \n    return result\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nd = int(data[1])\nqueries = list(map(int, data[2:]))\n\n# Get the result\nresult = beautiful_triples(q, d, queries)\n\n# Print the result\nfor count in result:\n    print(count)",
            "# YOUR CODE HERE\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    queries = list(map(int, data[2:]))\n    \n    points = SortedList()\n    beautiful_triples = 0\n    \n    for query in queries:\n        if query in points:\n            points.remove(query)\n            # Recalculate beautiful triples after removal\n            beautiful_triples = 0\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    for k in range(j + 1, len(points)):\n                        if points[k] - points[i] <= d:\n                            beautiful_triples += 1\n        else:\n            points.add(query)\n            # Recalculate beautiful triples after addition\n            beautiful_triples = 0\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    for k in range(j + 1, len(points)):\n                        if points[k] - points[i] <= d:\n                            beautiful_triples += 1\n        \n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()",
            "from sortedcontainers import SortedList\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    points = []\n    for i in range(q):\n        points.append(int(data[2 + i]))\n    \n    sl = SortedList()\n    beautiful_triples = 0\n    \n    for point in points:\n        # Remove the point if it already exists\n        if point in sl:\n            index = sl.index(point)\n            left = index - 1\n            right = index + 1\n            while left >= 0 and sl[left] + d >= point:\n                left -= 1\n            while right < len(sl) and sl[right] - d <= point:\n                right += 1\n            beautiful_triples -= (index - left - 1) * (right - index - 1)\n            sl.remove(point)\n        else:\n            # Add the point and count new beautiful triples\n            index = sl.bisect_left(point)\n            left = index - 1\n            right = index\n            while left >= 0 and sl[left] + d >= point:\n                left -= 1\n            while right < len(sl) and sl[right] - d <= point:\n                right += 1\n            beautiful_triples += (index - left - 1) * (right - index)\n            sl.add(point)\n        \n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    queries = data[2:]\n    \n    points = SortedList()\n    beautiful_triples = 0\n    \n    for i in range(q):\n        a = int(queries[i])\n        \n        if a in points:\n            points.remove(a)\n            # Recalculate beautiful triples after removal\n            beautiful_triples = 0\n            for j in range(len(points)):\n                for k in range(j + 1, len(points)):\n                    if points[k] - points[j] <= d:\n                        beautiful_triples += 1\n        else:\n            points.add(a)\n            # Recalculate beautiful triples after addition\n            beautiful_triples = 0\n            for j in range(len(points)):\n                for k in range(j + 1, len(points)):\n                    if points[k] - points[j] <= d:\n                        beautiful_triples += 1\n        \n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    queries = data[2:]\n    \n    points = SortedList()\n    beautiful_triples = 0\n    \n    for i in range(q):\n        point = int(queries[i])\n        \n        # Remove the point if it exists\n        if point in points:\n            points.remove(point)\n            # Recalculate beautiful triples after removal\n            beautiful_triples -= points.bisect_right(point - d) * (len(points) - points.bisect_left(point + 1))\n        else:\n            # Add the point\n            points.add(point)\n            # Recalculate beautiful triples after addition\n            beautiful_triples += points.bisect_right(point - d) * (len(points) - points.bisect_left(point + 1))\n        \n        # Print the number of beautiful triples\n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()",
            "from sortedcontainers import SortedList\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    queries = list(map(int, data[2:]))\n    \n    points = SortedList()\n    result = []\n    \n    for query in queries:\n        if query in points:\n            points.remove(query)\n        else:\n            points.add(query)\n        \n        count = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                k = points.bisect_right(points[j] + d)\n                if k > j:\n                    count += k - j - 1\n        \n        result.append(count)\n    \n    for r in result:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    queries = list(map(int, data[2:]))\n    \n    points = SortedList()\n    beautiful_triples = 0\n    \n    for a in queries:\n        if a in points:\n            points.remove(a)\n            # Recalculate beautiful triples after removal\n            beautiful_triples = 0\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    for k in range(j + 1, len(points)):\n                        if points[k] - points[i] <= d:\n                            beautiful_triples += 1\n        else:\n            points.add(a)\n            # Recalculate beautiful triples after addition\n            beautiful_triples = 0\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    for k in range(j + 1, len(points)):\n                        if points[k] - points[i] <= d:\n                            beautiful_triples += 1\n        \n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\n# YOUR CODE HERE\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    d = int(data[1])\n    points = SortedList()\n    beautiful_triples = 0\n    \n    for i in range(q):\n        point = int(data[2 + i])\n        \n        # Remove the point if it exists\n        if point in points:\n            points.remove(point)\n            # Recalculate beautiful triples after removal\n            beautiful_triples -= points.bisect_right(point - d) * (len(points) - points.bisect_left(point + 1))\n        else:\n            # Add the point\n            points.add(point)\n            # Recalculate beautiful triples after addition\n            beautiful_triples += points.bisect_right(point - d) * (len(points) - points.bisect_left(point + 1))\n        \n        # Print the number of beautiful triples\n        print(beautiful_triples)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of queries and the parameter d\nq = int(data[0])\nd = int(data[1])\n\n# Parse the queries\nqueries = list(map(int, data[2:]))\n\n# Initialize the set of points and the sorted list of points\npoints = set()\nsorted_points = SortedList()\n\n# Initialize the number of beautiful triples\nbeautiful_triples = 0\n\n# Process each query\nfor a in queries:\n    if a in points:\n        # Remove the point\n        points.remove(a)\n        sorted_points.remove(a)\n        # Recalculate the number of beautiful triples\n        i = sorted_points.bisect_left(a - d)\n        j = sorted_points.bisect_right(a)\n        beautiful_triples -= i * (j - i - 1) // 2\n    else:\n        # Add the point\n        points.add(a)\n        sorted_points.add(a)\n        # Recalculate the number of beautiful triples\n        i = sorted_points.bisect_left(a - d)\n        j = sorted_points.bisect_right(a)\n        beautiful_triples += i * (j - i - 1) // 2\n\n    # Print the number of beautiful triples\n    print(beautiful_triples)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nd = int(data[1])\npoints = set()\nresult = []\n\nfor i in range(q):\n    a = int(data[2 + i])\n    if a in points:\n        points.remove(a)\n    else:\n        points.add(a)\n        for j in points:\n            if j <= a:\n                continue\n            for k in points:\n                if k <= j:\n                    continue\n                if k - j <= d:\n                    result.append(1)\n\n    print(sum(result))\n    result = []"
        ]
    },
    {
        "question_title": "DFS Trees",
        "question_content": "You are given a connected undirected graph consisting of n vertices and m edges. The weight of the i-th edge is i.\n\nHere is a wrong algorithm of finding a minimum spanning tree (MST) of a graph:\n\nEach of the calls findMST(1), findMST(2), ..., findMST(n) gives you a spanning tree of the graph. Determine which of these trees are minimum spanning trees.\n\n\nInput Format\nThe first line of the input contains two integers n, m (2\\le n\\le 10^5, n-1\\le m\\le 2\\cdot 10^5)\u00a0\u2014 the number of vertices and the number of edges in the graph.\n\nEach of the following m lines contains two integers u_i and v_i (1\\le u_i, v_i\\le n, u_i\\ne v_i), describing an undirected edge (u_i,v_i) in the graph. The i-th edge in the input has weight i.\n\nIt is guaranteed that the graph is connected and there is at most one edge between any pair of vertices.\n\n\nOutput Format\nYou need to output a binary string s, where s_i=1 if findMST(i) creates an MST, and s_i = 0 otherwise.\n\n\nSample Input 1\n\n5 5\n1 2\n3 5\n1 3\n3 2\n4 2\n\nSample Output 1\n\n01111\n\n\nSample Input 2\n\n10 11\n1 2\n2 5\n3 4\n4 2\n8 1\n4 5\n10 5\n9 5\n8 2\n5 7\n4 6\n\nSample Output 2\n\n0011111011\n\n\nNote\nHere is the graph given in the first example.\n\nThere is only one minimum spanning tree in this graph. A minimum spanning tree is (1,2),(3,5),(1,3),(2,4) which has weight 1+2+3+5=11.\n\nHere is a part of the process of calling findMST(1):\n\n- reset the array vis and the edge set s;\n- calling dfs(1);\n- vis[1] := true;\n- iterate through each edge (1,2),(1,3);\n- add edge (1,2) into the edge set s, calling dfs(2): vis[2] := true iterate through each edge (2,1),(2,3),(2,4); because vis[1] = true, ignore the edge (2,1); add edge (2,3) into the edge set s, calling dfs(3): ...\n\nIn the end, it will select edges (1,2),(2,3),(3,5),(2,4) with total weight 1+4+2+5=12>11, so findMST(1) does not find a minimum spanning tree.\n\nIt can be shown that the other trees are all MSTs, so the answer is 01111.",
        "platform": "codeforces",
        "question_id": "1707/C",
        "contest_id": "1707",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef findMST(k):\n    vis = [False] * (n + 1)\n    s = set()\n    q = deque([1])\n    while q:\n        u = q.popleft()\n        if vis[u]:\n            continue\n        vis[u] = True\n        for v in adj[u]:\n            if vis[v]:\n                continue\n            if len(s) < n - 1:\n                s.add((min(u, v), max(u, v)))\n                q.append(v)\n            else:\n                break\n    return sum(w for u, v, w in edges if (u, v) in s or (v, u) in s) == k * (k + 1) // 2\n\nn, m = map(int, sys.stdin.readline().split())\nedges = []\nadj = defaultdict(list)\nfor i in range(m):\n    u, v = map(int, sys.stdin.readline().split())\n    edges.append((u, v, i + 1))\n    adj[u].append(v)\n    adj[v].append(u)\n\nresult = ''.join('1' if findMST(i + 1) else '0' for i in range(n))\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight in graph[node]:\n            if neighbor == parent:\n                continue\n            if not vis[neighbor]:\n                s.add((min(node, neighbor), max(node, neighbor), weight))\n                dfs(neighbor, node)\n    \n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    mst_weight = sum(weight for _, _, weight in s)\n    min_mst_weight = sum(range(1, m + 1))\n    \n    return 1 if mst_weight == min_mst_weight else 0\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    \n    result = []\n    for i in range(1, m + 1):\n        sys.stdin = open(f'input_{i}.txt', 'r')\n        result.append(str(findMST(i)))\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight in graph[node]:\n            if not vis[neighbor]:\n                if weight == k:\n                    s.add((node, neighbor))\n                dfs(neighbor, node)\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    parent = [-1] * (n + 1)\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] == -1:\n            return x\n        parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        x_set = find(x)\n        y_set = find(y)\n        if x_set != y_set:\n            if rank[x_set] < rank[y_set]:\n                parent[x_set] = y_set\n            elif rank[x_set] > rank[y_set]:\n                parent[y_set] = x_set\n            else:\n                parent[y_set] = x_set\n                rank[x_set] += 1\n    \n    mst_weight = 0\n    for u, v in s:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += k\n    \n    return mst_weight == sum(range(1, n))\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nresult = ''.join('1' if findMST(i) else '0' for i in range(1, n + 1))\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    vis = [False] * (n + 1)\n    s = set()\n    def dfs(u):\n        vis[u] = True\n        for v in graph[u]:\n            if not vis[v] and (u, v) not in s and (v, u) not in s:\n                s.add((u, v))\n                dfs(v)\n    dfs(1)\n    if len(s) != n - 1:\n        return 0\n    total_weight = sum(k for u, v in s)\n    mst_weight = sum(i for i in range(1, m + 1) if (i, i + 1) in s or (i + 1, i) in s)\n    return 1 if total_weight == mst_weight else 0\n\nn, m = map(int, input().split())\ngraph = defaultdict(list)\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nresult = ''.join(str(findMST(k)) for k in range(1, m + 1))\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef findMST(k):\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges.append((u, v, k))\n    \n    edges.sort(key=lambda x: x[2])\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    mst_edges = []\n    for u, v, w in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_edges.append((u, v, w))\n    \n    return mst_edges\n\ndef isMST(mst_edges, n):\n    return len(mst_edges) == n - 1\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    results = []\n    for _ in range(m):\n        mst_edges = findMST(_ + 1)\n        if isMST(mst_edges, n):\n            results.append('1')\n        else:\n            results.append('0')\n    \n    print(''.join(results))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    edges.sort(key=lambda x: x[2])\n    \n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    mst_edges = []\n    for u, v, w in edges:\n        if w == k:\n            continue\n        if find(u) != find(v):\n            union(u, v)\n            mst_edges.append((u, v, w))\n    \n    visited = [False] * (n + 1)\n    def dfs(node):\n        visited[node] = True\n        for u, v, w in edges:\n            if w == k and (u == node or v == node) and not visited[v if u == node else u]:\n                dfs(v if u == node else u)\n    \n    dfs(1)\n    \n    for u, v, w in mst_edges:\n        if not visited[u] or not visited[v]:\n            return 0\n    return 1\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    edges.sort(key=lambda x: x[2])\n    \n    mst_edges = []\n    for u, v, w in edges:\n        if findMST(w):\n            mst_edges.append(w)\n    \n    mst_weight = sum(mst_edges)\n    \n    result = []\n    for u, v, w in edges:\n        if findMST(w):\n            result.append('1')\n        else:\n            result.append('0')\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight in graph[node]:\n            if not vis[neighbor]:\n                if weight == k:\n                    s.add((node, neighbor))\n                dfs(neighbor, node)\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    parent = [-1] * (n + 1)\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    for u, v in s:\n        if find(u) != find(v):\n            union(u, v)\n    \n    return len(s) == n - 1\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nresult = []\nfor k in range(1, m + 1):\n    if findMST(k):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef findMST(k):\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v, k))\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight, _ in graph[node]:\n            if not vis[neighbor]:\n                s.add((node, neighbor, weight))\n                dfs(neighbor, node)\n    \n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w, k))\n        graph[v].append((u, w, k))\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    mst_weight = sum(weight for _, _, weight in s)\n    min_mst_weight = sum(weight for u, v, weight in edges if weight <= k)\n    \n    return 1 if mst_weight == min_mst_weight else 0\n\ndef main():\n    n = int(input())\n    result = []\n    for _ in range(n):\n        result.append(str(findMST(_ + 1)))\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight in graph[node]:\n            if not vis[neighbor]:\n                if weight == k:\n                    s.add((node, neighbor))\n                dfs(neighbor, node)\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    parent = [-1] * (n + 1)\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] == -1:\n            return x\n        return find(parent[x])\n    \n    def union(x, y):\n        x_set = find(x)\n        y_set = find(y)\n        if x_set != y_set:\n            if rank[x_set] < rank[y_set]:\n                parent[x_set] = y_set\n            elif rank[x_set] > rank[y_set]:\n                parent[y_set] = x_set\n            else:\n                parent[y_set] = x_set\n                rank[x_set] += 1\n    \n    mst_edges = 0\n    total_weight = 0\n    for u, v in s:\n        u_set = find(u)\n        v_set = find(v)\n        if u_set != v_set:\n            union(u, v)\n            mst_edges += 1\n            total_weight += k\n    \n    return mst_edges == n - 1 and total_weight == (n - 1) * (n - 2) // 2 + (n - 1)\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nresult = ''.join('1' if findMST(i) else '0' for i in range(1, m + 1))\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight in graph[node]:\n            if not vis[neighbor]:\n                if weight == k:\n                    s.add((node, neighbor))\n                dfs(neighbor, node)\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    parent = [-1] * (n + 1)\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] == -1:\n            return x\n        return find(parent[x])\n    \n    def union(x, y):\n        x_set = find(x)\n        y_set = find(y)\n        if x_set != y_set:\n            if rank[x_set] < rank[y_set]:\n                parent[x_set] = y_set\n            elif rank[x_set] > rank[y_set]:\n                parent[y_set] = x_set\n            else:\n                parent[y_set] = x_set\n                rank[x_set] += 1\n    \n    mst_weight = 0\n    for u, v in s:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += k\n    \n    return mst_weight == (n - 1) * (n - 2) // 2\n\nn, m = map(int, sys.stdin.readline().split())\nedges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n\nresult = ''.join('1' if findMST(i) else '0' for i in range(1, n + 1))\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ndef findMST(k):\n    vis = [False] * (n + 1)\n    s = set()\n    q = deque([1])\n    while q:\n        u = q.popleft()\n        if vis[u]:\n            continue\n        vis[u] = True\n        for v in adj[u]:\n            if vis[v]:\n                continue\n            if len(s) < n - 1:\n                s.add((min(u, v), max(u, v)))\n                q.append(v)\n            else:\n                break\n    return sum(w for u, v, w in edges if (u, v) in s or (v, u) in s) == k * (k + 1) // 2\n\nn, m = map(int, sys.stdin.readline().split())\nedges = []\nadj = defaultdict(list)\nfor i in range(m):\n    u, v = map(int, sys.stdin.readline().split())\n    edges.append((u, v, i + 1))\n    adj[u].append(v)\n    adj[v].append(u)\n\nresult = ''.join('1' if findMST(i + 1) else '0' for i in range(n))\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight in graph[node]:\n            if neighbor == parent:\n                continue\n            if not vis[neighbor]:\n                s.add((min(node, neighbor), max(node, neighbor), weight))\n                dfs(neighbor, node)\n    \n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    mst_weight = sum(weight for _, _, weight in s)\n    min_mst_weight = sum(range(1, m + 1))\n    \n    return 1 if mst_weight == min_mst_weight else 0\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    \n    result = []\n    for i in range(1, m + 1):\n        sys.stdin = open(f'input_{i}.txt', 'r')\n        result.append(str(findMST(i)))\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight in graph[node]:\n            if not vis[neighbor]:\n                if weight == k:\n                    s.add((node, neighbor))\n                dfs(neighbor, node)\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    parent = [-1] * (n + 1)\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] == -1:\n            return x\n        parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        x_set = find(x)\n        y_set = find(y)\n        if x_set != y_set:\n            if rank[x_set] < rank[y_set]:\n                parent[x_set] = y_set\n            elif rank[x_set] > rank[y_set]:\n                parent[y_set] = x_set\n            else:\n                parent[y_set] = x_set\n                rank[x_set] += 1\n    \n    mst_weight = 0\n    for u, v in s:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += k\n    \n    return mst_weight == sum(range(1, n))\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nresult = ''.join('1' if findMST(i) else '0' for i in range(1, n + 1))\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    vis = [False] * (n + 1)\n    s = set()\n    def dfs(u):\n        vis[u] = True\n        for v in graph[u]:\n            if not vis[v] and (u, v) not in s and (v, u) not in s:\n                s.add((u, v))\n                dfs(v)\n    dfs(1)\n    if len(s) != n - 1:\n        return 0\n    total_weight = sum(k for u, v in s)\n    mst_weight = sum(i for i in range(1, m + 1) if (i, i + 1) in s or (i + 1, i) in s)\n    return 1 if total_weight == mst_weight else 0\n\nn, m = map(int, input().split())\ngraph = defaultdict(list)\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nresult = ''.join(str(findMST(k)) for k in range(1, m + 1))\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef findMST(k):\n    n, m = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        edges.append((u, v, k))\n    \n    edges.sort(key=lambda x: x[2])\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    mst_edges = []\n    for u, v, w in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_edges.append((u, v, w))\n    \n    return mst_edges\n\ndef isMST(mst_edges, n):\n    return len(mst_edges) == n - 1\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    results = []\n    for _ in range(m):\n        mst_edges = findMST(_ + 1)\n        if isMST(mst_edges, n):\n            results.append('1')\n        else:\n            results.append('0')\n    \n    print(''.join(results))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    edges.sort(key=lambda x: x[2])\n    \n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    mst_edges = []\n    for u, v, w in edges:\n        if w == k:\n            continue\n        if find(u) != find(v):\n            union(u, v)\n            mst_edges.append((u, v, w))\n    \n    visited = [False] * (n + 1)\n    def dfs(node):\n        visited[node] = True\n        for u, v, w in edges:\n            if w == k and (u == node or v == node) and not visited[v if u == node else u]:\n                dfs(v if u == node else u)\n    \n    dfs(1)\n    \n    for u, v, w in mst_edges:\n        if not visited[u] or not visited[v]:\n            return 0\n    return 1\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    edges.sort(key=lambda x: x[2])\n    \n    mst_edges = []\n    for u, v, w in edges:\n        if findMST(w):\n            mst_edges.append(w)\n    \n    mst_weight = sum(mst_edges)\n    \n    result = []\n    for u, v, w in edges:\n        if findMST(w):\n            result.append('1')\n        else:\n            result.append('0')\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight in graph[node]:\n            if not vis[neighbor]:\n                if weight == k:\n                    s.add((node, neighbor))\n                dfs(neighbor, node)\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    parent = [-1] * (n + 1)\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    for u, v in s:\n        if find(u) != find(v):\n            union(u, v)\n    \n    return len(s) == n - 1\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nresult = []\nfor k in range(1, m + 1):\n    if findMST(k):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))",
            "import sys\nfrom collections import defaultdict, deque\n\ndef findMST(k):\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v, k))\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight, _ in graph[node]:\n            if not vis[neighbor]:\n                s.add((node, neighbor, weight))\n                dfs(neighbor, node)\n    \n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w, k))\n        graph[v].append((u, w, k))\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    mst_weight = sum(weight for _, _, weight in s)\n    min_mst_weight = sum(weight for u, v, weight in edges if weight <= k)\n    \n    return 1 if mst_weight == min_mst_weight else 0\n\ndef main():\n    n = int(input())\n    result = []\n    for _ in range(n):\n        result.append(str(findMST(_ + 1)))\n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight in graph[node]:\n            if not vis[neighbor]:\n                if weight == k:\n                    s.add((node, neighbor))\n                dfs(neighbor, node)\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    parent = [-1] * (n + 1)\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] == -1:\n            return x\n        return find(parent[x])\n    \n    def union(x, y):\n        x_set = find(x)\n        y_set = find(y)\n        if x_set != y_set:\n            if rank[x_set] < rank[y_set]:\n                parent[x_set] = y_set\n            elif rank[x_set] > rank[y_set]:\n                parent[y_set] = x_set\n            else:\n                parent[y_set] = x_set\n                rank[x_set] += 1\n    \n    mst_edges = 0\n    total_weight = 0\n    for u, v in s:\n        u_set = find(u)\n        v_set = find(v)\n        if u_set != v_set:\n            union(u, v)\n            mst_edges += 1\n            total_weight += k\n    \n    return mst_edges == n - 1 and total_weight == (n - 1) * (n - 2) // 2 + (n - 1)\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\nresult = ''.join('1' if findMST(i) else '0' for i in range(1, m + 1))\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef findMST(k):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append((v, k))\n        graph[v].append((u, k))\n    \n    def dfs(node, parent):\n        vis[node] = True\n        for neighbor, weight in graph[node]:\n            if not vis[neighbor]:\n                if weight == k:\n                    s.add((node, neighbor))\n                dfs(neighbor, node)\n    \n    vis = [False] * (n + 1)\n    s = set()\n    dfs(1, -1)\n    \n    parent = [-1] * (n + 1)\n    rank = [0] * (n + 1)\n    \n    def find(x):\n        if parent[x] == -1:\n            return x\n        return find(parent[x])\n    \n    def union(x, y):\n        x_set = find(x)\n        y_set = find(y)\n        if x_set != y_set:\n            if rank[x_set] < rank[y_set]:\n                parent[x_set] = y_set\n            elif rank[x_set] > rank[y_set]:\n                parent[y_set] = x_set\n            else:\n                parent[y_set] = x_set\n                rank[x_set] += 1\n    \n    mst_weight = 0\n    for u, v in s:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += k\n    \n    return mst_weight == (n - 1) * (n - 2) // 2\n\nn, m = map(int, sys.stdin.readline().split())\nedges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n\nresult = ''.join('1' if findMST(i) else '0' for i in range(1, n + 1))\nprint(result)"
        ]
    },
    {
        "question_title": "Almost Perfect",
        "question_content": "A permutation p of length n is called almost perfect if for all integer 1 \\leq i \\leq n, it holds that \\lvert p_i - p^{-1}_i \\rvert \\le 1, where p^{-1} is the inverse permutation of p (i.e. p^{-1}_{k_1} = k_2 if and only if p_{k_2} = k_1).\n\nCount the number of almost perfect permutations of length n modulo 998244353.\n\n\nInput Format\nThe first line contains a single integer t (1 \\leq t \\leq 1000) \u2014 the number of test cases. The description of each test case follows.\n\nThe first and only line of each test case contains a single integer n (1 \\leq n \\leq 3 \\cdot 10^5) \u2014 the length of the permutation.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 3 \\cdot 10^5.\n\n\nOutput Format\nFor each test case, output a single integer \u2014 the number of almost perfect permutations of length n modulo 998244353.\n\n\nSample Input 1\n\n3\n2\n3\n50\n\nSample Output 1\n\n2\n4\n830690567\n\n\nNote\nFor n = 2, both permutations [1, 2], and [2, 1] are almost perfect.\n\nFor n = 3, there are only 6 permutations. Having a look at all of them gives us:\n\n- [1, 2, 3] is an almost perfect permutation.\n- [1, 3, 2] is an almost perfect permutation.\n- [2, 1, 3] is an almost perfect permutation.\n- [2, 3, 1] is NOT an almost perfect permutation (\\lvert p_2 - p^{-1}_2 \\rvert = \\lvert 3 - 1 \\rvert = 2).\n- [3, 1, 2] is NOT an almost perfect permutation (\\lvert p_2 - p^{-1}_2 \\rvert = \\lvert 1 - 3 \\rvert = 2).\n- [3, 2, 1] is an almost perfect permutation.\n\nSo we get 4 almost perfect permutations.",
        "platform": "codeforces",
        "question_id": "1726/E",
        "contest_id": "1726",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nMOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    dp[3] = 4\n    \n    for i in range(4, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 3]) % MOD\n    \n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    result = almost_perfect_permutations(n)\n    results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nMOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)\n```",
            "```python\nMOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)\n```",
            "```python\nMOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)\n```",
            "```python\nMOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    result = almost_perfect_permutations(n)\n    results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nMOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)\n```",
            "```python\nMOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)\n```",
            "```python\nMOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    result = almost_perfect_permutations(n)\n    results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nMOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)\n```",
            "```python\nMOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    result = almost_perfect_permutations(n)\n    results.append(result)\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "MOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    dp[3] = 4\n    \n    for i in range(4, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 3]) % MOD\n    \n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    result = almost_perfect_permutations(n)\n    results.append(result)\n\nfor result in results:\n    print(result)",
            "MOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)",
            "MOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)",
            "MOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)",
            "MOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    result = almost_perfect_permutations(n)\n    results.append(result)\n\nfor result in results:\n    print(result)",
            "MOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)",
            "MOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)",
            "MOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    result = almost_perfect_permutations(n)\n    results.append(result)\n\nfor result in results:\n    print(result)",
            "MOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    results.append(almost_perfect_permutations(n))\n\nfor result in results:\n    print(result)",
            "MOD = 998244353\n\ndef almost_perfect_permutations(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    for i in range(3, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    result = almost_perfect_permutations(n)\n    results.append(result)\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Prefixes and Suffixes",
        "question_content": "You have two strings s_1 and s_2 of length n, consisting of lowercase English letters. You can perform the following operation any (possibly zero) number of times:\n\n- Choose a positive integer 1 \\leq k \\leq n.\n- Swap the prefix of the string s_1 and the suffix of the string s_2 of length k.\n\nIs it possible to make these two strings equal by doing described operations?\n\n\nInput Format\nThe first line contains a single integer t (1 \\le t \\le 10^4) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of three lines.\n\nThe first line contains a single integer n (1 \\le n \\le 10^5) \u2014 the length of the strings s_1 and s_2.\n\nThe second line contains the string s_1 of length n, consisting of lowercase English letters.\n\nThe third line contains the string s_2 of length n, consisting of lowercase English letters.\n\nIt is guaranteed that the sum of n for all test cases does not exceed 2 \\cdot 10^5.\n\n\nOutput Format\nFor each test case, print \"YES\" if it is possible to make the strings equal, and \"NO\" otherwise.\n\n\nSample Input 1\n\n7\n3\ncbc\naba\n5\nabcaa\ncbabb\n5\nabcaa\ncbabz\n1\na\na\n1\na\nb\n6\nabadaa\nadaaba\n8\nabcabdaa\nadabcaba\n\nSample Output 1\n\nYES\nYES\nNO\nYES\nNO\nNO\nYES\n\n\nNote\nIn the first test case:\n\n- Initially s_1 = \\mathtt{cbc}, s_2 = \\mathtt{aba}.\n- Operation with k = 1, after the operation s_1 = \\mathtt{abc}, s_2 = \\mathtt{abc}.\n\nIn the second test case:\n\n- Initially s_1 = \\mathtt{abcaa}, s_2 = \\mathtt{cbabb}.\n- Operation with k = 2, after the operation s_1 = \\mathtt{bbcaa}, s_2 = \\mathtt{cbaab}.\n- Operation with k = 3, after the operation s_1 = \\mathtt{aabaa}, s_2 = \\mathtt{cbbbc}.\n- Operation with k = 1, after the operation s_1 = \\mathtt{cabaa}, s_2 = \\mathtt{cbbba}.\n- Operation with k = 2, after the operation s_1 = \\mathtt{babaa}, s_2 = \\mathtt{cbbca}.\n- Operation with k = 1, after the operation s_1 = \\mathtt{aabaa}, s_2 = \\mathtt{cbbcb}.\n- Operation with k = 2, after the operation s_1 = \\mathtt{cbbaa}, s_2 = \\mathtt{cbbaa}.\n\nIn the third test case, it's impossible to make strings equal.",
        "platform": "codeforces",
        "question_id": "1730/D",
        "contest_id": "1730",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    \n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = s1\n    suffix = s2[::-1]\n    \n    if prefix == suffix:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    s1 = data[index + 1]\n    s2 = data[index + 2]\n    index += 3\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    s1 = data[index + 1]\n    s2 = data[index + 2]\n    index += 3\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    \n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = s1[:n//2]\n    suffix = s2[n//2:]\n    \n    if prefix == suffix:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    for i in range(n):\n        if s1[i] == s2[-(i+1)]:\n            prefix += s1[i]\n            suffix += s2[-(i+1)]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    s1 = data[index + 1]\n    s2 = data[index + 2]\n    index += 3\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = s1\n    suffix = s2[::-1]\n    \n    if prefix == suffix:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    \n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = s1\n    suffix = s2[::-1]\n    \n    if prefix == suffix:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    s1 = data[index + 1]\n    s2 = data[index + 2]\n    index += 3\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    s1 = data[index + 1]\n    s2 = data[index + 2]\n    index += 3\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    \n    for i in range(n):\n        if s1[i] == s2[n-1-i]:\n            prefix += s1[i]\n            suffix += s2[n-1-i]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = s1[:n//2]\n    suffix = s2[n//2:]\n    \n    if prefix == suffix:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    s1 = data[index]\n    index += 1\n    s2 = data[index]\n    index += 1\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = \"\"\n    suffix = \"\"\n    for i in range(n):\n        if s1[i] == s2[-(i+1)]:\n            prefix += s1[i]\n            suffix += s2[-(i+1)]\n        else:\n            break\n    \n    if prefix == s1[:len(prefix)] and suffix == s2[-len(suffix):]:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    s1 = data[index + 1]\n    s2 = data[index + 2]\n    index += 3\n    \n    if s1 == s2:\n        results.append(\"YES\")\n        continue\n    \n    prefix = s1\n    suffix = s2[::-1]\n    \n    if prefix == suffix:\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Maximums and Minimums",
        "question_content": "You are given an array a_1, a_2, \\ldots, a_n of positive integers.\n\nFind the number of pairs of indices (l, r), where 1 \\le l \\le r \\le n, that pass the check. The check is performed in the following manner:\n\n1. The minimum and maximum numbers are found among a_l, a_{l+1}, \\ldots, a_r.\n2. The check is passed if the maximum number is divisible by the minimum number.\n\n\nInput Format\nThe first line contains a single integer t (1 \\le t \\le 10) \u2014 the number of test cases. Then the test cases follow.\n\nEach test case consists of two lines.\n\nThe first line contains a single integer n (1 \\le n \\le 5 \\cdot 10^5) \u2014 the size of the array.\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le 10^6).\n\nIt is guaranteed that the sum of n over all test cases does not exceed 5 \\cdot 10^5.\n\n\nOutput Format\nFor each test case, print a single integer \u2014 the number of pairs of indices that pass the check.\n\n\nSample Input 1\n\n6\n1\n1\n2\n2 4\n2\n2 3\n4\n2 4 7 14\n7\n16 5 18 7 7 12 14\n6\n16 14 2 6 16 2\n\nSample Output 1\n\n1\n3\n2\n7\n10\n19\n\n\nNote\nBelow x \\mid y denotes that y is divisible by x.\n\nIn the first test case, there is one pair (1, 1), the maximum for this pair is 1, the minimum is also 1, 1 \\mid 1, so the check is passed, and the answer is 1.\n\nIn the second test case, there are 3 segments:\n\n- (1, 1): the maximum is 2, the minimum is 2, 2 \\mid 2, so the check is passed.\n- (1, 2): the maximum is 4, the minimum is 2, 2 \\mid 4, so the check is passed.\n- (2, 2): the maximum is 4, the minimum is 4, 4 \\mid 4, so the check is passed.\n\nIn the third test case, there are 3 segments:\n\n- (1, 1): the maximum is 2, the minimum is 2, 2 \\mid 2, so the check is passed.\n- (1, 2): the maximum is 3, the minimum is 2, 3 isn't divisible by 2, so the check is failed.\n- (2, 2): the maximum is 3, the minimum is 3, 3 \\mid 3, so the check is passed.",
        "platform": "codeforces",
        "question_id": "1730/E",
        "contest_id": "1730",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = a[l]\n        max_val = a[l]\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    count = 0\n    for l in range(n):\n        min_val = float('inf')\n        max_val = float('-inf')\n        for r in range(l, n):\n            min_val = min(min_val, a[r])\n            max_val = max(max_val, a[r])\n            if max_val % min_val == 0:\n                count += 1\n    \n    results.append(count)\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Swap and Take",
        "question_content": "You're given an array consisting of n integers. You have to perform n turns.\n\nInitially your score is 0.\n\nOn the i-th turn, you are allowed to leave the array as it is or swap any one pair of 2 adjacent elements in the array and change exactly one of them to 0(and leave the value of other element unchanged) after swapping. In either case(whether you swap or not), after this you add a_i to your score.\n\nWhat's the maximum possible score you can get?\n\n\nInput Format\nThe first line contains a single integer n (2 \\le n \\le 500).\n\nThe second line contains n integers a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 10^6).\n\n\nOutput Format\nPrint a single integer\u00a0\u2014 the maximum possible score.\n\n\nSample Input 1\n\n2\n3 1\n\nSample Output 1\n\n6\n\n\nSample Input 2\n\n5\n7 3 9 6 12\n\nSample Output 2\n\n52\n\n\nNote\nIn the first example, to get the maximum score we do as follows. Do nothing on the first turn, add 3 to the score. Swap the first and the second elements and turn 1 to 0 on the second turn, and add 3 to the score. The final score is 6.",
        "platform": "codeforces",
        "question_id": "1736/E",
        "contest_id": "1736",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Calculate the maximum possible score\nmax_score = sum(a)\n\n# Print the result\nprint(max_score)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Calculate the maximum possible score\nmax_score = sum(a)\n\n# Print the result\nprint(max_score)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# The optimal strategy is to always swap and change the smaller element to 0\n# This way, we maximize the score by adding the larger element to the score\n# and then adding the smaller element (which is now 0) in the next turn\n\nscore = 0\nfor i in range(n):\n    if i % 2 == 0:\n        score += a[i]\n    else:\n        score += max(a[i], a[i-1])\n        if a[i] < a[i-1]:\n            a[i], a[i-1] = a[i-1], a[i]\n            a[i] = 0\n\nprint(score)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Initialize the score\nscore = 0\n\n# Iterate through the array and add the maximum possible value to the score\nfor i in range(n):\n    score += a[i]\n\n# Print the final score\nprint(score)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Calculate the maximum possible score\nmax_score = sum(a)\n\n# Print the result\nprint(max_score)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# The optimal strategy is to always swap and change the smaller element to 0\n# This way, we maximize the score by adding the larger element to the score\n# and then adding the smaller element (which is now 0) in the next turn\n\nscore = 0\nfor i in range(n):\n    if i % 2 == 0:\n        score += max(a[i], a[i+1])\n    else:\n        score += min(a[i], a[i+1])\n\nprint(score)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Calculate the maximum possible score\nmax_score = sum(a)\n\n# Print the result\nprint(max_score)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# The optimal strategy is to always swap and change the smaller element to 0\n# This way, we maximize the score by adding the larger element to the score\n# We can do this for all elements except the last one\nmax_score = sum(a) - min(a)\n\nprint(max_score)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the score\nscore = 0\n\n# Iterate through the array\nfor i in range(n):\n    # Add the current element to the score\n    score += a[i]\n    \n    # If the current element is not 0, swap it with the next element and change the next element to 0\n    if a[i] != 0:\n        if i + 1 < n:\n            a[i], a[i + 1] = a[i + 1], a[i]\n            a[i + 1] = 0\n\n# Print the final score\nprint(score)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# The optimal strategy is to always swap and change the smaller number to 0\n# This way, we maximize the score by always adding the larger number\nmax_score = 0\nfor i in range(n):\n    if i % 2 == 0:\n        max_score += a[i]\n    else:\n        max_score += max(a[i], a[i-1])\n\nprint(max_score)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Calculate the maximum possible score\nmax_score = sum(a)\n\n# Print the result\nprint(max_score)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Calculate the maximum possible score\nmax_score = sum(a)\n\n# Print the result\nprint(max_score)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# The optimal strategy is to always swap and change the smaller element to 0\n# This way, we maximize the score by adding the larger element to the score\n# and then adding the smaller element (which is now 0) in the next turn\n\nscore = 0\nfor i in range(n):\n    if i % 2 == 0:\n        score += a[i]\n    else:\n        score += max(a[i], a[i-1])\n        if a[i] < a[i-1]:\n            a[i], a[i-1] = a[i-1], a[i]\n            a[i] = 0\n\nprint(score)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Initialize the score\nscore = 0\n\n# Iterate through the array and add the maximum possible value to the score\nfor i in range(n):\n    score += a[i]\n\n# Print the final score\nprint(score)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Calculate the maximum possible score\nmax_score = sum(a)\n\n# Print the result\nprint(max_score)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# The optimal strategy is to always swap and change the smaller element to 0\n# This way, we maximize the score by adding the larger element to the score\n# and then adding the smaller element (which is now 0) in the next turn\n\nscore = 0\nfor i in range(n):\n    if i % 2 == 0:\n        score += max(a[i], a[i+1])\n    else:\n        score += min(a[i], a[i+1])\n\nprint(score)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array in descending order\na.sort(reverse=True)\n\n# Calculate the maximum possible score\nmax_score = sum(a)\n\n# Print the result\nprint(max_score)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# The optimal strategy is to always swap and change the smaller element to 0\n# This way, we maximize the score by adding the larger element to the score\n# We can do this for all elements except the last one\nmax_score = sum(a) - min(a)\n\nprint(max_score)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the score\nscore = 0\n\n# Iterate through the array\nfor i in range(n):\n    # Add the current element to the score\n    score += a[i]\n    \n    # If the current element is not 0, swap it with the next element and change the next element to 0\n    if a[i] != 0:\n        if i + 1 < n:\n            a[i], a[i + 1] = a[i + 1], a[i]\n            a[i + 1] = 0\n\n# Print the final score\nprint(score)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# The optimal strategy is to always swap and change the smaller number to 0\n# This way, we maximize the score by always adding the larger number\nmax_score = 0\nfor i in range(n):\n    if i % 2 == 0:\n        max_score += a[i]\n    else:\n        max_score += max(a[i], a[i-1])\n\nprint(max_score)"
        ]
    },
    {
        "question_title": "Kazaee",
        "question_content": "You have an array a consisting of n positive integers and you have to handle q queries of the following types:\n\n- 1 i x: change a_{i} to x,\n- 2 l r k: check if the number of occurrences of every positive integer in the subarray a_{l}, a_{l+1}, \\ldots a_{r} is a multiple of k (check the example for better understanding).\n\n\nInput Format\nThe first line of the input contains two integers n and q (1 \\le n , q \\le 3 \\cdot 10^5), the length of a and the number of queries.\n\nNext line contains n integers a_{1}, a_{2}, \\ldots a_{n} (1 \\le a_{i} \\le 10^9) \u2014 the elements of a.\n\nEach of the next q lines describes a query. It has one of the following forms.\n\n- 1 i x, (1 \\le i \\le n , 1 \\le x \\le 10^9), or\n- 2 l r k, (1 \\le l \\le r \\le n , 1 \\le k \\le n).\n\n\nOutput Format\nFor each query of the second type, if answer of the query is yes, print \"YES\", otherwise print \"NO\".\n\n\nSample Input 1\n\n10 8\n1234 2 3 3 2 1 1 2 3 4\n2 1 6 2\n1 1 1\n2 1 6 2\n2 1 9 2\n1 10 5\n2 1 9 3\n1 3 5\n2 3 10 2\n\nSample Output 1\n\nNO\nYES\nNO\nYES\nYES\n\n\nNote\nIn the first query, requested subarray is [1234, 2, 3, 3, 2, 1], and it's obvious that the number of occurrence of 1 isn't divisible by k = 2. So the answer is \"NO\".\n\nIn the third query, requested subarray is [1, 2, 3, 3, 2, 1], and it can be seen that the number of occurrence of every integer in this sub array is divisible by k = 2. So the answer is \"YES\".\n\nIn the sixth query, requested subarray is [1, 2, 3, 3, 2, 1, 1, 2, 3], and it can be seen that the number of occurrence of every integer in this sub array is divisible by k = 3. So the answer is \"YES\".",
        "platform": "codeforces",
        "question_id": "1746/F",
        "contest_id": "1746",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor i in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        a[query[1]] = query[2]\n    elif query[0] == 2:\n        subarray = a[query[1]:query[2] + 1]\n        count = defaultdict(int)\n        for num in subarray:\n            count[num] += 1\n        for value in count.values():\n            if value % query[3] != 0:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(a, queries):\n    for query in queries:\n        if query[0] == 1:\n            a[query[1]] = query[2]\n        elif query[0] == 2:\n            l, r, k = query[1], query[2], query[3]\n            count = defaultdict(int)\n            for i in range(l, r + 1):\n                count[a[i]] += 1\n            for v in count.values():\n                if v % k != 0:\n                    print(\"NO\")\n                    break\n            else:\n                print(\"YES\")\n\nprocess_queries(a, queries)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    else:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(n, a, queries):\n    for query in queries:\n        if query[0] == 1:\n            i, x = query[1], query[2]\n            a[i] = x\n        else:\n            l, r, k = query[1], query[2], query[3]\n            subarray = a[l:r+1]\n            count = defaultdict(int)\n            for num in subarray:\n                count[num] += 1\n            for num in count.values():\n                if num % k != 0:\n                    print(\"NO\")\n                    break\n            else:\n                print(\"YES\")\n\nprocess_queries(n, a, queries)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    else:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        a[query[1]] = query[2]\n    else:\n        l, r, k = query[1], query[2], query[3]\n        count = defaultdict(int)\n        for i in range(l, r + 1):\n            count[a[i]] += 1\n        for v in count.values():\n            if v % k != 0:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(a, queries):\n    for query in queries:\n        if query[0] == 1:\n            i, x = query[1], query[2]\n            a[i] = x\n        elif query[0] == 2:\n            l, r, k = query[1], query[2], query[3]\n            subarray = a[l:r+1]\n            count = defaultdict(int)\n            for num in subarray:\n                count[num] += 1\n            for value in count.values():\n                if value % k != 0:\n                    print(\"NO\")\n                    break\n            else:\n                print(\"YES\")\n\nprocess_queries(a, queries)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(n, a, queries):\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            i, x = query[1], query[2]\n            a[i] = x\n        elif query[0] == 2:\n            l, r, k = query[1], query[2], query[3]\n            subarray = a[l:r+1]\n            count = defaultdict(int)\n            for num in subarray:\n                count[num] += 1\n            all_divisible = True\n            for num in count.values():\n                if num % k != 0:\n                    all_divisible = False\n                    break\n            result.append(\"YES\" if all_divisible else \"NO\")\n    return result\n\nresult = process_queries(n, a, queries)\n\nfor res in result:\n    print(res)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    else:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        a[query[1]] = query[2]\n    else:\n        l, r, k = query[1], query[2], query[3]\n        count = defaultdict(int)\n        for i in range(l, r + 1):\n            count[a[i]] += 1\n        all_divisible = True\n        for c in count.values():\n            if c % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n```",
            "```python\nimport sys\nfrom collections import Counter\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor i in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        a[i] = x\n    else:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        subarray = a[l:r+1]\n        counts = Counter(subarray)\n        if all(count % k == 0 for count in counts.values()):\n            queries.append(\"YES\")\n        else:\n            queries.append(\"NO\")\n    index += 4\n\nfor query in queries:\n    print(query)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(n, a, queries):\n    for query in queries:\n        if query[0] == 1:\n            i, x = query[1], query[2]\n            a[i] = x\n        elif query[0] == 2:\n            l, r, k = query[1], query[2], query[3]\n            subarray = a[l:r+1]\n            count = defaultdict(int)\n            for num in subarray:\n                count[num] += 1\n            for value in count.values():\n                if value % k != 0:\n                    print(\"NO\")\n                    break\n            else:\n                print(\"YES\")\n\nprocess_queries(n, a, queries)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(n, a, queries):\n    for query in queries:\n        if query[0] == 1:\n            i, x = query[1], query[2]\n            a[i] = x\n        elif query[0] == 2:\n            l, r, k = query[1], query[2], query[3]\n            subarray = a[l:r+1]\n            count = defaultdict(int)\n            for num in subarray:\n                count[num] += 1\n            if all(v % k == 0 for v in count.values()):\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\nprocess_queries(n, a, queries)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor i in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        a[query[1]] = query[2]\n    elif query[0] == 2:\n        subarray = a[query[1]:query[2] + 1]\n        count = defaultdict(int)\n        for num in subarray:\n            count[num] += 1\n        for value in count.values():\n            if value % query[3] != 0:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(a, queries):\n    for query in queries:\n        if query[0] == 1:\n            a[query[1]] = query[2]\n        elif query[0] == 2:\n            l, r, k = query[1], query[2], query[3]\n            count = defaultdict(int)\n            for i in range(l, r + 1):\n                count[a[i]] += 1\n            for v in count.values():\n                if v % k != 0:\n                    print(\"NO\")\n                    break\n            else:\n                print(\"YES\")\n\nprocess_queries(a, queries)",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    else:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(n, a, queries):\n    for query in queries:\n        if query[0] == 1:\n            i, x = query[1], query[2]\n            a[i] = x\n        else:\n            l, r, k = query[1], query[2], query[3]\n            subarray = a[l:r+1]\n            count = defaultdict(int)\n            for num in subarray:\n                count[num] += 1\n            for num in count.values():\n                if num % k != 0:\n                    print(\"NO\")\n                    break\n            else:\n                print(\"YES\")\n\nprocess_queries(n, a, queries)",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    else:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        a[query[1]] = query[2]\n    else:\n        l, r, k = query[1], query[2], query[3]\n        count = defaultdict(int)\n        for i in range(l, r + 1):\n            count[a[i]] += 1\n        for v in count.values():\n            if v % k != 0:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(a, queries):\n    for query in queries:\n        if query[0] == 1:\n            i, x = query[1], query[2]\n            a[i] = x\n        elif query[0] == 2:\n            l, r, k = query[1], query[2], query[3]\n            subarray = a[l:r+1]\n            count = defaultdict(int)\n            for num in subarray:\n                count[num] += 1\n            for value in count.values():\n                if value % k != 0:\n                    print(\"NO\")\n                    break\n            else:\n                print(\"YES\")\n\nprocess_queries(a, queries)",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(n, a, queries):\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            i, x = query[1], query[2]\n            a[i] = x\n        elif query[0] == 2:\n            l, r, k = query[1], query[2], query[3]\n            subarray = a[l:r+1]\n            count = defaultdict(int)\n            for num in subarray:\n                count[num] += 1\n            all_divisible = True\n            for num in count.values():\n                if num % k != 0:\n                    all_divisible = False\n                    break\n            result.append(\"YES\" if all_divisible else \"NO\")\n    return result\n\nresult = process_queries(n, a, queries)\n\nfor res in result:\n    print(res)",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    else:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        a[query[1]] = query[2]\n    else:\n        l, r, k = query[1], query[2], query[3]\n        count = defaultdict(int)\n        for i in range(l, r + 1):\n            count[a[i]] += 1\n        all_divisible = True\n        for c in count.values():\n            if c % k != 0:\n                all_divisible = False\n                break\n        if all_divisible:\n            print(\"YES\")\n        else:\n            print(\"NO\")",
            "import sys\nfrom collections import Counter\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor i in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        a[i] = x\n    else:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        subarray = a[l:r+1]\n        counts = Counter(subarray)\n        if all(count % k == 0 for count in counts.values()):\n            queries.append(\"YES\")\n        else:\n            queries.append(\"NO\")\n    index += 4\n\nfor query in queries:\n    print(query)",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(n, a, queries):\n    for query in queries:\n        if query[0] == 1:\n            i, x = query[1], query[2]\n            a[i] = x\n        elif query[0] == 2:\n            l, r, k = query[1], query[2], query[3]\n            subarray = a[l:r+1]\n            count = defaultdict(int)\n            for num in subarray:\n                count[num] += 1\n            for value in count.values():\n                if value % k != 0:\n                    print(\"NO\")\n                    break\n            else:\n                print(\"YES\")\n\nprocess_queries(n, a, queries)",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        x = int(data[index + 2])\n        queries.append((query_type, i, x))\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        k = int(data[index + 3])\n        queries.append((query_type, l, r, k))\n    index += 4\n\ndef process_queries(n, a, queries):\n    for query in queries:\n        if query[0] == 1:\n            i, x = query[1], query[2]\n            a[i] = x\n        elif query[0] == 2:\n            l, r, k = query[1], query[2], query[3]\n            subarray = a[l:r+1]\n            count = defaultdict(int)\n            for num in subarray:\n                count[num] += 1\n            if all(v % k == 0 for v in count.values()):\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\nprocess_queries(n, a, queries)"
        ]
    },
    {
        "question_title": "Another Array Problem",
        "question_content": "You are given an array a of n integers. You are allowed to perform the following operation on it as many times as you want (0 or more times):\n\n- Choose 2 indices i,j where 1 \\le i < j \\le n and replace a_k for all i \\leq k \\leq j with |a_i - a_j|\n\nPrint the maximum sum of all the elements of the final array that you can obtain in such a way.\n\n\nInput Format\nThe first line contains a single integer t (1 \\le t \\le 10^5)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer n (2 \\le n \\le 2 \\cdot 10^5)\u00a0\u2014 the length of the array a.\n\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 10^9)\u00a0\u2014 the elements of array a.\n\nIt's guaranteed that the sum of n over all test cases does not exceed 2 \\cdot 10^5.\n\n\nOutput Format\nFor each test case, print the sum of the final array.\n\n\nSample Input 1\n\n3\n3\n1 1 1\n2\n9 1\n3\n4 9 5\n\nSample Output 1\n\n3\n16\n18\n\n\nNote\nIn the first test case, it is not possible to achieve a sum > 3 by using these operations, therefore the maximum sum is 3.\n\nIn the second test case, it can be shown that the maximum sum achievable is 16. By using operation (1,2) we transform the array from [9,1] into [8,8], thus the sum of the final array is 16.\n\nIn the third test case, it can be shown that it is not possible to achieve a sum > 18 by using these operations, therefore the maximum sum is 18.",
        "platform": "codeforces",
        "question_id": "1763/C",
        "contest_id": "1763",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element\n    min_val = min(a)\n    max_sum = n * min_val\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nfor _ in range(t):\n    # Length of the array\n    n = int(data[index])\n    index += 1\n    \n    # Elements of the array\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Sort the array to maximize the sum\n    a.sort()\n    \n    # The maximum sum is achieved by keeping the largest element and making all other elements equal to it\n    max_sum = a[-1] * n\n    \n    # Print the result for the current test case\n    print(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = n * min_val\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum we can achieve is by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = min_val * n\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element\n    min_val = min(a)\n    max_sum = min_val * n\n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = n * min_val\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum we can achieve is by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = n * min_val\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = n * min_val\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = min_val * n\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = min_val * n\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element\n    min_val = min(a)\n    max_sum = n * min_val\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of test cases\nt = int(data[0])\n\n# Initialize index for data list\nindex = 1\n\n# Process each test case\nfor _ in range(t):\n    # Length of the array\n    n = int(data[index])\n    index += 1\n    \n    # Elements of the array\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # Sort the array to maximize the sum\n    a.sort()\n    \n    # The maximum sum is achieved by keeping the largest element and making all other elements equal to it\n    max_sum = a[-1] * n\n    \n    # Print the result for the current test case\n    print(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = n * min_val\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum we can achieve is by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = min_val * n\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element\n    min_val = min(a)\n    max_sum = min_val * n\n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = n * min_val\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum we can achieve is by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = n * min_val\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = n * min_val\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = min_val * n\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    # The maximum sum is achieved by making all elements equal to the minimum element in the array\n    min_val = min(a)\n    max_sum = min_val * n\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Wonderful Jump",
        "question_content": "You are given an array of positive integers a_1,a_2,\\ldots,a_n of length n.\n\nIn one operation you can jump from index i to index j (1 \\le i \\le j \\le n) by paying \\min(a_i, a_{i + 1}, \\ldots, a_j) \\cdot (j - i)^2 eris.\n\nFor all k from 1 to n, find the minimum number of eris needed to get from index 1 to index k.\n\n\nInput Format\nThe first line contains a single integer n (2 \\le n \\le 4 \\cdot 10^5).\n\nThe second line contains n integers a_1,a_2,\\ldots a_n (1 \\le a_i \\le n).\n\n\nOutput Format\nOutput n integers\u00a0\u2014 the k-th integer is the minimum number of eris needed to reach index k if you start from index 1.\n\n\nSample Input 1\n\n3\n2 1 3\n\nSample Output 1\n\n0 1 2\n\n\nSample Input 2\n\n6\n1 4 1 6 3 2\n\nSample Output 2\n\n0 1 2 3 6 8\n\n\nSample Input 3\n\n2\n1 2\n\nSample Output 3\n\n0 1\n\n\nSample Input 4\n\n4\n1 4 4 4\n\nSample Output 4\n\n0 1 4 8\n\n\nNote\nIn the first example:\n\n- From 1 to 1: the cost is 0,\n- From 1 to 2: 1 \\rightarrow 2 \u2014 the cost is \\min(2, 1) \\cdot (2 - 1) ^ 2=1,\n- From 1 to 3: 1 \\rightarrow 2 \\rightarrow 3 \u2014 the cost is \\min(2, 1) \\cdot (2 - 1) ^ 2 + \\min(1, 3) \\cdot (3 - 2) ^ 2 = 1 + 1 = 2.\n\nIn the fourth example from 1 to 4: 1 \\rightarrow 3 \\rightarrow 4 \u2014 the cost is \\min(1, 4, 4) \\cdot (3 - 1) ^ 2 + \\min(4, 4) \\cdot (4 - 3) ^ 2 = 4 + 4 = 8.",
        "platform": "codeforces",
        "question_id": "1768/F",
        "contest_id": "1768",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array with infinity\nresult = [float('inf')] * n\nresult[0] = 0\n\n# Iterate over each position k\nfor k in range(1, n):\n    # Iterate over each possible starting position i\n    for i in range(k):\n        # Calculate the cost to jump from i to k\n        cost = min(a[i:k+1]) * (k - i) ** 2\n        # Update the result for position k\n        result[k] = min(result[k], result[i] + cost)\n\n# Output the result\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndp = [0] * n\nmin_val = a[0]\n\nfor i in range(1, n):\n    min_val = min(min_val, a[i])\n    dp[i] = dp[i-1] + min_val * (i - (i-1))**2\n\nfor i in range(1, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-1:i+1]) * (i - (i-1))**2)\n\nfor i in range(2, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-2:i+1]) * (i - (i-2))**2)\n\nfor i in range(3, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-3:i+1]) * (i - (i-3))**2)\n\nfor i in range(4, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-4:i+1]) * (i - (i-4))**2)\n\nfor i in range(5, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-5:i+1]) * (i - (i-5))**2)\n\nfor i in range(6, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-6:i+1]) * (i - (i-6))**2)\n\nfor i in range(7, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-7:i+1]) * (i - (i-7))**2)\n\nfor i in range(8, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-8:i+1]) * (i - (i-8))**2)\n\nfor i in range(9, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-9:i+1]) * (i - (i-9))**2)\n\nfor i in range(10, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-10:i+1]) * (i - (i-10))**2)\n\nfor i in range(11, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-11:i+1]) * (i - (i-11))**2)\n\nfor i in range(12, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-12:i+1]) * (i - (i-12))**2)\n\nfor i in range(13, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-13:i+1]) * (i - (i-13))**2)\n\nfor i in range(14, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-14:i+1]) * (i - (i-14))**2)\n\nfor i in range(15, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-15:i+1]) * (i - (i-15))**2)\n\nfor i in range(16, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-16:i+1]) * (i - (i-16))**2)\n\nfor i in range(17, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-17:i+1]) * (i - (i-17))**2)\n\nfor i in range(18, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-18:i+1]) * (i - (i-18))**2)\n\nfor i in range(19, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-19:i+1]) * (i - (i-19))**2)\n\nfor i in range(20, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-20:i+1]) * (i - (i-20))**2)\n\nfor i in range(21, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-21:i+1]) * (i - (i-21))**2)\n\nfor i in range(22, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-22:i+1]) * (i - (i-22))**2)\n\nfor i in range(23, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-23:i+1]) * (i - (i-23))**2)\n\nfor i in range(24, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-24:i+1]) * (i - (i-24))**2)\n\nfor i in range(25, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-25:i+1]) * (i - (i-25))**2)\n\nfor i in range(26, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-26:i+1]) * (i - (i-26))**2)\n\nfor i in range(27, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-27:i+1]) * (i - (i-27))**2)\n\nfor i in range(28, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-28:i+1]) * (i - (i-28))**2)\n\nfor i in range(29, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-29:i+1]) * (i - (i-29))**2)\n\nfor i in range(30, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-30:i+1]) * (i - (i-30))**2)\n\nfor i in range(31, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-31:i+1]) * (i - (i-31))**2)\n\nfor i in range(32, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-32:i+1]) * (i - (i-32))**2)\n\nfor i in range(33, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-33:i+1]) * (i - (i-33))**2)\n\nfor i in range(34, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-34:i+1]) * (i - (i-34))**2)\n\nfor i in range(35, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-35:i+1]) * (i - (i-35))**2)\n\nfor i in range(36, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-36:i+1]) * (i - (i-36))**2)\n\nfor i in range(37, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-37:i+1]) * (i - (i-37))**2)\n\nfor i in range(38, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-38:i+1]) * (i - (i-38))**2)\n\nfor i in range(39, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-39:i+1]) * (i - (i-39))**2)\n\nfor i in range(40, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-40:i+1]) * (i - (i-40))**2)\n\nfor i in range(41, n):\n   ",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array\nresult = [0] * n\n\n# Iterate over each position k\nfor k in range(1, n):\n    min_cost = float('inf')\n    min_val = float('inf')\n    # Iterate over each possible starting position i\n    for i in range(k, -1, -1):\n        min_val = min(min_val, a[i])\n        cost = min_val * (k - i) ** 2\n        min_cost = min(min_cost, cost)\n        result[k] = min_cost\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndp = [0] * n\nmin_val = a[0]\n\nfor i in range(1, n):\n    min_val = min(min_val, a[i])\n    dp[i] = dp[i-1] + min_val * (i - (i-1))**2\n\nfor i in range(1, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-1:i+1]) * (i - (i-1))**2)\n\nfor i in range(2, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-2:i+1]) * (i - (i-2))**2)\n\nfor i in range(3, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-3:i+1]) * (i - (i-3))**2)\n\nfor i in range(4, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-4:i+1]) * (i - (i-4))**2)\n\nfor i in range(5, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-5:i+1]) * (i - (i-5))**2)\n\nfor i in range(6, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-6:i+1]) * (i - (i-6))**2)\n\nfor i in range(7, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-7:i+1]) * (i - (i-7))**2)\n\nfor i in range(8, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-8:i+1]) * (i - (i-8))**2)\n\nfor i in range(9, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-9:i+1]) * (i - (i-9))**2)\n\nfor i in range(10, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-10:i+1]) * (i - (i-10))**2)\n\nfor i in range(11, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-11:i+1]) * (i - (i-11))**2)\n\nfor i in range(12, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-12:i+1]) * (i - (i-12))**2)\n\nfor i in range(13, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-13:i+1]) * (i - (i-13))**2)\n\nfor i in range(14, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-14:i+1]) * (i - (i-14))**2)\n\nfor i in range(15, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-15:i+1]) * (i - (i-15))**2)\n\nfor i in range(16, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-16:i+1]) * (i - (i-16))**2)\n\nfor i in range(17, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-17:i+1]) * (i - (i-17))**2)\n\nfor i in range(18, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-18:i+1]) * (i - (i-18))**2)\n\nfor i in range(19, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-19:i+1]) * (i - (i-19))**2)\n\nfor i in range(20, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-20:i+1]) * (i - (i-20))**2)\n\nfor i in range(21, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-21:i+1]) * (i - (i-21))**2)\n\nfor i in range(22, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-22:i+1]) * (i - (i-22))**2)\n\nfor i in range(23, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-23:i+1]) * (i - (i-23))**2)\n\nfor i in range(24, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-24:i+1]) * (i - (i-24))**2)\n\nfor i in range(25, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-25:i+1]) * (i - (i-25))**2)\n\nfor i in range(26, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-26:i+1]) * (i - (i-26))**2)\n\nfor i in range(27, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-27:i+1]) * (i - (i-27))**2)\n\nfor i in range(28, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-28:i+1]) * (i - (i-28))**2)\n\nfor i in range(29, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-29:i+1]) * (i - (i-29))**2)\n\nfor i in range(30, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-30:i+1]) * (i - (i-30))**2)\n\nfor i in range(31, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-31:i+1]) * (i - (i-31))**2)\n\nfor i in range(32, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-32:i+1]) * (i - (i-32))**2)\n\nfor i in range(33, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-33:i+1]) * (i - (i-33))**2)\n\nfor i in range(34, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-34:i+1]) * (i - (i-34))**2)\n\nfor i in range(35, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-35:i+1]) * (i - (i-35))**2)\n\nfor i in range(36, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-36:i+1]) * (i - (i-36))**2)\n\nfor i in range(37, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-37:i+1]) * (i - (i-37))**2)\n\nfor i in range(38, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-38:i+1]) * (i - (i-38))**2)\n\nfor i in range(39, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-39:i+1]) * (i - (i-39))**2)\n\nfor i in range(40, n):\n    dp[i] = min(dp[i], dp[i-1] + min(a[i-40:i+1]) * (i - (i-40))**2)\n\nfor i in range(41, n):\n   ",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array with infinity\ndp = [float('inf')] * n\ndp[0] = 0\n\n# Iterate over each index k\nfor k in range(1, n):\n    # Iterate over each possible starting index i for the jump\n    for i in range(k):\n        # Calculate the cost of jumping from i to k\n        cost = min(a[i:k+1]) * (k - i) ** 2\n        # Update the minimum cost to reach index k\n        dp[k] = min(dp[k], dp[i] + cost)\n\n# Output the result\nprint(' '.join(map(str, dp)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array\nresult = [0] * n\n\n# Iterate over each index k from 1 to n\nfor k in range(1, n):\n    min_cost = float('inf')\n    min_value = float('inf')\n    # Iterate over each index i from 1 to k\n    for i in range(k, 0, -1):\n        min_value = min(min_value, a[i-1])\n        cost = min_value * (k - i + 1) ** 2\n        min_cost = min(min_cost, cost)\n        result[k] = min_cost\n\n# Output the result\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndp = [float('inf')] * n\ndp[0] = 0\n\nfor i in range(1, n):\n    min_val = a[i]\n    for j in range(i, -1, -1):\n        min_val = min(min_val, a[j])\n        dp[i] = min(dp[i], dp[j] + min_val * (i - j) ** 2)\n\nfor i in range(n):\n    print(dp[i], end=' ')\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array with infinity\ndp = [float('inf')] * n\ndp[0] = 0\n\n# Iterate over each index k\nfor k in range(1, n):\n    # Iterate over each possible starting index i\n    for i in range(k):\n        # Calculate the cost to jump from i to k\n        cost = min(a[i:k+1]) * (k - i) ** 2\n        # Update the dp array\n        dp[k] = min(dp[k], dp[i] + cost)\n\n# Output the result\nprint(' '.join(map(str, dp)))\n```",
            "```python\nimport sys\n\ndef min_eris_to_reach_index(n, a):\n    dp = [float('inf')] * n\n    dp[0] = 0\n    min_val = a[0]\n    \n    for i in range(1, n):\n        min_val = min(min_val, a[i])\n        for j in range(i, -1, -1):\n            dp[i] = min(dp[i], dp[j] + min_val * (i - j) ** 2)\n    \n    return dp\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = min_eris_to_reach_index(n, a)\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array with infinity\nresult = [float('inf')] * n\nresult[0] = 0\n\n# Iterate over each index k from 2 to n\nfor k in range(1, n):\n    # Iterate over each index i from 1 to k\n    for i in range(k):\n        # Calculate the minimum cost to jump from i to k\n        cost = min(a[i:k+1]) * (k - i) ** 2\n        # Update the result for index k\n        result[k] = min(result[k], result[i] + cost)\n\n# Output the result\nprint(' '.join(map(str, result)))\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array with infinity\nresult = [float('inf')] * n\nresult[0] = 0\n\n# Iterate over each position k\nfor k in range(1, n):\n    # Iterate over each possible starting position i\n    for i in range(k):\n        # Calculate the cost to jump from i to k\n        cost = min(a[i:k+1]) * (k - i) ** 2\n        # Update the result for position k\n        result[k] = min(result[k], result[i] + cost)\n\n# Output the result\nprint(' '.join(map(str, result)))",
            "",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array\nresult = [0] * n\n\n# Iterate over each position k\nfor k in range(1, n):\n    min_cost = float('inf')\n    min_val = float('inf')\n    # Iterate over each possible starting position i\n    for i in range(k, -1, -1):\n        min_val = min(min_val, a[i])\n        cost = min_val * (k - i) ** 2\n        min_cost = min(min_cost, cost)\n        result[k] = min_cost\n\n# Print the result\nprint(' '.join(map(str, result)))",
            "",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array with infinity\ndp = [float('inf')] * n\ndp[0] = 0\n\n# Iterate over each index k\nfor k in range(1, n):\n    # Iterate over each possible starting index i for the jump\n    for i in range(k):\n        # Calculate the cost of jumping from i to k\n        cost = min(a[i:k+1]) * (k - i) ** 2\n        # Update the minimum cost to reach index k\n        dp[k] = min(dp[k], dp[i] + cost)\n\n# Output the result\nprint(' '.join(map(str, dp)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array\nresult = [0] * n\n\n# Iterate over each index k from 1 to n\nfor k in range(1, n):\n    min_cost = float('inf')\n    min_value = float('inf')\n    # Iterate over each index i from 1 to k\n    for i in range(k, 0, -1):\n        min_value = min(min_value, a[i-1])\n        cost = min_value * (k - i + 1) ** 2\n        min_cost = min(min_cost, cost)\n        result[k] = min_cost\n\n# Output the result\nprint(' '.join(map(str, result)))",
            "import sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndp = [float('inf')] * n\ndp[0] = 0\n\nfor i in range(1, n):\n    min_val = a[i]\n    for j in range(i, -1, -1):\n        min_val = min(min_val, a[j])\n        dp[i] = min(dp[i], dp[j] + min_val * (i - j) ** 2)\n\nfor i in range(n):\n    print(dp[i], end=' ')",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array with infinity\ndp = [float('inf')] * n\ndp[0] = 0\n\n# Iterate over each index k\nfor k in range(1, n):\n    # Iterate over each possible starting index i\n    for i in range(k):\n        # Calculate the cost to jump from i to k\n        cost = min(a[i:k+1]) * (k - i) ** 2\n        # Update the dp array\n        dp[k] = min(dp[k], dp[i] + cost)\n\n# Output the result\nprint(' '.join(map(str, dp)))",
            "import sys\n\ndef min_eris_to_reach_index(n, a):\n    dp = [float('inf')] * n\n    dp[0] = 0\n    min_val = a[0]\n    \n    for i in range(1, n):\n        min_val = min(min_val, a[i])\n        for j in range(i, -1, -1):\n            dp[i] = min(dp[i], dp[j] + min_val * (i - j) ** 2)\n    \n    return dp\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = min_eris_to_reach_index(n, a)\nprint(' '.join(map(str, result)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result array with infinity\nresult = [float('inf')] * n\nresult[0] = 0\n\n# Iterate over each index k from 2 to n\nfor k in range(1, n):\n    # Iterate over each index i from 1 to k\n    for i in range(k):\n        # Calculate the minimum cost to jump from i to k\n        cost = min(a[i:k+1]) * (k - i) ** 2\n        # Update the result for index k\n        result[k] = min(result[k], result[i] + cost)\n\n# Output the result\nprint(' '.join(map(str, result)))"
        ]
    },
    {
        "question_title": "Hossam and Range Minimum Query",
        "question_content": "Hossam gives you a sequence of integers a_1, \\, a_2, \\, \\dots, \\, a_n of length n. Moreover, he will give you q queries of type (l, \\, r). For each query, consider the elements a_l, \\, a_{l + 1}, \\, \\dots, \\, a_r. Hossam wants to know the smallest number in this sequence, such that it occurs in this sequence an odd number of times.\n\nYou need to compute the answer for each query before process the next query.\n\n\nInput Format\nThe first line of the input contains one integer n (1 \\le n \\le 2 \\cdot 10^5), the length of the sequence.\n\nThe second line contains n integers a_1, \\, a_2, \\, \\dots, \\, a_n (1 \\le a_i \\le 10^9).\n\nThe third line contains one integer q (1 \\le q \\le 2 \\cdot 10^5), the number of queries.\n\nEach of the next q lines contains two integers a and b (0 \\le a, \\, b \\le 2 \\cdot 10^9), the numbers used to encode the queries.\n\nLet \\mathrm{ans}_i be the answer on the i-th query, and \\mathrm{ans}_0 be zero. Then l_i = a_i \\oplus \\mathrm{ans}_{i - 1}, r_i = b_i \\oplus \\mathrm{ans}_{i - 1}, where l_i, \\, r_i are parameters of the i-th query and \\oplus means the bitwise exclusive or operation. It is guaranteed that 1 \\le l \\le r \\le n.\n\n\nOutput Format\nFor each query, print the smallest number that occurs an odd number of times on the given segment of the sequence.\n\nIf there is no such number, print 0.\n\n\nSample Input 1\n\n5\n1 2 1 2 2\n6\n1 2\n0 2\n0 6\n0 5\n2 2\n3 7\n\nSample Output 1\n\n1\n2\n1\n0\n2\n2\n\n\nSample Input 2\n\n10\n51 43 69 48 23 52 48 76 19 55\n10\n1 1\n57 57\n54 62\n20 27\n56 56\n79 69\n16 21\n18 30\n25 25\n62 61\n\nSample Output 2\n\n51\n55\n19\n48\n76\n19\n23\n19\n55\n19\n\n\nNote\nIn the example,\n\nl_1 = 1, \\, r_1 = 2, l_2 = 1, \\, r_2 = 3, l_3 = 2, \\, r_3 = 4, l_4 = 1, \\, r_4 = 4, l_5 = 2, \\, r_5 = 2, l_6 = 1, \\, r_6 = 5.",
        "platform": "codeforces",
        "question_id": "1771/F",
        "contest_id": "1771",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Function to find the smallest number occurring an odd number of times in the range [l, r]\ndef find_smallest_odd(l, r):\n    xor_val = get_xor(l, r)\n    count = defaultdict(int)\n    for i in range(l, r + 1):\n        count[a[i]] ^= 1\n    for num in range(1, 10**9 + 1):\n        if count[num] % 2 == 1:\n            return num\n    return 0\n\n# Process each query\nresults = []\nans = 0\nfor l, r in queries:\n    l = l ^ ans\n    r = r ^ ans\n    results.append(find_smallest_odd(l, r))\n    ans = results[-1]\n\n# Print the results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the frequency of XOR values\nxor_freq = defaultdict(int)\n\n# Process each query\nresults = []\nfor l, r in queries:\n    xor_val = get_xor(l, r)\n    xor_freq[xor_val] += 1\n    # Find the smallest number that occurs an odd number of times\n    for num in range(1, 10**9 + 1):\n        if (xor_val ^ num) in xor_freq and xor_freq[xor_val ^ num] % 2 == 1:\n            results.append(num)\n            break\n    else:\n        results.append(0)\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to find the smallest number occurring an odd number of times in the range [l, r]\ndef find_smallest_odd(l, r):\n    xor_val = prefix_xor[r] ^ prefix_xor[l-1]\n    count = defaultdict(int)\n    for i in range(l-1, r):\n        count[a[i]] ^= 1\n    for num in sorted(count):\n        if count[num] % 2 == 1:\n            return num\n    return 0\n\n# Process each query\nresults = []\nans = 0\nfor l, r in queries:\n    l = l ^ ans\n    r = r ^ ans\n    result = find_smallest_odd(l, r)\n    results.append(result)\n    ans = result\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nsequence = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ sequence[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the count of each number in the current segment\ncount = defaultdict(int)\nresult = []\n\n# Process each query\nfor a, b in queries:\n    l = a ^ result[-1] if result else a\n    r = b ^ result[-1] if result else b\n    if l > r:\n        result.append(0)\n        continue\n    \n    # Get the XOR of the segment [l, r]\n    segment_xor = get_xor(l-1, r)\n    \n    # Find the smallest number that occurs an odd number of times\n    for num in range(1, 10**9 + 1):\n        if (segment_xor ^ num) & num == 0:\n            result.append(num)\n            break\n    else:\n        result.append(0)\n\n# Print the results\nfor ans in result:\n    print(ans)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the frequency of XOR values\nxor_freq = defaultdict(int)\n\n# Process each query\nresults = []\nfor l, r in queries:\n    xor_val = get_xor(l, r)\n    xor_freq[xor_val] += 1\n    if xor_freq[xor_val] % 2 == 1:\n        results.append(xor_val)\n    else:\n        results.append(0)\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to find the smallest number occurring an odd number of times in the range [l, r]\ndef find_smallest_odd(l, r):\n    xor_val = prefix_xor[r] ^ prefix_xor[l-1]\n    count = defaultdict(int)\n    for i in range(l, r+1):\n        count[a[i-1]] ^= 1\n    for num in sorted(count):\n        if count[num] % 2 == 1:\n            return num\n    return 0\n\n# Process each query\nresults = []\nans = 0\nfor l, r in queries:\n    l = l ^ ans\n    r = r ^ ans\n    results.append(find_smallest_odd(l, r))\n    ans = results[-1]\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the frequency of XOR values\nxor_freq = defaultdict(int)\n\n# Process each query\nresults = []\nfor l, r in queries:\n    xor_val = get_xor(l, r)\n    xor_freq[xor_val] += 1\n    # Find the smallest number that occurs an odd number of times\n    for num in sorted(a[l-1:r]):\n        if xor_freq[num ^ xor_val] % 2 == 1:\n            results.append(num)\n            break\n    else:\n        results.append(0)\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize the answer for the first query\nans = 0\n\n# Process each query\nfor l, r in queries:\n    # Apply the bitwise XOR operation to the query parameters\n    l ^= ans\n    r ^= ans\n    \n    # Find the smallest number that occurs an odd number of times in the segment [l, r]\n    count = defaultdict(int)\n    for i in range(l, r+1):\n        count[a[i-1]] ^= 1\n    min_odd = float('inf')\n    for num, cnt in count.items():\n        if cnt % 2 == 1:\n            min_odd = min(min_odd, num)\n    \n    # If no such number exists, set min_odd to 0\n    if min_odd == float('inf'):\n        min_odd = 0\n    \n    # Update the answer for the next query\n    ans = min_odd\n    \n    # Print the answer for the current query\n    print(ans)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the frequency of XOR values\nxor_freq = defaultdict(int)\n\n# Process each query\nresults = []\nfor l, r in queries:\n    xor_val = get_xor(l, r)\n    xor_freq[xor_val] += 1\n    # Find the smallest number that occurs an odd number of times\n    for num in sorted(a[l-1:r]):\n        if xor_freq[num ^ xor_val] % 2 == 1:\n            results.append(num)\n            break\n    else:\n        results.append(0)\n\n# Print the results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the frequency of XOR values\nfreq = defaultdict(int)\n\n# Process each query\nresults = []\nfor l, r in queries:\n    xor_val = get_xor(l, r)\n    if xor_val in freq:\n        freq[xor_val] += 1\n    else:\n        freq[xor_val] = 1\n    \n    # Find the smallest number that occurs an odd number of times\n    for num in a[l-1:r]:\n        if (xor_val ^ num) in freq and freq[xor_val ^ num] % 2 == 1:\n            results.append(num)\n            break\n    else:\n        results.append(0)\n\n# Print the results\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Function to find the smallest number occurring an odd number of times in the range [l, r]\ndef find_smallest_odd(l, r):\n    xor_val = get_xor(l, r)\n    count = defaultdict(int)\n    for i in range(l, r + 1):\n        count[a[i]] ^= 1\n    for num in range(1, 10**9 + 1):\n        if count[num] % 2 == 1:\n            return num\n    return 0\n\n# Process each query\nresults = []\nans = 0\nfor l, r in queries:\n    l = l ^ ans\n    r = r ^ ans\n    results.append(find_smallest_odd(l, r))\n    ans = results[-1]\n\n# Print the results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the frequency of XOR values\nxor_freq = defaultdict(int)\n\n# Process each query\nresults = []\nfor l, r in queries:\n    xor_val = get_xor(l, r)\n    xor_freq[xor_val] += 1\n    # Find the smallest number that occurs an odd number of times\n    for num in range(1, 10**9 + 1):\n        if (xor_val ^ num) in xor_freq and xor_freq[xor_val ^ num] % 2 == 1:\n            results.append(num)\n            break\n    else:\n        results.append(0)\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to find the smallest number occurring an odd number of times in the range [l, r]\ndef find_smallest_odd(l, r):\n    xor_val = prefix_xor[r] ^ prefix_xor[l-1]\n    count = defaultdict(int)\n    for i in range(l-1, r):\n        count[a[i]] ^= 1\n    for num in sorted(count):\n        if count[num] % 2 == 1:\n            return num\n    return 0\n\n# Process each query\nresults = []\nans = 0\nfor l, r in queries:\n    l = l ^ ans\n    r = r ^ ans\n    result = find_smallest_odd(l, r)\n    results.append(result)\n    ans = result\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nsequence = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ sequence[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the count of each number in the current segment\ncount = defaultdict(int)\nresult = []\n\n# Process each query\nfor a, b in queries:\n    l = a ^ result[-1] if result else a\n    r = b ^ result[-1] if result else b\n    if l > r:\n        result.append(0)\n        continue\n    \n    # Get the XOR of the segment [l, r]\n    segment_xor = get_xor(l-1, r)\n    \n    # Find the smallest number that occurs an odd number of times\n    for num in range(1, 10**9 + 1):\n        if (segment_xor ^ num) & num == 0:\n            result.append(num)\n            break\n    else:\n        result.append(0)\n\n# Print the results\nfor ans in result:\n    print(ans)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the frequency of XOR values\nxor_freq = defaultdict(int)\n\n# Process each query\nresults = []\nfor l, r in queries:\n    xor_val = get_xor(l, r)\n    xor_freq[xor_val] += 1\n    if xor_freq[xor_val] % 2 == 1:\n        results.append(xor_val)\n    else:\n        results.append(0)\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to find the smallest number occurring an odd number of times in the range [l, r]\ndef find_smallest_odd(l, r):\n    xor_val = prefix_xor[r] ^ prefix_xor[l-1]\n    count = defaultdict(int)\n    for i in range(l, r+1):\n        count[a[i-1]] ^= 1\n    for num in sorted(count):\n        if count[num] % 2 == 1:\n            return num\n    return 0\n\n# Process each query\nresults = []\nans = 0\nfor l, r in queries:\n    l = l ^ ans\n    r = r ^ ans\n    results.append(find_smallest_odd(l, r))\n    ans = results[-1]\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the frequency of XOR values\nxor_freq = defaultdict(int)\n\n# Process each query\nresults = []\nfor l, r in queries:\n    xor_val = get_xor(l, r)\n    xor_freq[xor_val] += 1\n    # Find the smallest number that occurs an odd number of times\n    for num in sorted(a[l-1:r]):\n        if xor_freq[num ^ xor_val] % 2 == 1:\n            results.append(num)\n            break\n    else:\n        results.append(0)\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize the answer for the first query\nans = 0\n\n# Process each query\nfor l, r in queries:\n    # Apply the bitwise XOR operation to the query parameters\n    l ^= ans\n    r ^= ans\n    \n    # Find the smallest number that occurs an odd number of times in the segment [l, r]\n    count = defaultdict(int)\n    for i in range(l, r+1):\n        count[a[i-1]] ^= 1\n    min_odd = float('inf')\n    for num, cnt in count.items():\n        if cnt % 2 == 1:\n            min_odd = min(min_odd, num)\n    \n    # If no such number exists, set min_odd to 0\n    if min_odd == float('inf'):\n        min_odd = 0\n    \n    # Update the answer for the next query\n    ans = min_odd\n    \n    # Print the answer for the current query\n    print(ans)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the frequency of XOR values\nxor_freq = defaultdict(int)\n\n# Process each query\nresults = []\nfor l, r in queries:\n    xor_val = get_xor(l, r)\n    xor_freq[xor_val] += 1\n    # Find the smallest number that occurs an odd number of times\n    for num in sorted(a[l-1:r]):\n        if xor_freq[num ^ xor_val] % 2 == 1:\n            results.append(num)\n            break\n    else:\n        results.append(0)\n\n# Print the results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Initialize prefix XOR array\nprefix_xor = [0] * (n + 1)\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n\n# Function to get the XOR of elements in the range [l, r]\ndef get_xor(l, r):\n    return prefix_xor[r] ^ prefix_xor[l]\n\n# Dictionary to store the frequency of XOR values\nfreq = defaultdict(int)\n\n# Process each query\nresults = []\nfor l, r in queries:\n    xor_val = get_xor(l, r)\n    if xor_val in freq:\n        freq[xor_val] += 1\n    else:\n        freq[xor_val] = 1\n    \n    # Find the smallest number that occurs an odd number of times\n    for num in a[l-1:r]:\n        if (xor_val ^ num) in freq and freq[xor_val ^ num] % 2 == 1:\n            results.append(num)\n            break\n    else:\n        results.append(0)\n\n# Print the results\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "LuoTianyi and XOR-Tree",
        "question_content": "LuoTianyi gives you a tree with values in its vertices, and the root of the tree is vertex 1.\n\nIn one operation, you can change the value in one vertex to any non-negative integer.\n\nNow you need to find the minimum number of operations you need to perform to make each path from the root to leaf^{\\dagger} has a bitwise XOR value of zero.\n\n^{\\dagger}A leaf in a rooted tree is a vertex that has exactly one neighbor and is not a root.\n\n\nInput Format\nThe first line contains a single integer n (2 \\le n \\le 10^5) \u2014 the number of vertices in the tree.\n\nThe second line contains n integers a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 10^9), the i-th number represents the value in the i-th vertex.\n\nNext n-1 lines describe the edges of the tree. The i-th line contains two integers u_i and v_i (1 \\le u_i,v_i \\le n, u_i \\neq v_i) \u2014 the vertices connected by an edge of the tree. It's guaranteed that the given edges form a tree.\n\n\nOutput Format\nPrint a single integer \u2014 the minimum number of operations.\n\n\nSample Input 1\n\n6\n3 5 7 5 8 4\n1 2\n1 3\n1 4\n3 5\n4 6\n\nSample Output 1\n\n3\n\n\nSample Input 2\n\n8\n7 10 7 16 19 9 16 11\n1 5\n4 2\n6 5\n5 2\n7 2\n2 3\n3 8\n\nSample Output 2\n\n3\n\n\nSample Input 3\n\n4\n1 2 1 2\n1 2\n2 3\n4 3\n\nSample Output 3\n\n0\n\n\nSample Input 4\n\n9\n4 3 6 1 5 5 5 2 7\n1 2\n2 3\n4 1\n4 5\n4 6\n4 7\n8 1\n8 9\n\nSample Output 4\n\n2\n\n\nNote\nThe tree in the first example:\n\nIf we change the value in the vertex 2 to 3, the value in the vertex 5 to 4, and the value in the vertex 6 to 6, then the tree will be ok.\n\nThe bitwise XOR from the root to the leaf 2 will be 3 \\oplus 3=0.\n\nThe bitwise XOR from the root to the leaf 5 will be 4 \\oplus 7 \\oplus 3=0.\n\nThe bitwise XOR from the root to the leaf 6 will be 6 \\oplus 5 \\oplus 3=0.\n\nThe tree in the second example:\n\nIf we change the value in the vertex 2 to 4, the value in the vertex 3 to 27, and the value in the vertex 6 to 20, then the tree will be ok.\n\nThe bitwise XOR from the root to the leaf 6 will be 20 \\oplus 19 \\oplus 7=0.\n\nThe bitwise XOR from the root to the leaf 8 will be 11 \\oplus 27 \\oplus 4 \\oplus 19 \\oplus 7=0.\n\nThe bitwise XOR from the root to the leaf 4 will be 16 \\oplus 4 \\oplus 19 \\oplus 7=0.\n\nThe bitwise XOR from the root to the leaf 7 will be 16 \\oplus 4 \\oplus 19 \\oplus 7=0.\n\nIn the third example, the only leaf is the vertex 4 and the bitwise XOR on the path to it is 1 \\oplus 2 \\oplus 1 \\oplus 2 = 0, so we don't need to change values.\n\nIn the fourth example, we can change the value in the vertex 1 to 5, and the value in the vertex 4 to 0.\n\nHere \\oplus denotes the bitwise XOR operation.",
        "platform": "codeforces",
        "question_id": "1824/C",
        "contest_id": "1824",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_operations_to_zero_xor(n, values, edges):\n    # Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to perform DFS and calculate the minimum operations\n    def dfs(node, parent):\n        xor_values = [0] * 32\n        for child in tree[node]:\n            if child != parent:\n                child_xor_values = dfs(child, node)\n                for i in range(32):\n                    xor_values[i] += child_xor_values[i]\n        \n        # Calculate the current node's contribution\n        for i in range(32):\n            if (values[node] >> i) & 1:\n                xor_values[i] += 1\n        \n        # Calculate the number of operations needed to make XOR zero\n        operations = 0\n        for i in range(32):\n            if xor_values[i] % 2 != 0:\n                operations += 1\n        \n        return xor_values\n    \n    # Start DFS from the root (node 1)\n    dfs(1, -1)\n    \n    return operations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = min_operations_to_zero_xor(n, values, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_operations_to_zero_xor(n, values, edges):\n    # Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to perform DFS and calculate the minimum operations\n    def dfs(node, parent):\n        xor_values = [0] * 32\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_xor_values = dfs(neighbor, node)\n                for i in range(32):\n                    xor_values[i] += child_xor_values[i]\n        \n        # Calculate the current node's contribution\n        for i in range(32):\n            if (values[node] >> i) & 1:\n                xor_values[i] += 1\n        \n        # Calculate the number of operations needed\n        operations = 0\n        for i in range(32):\n            if xor_values[i] % 2 != 0:\n                operations += 1\n        \n        return xor_values\n    \n    # Start DFS from the root (node 1)\n    dfs(1, -1)\n    \n    return operations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = min_operations_to_zero_xor(n, values, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate the minimum operations\ndef dfs(node, parent):\n    xor_path = values[node]\n    children = [child for child in tree[node] if child != parent]\n    if not children:\n        return xor_path, 0\n    min_operations = float('inf')\n    for child in children:\n        child_xor, child_ops = dfs(child, node)\n        xor_path ^= child_xor\n        min_operations = min(min_operations, child_ops)\n    if xor_path != 0:\n        min_operations += 1\n    return xor_path, min_operations\n\n# Start DFS from the root (node 0)\n_, result = dfs(0, -1)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\n\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate the minimum operations\ndef dfs(node, parent):\n    xor_val = values[node]\n    children_xor = [0] * 32\n    \n    for neighbor in tree[node]:\n        if neighbor != parent:\n            child_xor, child_ops = dfs(neighbor, node)\n            xor_val ^= child_xor\n            for i in range(32):\n                if child_xor & (1 << i):\n                    children_xor[i] += 1\n    \n    # Calculate the number of operations needed\n    ops = 0\n    for i in range(32):\n        if children_xor[i] % 2 != 0:\n            ops += 1\n    \n    return xor_val, ops\n\n# Start DFS from the root (node 0)\n_, min_ops = dfs(0, -1)\n\n# Output the result\nprint(min_ops)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef min_operations_to_zero_xor(n, values, edges):\n    # Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to perform DFS and calculate the minimum operations\n    def dfs(node, parent):\n        xor_values = [0] * 32  # To store the count of each bit position\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_xor_values = dfs(neighbor, node)\n                for i in range(32):\n                    xor_values[i] += child_xor_values[i]\n        \n        # Calculate the current node's contribution\n        current_value = values[node - 1]\n        for i in range(32):\n            if (current_value >> i) & 1:\n                xor_values[i] += 1\n        \n        # Calculate the number of operations needed to make XOR zero\n        operations = 0\n        for i in range(32):\n            if xor_values[i] % 2 != 0:\n                operations += 1\n        \n        return xor_values\n    \n    # Start DFS from the root (node 1)\n    dfs(1, -1)\n    \n    return operations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i])\n    v = int(data[n+2+2*i])\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = min_operations_to_zero_xor(n, values, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_operations_to_zero_xor(n, values, edges):\n    # Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to perform DFS and calculate the minimum operations\n    def dfs(node, parent):\n        xor_values = [0] * 32  # To store the count of each bit position\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_xor_values = dfs(neighbor, node)\n                for i in range(32):\n                    xor_values[i] += child_xor_values[i]\n        \n        # Calculate the current node's contribution\n        for i in range(32):\n            if (values[node] >> i) & 1:\n                xor_values[i] += 1\n        \n        # Calculate the number of operations needed to make the XOR zero\n        operations = 0\n        for i in range(32):\n            if xor_values[i] % 2 != 0:\n                operations += 1\n        \n        return xor_values\n    \n    # Start DFS from the root (node 1)\n    dfs(1, -1)\n    \n    return operations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = min_operations_to_zero_xor(n, values, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\n\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate the minimum operations\ndef dfs(node, parent):\n    xor_value = values[node]\n    children_xor = [0] * 32\n    \n    for neighbor in tree[node]:\n        if neighbor != parent:\n            child_xor, child_operations = dfs(neighbor, node)\n            xor_value ^= child_xor\n            for i in range(32):\n                if child_xor & (1 << i):\n                    children_xor[i] += 1\n    \n    operations = 0\n    for i in range(32):\n        if children_xor[i] % 2 != 0:\n            operations += 1\n    \n    return xor_value, operations\n\n# Start DFS from the root (node 0)\n_, min_operations = dfs(0, -1)\n\n# Output the result\nprint(min_operations)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\n\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate the minimum operations\ndef dfs(node, parent):\n    xor_val = values[node]\n    children = [child for child in tree[node] if child != parent]\n    \n    if not children:\n        return xor_val\n    \n    child_xors = [dfs(child, node) for child in children]\n    min_operations = 0\n    \n    for xor in child_xors:\n        min_operations += xor_val ^ xor\n    \n    return min_operations\n\n# Start DFS from the root (node 0)\nmin_operations = dfs(0, -1)\n\n# Output the result\nprint(min_operations)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\n\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate the minimum operations\ndef dfs(node, parent):\n    xor_value = values[node]\n    children_xor = [0] * 32\n    \n    for neighbor in tree[node]:\n        if neighbor != parent:\n            child_xor, child_operations = dfs(neighbor, node)\n            xor_value ^= child_xor\n            for i in range(32):\n                children_xor[i] += child_operations[i]\n    \n    # Calculate the number of operations needed to make the XOR value zero\n    operations = 0\n    for i in range(32):\n        if (xor_value >> i) & 1:\n            operations += min(children_xor[i], 1)\n    \n    return xor_value, operations\n\n# Start DFS from the root (node 0)\n_, min_operations = dfs(0, -1)\n\n# Output the result\nprint(min_operations)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef min_operations_to_zero_xor(n, values, edges):\n    # Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to perform DFS and calculate the minimum operations\n    def dfs(node, parent):\n        xor_values = [0] * 32  # To count the parity of each bit position\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_xor_values = dfs(neighbor, node)\n                for i in range(32):\n                    xor_values[i] += child_xor_values[i]\n        \n        # Calculate the number of operations needed for the current node\n        operations = 0\n        for i in range(32):\n            if xor_values[i] % 2 == 1:\n                operations += 1\n        \n        # Update the current node's value to make the XOR of the path to the root zero\n        values[node] ^= (1 << operations) - 1\n        \n        # Return the updated XOR values for the current node\n        for i in range(32):\n            xor_values[i] += (values[node] >> i) & 1\n        \n        return xor_values\n    \n    # Start DFS from the root (node 1)\n    dfs(1, -1)\n    \n    # The result is the number of operations needed for the root node\n    return (values[1] - 1).bit_count()\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = min_operations_to_zero_xor(n, values, edges)\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_operations_to_zero_xor(n, values, edges):\n    # Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to perform DFS and calculate the minimum operations\n    def dfs(node, parent):\n        xor_values = [0] * 32\n        for child in tree[node]:\n            if child != parent:\n                child_xor_values = dfs(child, node)\n                for i in range(32):\n                    xor_values[i] += child_xor_values[i]\n        \n        # Calculate the current node's contribution\n        for i in range(32):\n            if (values[node] >> i) & 1:\n                xor_values[i] += 1\n        \n        # Calculate the number of operations needed to make XOR zero\n        operations = 0\n        for i in range(32):\n            if xor_values[i] % 2 != 0:\n                operations += 1\n        \n        return xor_values\n    \n    # Start DFS from the root (node 1)\n    dfs(1, -1)\n    \n    return operations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = min_operations_to_zero_xor(n, values, edges)\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_operations_to_zero_xor(n, values, edges):\n    # Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to perform DFS and calculate the minimum operations\n    def dfs(node, parent):\n        xor_values = [0] * 32\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_xor_values = dfs(neighbor, node)\n                for i in range(32):\n                    xor_values[i] += child_xor_values[i]\n        \n        # Calculate the current node's contribution\n        for i in range(32):\n            if (values[node] >> i) & 1:\n                xor_values[i] += 1\n        \n        # Calculate the number of operations needed\n        operations = 0\n        for i in range(32):\n            if xor_values[i] % 2 != 0:\n                operations += 1\n        \n        return xor_values\n    \n    # Start DFS from the root (node 1)\n    dfs(1, -1)\n    \n    return operations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = min_operations_to_zero_xor(n, values, edges)\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate the minimum operations\ndef dfs(node, parent):\n    xor_path = values[node]\n    children = [child for child in tree[node] if child != parent]\n    if not children:\n        return xor_path, 0\n    min_operations = float('inf')\n    for child in children:\n        child_xor, child_ops = dfs(child, node)\n        xor_path ^= child_xor\n        min_operations = min(min_operations, child_ops)\n    if xor_path != 0:\n        min_operations += 1\n    return xor_path, min_operations\n\n# Start DFS from the root (node 0)\n_, result = dfs(0, -1)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\n\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate the minimum operations\ndef dfs(node, parent):\n    xor_val = values[node]\n    children_xor = [0] * 32\n    \n    for neighbor in tree[node]:\n        if neighbor != parent:\n            child_xor, child_ops = dfs(neighbor, node)\n            xor_val ^= child_xor\n            for i in range(32):\n                if child_xor & (1 << i):\n                    children_xor[i] += 1\n    \n    # Calculate the number of operations needed\n    ops = 0\n    for i in range(32):\n        if children_xor[i] % 2 != 0:\n            ops += 1\n    \n    return xor_val, ops\n\n# Start DFS from the root (node 0)\n_, min_ops = dfs(0, -1)\n\n# Output the result\nprint(min_ops)",
            "import sys\nfrom collections import defaultdict\n\ndef min_operations_to_zero_xor(n, values, edges):\n    # Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to perform DFS and calculate the minimum operations\n    def dfs(node, parent):\n        xor_values = [0] * 32  # To store the count of each bit position\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_xor_values = dfs(neighbor, node)\n                for i in range(32):\n                    xor_values[i] += child_xor_values[i]\n        \n        # Calculate the current node's contribution\n        current_value = values[node - 1]\n        for i in range(32):\n            if (current_value >> i) & 1:\n                xor_values[i] += 1\n        \n        # Calculate the number of operations needed to make XOR zero\n        operations = 0\n        for i in range(32):\n            if xor_values[i] % 2 != 0:\n                operations += 1\n        \n        return xor_values\n    \n    # Start DFS from the root (node 1)\n    dfs(1, -1)\n    \n    return operations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i])\n    v = int(data[n+2+2*i])\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = min_operations_to_zero_xor(n, values, edges)\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_operations_to_zero_xor(n, values, edges):\n    # Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to perform DFS and calculate the minimum operations\n    def dfs(node, parent):\n        xor_values = [0] * 32  # To store the count of each bit position\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_xor_values = dfs(neighbor, node)\n                for i in range(32):\n                    xor_values[i] += child_xor_values[i]\n        \n        # Calculate the current node's contribution\n        for i in range(32):\n            if (values[node] >> i) & 1:\n                xor_values[i] += 1\n        \n        # Calculate the number of operations needed to make the XOR zero\n        operations = 0\n        for i in range(32):\n            if xor_values[i] % 2 != 0:\n                operations += 1\n        \n        return xor_values\n    \n    # Start DFS from the root (node 1)\n    dfs(1, -1)\n    \n    return operations\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = min_operations_to_zero_xor(n, values, edges)\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\n\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate the minimum operations\ndef dfs(node, parent):\n    xor_value = values[node]\n    children_xor = [0] * 32\n    \n    for neighbor in tree[node]:\n        if neighbor != parent:\n            child_xor, child_operations = dfs(neighbor, node)\n            xor_value ^= child_xor\n            for i in range(32):\n                if child_xor & (1 << i):\n                    children_xor[i] += 1\n    \n    operations = 0\n    for i in range(32):\n        if children_xor[i] % 2 != 0:\n            operations += 1\n    \n    return xor_value, operations\n\n# Start DFS from the root (node 0)\n_, min_operations = dfs(0, -1)\n\n# Output the result\nprint(min_operations)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\n\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate the minimum operations\ndef dfs(node, parent):\n    xor_val = values[node]\n    children = [child for child in tree[node] if child != parent]\n    \n    if not children:\n        return xor_val\n    \n    child_xors = [dfs(child, node) for child in children]\n    min_operations = 0\n    \n    for xor in child_xors:\n        min_operations += xor_val ^ xor\n    \n    return min_operations\n\n# Start DFS from the root (node 0)\nmin_operations = dfs(0, -1)\n\n# Output the result\nprint(min_operations)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\n\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate the minimum operations\ndef dfs(node, parent):\n    xor_value = values[node]\n    children_xor = [0] * 32\n    \n    for neighbor in tree[node]:\n        if neighbor != parent:\n            child_xor, child_operations = dfs(neighbor, node)\n            xor_value ^= child_xor\n            for i in range(32):\n                children_xor[i] += child_operations[i]\n    \n    # Calculate the number of operations needed to make the XOR value zero\n    operations = 0\n    for i in range(32):\n        if (xor_value >> i) & 1:\n            operations += min(children_xor[i], 1)\n    \n    return xor_value, operations\n\n# Start DFS from the root (node 0)\n_, min_operations = dfs(0, -1)\n\n# Output the result\nprint(min_operations)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef min_operations_to_zero_xor(n, values, edges):\n    # Build the tree\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    # Function to perform DFS and calculate the minimum operations\n    def dfs(node, parent):\n        xor_values = [0] * 32  # To count the parity of each bit position\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                child_xor_values = dfs(neighbor, node)\n                for i in range(32):\n                    xor_values[i] += child_xor_values[i]\n        \n        # Calculate the number of operations needed for the current node\n        operations = 0\n        for i in range(32):\n            if xor_values[i] % 2 == 1:\n                operations += 1\n        \n        # Update the current node's value to make the XOR of the path to the root zero\n        values[node] ^= (1 << operations) - 1\n        \n        # Return the updated XOR values for the current node\n        for i in range(32):\n            xor_values[i] += (values[node] >> i) & 1\n        \n        return xor_values\n    \n    # Start DFS from the root (node 1)\n    dfs(1, -1)\n    \n    # The result is the number of operations needed for the root node\n    return (values[1] - 1).bit_count()\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvalues = list(map(int, data[1:n+1]))\nedges = []\nfor i in range(n-1):\n    u = int(data[n+1+2*i]) - 1\n    v = int(data[n+2+2*i]) - 1\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = min_operations_to_zero_xor(n, values, edges)\nprint(result)"
        ]
    },
    {
        "question_title": "LuoTianyi and the Function",
        "question_content": "LuoTianyi gives you an array a of n integers and the index begins from 1.\n\nDefine g(i,j) as follows:\n\n- g(i,j) is the largest integer x that satisfies \\{a_p:i\\le p\\le j\\}\\subseteq\\{a_q:x\\le q\\le j\\} while i \\le j;\n- and g(i,j)=0 while i>j.\n\nThere are q queries. For each query you are given four integers l,r,x,y, you need to calculate \\sum\\limits_{i=l}^{r}\\sum\\limits_{j=x}^{y}g(i,j).\n\n\nInput Format\nThe first line contains two integers n and q (1\\le n,q\\le 10^6) \u2014 the length of the array a and the number of queries.\n\nThe second line contains n integers a_1,a_2,\\ldots,a_n (1\\le a_i\\le n) \u2014 the elements of the array a.\n\nNext q lines describe a query. The i-th line contains four integers l,r,x,y (1\\le l\\le r\\le n, 1\\le x\\le y\\le n) \u2014 the integers in the i-th query.\n\n\nOutput Format\nPrint q lines where i-th line contains one integer \u2014 the answer for the i-th query.\n\n\nSample Input 1\n\n6 4\n1 2 2 1 3 4\n1 1 4 5\n2 3 3 3\n3 6 1 2\n6 6 6 6\n\nSample Output 1\n\n6\n6\n0\n6\n\n\nSample Input 2\n\n10 5\n10 2 8 10 9 8 2 1 1 8\n1 1 10 10\n2 2 3 3\n6 6 6 6\n1 1 4 5\n4 8 4 8\n\nSample Output 2\n\n4\n2\n6\n4\n80\n\n\nNote\nIn the first example:\n\nIn the first query, the answer is g(1,4)+g(1,5)=3+3=6.\n\nx=1,2,3 can satisfies \\{a_p:1\\le p\\le 4\\}\\subseteq\\{a_q:x\\le q\\le 4\\}, 3 is the largest integer so g(1,4)=3.\n\nIn the second query, the answer is g(2,3)+g(3,3)=3+3=6.\n\nIn the third query, the answer is 0, because all i > j and g(i,j)=0.\n\nIn the fourth query, the answer is g(6,6)=6.\n\nIn the second example:\n\nIn the second query, the answer is g(2,3)=2.\n\nIn the fourth query, the answer is g(1,4)+g(1,5)=2+2=4.",
        "platform": "codeforces",
        "question_id": "1824/D",
        "contest_id": "1824",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = max(a[i:j+1])\n    for x in range(max_val, -1, -1):\n        if all(a[p] >= x for p in range(i, j+1)):\n            return x\n    return 0\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    x = a[i]\n    for p in range(i, j+1):\n        if a[p] < x:\n            x = a[p]\n    return x\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = max(a[i:j+1])\n    for x in range(max_val, -1, -1):\n        if all(a[p] >= x for p in range(i, j+1)):\n            return x\n    return 0\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(q):\n    l = int(data[index]) - 1\n    r = int(data[index + 1]) - 1\n    x = int(data[index + 2]) - 1\n    y = int(data[index + 3]) - 1\n    queries.append((l, r, x, y))\n    index += 4\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = 0\n    for p in range(i, j + 1):\n        if a[p] > max_val:\n            max_val = a[p]\n    for q in range(x, j + 1):\n        if a[q] < max_val:\n            return 0\n    return max_val\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r + 1):\n        for j in range(x, y + 1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = max(a[i:j+1])\n    for x in range(max_val, 0, -1):\n        if all(a[p] >= x for p in range(i, j+1)):\n            return x\n    return 0\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(q):\n    l = int(data[index]) - 1\n    r = int(data[index + 1]) - 1\n    x = int(data[index + 2]) - 1\n    y = int(data[index + 3]) - 1\n    queries.append((l, r, x, y))\n    index += 4\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = 0\n    for p in range(i, j + 1):\n        if a[p] > max_val:\n            max_val = a[p]\n    for q in range(x, j + 1):\n        if a[q] < max_val:\n            return 0\n    return max_val\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r + 1):\n        for j in range(x, y + 1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(q):\n    l = int(data[index]) - 1\n    r = int(data[index + 1]) - 1\n    x = int(data[index + 2]) - 1\n    y = int(data[index + 3]) - 1\n    queries.append((l, r, x, y))\n    index += 4\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = 0\n    for p in range(i, j + 1):\n        max_val = max(max_val, a[p])\n    for q in range(x, j + 1):\n        if all(a[p] <= max_val for p in range(i, j + 1)):\n            return max_val\n    return 0\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r + 1):\n        for j in range(x, y + 1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    x = a[i]\n    for p in range(i, j+1):\n        x = min(x, a[p])\n    return x\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = 0\n    for p in range(i, j+1):\n        if a[p] > max_val:\n            max_val = a[p]\n    for q in range(x, j+1):\n        if a[q] < max_val:\n            return 0\n    return max_val\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = 0\n    for p in range(i, j+1):\n        if a[p] > max_val:\n            max_val = a[p]\n    for q in range(x, j+1):\n        if a[q] < max_val:\n            return 0\n    return max_val\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = max(a[i:j+1])\n    for x in range(max_val, -1, -1):\n        if all(a[p] >= x for p in range(i, j+1)):\n            return x\n    return 0\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    x = a[i]\n    for p in range(i, j+1):\n        if a[p] < x:\n            x = a[p]\n    return x\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = max(a[i:j+1])\n    for x in range(max_val, -1, -1):\n        if all(a[p] >= x for p in range(i, j+1)):\n            return x\n    return 0\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(q):\n    l = int(data[index]) - 1\n    r = int(data[index + 1]) - 1\n    x = int(data[index + 2]) - 1\n    y = int(data[index + 3]) - 1\n    queries.append((l, r, x, y))\n    index += 4\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = 0\n    for p in range(i, j + 1):\n        if a[p] > max_val:\n            max_val = a[p]\n    for q in range(x, j + 1):\n        if a[q] < max_val:\n            return 0\n    return max_val\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r + 1):\n        for j in range(x, y + 1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = max(a[i:j+1])\n    for x in range(max_val, 0, -1):\n        if all(a[p] >= x for p in range(i, j+1)):\n            return x\n    return 0\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(q):\n    l = int(data[index]) - 1\n    r = int(data[index + 1]) - 1\n    x = int(data[index + 2]) - 1\n    y = int(data[index + 3]) - 1\n    queries.append((l, r, x, y))\n    index += 4\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = 0\n    for p in range(i, j + 1):\n        if a[p] > max_val:\n            max_val = a[p]\n    for q in range(x, j + 1):\n        if a[q] < max_val:\n            return 0\n    return max_val\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r + 1):\n        for j in range(x, y + 1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(q):\n    l = int(data[index]) - 1\n    r = int(data[index + 1]) - 1\n    x = int(data[index + 2]) - 1\n    y = int(data[index + 3]) - 1\n    queries.append((l, r, x, y))\n    index += 4\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = 0\n    for p in range(i, j + 1):\n        max_val = max(max_val, a[p])\n    for q in range(x, j + 1):\n        if all(a[p] <= max_val for p in range(i, j + 1)):\n            return max_val\n    return 0\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r + 1):\n        for j in range(x, y + 1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    x = a[i]\n    for p in range(i, j+1):\n        x = min(x, a[p])\n    return x\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = 0\n    for p in range(i, j+1):\n        if a[p] > max_val:\n            max_val = a[p]\n    for q in range(x, j+1):\n        if a[q] < max_val:\n            return 0\n    return max_val\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\na = list(map(int, data[2:2+n]))\n\nqueries = []\nfor i in range(q):\n    l = int(data[2+n+4*i]) - 1\n    r = int(data[2+n+4*i+1]) - 1\n    x = int(data[2+n+4*i+2]) - 1\n    y = int(data[2+n+4*i+3]) - 1\n    queries.append((l, r, x, y))\n\ndef g(i, j):\n    if i > j:\n        return 0\n    max_val = 0\n    for p in range(i, j+1):\n        if a[p] > max_val:\n            max_val = a[p]\n    for q in range(x, j+1):\n        if a[q] < max_val:\n            return 0\n    return max_val\n\nresult = []\nfor l, r, x, y in queries:\n    total = 0\n    for i in range(l, r+1):\n        for j in range(x, y+1):\n            total += g(i, j)\n    result.append(total)\n\nfor res in result:\n    print(res)"
        ]
    },
    {
        "question_title": "Swaps",
        "question_content": "You are given an array of integers a_1, a_2, \\dots, a_n (1 \\le a_i \\le n). You can perform the following operation several (possibly, zero) times:\n\n- pick an arbitrary i and perform swap(a_i, a_{a_i}).\n\nHow many distinct arrays is it possible to attain? Output the answer modulo (10^9 + 7).\n\n\nInput Format\nThe first line contains an integer n (1 \\le n \\le 10^6).\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (1\\le a_i\\le n).\n\n\nOutput Format\nOutput the number of attainable arrays modulo (10^9 + 7).\n\n\nSample Input 1\n\n3\n1 1 2\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n4\n2 1 4 3\n\nSample Output 2\n\n4\n\n\nSample Input 3\n\n6\n2 3 1 1 1 2\n\nSample Output 3\n\n18\n\n\nNote\nIn the first example, the initial array is [1, 1, 2]. If we perform the operation with i = 3, we swap a_3 and a_2, obtaining [1, 2, 1]. One can show that there are no other attainable arrays.\n\nIn the second example, the four attainable arrays are [2, 1, 4, 3], [1, 2, 4, 3], [1, 2, 3, 4], [2, 1, 3, 4]. One can show that there are no other attainable arrays.",
        "platform": "codeforces",
        "question_id": "1863/G",
        "contest_id": "1863",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element\n    freq = defaultdict(int)\n    for x in a:\n        freq[x] += 1\n    \n    # Calculate the number of distinct arrays\n    result = 1\n    for count in freq.values():\n        result = result * (count + 1) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nprint(count_distinct_arrays(n, a))\n```",
            "```python\nimport sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the number of distinct arrays\n# The number of distinct arrays is the product of factorials of the sizes of the cycles in the permutation\nmod = 10**9 + 7\nfactorials = [1] * (n + 1)\nfor i in range(1, n + 1):\n    factorials[i] = factorials[i - 1] * i % mod\n\n# Count the sizes of the cycles\ncycle_sizes = []\nvisited = [False] * (n + 1)\nfor i in range(1, n + 1):\n    if not visited[i]:\n        cycle_size = 0\n        x = i\n        while not visited[x]:\n            visited[x] = True\n            x = a[x - 1]\n            cycle_size += 1\n        cycle_sizes.append(cycle_size)\n\n# Calculate the number of distinct arrays\nresult = 1\nfor size in cycle_sizes:\n    result = result * factorials[size] % mod\n\n# Output the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Create a dictionary to count the frequency of each element\n    freq = defaultdict(int)\n    for num in a:\n        freq[num] += 1\n    \n    # Calculate the number of distinct arrays\n    result = 1\n    for count in freq.values():\n        result = (result * (count + 1)) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nprint(count_distinct_arrays(n, a))\n```",
            "```python\nimport sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Create a dictionary to count the frequency of each element\n    freq = defaultdict(int)\n    for num in a:\n        freq[num] += 1\n    \n    # Calculate the number of distinct arrays\n    result = 1\n    for count in freq.values():\n        result = (result * (count + 1)) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nprint(count_distinct_arrays(n, a))\n```",
            "```python\nimport sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element\n    freq = defaultdict(int)\n    for x in a:\n        freq[x] += 1\n    \n    # Calculate the number of distinct arrays\n    result = 1\n    for count in freq.values():\n        result = result * (count + 1) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nprint(count_distinct_arrays(n, a))",
            "import sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)",
            "import sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)",
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the number of distinct arrays\n# The number of distinct arrays is the product of factorials of the sizes of the cycles in the permutation\nmod = 10**9 + 7\nfactorials = [1] * (n + 1)\nfor i in range(1, n + 1):\n    factorials[i] = factorials[i - 1] * i % mod\n\n# Count the sizes of the cycles\ncycle_sizes = []\nvisited = [False] * (n + 1)\nfor i in range(1, n + 1):\n    if not visited[i]:\n        cycle_size = 0\n        x = i\n        while not visited[x]:\n            visited[x] = True\n            x = a[x - 1]\n            cycle_size += 1\n        cycle_sizes.append(cycle_size)\n\n# Calculate the number of distinct arrays\nresult = 1\nfor size in cycle_sizes:\n    result = result * factorials[size] % mod\n\n# Output the result\nprint(result)",
            "import sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Create a dictionary to count the frequency of each element\n    freq = defaultdict(int)\n    for num in a:\n        freq[num] += 1\n    \n    # Calculate the number of distinct arrays\n    result = 1\n    for count in freq.values():\n        result = (result * (count + 1)) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nprint(count_distinct_arrays(n, a))",
            "import sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Create a dictionary to count the frequency of each element\n    freq = defaultdict(int)\n    for num in a:\n        freq[num] += 1\n    \n    # Calculate the number of distinct arrays\n    result = 1\n    for count in freq.values():\n        result = (result * (count + 1)) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nprint(count_distinct_arrays(n, a))",
            "import sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_arrays(n, a):\n    # Count the frequency of each element in the array\n    freq = Counter(a)\n    \n    # Calculate the number of distinct arrays\n    distinct_arrays = 1\n    for count in freq.values():\n        distinct_arrays = (distinct_arrays * (count + 1)) % MOD\n    \n    return distinct_arrays\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_distinct_arrays(n, a)\nprint(result)"
        ]
    },
    {
        "question_title": "Game of Stacks",
        "question_content": "You have n stacks r_1,r_2,\\ldots,r_n. Each stack contains some positive integers ranging from 1 to n.\n\nDefine the following functions:\n\nYou want to know the values returned by \\texttt{init(1)}, \\texttt{init(2)}, \\ldots, \\texttt{init(n)}.\n\nNote that, during these calls, the stacks r_1,r_2,\\ldots,r_n don't change, so the calls \\texttt{init(1)}, \\texttt{init(2)}, \\ldots, \\texttt{init(n)} are independent.\n\n\nInput Format\nThe first line of the input contains one integer n (1\\le n\\le 10^5)\u00a0\u2014 the length of the array r.\n\nEach of the following n lines contains several integers. The first integer k_i (0\\le k_i\\le 10^5) represents the number of elements in the i-th stack, and the following k_i positive integers c_{i,1},c_{i,2},\\ldots,c_{i,k_i} (1\\le c_{i,j}\\le n) represent the elements in the i-th stack. c_{i,1} is the bottom element.\n\nIn each test, \\sum k_i\\le 10^6.\n\n\nOutput Format\nYou need to output n values, the i-th of which is the value returned by \\texttt{init(i)}.\n\n\nSample Input 1\n\n3\n3 1 2 2\n3 3 1 2\n3 1 2 1\n\nSample Output 1\n\n1 2 2\n\n\nSample Input 2\n\n5\n5 1 2 4 3 4\n6 1 2 5 3 3 4\n6 1 1 4 4 4 2\n9 3 1 4 2 3 5 5 1 2\n4 4 4 1 3\n\nSample Output 2\n\n1 1 1 1 1\n\n\nNote\nIn the first example:\n\n- When you call \\texttt{init(1)}, set \\texttt{stacks := [[1,2,2],[3,1,2],[1,2,1]]}, and then call \\texttt{get(stacks, 1)}. \\texttt{stacks[1]} is not empty, set \\texttt{new_pos := 2}, and pop the top element of \\texttt{stacks[1]}, which makes \\texttt{stacks} become [[1,2],[3,1,2],[1,2,1]], and then call \\texttt{get(stacks, 2)}. \\texttt{stacks[2]} is not empty, set \\texttt{new_pos := 2}, and pop the top element of \\texttt{stacks[2]}, which makes \\texttt{stacks} become [[1,2],[3,1],[1,2,1]], and then call \\texttt{get(stacks, 2)}. \\texttt{stacks[2]} is not empty, set \\texttt{new_pos := 1}, and pop the top element of \\texttt{stacks[2]}, which makes \\texttt{stacks} become [[1,2],[3],[1,2,1]], and then call \\texttt{get(stacks, 1)}. \\texttt{stacks[1]} is not empty, set \\texttt{new_pos := 2}, and pop the top element of \\texttt{stacks[1]}, which makes \\texttt{stacks} become [[1],[3],[1,2,1]], and then call \\texttt{get(stacks, 2)}. \\texttt{stacks[2]} is not empty, set \\texttt{new_pos := 3}, and pop the top element of \\texttt{stacks[2]}, which makes \\texttt{stacks} become [[1],[],[1,2,1]], and then call \\texttt{get(stacks, 3)}. \\texttt{stacks[3]} is not empty, set \\texttt{new_pos := 1}, and pop the top element of \\texttt{stacks[3]}, which makes \\texttt{stacks} become [[1],[],[1,2]], and then call \\texttt{get(stacks, 1)}. \\texttt{stacks[1]} is not empty, set \\texttt{new_pos := 1}, and pop the top element of \\texttt{stacks[1]}, which makes \\texttt{stacks} become [[],[],[1,2]], and then call \\texttt{get(stacks, 1)}. \\texttt{stacks[1]} is empty, return 1.\n- When you call \\texttt{init(2)}, set \\texttt{stacks := [[1,2,2],[3,1,2],[1,2,1]]}, and then call \\texttt{get(stacks, 2)}. \\texttt{stacks[2]} is not empty, set \\texttt{new_pos := 2}, and pop the top element of \\texttt{stacks[2]}, which makes \\texttt{stacks} become [[1,2,2],[3,1],[1,2,1]], and then call \\texttt{get(stacks, 2)}. \\texttt{stacks[2]} is not empty, set \\texttt{new_pos := 1}, and pop the top element of \\texttt{stacks[2]}, which makes \\texttt{stacks} become [[1,2,2],[3],[1,2,1]], and then call \\texttt{get(stacks, 1)}. \\texttt{stacks[1]} is not empty, set \\texttt{new_pos := 2}, and pop the top element of \\texttt{stacks[1]}, which makes \\texttt{stacks} become [[1,2],[3],[1,2,1]], and then call \\texttt{get(stacks, 2)}. \\texttt{stacks[2]} is not empty, set \\texttt{new_pos := 3}, and pop the top element of \\texttt{stacks[2]}, which makes \\texttt{stacks} become [[1,2],[],[1,2,1]], and then call \\texttt{get(stacks, 3)}. \\texttt{stacks[3]} is not empty, set \\texttt{new_pos := 1}, and pop the top element of \\texttt{stacks[3]}, which makes \\texttt{stacks} become [[1,2],[],[1,2]], and then call \\texttt{get(stacks, 1)}. \\texttt{stacks[1]} is not empty, set \\texttt{new_pos := 2}, and pop the top element of \\texttt{stacks[1]}, which makes \\texttt{stacks} become [[1],[],[1,2]], and then call \\texttt{get(stacks, 2)}. \\texttt{stacks[2]} is empty, return 2.\n- When you call \\texttt{init(3)}, set \\texttt{stacks := [[1,2,2],[3,1,2],[1,2,1]]}, and then call \\texttt{get(stacks, 3)}. \\texttt{stacks[3]} is not empty, set \\texttt{new_pos := 1}, and pop the top element of \\texttt{stacks[3]}, which makes \\texttt{stacks} become [[1,2,2],[3,1,2],[1,2]], and then call \\texttt{get(stacks, 1)}. \\texttt{stacks[1]} is not empty, set \\texttt{new_pos := 2}, and pop the top element of \\texttt{stacks[1]}, which makes \\texttt{stacks} become [[1,2],[3,1,2],[1,2]], and then call \\texttt{get(stacks, 2)}. \\texttt{stacks[2]} is not empty, set \\texttt{new_pos := 2}, and pop the top element of \\texttt{stacks[2]}, which makes \\texttt{stacks} become [[1,2],[3,1],[1,2]], and then call \\texttt{get(stacks, 2)}. \\texttt{stacks[2]} is not empty, set \\texttt{new_pos := 1}, and pop the top element of \\texttt{stacks[2]}, which makes \\texttt{stacks} become [[1,2],[3],[1,2]], and then call \\texttt{get(stacks, 1)}. \\texttt{stacks[1]} is not empty, set \\texttt{new_pos := 2}, and pop the top element of \\texttt{stacks[1]}, which makes \\texttt{stacks} become [[1],[3],[1,2]], and then call \\texttt{get(stacks, 2)}. \\texttt{stacks[2]} is not empty, set \\texttt{new_pos := 3}, and pop the top element of \\texttt{stacks[2]}, which makes \\texttt{stacks} become [[1],[],[1,2]], and then call \\texttt{get(stacks, 3)}. \\texttt{stacks[3]} is not empty, set \\texttt{new_pos := 2}, and pop the top element of \\texttt{stacks[3]}, which makes \\texttt{stacks} become [[1],[],[1]], and then call \\texttt{get(stacks, 2)}. \\texttt{stacks[2]} is empty, return 2.",
        "platform": "codeforces",
        "question_id": "1889/D",
        "contest_id": "1889",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + 1 + k]))\n    stacks.append(stack)\n    index += 1 + k\n\nresults = []\n\nfor i in range(n):\n    new_pos = 0\n    while stacks[i]:\n        if stacks[i][new_pos] == i + 1:\n            new_pos += 1\n        else:\n            stacks[i].pop(new_pos)\n    results.append(new_pos)\n\nprint(' '.join(map(str, results)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + k + 1]))\n    stacks.append(stack)\n    index += k + 1\n\ndef get(stacks, i):\n    stack = stacks[i - 1]\n    if not stack:\n        return 1\n    new_pos = 0\n    while new_pos < len(stack) and stack[new_pos] == i:\n        new_pos += 1\n    if new_pos == len(stack):\n        return i\n    stack[new_pos], stack[-1] = stack[-1], stack[new_pos]\n    return stack.pop()\n\nresults = []\nfor i in range(1, n + 1):\n    result = get(stacks, i)\n    results.append(result)\n\nprint(\" \".join(map(str, results)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nindex = 1\nresults = []\n\nfor i in range(n):\n    k = int(data[index])\n    index += 1\n    stack = list(map(int, data[index:index + k]))\n    index += k\n    \n    new_pos = 0\n    while True:\n        if stack[new_pos] != i + 1:\n            new_pos += 1\n            if new_pos == len(stack):\n                new_pos = 0\n        else:\n            stack.pop(new_pos)\n            if not stack:\n                results.append(1)\n                break\n            else:\n                new_pos = 0\n\nfor result in results:\n    print(result, end=' ')\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + k + 1]))\n    stacks.append(stack)\n    index += k + 1\n\nresults = []\n\nfor i in range(n):\n    stack = stacks[i]\n    new_pos = 0\n    while stack:\n        if stack[new_pos] == i + 1:\n            new_pos += 1\n        else:\n            stack.pop(new_pos)\n    results.append(new_pos)\n\nprint(' '.join(map(str, results)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + 1 + k]))\n    stacks.append(stack)\n    index += 1 + k\n\ndef get(stacks, i):\n    stack = stacks[i - 1]\n    if not stack:\n        return 1\n    new_pos = 0\n    while new_pos < len(stack) and stack[new_pos] == i:\n        new_pos += 1\n    if new_pos == len(stack):\n        return i\n    stack[new_pos] = i\n    return get(stacks, i)\n\nresults = [get(stacks, i) for i in range(1, n + 1)]\n\nprint(' '.join(map(str, results)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nindex = 1\nresults = []\n\nfor i in range(n):\n    k = int(data[index])\n    index += 1\n    stack = list(map(int, data[index:index+k]))\n    index += k\n    \n    def get(stacks, pos):\n        while stacks[pos-1]:\n            top = stacks[pos-1].pop()\n            if top == pos:\n                return pos\n            else:\n                stacks[top-1].append(top)\n        return 1\n    \n    results.append(get([stack], i+1))\n\nprint(' '.join(map(str, results)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nindex = 1\nresults = []\n\nfor i in range(n):\n    k = int(data[index])\n    index += 1\n    stack = list(map(int, data[index:index + k]))\n    index += k\n    \n    def get(stacks, pos):\n        while stacks[pos - 1]:\n            stacks[pos - 1].pop()\n        return pos\n    \n    result = get([stack], 1)\n    results.append(result)\n\nprint(' '.join(map(str, results)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nindex = 1\nresults = []\n\nfor i in range(n):\n    k = int(data[index])\n    index += 1\n    stack = list(map(int, data[index:index + k]))\n    index += k\n    \n    def get(stacks, pos):\n        while stacks[pos - 1]:\n            stacks[pos - 1].pop()\n        return pos\n    \n    result = get([stack], 1)\n    results.append(result)\n\nprint(' '.join(map(str, results)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + k + 1]))\n    stacks.append(stack)\n    index += k + 1\n\nresults = []\n\nfor i in range(n):\n    stack = stacks[i].copy()\n    count = 0\n    while stack:\n        new_pos = stack[0] - 1\n        stack.pop(0)\n        count += 1\n        if stack and stack[0] == new_pos + 1:\n            stack.pop(0)\n        else:\n            stack.insert(0, new_pos + 1)\n    results.append(count)\n\nprint(\" \".join(map(str, results)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + k + 1]))\n    stacks.append(stack)\n    index += k + 1\n\nresults = []\n\nfor i in range(n):\n    new_pos = 0\n    while stacks[i]:\n        if stacks[i][new_pos] == i + 1:\n            new_pos += 1\n        else:\n            stacks[i].pop(new_pos)\n    results.append(new_pos)\n\nprint(' '.join(map(str, results)))\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + 1 + k]))\n    stacks.append(stack)\n    index += 1 + k\n\nresults = []\n\nfor i in range(n):\n    new_pos = 0\n    while stacks[i]:\n        if stacks[i][new_pos] == i + 1:\n            new_pos += 1\n        else:\n            stacks[i].pop(new_pos)\n    results.append(new_pos)\n\nprint(' '.join(map(str, results)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + k + 1]))\n    stacks.append(stack)\n    index += k + 1\n\ndef get(stacks, i):\n    stack = stacks[i - 1]\n    if not stack:\n        return 1\n    new_pos = 0\n    while new_pos < len(stack) and stack[new_pos] == i:\n        new_pos += 1\n    if new_pos == len(stack):\n        return i\n    stack[new_pos], stack[-1] = stack[-1], stack[new_pos]\n    return stack.pop()\n\nresults = []\nfor i in range(1, n + 1):\n    result = get(stacks, i)\n    results.append(result)\n\nprint(\" \".join(map(str, results)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nindex = 1\nresults = []\n\nfor i in range(n):\n    k = int(data[index])\n    index += 1\n    stack = list(map(int, data[index:index + k]))\n    index += k\n    \n    new_pos = 0\n    while True:\n        if stack[new_pos] != i + 1:\n            new_pos += 1\n            if new_pos == len(stack):\n                new_pos = 0\n        else:\n            stack.pop(new_pos)\n            if not stack:\n                results.append(1)\n                break\n            else:\n                new_pos = 0\n\nfor result in results:\n    print(result, end=' ')",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + k + 1]))\n    stacks.append(stack)\n    index += k + 1\n\nresults = []\n\nfor i in range(n):\n    stack = stacks[i]\n    new_pos = 0\n    while stack:\n        if stack[new_pos] == i + 1:\n            new_pos += 1\n        else:\n            stack.pop(new_pos)\n    results.append(new_pos)\n\nprint(' '.join(map(str, results)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + 1 + k]))\n    stacks.append(stack)\n    index += 1 + k\n\ndef get(stacks, i):\n    stack = stacks[i - 1]\n    if not stack:\n        return 1\n    new_pos = 0\n    while new_pos < len(stack) and stack[new_pos] == i:\n        new_pos += 1\n    if new_pos == len(stack):\n        return i\n    stack[new_pos] = i\n    return get(stacks, i)\n\nresults = [get(stacks, i) for i in range(1, n + 1)]\n\nprint(' '.join(map(str, results)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nindex = 1\nresults = []\n\nfor i in range(n):\n    k = int(data[index])\n    index += 1\n    stack = list(map(int, data[index:index+k]))\n    index += k\n    \n    def get(stacks, pos):\n        while stacks[pos-1]:\n            top = stacks[pos-1].pop()\n            if top == pos:\n                return pos\n            else:\n                stacks[top-1].append(top)\n        return 1\n    \n    results.append(get([stack], i+1))\n\nprint(' '.join(map(str, results)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nindex = 1\nresults = []\n\nfor i in range(n):\n    k = int(data[index])\n    index += 1\n    stack = list(map(int, data[index:index + k]))\n    index += k\n    \n    def get(stacks, pos):\n        while stacks[pos - 1]:\n            stacks[pos - 1].pop()\n        return pos\n    \n    result = get([stack], 1)\n    results.append(result)\n\nprint(' '.join(map(str, results)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nindex = 1\nresults = []\n\nfor i in range(n):\n    k = int(data[index])\n    index += 1\n    stack = list(map(int, data[index:index + k]))\n    index += k\n    \n    def get(stacks, pos):\n        while stacks[pos - 1]:\n            stacks[pos - 1].pop()\n        return pos\n    \n    result = get([stack], 1)\n    results.append(result)\n\nprint(' '.join(map(str, results)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + k + 1]))\n    stacks.append(stack)\n    index += k + 1\n\nresults = []\n\nfor i in range(n):\n    stack = stacks[i].copy()\n    count = 0\n    while stack:\n        new_pos = stack[0] - 1\n        stack.pop(0)\n        count += 1\n        if stack and stack[0] == new_pos + 1:\n            stack.pop(0)\n        else:\n            stack.insert(0, new_pos + 1)\n    results.append(count)\n\nprint(\" \".join(map(str, results)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nstacks = []\n\nindex = 1\nfor i in range(n):\n    k = int(data[index])\n    stack = list(map(int, data[index + 1:index + k + 1]))\n    stacks.append(stack)\n    index += k + 1\n\nresults = []\n\nfor i in range(n):\n    new_pos = 0\n    while stacks[i]:\n        if stacks[i][new_pos] == i + 1:\n            new_pos += 1\n        else:\n            stacks[i].pop(new_pos)\n    results.append(new_pos)\n\nprint(' '.join(map(str, results)))"
        ]
    },
    {
        "question_title": "Fancy Arrays",
        "question_content": "Let's call an array a of n non-negative integers fancy if the following conditions hold:\n\n- at least one from the numbers x, x + 1, ..., x+k-1 appears in the array;\n- consecutive elements of the array differ by at most k (i.e. |a_i-a_{i-1}| \\le k for each i \\in [2, n]).\n\nYou are given n, x and k. Your task is to calculate the number of fancy arrays of length n. Since the answer can be large, print it modulo 10^9+7.\n\n\nInput Format\nThe first line contains a single integer t (1 \\le t \\le 50)\u00a0\u2014 the number of test cases.\n\nThe only line of each test case contains three integers n, x and k (1 \\le n, k \\le 10^9; 0 \\le x \\le 40).\n\n\nOutput Format\nFor each test case, print a single integer\u00a0\u2014 the number of fancy arrays of length n, taken modulo 10^9+7.\n\n\nSample Input 1\n\n4\n3 0 1\n1 4 25\n4 7 2\n1000000000 40 1000000000\n\nSample Output 1\n\n9\n25\n582\n514035484\n\n\nNote\nIn the first test case of the example, the following arrays are fancy:\n\n- [0, 0, 0];\n- [0, 0, 1];\n- [0, 1, 0];\n- [0, 1, 1];\n- [0, 1, 2];\n- [1, 0, 0];\n- [1, 0, 1];\n- [1, 1, 0];\n- [2, 1, 0].",
        "platform": "codeforces",
        "question_id": "1895/F",
        "contest_id": "1895",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i > x:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i < x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp[x:x + k + 1]) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - k >= 0:\n                new_dp[i] = (new_dp[i] + dp[i - k]) % MOD\n            if i + 1 <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp[x:x + k + 1]) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(n - 1):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - k >= 0:\n                new_dp[i] = (new_dp[i] + dp[i - k]) % MOD\n            if i + k <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + k]) % MOD\n        dp = new_dp\n    \n    return sum(dp) % MOD\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    x = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    results.append(count_fancy_arrays(n, x, k))\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - 1 >= x:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i + 1 <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp[x:x + k + 1]) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(n - 1):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - 1 >= x:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i + 1 <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - 1 >= x:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i + 1 <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp[x:x + k + 1]) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    x = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    \n    MOD = 10**9 + 7\n    \n    if n == 1:\n        results.append(1)\n        continue\n    \n    if k == 0:\n        if x in range(n):\n            results.append(1)\n        else:\n            results.append(0)\n        continue\n    \n    dp = [0] * (n + 1)\n    dp[x] = 1\n    \n    for i in range(1, n):\n        for j in range(max(0, x - k), min(n, x + k + 1)):\n            dp[i] = (dp[i] + dp[j]) % MOD\n    \n    results.append(sum(dp) % MOD)\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    x = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    \n    MOD = 10**9 + 7\n    \n    if k == 0:\n        if x < n:\n            results.append(0)\n        else:\n            results.append(1)\n        continue\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(max(0, i - k), min(n, i + k) + 1):\n            if abs(j - x) < k:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    results.append(dp[n])\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - k >= 0:\n                new_dp[i] = (new_dp[i] + dp[i - k]) % MOD\n            if i + k <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + k]) % MOD\n        dp = new_dp\n    \n    return sum(dp) % MOD\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    x = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    results.append(count_fancy_arrays(n, x, k))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - 1 >= x:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i + 1 <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp[x:x + k + 1]) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i > x:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i < x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp[x:x + k + 1]) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - k >= 0:\n                new_dp[i] = (new_dp[i] + dp[i - k]) % MOD\n            if i + 1 <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp[x:x + k + 1]) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(n - 1):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - k >= 0:\n                new_dp[i] = (new_dp[i] + dp[i - k]) % MOD\n            if i + k <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + k]) % MOD\n        dp = new_dp\n    \n    return sum(dp) % MOD\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    x = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    results.append(count_fancy_arrays(n, x, k))\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - 1 >= x:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i + 1 <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp[x:x + k + 1]) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(n - 1):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - 1 >= x:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i + 1 <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - 1 >= x:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i + 1 <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp[x:x + k + 1]) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    x = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    \n    MOD = 10**9 + 7\n    \n    if n == 1:\n        results.append(1)\n        continue\n    \n    if k == 0:\n        if x in range(n):\n            results.append(1)\n        else:\n            results.append(0)\n        continue\n    \n    dp = [0] * (n + 1)\n    dp[x] = 1\n    \n    for i in range(1, n):\n        for j in range(max(0, x - k), min(n, x + k + 1)):\n            dp[i] = (dp[i] + dp[j]) % MOD\n    \n    results.append(sum(dp) % MOD)\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    x = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    \n    MOD = 10**9 + 7\n    \n    if k == 0:\n        if x < n:\n            results.append(0)\n        else:\n            results.append(1)\n        continue\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(max(0, i - k), min(n, i + k) + 1):\n            if abs(j - x) < k:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    results.append(dp[n])\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - k >= 0:\n                new_dp[i] = (new_dp[i] + dp[i - k]) % MOD\n            if i + k <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + k]) % MOD\n        dp = new_dp\n    \n    return sum(dp) % MOD\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    x = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    results.append(count_fancy_arrays(n, x, k))\n\nfor result in results:\n    print(result)",
            "import sys\n\nMOD = 10**9 + 7\n\ndef count_fancy_arrays(n, x, k):\n    if n == 1:\n        return 1\n    if k == 0:\n        return 1 if x == 0 else 0\n    \n    dp = [0] * (x + k + 1)\n    dp[x] = 1\n    \n    for _ in range(1, n):\n        new_dp = [0] * (x + k + 1)\n        for i in range(x, x + k + 1):\n            if i - 1 >= x:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n            if i + 1 <= x + k:\n                new_dp[i] = (new_dp[i] + dp[i + 1]) % MOD\n        dp = new_dp\n    \n    return sum(dp[x:x + k + 1]) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        x = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(count_fancy_arrays(n, x, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Pumping Lemma",
        "question_content": "You are given two strings s, t of length n, m, respectively. Both strings consist of lowercase letters of the English alphabet.\n\nCount the triples (x, y, z) of strings such that the following conditions are true:\n\n- s = x+y+z (the symbol + represents the concatenation);\n- t = x+\\underbrace{ y+\\dots+y }_{k \\text{ times}} + z for some integer k.\n\n\nInput Format\nThe first line contains two integers n and m (1 \\leq n < m \\leq 10^7)\u00a0\u2014 the length of the strings s and t, respectively.\n\nThe second line contains the string s of length n, consisting of lowercase letters of the English alphabet.\n\nThe third line contains the string t of length m, consisting of lowercase letters of the English alphabet.\n\n\nOutput Format\nOutput a single integer: the number of valid triples (x, y, z).\n\n\nSample Input 1\n\n4 8\nabcd\nabcbcbcd\n\nSample Output 1\n\n1\n\n\nSample Input 2\n\n3 5\naaa\naaaaa\n\nSample Output 2\n\n5\n\n\nSample Input 3\n\n12 16\nabbababacaab\nabbababababacaab\n\nSample Output 3\n\n8\n\n\nNote\nIn the first test case, the only valid triple is (x, y, z) = (\\texttt{\"a\"}, \\texttt{\"bc\"}, \\texttt{\"d\"}). In fact,\n\n- \\texttt{\"abcd\"} = \\texttt{\"a\"} + \\texttt{\"bc\"} + \\texttt{\"d\"};\n- \\texttt{\"abcbcbcd\"} = \\texttt{\"a\"} + \\texttt{\"bc\"} + \\texttt{\"bc\"} + \\texttt{\"bc\"} + \\texttt{\"d\"}.\n\nIn the second test case, there are 5 valid triples:\n\n- (x, y, z) = (\\texttt{\"\"}, \\texttt{\"a\"}, \\texttt{\"aa\"});\n- (x, y, z) = (\\texttt{\"\"}, \\texttt{\"aa\"}, \\texttt{\"a\"});\n- (x, y, z) = (\\texttt{\"a\"}, \\texttt{\"a\"}, \\texttt{\"a\"});\n- (x, y, z) = (\\texttt{\"a\"}, \\texttt{\"aa\"}, \\texttt{\"\"});\n- (x, y, z) = (\\texttt{\"aa\"}, \\texttt{\"a\"}, \\texttt{\"\"}).\n\nIn the third test case, there are 8 valid triples:\n\n- (x, y, z) = (\\texttt{\"ab\"}, \\texttt{\"ba\"}, \\texttt{\"babacaab\"});\n- (x, y, z) = (\\texttt{\"abb\"}, \\texttt{\"ab\"}, \\texttt{\"abacaab\"});\n- (x, y, z) = (\\texttt{\"abba\"}, \\texttt{\"ba\"}, \\texttt{\"bacaab\"});\n- (x, y, z) = (\\texttt{\"ab\"}, \\texttt{\"baba\"}, \\texttt{\"bacaab\"});\n- (x, y, z) = (\\texttt{\"abbab\"}, \\texttt{\"ab\"}, \\texttt{\"acaab\"});\n- (x, y, z) = (\\texttt{\"abb\"}, \\texttt{\"abab\"}, \\texttt{\"acaab\"});\n- (x, y, z) = (\\texttt{\"abbaba\"}, \\texttt{\"ba\"}, \\texttt{\"caab\"});\n- (x, y, z) = (\\texttt{\"abba\"}, \\texttt{\"baba\"}, \\texttt{\"caab\"}).",
        "platform": "codeforces",
        "question_id": "1909/G",
        "contest_id": "1909",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\n# Initialize the count of valid triples\ncount = 0\n\n# Iterate over all possible positions for x and z\nfor i in range(n + 1):\n    for j in range(m - n + 1):\n        x = s[:i]\n        z = s[i:]\n        y = t[j:j + m - n]\n        if x + y + z == s and t == x + y * (len(t) - j - m + n) + z:\n            count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\n# Initialize the count of valid triples\ncount = 0\n\n# Iterate over possible lengths of x\nfor i in range(n + 1):\n    x = s[:i]\n    remaining_s = s[i:]\n    \n    # Check if the remaining part of s can be split into y and z\n    if remaining_s in t:\n        # Iterate over possible lengths of y\n        for j in range(len(remaining_s) + 1):\n            y = remaining_s[:j]\n            z = remaining_s[j:]\n            \n            # Check if t matches the pattern x + y + ... + y + z\n            if t.startswith(x) and t.endswith(z):\n                k = (len(t) - len(x) - len(z)) // len(y)\n                if k * y + z == t[len(x):-len(z)]:\n                    count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ncount = 0\n\nfor i in range(n + 1):\n    x = s[:i]\n    if t.startswith(x):\n        remaining_t = t[len(x):]\n        k = 1\n        while remaining_t.startswith(s[i:i+k]):\n            remaining_t = remaining_t[len(s[i:i+k]):]\n            k += 1\n        if remaining_t == s[i+k:]:\n            count += 1\n\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ncount = 0\n\nfor i in range(n + 1):\n    x = s[:i]\n    if t.startswith(x):\n        remaining_t = t[len(x):]\n        y = remaining_t[:len(remaining_t) // (m - n)]\n        if y * (m - n) == remaining_t:\n            z = remaining_t[len(y) * (m - n):]\n            count += 1\n\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ncount = 0\n\nfor i in range(n + 1):\n    x = s[:i]\n    if t.startswith(x):\n        remaining_t = t[len(x):]\n        k = 1\n        while remaining_t.startswith(s[i:i+k]):\n            remaining_t = remaining_t[len(s[i:i+k]):]\n            k += 1\n        if remaining_t == s[i+k:]:\n            count += 1\n\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\n# Initialize the count of valid triples\ncount = 0\n\n# Iterate over all possible positions for x and z\nfor i in range(n + 1):\n    for j in range(m - n + 1):\n        x = s[:i]\n        z = s[i:]\n        y = t[j:j + n]\n        if s == x + y + z and t == x + y * (len(t) - j - n // len(y)) + z:\n            count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ncount = 0\n\nfor i in range(n + 1):\n    for j in range(i + 1, n + 1):\n        x = s[:i]\n        y = s[i:j]\n        z = s[j:]\n        if t.startswith(x) and t.endswith(z):\n            k = (len(t) - len(x) - len(z)) // len(y)\n            if k * len(y) + len(x) + len(z) == len(t):\n                count += 1\n\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ndef count_triples(n, m, s, t):\n    count = 0\n    for i in range(n + 1):\n        x = s[:i]\n        if t.startswith(x):\n            remaining_t = t[len(x):]\n            if remaining_t.endswith(s[i:]):\n                y = remaining_t[:-len(s[i:])]\n                z = s[i:]\n                if y == z:\n                    count += 1\n    return count\n\nprint(count_triples(n, m, s, t))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\n# Initialize the count of valid triples\ncount = 0\n\n# Iterate over all possible positions for x and z\nfor i in range(n + 1):\n    for j in range(m - n + 1):\n        # Extract x and z\n        x = s[:i]\n        z = s[i:]\n        y = t[j:j + n]\n        \n        # Check if y repeated k times equals the remaining part of t\n        if y * ((m - j) // n) == t[j:]:\n            count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ncount = 0\n\nfor i in range(n + 1):\n    x = s[:i]\n    if t.startswith(x):\n        remaining_t = t[len(x):]\n        k = 0\n        while remaining_t.startswith(s[i:i + len(x)]):\n            k += 1\n            remaining_t = remaining_t[len(x):]\n        if remaining_t == s[i + len(x):]:\n            count += 1\n\nprint(count)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\n# Initialize the count of valid triples\ncount = 0\n\n# Iterate over all possible positions for x and z\nfor i in range(n + 1):\n    for j in range(m - n + 1):\n        x = s[:i]\n        z = s[i:]\n        y = t[j:j + m - n]\n        if x + y + z == s and t == x + y * (len(t) - j - m + n) + z:\n            count += 1\n\n# Output the result\nprint(count)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\n# Initialize the count of valid triples\ncount = 0\n\n# Iterate over possible lengths of x\nfor i in range(n + 1):\n    x = s[:i]\n    remaining_s = s[i:]\n    \n    # Check if the remaining part of s can be split into y and z\n    if remaining_s in t:\n        # Iterate over possible lengths of y\n        for j in range(len(remaining_s) + 1):\n            y = remaining_s[:j]\n            z = remaining_s[j:]\n            \n            # Check if t matches the pattern x + y + ... + y + z\n            if t.startswith(x) and t.endswith(z):\n                k = (len(t) - len(x) - len(z)) // len(y)\n                if k * y + z == t[len(x):-len(z)]:\n                    count += 1\n\n# Output the result\nprint(count)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ncount = 0\n\nfor i in range(n + 1):\n    x = s[:i]\n    if t.startswith(x):\n        remaining_t = t[len(x):]\n        k = 1\n        while remaining_t.startswith(s[i:i+k]):\n            remaining_t = remaining_t[len(s[i:i+k]):]\n            k += 1\n        if remaining_t == s[i+k:]:\n            count += 1\n\nprint(count)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ncount = 0\n\nfor i in range(n + 1):\n    x = s[:i]\n    if t.startswith(x):\n        remaining_t = t[len(x):]\n        y = remaining_t[:len(remaining_t) // (m - n)]\n        if y * (m - n) == remaining_t:\n            z = remaining_t[len(y) * (m - n):]\n            count += 1\n\nprint(count)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ncount = 0\n\nfor i in range(n + 1):\n    x = s[:i]\n    if t.startswith(x):\n        remaining_t = t[len(x):]\n        k = 1\n        while remaining_t.startswith(s[i:i+k]):\n            remaining_t = remaining_t[len(s[i:i+k]):]\n            k += 1\n        if remaining_t == s[i+k:]:\n            count += 1\n\nprint(count)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\n# Initialize the count of valid triples\ncount = 0\n\n# Iterate over all possible positions for x and z\nfor i in range(n + 1):\n    for j in range(m - n + 1):\n        x = s[:i]\n        z = s[i:]\n        y = t[j:j + n]\n        if s == x + y + z and t == x + y * (len(t) - j - n // len(y)) + z:\n            count += 1\n\n# Output the result\nprint(count)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ncount = 0\n\nfor i in range(n + 1):\n    for j in range(i + 1, n + 1):\n        x = s[:i]\n        y = s[i:j]\n        z = s[j:]\n        if t.startswith(x) and t.endswith(z):\n            k = (len(t) - len(x) - len(z)) // len(y)\n            if k * len(y) + len(x) + len(z) == len(t):\n                count += 1\n\nprint(count)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ndef count_triples(n, m, s, t):\n    count = 0\n    for i in range(n + 1):\n        x = s[:i]\n        if t.startswith(x):\n            remaining_t = t[len(x):]\n            if remaining_t.endswith(s[i:]):\n                y = remaining_t[:-len(s[i:])]\n                z = s[i:]\n                if y == z:\n                    count += 1\n    return count\n\nprint(count_triples(n, m, s, t))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\n# Initialize the count of valid triples\ncount = 0\n\n# Iterate over all possible positions for x and z\nfor i in range(n + 1):\n    for j in range(m - n + 1):\n        # Extract x and z\n        x = s[:i]\n        z = s[i:]\n        y = t[j:j + n]\n        \n        # Check if y repeated k times equals the remaining part of t\n        if y * ((m - j) // n) == t[j:]:\n            count += 1\n\n# Output the result\nprint(count)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\nt = data[3]\n\ncount = 0\n\nfor i in range(n + 1):\n    x = s[:i]\n    if t.startswith(x):\n        remaining_t = t[len(x):]\n        k = 0\n        while remaining_t.startswith(s[i:i + len(x)]):\n            k += 1\n            remaining_t = remaining_t[len(x):]\n        if remaining_t == s[i + len(x):]:\n            count += 1\n\nprint(count)"
        ]
    },
    {
        "question_title": "Maximum Sum Subarrays",
        "question_content": "You are given two integer arrays a and b, both of length n.\n\nYou can perform the following operation any number of times (possibly zero): swap a_i and b_i.\n\nLet f(c) be the maximum sum of a contiguous subarray of the array c (including the empty subsegment, which sum is 0).\n\nYour task is to calculate the maximum possible value of f(a) + f(b), using the aforementioned operation any number of times.\n\n\nInput Format\nThe first line contains a single integer t (1 \\le t \\le 10^4)\u00a0\u2014 the number of test cases.\n\nThe first line of each test case contains a single integer n (1 \\le n \\le 2 \\cdot 10^5).\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (-10^9 \\le a_i \\le 10^9).\n\nThe third line contains n integers b_1, b_2, \\dots, b_n (-10^9 \\le b_i \\le 10^9).\n\nThe sum of n over all test case doesn't exceed 2 \\cdot 10^5.\n\n\nOutput Format\nFor each test case, print a single integer\u00a0\u2014 the maximum possible value of f(a) + f(b), using the aforementioned operation any number of times.\n\n\nSample Input 1\n\n3\n3\n2 -1 3\n-4 0 1\n6\n4 2 -6 1 6 -4\n-6 -2 -3 7 -3 2\n2\n-2 -5\n0 -1\n\nSample Output 1\n\n6\n21\n0",
        "platform": "codeforces",
        "question_id": "1910/E",
        "contest_id": "1910",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Try swapping each pair (a_i, b_i)\n    max_sum = max_a + max_b\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        max_a = max_subarray_sum(a)\n        max_b = max_subarray_sum(b)\n        max_sum = max(max_sum, max_a + max_b)\n        a[i], b[i] = b[i], a[i]\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Consider the case where we swap all elements\n    swapped_a = [-x for x in a]\n    swapped_b = [-x for x in b]\n    max_swapped_a = max_subarray_sum(swapped_a)\n    max_swapped_b = max_subarray_sum(swapped_b)\n    \n    results.append(max(max_a + max_b, max_a + max_swapped_b, max_swapped_a + max_b))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef max_subarray_sum(arr):\n    max_current = max_global = arr[0]\n    for num in arr[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\ndef solve():\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        max_a = max_subarray_sum(a)\n        max_b = max_subarray_sum(b)\n        \n        # Try swapping each element and calculate the new sums\n        max_sum = 0\n        for i in range(n):\n            new_a = a[:]\n            new_b = b[:]\n            new_a[i], new_b[i] = new_b[i], new_a[i]\n            new_max_a = max_subarray_sum(new_a)\n            new_max_b = max_subarray_sum(new_b)\n            max_sum = max(max_sum, max_max_a + new_max_b)\n        \n        results.append(max_sum)\n    \n    for result in results:\n        print(result)\n\nsolve()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Calculate the maximum possible value of f(a) + f(b)\n    # By swapping elements, we can potentially increase the sum of the subarray\n    # The best strategy is to swap elements to maximize the sum of the subarray\n    # in both arrays\n    max_possible = max_a + max_b\n    \n    results.append(max_possible)\n\n# Print all results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Calculate the maximum possible value of f(a) + f(b)\n    max_sum = max_a + max_b\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Try swapping each pair (a_i, b_i)\n    max_sum = max_a + max_b\n    for i in range(n):\n        swapped_a = a[:]\n        swapped_b = b[:]\n        swapped_a[i], swapped_b[i] = swapped_b[i], swapped_a[i]\n        max_sum = max(max_sum, max_subarray_sum(swapped_a) + max_subarray_sum(swapped_b))\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Consider the possibility of swapping elements to maximize the sum\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        max_a_new = max_subarray_sum(a)\n        max_b_new = max_subarray_sum(b)\n        max_a = max(max_a, max_a_new)\n        max_b = max(max_b, max_b_new)\n        a[i], b[i] = b[i], a[i]\n    \n    results.append(max_a + max_b)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Try swapping each pair (a_i, b_i)\n    max_sum = max_a + max_b\n    for i in range(n):\n        swapped_a = a[:]\n        swapped_b = b[:]\n        swapped_a[i], swapped_b[i] = swapped_b[i], swapped_a[i]\n        max_sum = max(max_sum, max_subarray_sum(swapped_a) + max_subarray_sum(swapped_b))\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Try swapping each pair (a_i, b_i)\n    max_sum = max_a + max_b\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        max_a = max_subarray_sum(a)\n        max_b = max_subarray_sum(b)\n        max_sum = max(max_sum, max_a + max_b)\n        a[i], b[i] = b[i], a[i]\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Try swapping each pair (a_i, b_i)\n    max_sum = max_a + max_b\n    for i in range(n):\n        swapped_a = a[:]\n        swapped_b = b[:]\n        swapped_a[i], swapped_b[i] = swapped_b[i], swapped_a[i]\n        max_sum = max(max_sum, max_subarray_sum(swapped_a) + max_subarray_sum(swapped_b))\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Try swapping each pair (a_i, b_i)\n    max_sum = max_a + max_b\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        max_a = max_subarray_sum(a)\n        max_b = max_subarray_sum(b)\n        max_sum = max(max_sum, max_a + max_b)\n        a[i], b[i] = b[i], a[i]\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Consider the case where we swap all elements\n    swapped_a = [-x for x in a]\n    swapped_b = [-x for x in b]\n    max_swapped_a = max_subarray_sum(swapped_a)\n    max_swapped_b = max_subarray_sum(swapped_b)\n    \n    results.append(max(max_a + max_b, max_a + max_swapped_b, max_swapped_a + max_b))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ndef max_subarray_sum(arr):\n    max_current = max_global = arr[0]\n    for num in arr[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\ndef solve():\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        b = list(map(int, data[index:index + n]))\n        index += n\n        \n        max_a = max_subarray_sum(a)\n        max_b = max_subarray_sum(b)\n        \n        # Try swapping each element and calculate the new sums\n        max_sum = 0\n        for i in range(n):\n            new_a = a[:]\n            new_b = b[:]\n            new_a[i], new_b[i] = new_b[i], new_a[i]\n            new_max_a = max_subarray_sum(new_a)\n            new_max_b = max_subarray_sum(new_b)\n            max_sum = max(max_sum, max_max_a + new_max_b)\n        \n        results.append(max_sum)\n    \n    for result in results:\n        print(result)\n\nsolve()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Calculate the maximum possible value of f(a) + f(b)\n    # By swapping elements, we can potentially increase the sum of the subarray\n    # The best strategy is to swap elements to maximize the sum of the subarray\n    # in both arrays\n    max_possible = max_a + max_b\n    \n    results.append(max_possible)\n\n# Print all results\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Calculate the maximum possible value of f(a) + f(b)\n    max_sum = max_a + max_b\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Try swapping each pair (a_i, b_i)\n    max_sum = max_a + max_b\n    for i in range(n):\n        swapped_a = a[:]\n        swapped_b = b[:]\n        swapped_a[i], swapped_b[i] = swapped_b[i], swapped_a[i]\n        max_sum = max(max_sum, max_subarray_sum(swapped_a) + max_subarray_sum(swapped_b))\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Consider the possibility of swapping elements to maximize the sum\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        max_a_new = max_subarray_sum(a)\n        max_b_new = max_subarray_sum(b)\n        max_a = max(max_a, max_a_new)\n        max_b = max(max_b, max_b_new)\n        a[i], b[i] = b[i], a[i]\n    \n    results.append(max_a + max_b)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Try swapping each pair (a_i, b_i)\n    max_sum = max_a + max_b\n    for i in range(n):\n        swapped_a = a[:]\n        swapped_b = b[:]\n        swapped_a[i], swapped_b[i] = swapped_b[i], swapped_a[i]\n        max_sum = max(max_sum, max_subarray_sum(swapped_a) + max_subarray_sum(swapped_b))\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Try swapping each pair (a_i, b_i)\n    max_sum = max_a + max_b\n    for i in range(n):\n        a[i], b[i] = b[i], a[i]\n        max_a = max_subarray_sum(a)\n        max_b = max_subarray_sum(b)\n        max_sum = max(max_sum, max_a + max_b)\n        a[i], b[i] = b[i], a[i]\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\n\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    b = list(map(int, data[index:index + n]))\n    index += n\n    \n    def max_subarray_sum(arr):\n        max_current = max_global = arr[0]\n        for num in arr[1:]:\n            max_current = max(num, max_current + num)\n            if max_current > max_global:\n                max_global = max_current\n        return max_global\n    \n    max_a = max_subarray_sum(a)\n    max_b = max_subarray_sum(b)\n    \n    # Try swapping each pair (a_i, b_i)\n    max_sum = max_a + max_b\n    for i in range(n):\n        swapped_a = a[:]\n        swapped_b = b[:]\n        swapped_a[i], swapped_b[i] = swapped_b[i], swapped_a[i]\n        max_sum = max(max_sum, max_subarray_sum(swapped_a) + max_subarray_sum(swapped_b))\n    \n    results.append(max_sum)\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Sum of Digits of Sums",
        "question_content": "You are given an array [a_1, a_2, \\dots, a_n], consisting of positive integers.\n\nFor every i from 1 to n, calculate \\sum \\limits_{j=1}^{n} F(a_i + a_j), where F(x) is the sum of digits of x.\n\n\nInput Format\nThe first line contains one integer n (2 \\le n \\le 2 \\cdot 10^5).\n\nThe second line contains n integers a_1, a_2, \\dots, a_n (1 \\le a_i < 10^9).\n\n\nOutput Format\nPrint n integers. The i-th of them should be equal to \\sum \\limits_{j=1}^{n} F(a_i + a_j).\n\n\nSample Input 1\n\n4\n1 3 3 7\n\nSample Output 1\n\n18 17 17 15\n\n\nSample Input 2\n\n3\n42 1337 999\n\nSample Output 2\n\n38 53 47",
        "platform": "codeforces",
        "question_id": "1910/H",
        "contest_id": "1910",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    \n    prefix_sum = [0] * (10**9 + 1)\n    for i in range(1, 10**9 + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + sum_of_digits(i)\n    \n    result = []\n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total += prefix_sum[a[i] + a[j]]\n        result.append(total)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve(n, a):\n    prefix_sums = [0] * (10**9 + 1)\n    for i in range(n):\n        prefix_sums[a[i]] += sum_of_digits(a[i])\n    \n    for i in range(1, 10**9 + 1):\n        prefix_sums[i] += prefix_sums[i - 1]\n    \n    result = []\n    for i in range(n):\n        total = prefix_sums[10**9] - prefix_sums[a[i] - 1]\n        result.append(total)\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = solve(n, a)\n\n# Write output\nprint(\" \".join(map(str, result)))\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    \n    prefix_sum = [0] * (max(a) * 2 + 1)\n    for i in range(n):\n        prefix_sum[a[i]] += 1\n    \n    for i in range(1, len(prefix_sum)):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total += prefix_sum[a[i] + a[j]]\n        result.append(total)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    \n    prefix_sums = [0] * (10**9 + 1)\n    for num in a:\n        prefix_sums[num] += 1\n    \n    for i in range(1, 10**9 + 1):\n        prefix_sums[i] += prefix_sums[i - 1]\n    \n    results = []\n    for num in a:\n        total = 0\n        for i in range(1, 10**9 + 1):\n            total += prefix_sums[i] * sum_of_digits(num + i)\n        results.append(total)\n    \n    print(\" \".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    solve()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    prefix_sum = [0] * (max(a) * 2 + 1)\n    for i in range(n):\n        prefix_sum[a[i]] += 1\n    \n    for i in range(1, len(prefix_sum)):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total += prefix_sum[a[i] + a[j]]\n        result.append(total)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve(n, a):\n    prefix_sums = [0] * (max(a) * 2 + 1)\n    for i in range(n):\n        prefix_sums[a[i]] += sum_of_digits(a[i])\n    \n    for i in range(1, len(prefix_sums)):\n        prefix_sums[i] += prefix_sums[i - 1]\n    \n    result = []\n    for i in range(n):\n        result.append(prefix_sums[-1] - prefix_sums[a[i]] + prefix_sums[a[i] - 1])\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = solve(n, a)\n\n# Write output\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    \n    prefix_sum = [0] * (max(a) * 2 + 1)\n    for i in range(n):\n        prefix_sum[a[i]] += 1\n    \n    for i in range(1, len(prefix_sum)):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total += prefix_sum[a[i] + a[j]]\n        result.append(total)\n    \n    for value in result:\n        print(value, end=' ')\n\nif __name__ == \"__main__\":\n    solve()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    \n    prefix_sum = [0] * (max(a) * 2 + 1)\n    for i in range(n):\n        prefix_sum[a[i]] += 1\n    \n    for i in range(1, len(prefix_sum)):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total += prefix_sum[a[i] + a[j]]\n        result.append(total)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    \n    prefix_sum = [0] * (10**9 + 1)\n    for num in a:\n        prefix_sum[num] += 1\n    \n    for i in range(1, 10**9 + 1):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for num in a:\n        total = 0\n        for j in range(1, 10**9 + 1):\n            total += prefix_sum[j] * sum_of_digits(num + j)\n        result.append(total)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()\n```",
            "```python\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    \n    prefix_sum = [0] * (10**9 + 1)\n    for i in range(n):\n        prefix_sum[a[i]] += sum_of_digits(a[i])\n    \n    for i in range(1, 10**9 + 1):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    for i in range(n):\n        result = prefix_sum[10**9] - prefix_sum[a[i] - 1]\n        print(result, end=' ')\n\nif __name__ == \"__main__\":\n    solve()\n```"
        ],
        "code_list": [
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    \n    prefix_sum = [0] * (10**9 + 1)\n    for i in range(1, 10**9 + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + sum_of_digits(i)\n    \n    result = []\n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total += prefix_sum[a[i] + a[j]]\n        result.append(total)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve(n, a):\n    prefix_sums = [0] * (10**9 + 1)\n    for i in range(n):\n        prefix_sums[a[i]] += sum_of_digits(a[i])\n    \n    for i in range(1, 10**9 + 1):\n        prefix_sums[i] += prefix_sums[i - 1]\n    \n    result = []\n    for i in range(n):\n        total = prefix_sums[10**9] - prefix_sums[a[i] - 1]\n        result.append(total)\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = solve(n, a)\n\n# Write output\nprint(\" \".join(map(str, result)))",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    \n    prefix_sum = [0] * (max(a) * 2 + 1)\n    for i in range(n):\n        prefix_sum[a[i]] += 1\n    \n    for i in range(1, len(prefix_sum)):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total += prefix_sum[a[i] + a[j]]\n        result.append(total)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
            "# YOUR CODE HERE\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    \n    prefix_sums = [0] * (10**9 + 1)\n    for num in a:\n        prefix_sums[num] += 1\n    \n    for i in range(1, 10**9 + 1):\n        prefix_sums[i] += prefix_sums[i - 1]\n    \n    results = []\n    for num in a:\n        total = 0\n        for i in range(1, 10**9 + 1):\n            total += prefix_sums[i] * sum_of_digits(num + i)\n        results.append(total)\n    \n    print(\" \".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    solve()",
            "# YOUR CODE HERE\nimport sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    prefix_sum = [0] * (max(a) * 2 + 1)\n    for i in range(n):\n        prefix_sum[a[i]] += 1\n    \n    for i in range(1, len(prefix_sum)):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total += prefix_sum[a[i] + a[j]]\n        result.append(total)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve(n, a):\n    prefix_sums = [0] * (max(a) * 2 + 1)\n    for i in range(n):\n        prefix_sums[a[i]] += sum_of_digits(a[i])\n    \n    for i in range(1, len(prefix_sums)):\n        prefix_sums[i] += prefix_sums[i - 1]\n    \n    result = []\n    for i in range(n):\n        result.append(prefix_sums[-1] - prefix_sums[a[i]] + prefix_sums[a[i] - 1])\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = solve(n, a)\n\n# Write output\nprint(' '.join(map(str, result)))",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    \n    prefix_sum = [0] * (max(a) * 2 + 1)\n    for i in range(n):\n        prefix_sum[a[i]] += 1\n    \n    for i in range(1, len(prefix_sum)):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total += prefix_sum[a[i] + a[j]]\n        result.append(total)\n    \n    for value in result:\n        print(value, end=' ')\n\nif __name__ == \"__main__\":\n    solve()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    \n    prefix_sum = [0] * (max(a) * 2 + 1)\n    for i in range(n):\n        prefix_sum[a[i]] += 1\n    \n    for i in range(1, len(prefix_sum)):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for i in range(n):\n        total = 0\n        for j in range(n):\n            total += prefix_sum[a[i] + a[j]]\n        result.append(total)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    \n    prefix_sum = [0] * (10**9 + 1)\n    for num in a:\n        prefix_sum[num] += 1\n    \n    for i in range(1, 10**9 + 1):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    result = []\n    for num in a:\n        total = 0\n        for j in range(1, 10**9 + 1):\n            total += prefix_sum[j] * sum_of_digits(num + j)\n        result.append(total)\n    \n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
            "import sys\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    a = list(map(int, sys.stdin.readline().strip().split()))\n    \n    prefix_sum = [0] * (10**9 + 1)\n    for i in range(n):\n        prefix_sum[a[i]] += sum_of_digits(a[i])\n    \n    for i in range(1, 10**9 + 1):\n        prefix_sum[i] += prefix_sum[i - 1]\n    \n    for i in range(n):\n        result = prefix_sum[10**9] - prefix_sum[a[i] - 1]\n        print(result, end=' ')\n\nif __name__ == \"__main__\":\n    solve()"
        ]
    },
    {
        "question_title": "Vlad and Avoiding X",
        "question_content": "Vladislav has a grid of size 7 \\times 7, where each cell is colored black or white. In one operation, he can choose any cell and change its color (black \\leftrightarrow white).\n\nFind the minimum number of operations required to ensure that there are no black cells with four diagonal neighbors also being black.\n\nThe left image shows that initially there are two black cells violating the condition. By flipping one cell, the grid will work.\n\n\nInput Format\nThe first line of input contains a single integer t (1 \\leq t \\leq 200)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\n\nEach test case consists of 7 lines, each containing 7 characters. Each of these characters is either \\texttt{W} or \\texttt{B}, denoting a white or black cell, respectively.\n\n\nOutput Format\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations required to ensure that there are no black cells with all four diagonal neighbors also being black.\n\n\nSample Input 1\n\n4\nWWWWWWW\nWWWWBBB\nWWWWWBW\nWWBBBBB\nWWWBWWW\nWWBBBWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWBBBBBW\nWBBBBBW\nWBBBBBW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWBBBBBW\nBBBBBBB\nBBBBBBB\nWWWWWWW\nBBBBBBB\nBBBBBBB\nBBBBBBB\n\nSample Output 1\n\n1\n2\n0\n5\n\n\nNote\nThe first test case is illustrated in the statement.\n\nThe second test case is illustrated below:\n\nIn the third test case, the grid already satisfies the condition.",
        "platform": "codeforces",
        "question_id": "1926/F",
        "contest_id": "1926",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i][j] = 'W'\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = []\n        for _ in range(7):\n            grid.append(data[index:index+7])\n            index += 7\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i][j] = 'W'\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = []\n        for _ in range(7):\n            grid.append(data[index:index+7])\n            index += 7\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i][j] = 'W'\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = []\n        for _ in range(7):\n            grid.append(data[index:index+7])\n            index += 7\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i][j] = 'W'\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = []\n        for _ in range(7):\n            grid.append(data[index:index+7])\n            index += 7\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = []\n        for _ in range(7):\n            grid.append(data[index:index+7])\n            index += 7\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    grid = [data[index + i] for i in range(7)]\n    index += 7\n    \n    operations = 0\n    for i in range(1, 6):\n        for j in range(1, 6):\n            if grid[i][j] == 'B' and grid[i-1][j-1] == 'B' and grid[i-1][j+1] == 'B' and grid[i+1][j-1] == 'B' and grid[i+1][j+1] == 'B':\n                operations += 1\n                grid[i][j] = 'W'\n    \n    results.append(operations)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    grid = [data[index + i] for i in range(7)]\n    index += 7\n    \n    operations = 0\n    \n    for i in range(1, 6):\n        for j in range(1, 6):\n            if grid[i][j] == 'B':\n                if grid[i-1][j-1] == 'B' and grid[i-1][j+1] == 'B' and grid[i+1][j-1] == 'B' and grid[i+1][j+1] == 'B':\n                    operations += 1\n    \n    results.append(operations)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    grid = [data[index + i] for i in range(7)]\n    index += 7\n    \n    operations = 0\n    \n    for i in range(7):\n        for j in range(7):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < 6 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < 6 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < 6 and j < 6 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i] = grid[i][:j] + 'W' + grid[i][j+1:]\n                    operations += 1\n    \n    results.append(operations)\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    grid = [data[index + i] for i in range(7)]\n    index += 7\n    \n    operations = 0\n    for i in range(1, 6):\n        for j in range(1, 6):\n            if grid[i][j] == 'B' and grid[i-1][j-1] == 'B' and grid[i-1][j+1] == 'B' and grid[i+1][j-1] == 'B' and grid[i+1][j+1] == 'B':\n                operations += 1\n                grid[i][j] = 'W'\n    \n    results.append(operations)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i][j] = 'W'\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = [data[index:index+7] for index in range(index, index+49)]\n        index += 49\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i][j] = 'W'\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = []\n        for _ in range(7):\n            grid.append(data[index:index+7])\n            index += 7\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i][j] = 'W'\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = []\n        for _ in range(7):\n            grid.append(data[index:index+7])\n            index += 7\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i][j] = 'W'\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = []\n        for _ in range(7):\n            grid.append(data[index:index+7])\n            index += 7\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i][j] = 'W'\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = []\n        for _ in range(7):\n            grid.append(data[index:index+7])\n            index += 7\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = []\n        for _ in range(7):\n            grid.append(data[index:index+7])\n            index += 7\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    grid = [data[index + i] for i in range(7)]\n    index += 7\n    \n    operations = 0\n    for i in range(1, 6):\n        for j in range(1, 6):\n            if grid[i][j] == 'B' and grid[i-1][j-1] == 'B' and grid[i-1][j+1] == 'B' and grid[i+1][j-1] == 'B' and grid[i+1][j+1] == 'B':\n                operations += 1\n                grid[i][j] = 'W'\n    \n    results.append(operations)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    grid = [data[index + i] for i in range(7)]\n    index += 7\n    \n    operations = 0\n    \n    for i in range(1, 6):\n        for j in range(1, 6):\n            if grid[i][j] == 'B':\n                if grid[i-1][j-1] == 'B' and grid[i-1][j+1] == 'B' and grid[i+1][j-1] == 'B' and grid[i+1][j+1] == 'B':\n                    operations += 1\n    \n    results.append(operations)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    grid = [data[index + i] for i in range(7)]\n    index += 7\n    \n    operations = 0\n    \n    for i in range(7):\n        for j in range(7):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < 6 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < 6 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < 6 and j < 6 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i] = grid[i][:j] + 'W' + grid[i][j+1:]\n                    operations += 1\n    \n    results.append(operations)\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    grid = [data[index + i] for i in range(7)]\n    index += 7\n    \n    operations = 0\n    for i in range(1, 6):\n        for j in range(1, 6):\n            if grid[i][j] == 'B' and grid[i-1][j-1] == 'B' and grid[i-1][j+1] == 'B' and grid[i+1][j-1] == 'B' and grid[i+1][j+1] == 'B':\n                operations += 1\n                grid[i][j] = 'W'\n    \n    results.append(operations)\n\nfor result in results:\n    print(result)",
            "import sys\n\ndef min_operations(grid):\n    n = 7\n    operations = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                count = 0\n                if i > 0 and j > 0 and grid[i-1][j-1] == 'B':\n                    count += 1\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 'B':\n                    count += 1\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 'B':\n                    count += 1\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 'B':\n                    count += 1\n                if count == 4:\n                    grid[i][j] = 'W'\n                    operations += 1\n    return operations\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        grid = [data[index:index+7] for index in range(index, index+49)]\n        index += 49\n        results.append(min_operations(grid))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Dating",
        "question_content": "You are the developer of a dating app which ignores gender completely. The app has n users, indexed from 1 to n. Each user's profile features a list of the activities they enjoy doing. There are m possible activities, indexed from 1 to m.\n\nA match between two users is good if they share at least one activity and, at the same time, both of them like at least one activity that the other user does not like.\n\nFind a good match if it exists.\n\n\nInput Format\nThe first line contains two integers n and m (2 \\leq n \\leq 200\\,000, 1 \\leq m \\leq 10^6) \u2014 the number of users and the number of activities.\n\nEach of the following n lines contains a number k_i (0 \\leq k_i \\leq m) \u2014 the number of activities that user i likes \u2014 followed by k_i distinct integers from 1 to m \u2014 the activities user i likes.\n\nIt is guaranteed that k_1+k_2+\\cdots+k_n does not exceed 10^6.\n\n\nOutput Format\nPrint \\texttt{YES} if a good match exists. Otherwise, print \\texttt{NO}.\n\nIf a good match exists, on the next line print two integers\u00a0\u2014 the indexes of two users that make a match.\n\n\nSample Input 1\n\n3 5\n3 1 2 4\n5 1 2 3 4 5\n2 1 5\n\nSample Output 1\n\nYES\n3 1\n\n\nSample Input 2\n\n3 3\n1 1\n1 2\n3 2 3 1\n\nSample Output 2\n\nNO\n\n\nNote\nIn the first sample, users 1 and 3 form a match, because they share activity 1, and, furthermore, user 3 likes activity 5 (which user 1 does not like) and user 1 likes activity 4 (which user 3 does not like). Note that users 1 and 2, as well as users 2 and 3, do not form a match, as there is no activity that users 1 or 3 like, and user 2 doesn't like.",
        "platform": "codeforces",
        "question_id": "1949/F",
        "contest_id": "1949",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nusers = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + 1 + k]))\n    users.append((i + 1, activities))\n    index += 1 + k\n\n# Create a dictionary to store activities liked by each user\nactivity_users = defaultdict(set)\n\nfor user_id, activities in users:\n    for activity in activities:\n        activity_users[activity].add(user_id)\n\n# Check for good matches\nfor user_id1, activities1 in users:\n    for user_id2, activities2 in users:\n        if user_id1 != user_id2:\n            common_activities = activities1 & activities2\n            if common_activities:\n                user1_unliked = activities1 - activities2\n                user2_unliked = activities2 - activities1\n                if user1_unliked and user2_unliked:\n                    print(\"YES\")\n                    print(user_id1, user_id2)\n                    sys.exit(0)\n\nprint(\"NO\")\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\n# Initialize sets to store activities liked by each user\nlikes = [set() for _ in range(n + 1)]\n\n# Read the activities liked by each user\nindex = 2\nfor i in range(1, n + 1):\n    k = int(data[index])\n    index += 1\n    for _ in range(k):\n        activity = int(data[index])\n        likes[i].add(activity)\n        index += 1\n\n# Check for good matches\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        common_activities = likes[i] & likes[j]\n        if common_activities:\n            user1_uncommon = likes[i] - likes[j]\n            user2_uncommon = likes[j] - likes[i]\n            if user1_uncommon or user2_uncommon:\n                print(\"YES\")\n                print(i, j)\n                sys.exit(0)\n\n# If no good match is found\nprint(\"NO\")\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\n# Read the list of liked activities for each user\nusers = []\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + 1 + k]))\n    users.append(activities)\n    index += 1 + k\n\n# Create a dictionary to store users who like each activity\nactivity_users = defaultdict(list)\nfor i, activities in enumerate(users):\n    for activity in activities:\n        activity_users[activity].append(i + 1)\n\n# Check for a good match\nfor activity, user_list in activity_users.items():\n    if len(user_list) < 2:\n        continue\n    for i in range(len(user_list)):\n        for j in range(i + 1, len(user_list)):\n            user1 = user_list[i]\n            user2 = user_list[j]\n            if not users[user1].issubset(users[user2]) and not users[user2].issubset(users[user1]):\n                print(\"YES\")\n                print(user1, user2)\n                sys.exit(0)\n\nprint(\"NO\")\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\n# Read the activities each user likes\nusers = []\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + 1 + k]))\n    users.append(activities)\n    index += 1 + k\n\n# Create a dictionary to store users who like each activity\nactivity_users = defaultdict(list)\nfor i, activities in enumerate(users):\n    for activity in activities:\n        activity_users[activity].append(i + 1)\n\n# Check for a good match\nfor activity, user_list in activity_users.items():\n    if len(user_list) < 2:\n        continue\n    for i in range(len(user_list)):\n        for j in range(i + 1, len(user_list)):\n            user1 = user_list[i]\n            user2 = user_list[j]\n            if not users[user1 - 1].intersection(users[user2 - 1]):\n                continue\n            if any(activity not in users[user1 - 1] for activity in users[user2 - 1]):\n                print(\"YES\")\n                print(user1, user2)\n                sys.exit(0)\n\nprint(\"NO\")\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nactivities = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities.append(set(map(int, data[index + 1:index + 1 + k])))\n    index += 1 + k\n\n# Find a good match\nfor i in range(n):\n    for j in range(i + 1, n):\n        common_activities = activities[i] & activities[j]\n        if common_activities:\n            user1_uncommon = activities[i] - activities[j]\n            user2_uncommon = activities[j] - activities[i]\n            if user1_uncommon or user2_uncommon:\n                print(\"YES\")\n                print(i + 1, j + 1)\n                sys.exit(0)\n\nprint(\"NO\")\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\n# Initialize sets to store activities liked by each user\nlikes = [set() for _ in range(n + 1)]\n\n# Read the activities liked by each user\nindex = 2\nfor i in range(1, n + 1):\n    k = int(data[index])\n    for _ in range(k):\n        activity = int(data[index + 1])\n        likes[i].add(activity)\n        index += 1\n\n# Check for a good match\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        common_activities = likes[i] & likes[j]\n        if common_activities:\n            user1_uncommon = likes[i] - likes[j]\n            user2_uncommon = likes[j] - likes[i]\n            if user1_uncommon or user2_uncommon:\n                print(\"YES\")\n                print(i, j)\n                sys.exit(0)\n\n# If no good match is found\nprint(\"NO\")\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nusers = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + 1 + k]))\n    users.append((i + 1, activities))\n    index += 1 + k\n\n# Create a dictionary to store users who like each activity\nactivity_users = defaultdict(list)\nfor i, activities in users:\n    for activity in activities:\n        activity_users[activity].append(i)\n\n# Check for good matches\nfor activity, user_list in activity_users.items():\n    if len(user_list) < 2:\n        continue\n    for i in range(len(user_list)):\n        for j in range(i + 1, len(user_list)):\n            user1, user2 = user_list[i], user_list[j]\n            if not users[user1 - 1][1].intersection(users[user2 - 1][1]):\n                continue\n            if not (users[user1 - 1][1] - users[user2 - 1][1]) or not (users[user2 - 1][1] - users[user1 - 1][1]):\n                continue\n            print(\"YES\")\n            print(user1, user2)\n            sys.exit(0)\n\nprint(\"NO\")\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nusers = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + k + 1]))\n    users.append(activities)\n    index += k + 1\n\n# Find a good match\nfor i in range(n):\n    for j in range(i + 1, n):\n        common_activities = users[i] & users[j]\n        if common_activities:\n            user1_uncommon = users[i] - users[j]\n            user2_uncommon = users[j] - users[i]\n            if user1_uncommon or user2_uncommon:\n                print(\"YES\")\n                print(i + 1, j + 1)\n                sys.exit(0)\n\nprint(\"NO\")\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nactivities = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities.append(set(map(int, data[index + 1:index + 1 + k])))\n    index += 1 + k\n\n# Find a good match\nfor i in range(n):\n    for j in range(i + 1, n):\n        if activities[i] & activities[j]:\n            common_activities = activities[i] & activities[j]\n            user1_extra = activities[i] - common_activities\n            user2_extra = activities[j] - common_activities\n            if user1_extra and user2_extra:\n                print(\"YES\")\n                print(i + 1, j + 1)\n                sys.exit(0)\n\nprint(\"NO\")\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nusers = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + 1 + k]))\n    users.append((i + 1, activities))\n    index += 1 + k\n\n# Create a dictionary to store users who like each activity\nactivity_users = defaultdict(list)\nfor i, activities in users:\n    for activity in activities:\n        activity_users[activity].append(i)\n\n# Check for good matches\nfor activity, user_list in activity_users.items():\n    if len(user_list) < 2:\n        continue\n    for i in range(len(user_list)):\n        for j in range(i + 1, len(user_list)):\n            user1, activities1 = users[user_list[i] - 1]\n            user2, activities2 = users[user_list[j] - 1]\n            if not activities1.isdisjoint(activities2):\n                print(\"YES\")\n                print(user1, user2)\n                sys.exit(0)\n\nprint(\"NO\")\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nusers = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + 1 + k]))\n    users.append((i + 1, activities))\n    index += 1 + k\n\n# Create a dictionary to store activities liked by each user\nactivity_users = defaultdict(set)\n\nfor user_id, activities in users:\n    for activity in activities:\n        activity_users[activity].add(user_id)\n\n# Check for good matches\nfor user_id1, activities1 in users:\n    for user_id2, activities2 in users:\n        if user_id1 != user_id2:\n            common_activities = activities1 & activities2\n            if common_activities:\n                user1_unliked = activities1 - activities2\n                user2_unliked = activities2 - activities1\n                if user1_unliked and user2_unliked:\n                    print(\"YES\")\n                    print(user_id1, user_id2)\n                    sys.exit(0)\n\nprint(\"NO\")",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\n# Initialize sets to store activities liked by each user\nlikes = [set() for _ in range(n + 1)]\n\n# Read the activities liked by each user\nindex = 2\nfor i in range(1, n + 1):\n    k = int(data[index])\n    index += 1\n    for _ in range(k):\n        activity = int(data[index])\n        likes[i].add(activity)\n        index += 1\n\n# Check for good matches\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        common_activities = likes[i] & likes[j]\n        if common_activities:\n            user1_uncommon = likes[i] - likes[j]\n            user2_uncommon = likes[j] - likes[i]\n            if user1_uncommon or user2_uncommon:\n                print(\"YES\")\n                print(i, j)\n                sys.exit(0)\n\n# If no good match is found\nprint(\"NO\")",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\n# Read the list of liked activities for each user\nusers = []\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + 1 + k]))\n    users.append(activities)\n    index += 1 + k\n\n# Create a dictionary to store users who like each activity\nactivity_users = defaultdict(list)\nfor i, activities in enumerate(users):\n    for activity in activities:\n        activity_users[activity].append(i + 1)\n\n# Check for a good match\nfor activity, user_list in activity_users.items():\n    if len(user_list) < 2:\n        continue\n    for i in range(len(user_list)):\n        for j in range(i + 1, len(user_list)):\n            user1 = user_list[i]\n            user2 = user_list[j]\n            if not users[user1].issubset(users[user2]) and not users[user2].issubset(users[user1]):\n                print(\"YES\")\n                print(user1, user2)\n                sys.exit(0)\n\nprint(\"NO\")",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\n# Read the activities each user likes\nusers = []\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + 1 + k]))\n    users.append(activities)\n    index += 1 + k\n\n# Create a dictionary to store users who like each activity\nactivity_users = defaultdict(list)\nfor i, activities in enumerate(users):\n    for activity in activities:\n        activity_users[activity].append(i + 1)\n\n# Check for a good match\nfor activity, user_list in activity_users.items():\n    if len(user_list) < 2:\n        continue\n    for i in range(len(user_list)):\n        for j in range(i + 1, len(user_list)):\n            user1 = user_list[i]\n            user2 = user_list[j]\n            if not users[user1 - 1].intersection(users[user2 - 1]):\n                continue\n            if any(activity not in users[user1 - 1] for activity in users[user2 - 1]):\n                print(\"YES\")\n                print(user1, user2)\n                sys.exit(0)\n\nprint(\"NO\")",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nactivities = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities.append(set(map(int, data[index + 1:index + 1 + k])))\n    index += 1 + k\n\n# Find a good match\nfor i in range(n):\n    for j in range(i + 1, n):\n        common_activities = activities[i] & activities[j]\n        if common_activities:\n            user1_uncommon = activities[i] - activities[j]\n            user2_uncommon = activities[j] - activities[i]\n            if user1_uncommon or user2_uncommon:\n                print(\"YES\")\n                print(i + 1, j + 1)\n                sys.exit(0)\n\nprint(\"NO\")",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\n\n# Initialize sets to store activities liked by each user\nlikes = [set() for _ in range(n + 1)]\n\n# Read the activities liked by each user\nindex = 2\nfor i in range(1, n + 1):\n    k = int(data[index])\n    for _ in range(k):\n        activity = int(data[index + 1])\n        likes[i].add(activity)\n        index += 1\n\n# Check for a good match\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        common_activities = likes[i] & likes[j]\n        if common_activities:\n            user1_uncommon = likes[i] - likes[j]\n            user2_uncommon = likes[j] - likes[i]\n            if user1_uncommon or user2_uncommon:\n                print(\"YES\")\n                print(i, j)\n                sys.exit(0)\n\n# If no good match is found\nprint(\"NO\")",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nusers = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + 1 + k]))\n    users.append((i + 1, activities))\n    index += 1 + k\n\n# Create a dictionary to store users who like each activity\nactivity_users = defaultdict(list)\nfor i, activities in users:\n    for activity in activities:\n        activity_users[activity].append(i)\n\n# Check for good matches\nfor activity, user_list in activity_users.items():\n    if len(user_list) < 2:\n        continue\n    for i in range(len(user_list)):\n        for j in range(i + 1, len(user_list)):\n            user1, user2 = user_list[i], user_list[j]\n            if not users[user1 - 1][1].intersection(users[user2 - 1][1]):\n                continue\n            if not (users[user1 - 1][1] - users[user2 - 1][1]) or not (users[user2 - 1][1] - users[user1 - 1][1]):\n                continue\n            print(\"YES\")\n            print(user1, user2)\n            sys.exit(0)\n\nprint(\"NO\")",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nusers = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + k + 1]))\n    users.append(activities)\n    index += k + 1\n\n# Find a good match\nfor i in range(n):\n    for j in range(i + 1, n):\n        common_activities = users[i] & users[j]\n        if common_activities:\n            user1_uncommon = users[i] - users[j]\n            user2_uncommon = users[j] - users[i]\n            if user1_uncommon or user2_uncommon:\n                print(\"YES\")\n                print(i + 1, j + 1)\n                sys.exit(0)\n\nprint(\"NO\")",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nactivities = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities.append(set(map(int, data[index + 1:index + 1 + k])))\n    index += 1 + k\n\n# Find a good match\nfor i in range(n):\n    for j in range(i + 1, n):\n        if activities[i] & activities[j]:\n            common_activities = activities[i] & activities[j]\n            user1_extra = activities[i] - common_activities\n            user2_extra = activities[j] - common_activities\n            if user1_extra and user2_extra:\n                print(\"YES\")\n                print(i + 1, j + 1)\n                sys.exit(0)\n\nprint(\"NO\")",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nusers = []\n\nindex = 2\nfor i in range(n):\n    k = int(data[index])\n    activities = set(map(int, data[index + 1:index + 1 + k]))\n    users.append((i + 1, activities))\n    index += 1 + k\n\n# Create a dictionary to store users who like each activity\nactivity_users = defaultdict(list)\nfor i, activities in users:\n    for activity in activities:\n        activity_users[activity].append(i)\n\n# Check for good matches\nfor activity, user_list in activity_users.items():\n    if len(user_list) < 2:\n        continue\n    for i in range(len(user_list)):\n        for j in range(i + 1, len(user_list)):\n            user1, activities1 = users[user_list[i] - 1]\n            user2, activities2 = users[user_list[j] - 1]\n            if not activities1.isdisjoint(activities2):\n                print(\"YES\")\n                print(user1, user2)\n                sys.exit(0)\n\nprint(\"NO\")"
        ]
    },
    {
        "question_title": "Triangle Formation",
        "question_content": "You are given n sticks, numbered from 1 to n. The length of the i-th stick is a_i.\n\nYou need to answer q queries. In each query, you are given two integers l and r (1 \\le l < r \\le n, r - l + 1 \\ge 6). Determine whether it is possible to choose 6 distinct sticks from the sticks numbered l to r, to form 2 non-degenerate triangles^{\\text{*}}.\n\n\nInput Format\nThe first line contains two integers n and q (6 \\le n \\le 10^5, 1 \\le q \\le 10^5)\u00a0\u2014 the number of sticks and the number of queries respectively.\n\nThe second line contains n integers a_1, a_2, \\ldots, a_n (1 \\le a_i \\le 10^9)\u00a0\u2014 a_i denotes the length of the i-th stick.\n\nEach of the following q lines contains two integers l and r (1 \\le l < r \\le n, r - l + 1 \\ge 6)\u00a0\u2014 the parameters of each query.\n\n\nOutput Format\nFor each query, output \"YES\" (without quotes) if it is possible to form 2 triangles, and \"NO\" (without quotes) otherwise.\n\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\n\n\nSample Input 1\n\n10 5\n5 2 2 10 4 10 6 1 5 3\n1 6\n2 7\n2 8\n5 10\n4 10\n\nSample Output 1\n\nYES\nNO\nYES\nNO\nYES\n\n\nNote\nIn the first query, the lengths of the sticks are [5, 2, 2, 10, 4, 10]. Two sets of sticks [2, 4, 5] and [2, 10, 10] can be selected to form 2 non-degenerate triangles.\n\nIn the second query, the lengths of the sticks are [2, 2, 10, 4, 10, 6]. It can be shown that it is impossible to form 2 non-degenerate triangles.\n\nIn the third query, the lengths of the sticks are [2, 2, 10, 4, 10, 6, 1]. Two sets of sticks [1, 2, 2] and [4, 10, 10] can be selected to form 2 non-degenerate triangles.\n\nIn the fourth query, the lengths of the sticks are [4, 10, 6, 1, 5, 3]. It can be shown that it is impossible to form 2 non-degenerate triangles.\n\nIn the fifth query, the lengths of the sticks are [10, 4, 10, 6, 1, 5, 3]. Two sets of sticks [1, 10, 10] and [3, 4, 5] can be selected to form 2 non-degenerate triangles.",
        "platform": "codeforces",
        "question_id": "1991/F",
        "contest_id": "1991",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        a, b, c, d, e, f = sticks[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n + 2*i])\n        r = int(data[2+n + 2*i + 1])\n        query_sticks = sticks[l-1:r]\n        if can_form_two_triangles(query_sticks):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\nsticks = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(q):\n    l = int(data[index])\n    r = int(data[index + 1])\n    queries.append((l, r))\n    index += 2\n\ndef can_form_two_triangles(l, r):\n    sticks_range = sticks[l-1:r]\n    sticks_range.sort()\n    for i in range(len(sticks_range) - 5):\n        a, b, c, d, e, f = sticks_range[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            if a + d > e and a + e > d and d + e > a and b + d > f and b + f > d and d + f > b:\n                return True\n    return False\n\nfor l, r in queries:\n    if can_form_two_triangles(l, r):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\nsticks = list(map(int, data[2:]))\n\ndef can_form_two_triangles(l, r):\n    sticks_range = sticks[l-1:r]\n    sticks_range.sort()\n    for i in range(len(sticks_range) - 5):\n        a, b, c, d, e, f = sticks_range[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            if a + d > e and a + e > d and d + e > a and b + d > f and b + f > d and d + f > b:\n                return True\n    return False\n\nresults = []\nfor i in range(q):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    if can_form_two_triangles(l, r):\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        if sticks[i] + sticks[i + 1] > sticks[i + 2] and sticks[i + 2] + sticks[i + 3] > sticks[i + 4] and sticks[i + 4] + sticks[i + 5] > sticks[i]:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n+i*2]) - 1\n        r = int(data[2+n+i*2+1]) - 1\n        if can_form_two_triangles(sticks[l:r+1]):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        a, b, c, d, e, f = sticks[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n+i*2]) - 1\n        r = int(data[2+n+i*2+1]) - 1\n        if can_form_two_triangles(sticks[l:r+1]):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef can_form_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        if sticks[i] + sticks[i + 1] > sticks[i + 2] and sticks[i + 2] + sticks[i + 3] > sticks[i + 4] and sticks[i + 4] + sticks[i + 5] > sticks[i]:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n + 2*i])\n        r = int(data[2+n + 2*i + 1])\n        selected_sticks = sticks[l-1:r]\n        if can_form_triangles(selected_sticks):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        a, b, c, d, e, f = sticks[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    queries = []\n    for i in range(q):\n        l = int(data[2+n+2*i])\n        r = int(data[2+n+2*i+1])\n        queries.append((l-1, r))\n    \n    for l, r in queries:\n        selected_sticks = sticks[l:r]\n        if can_form_two_triangles(selected_sticks):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        a, b, c, d, e, f = sticks[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n + 2*i]) - 1\n        r = int(data[2+n + 2*i + 1]) - 1\n        if can_form_two_triangles(sticks[l:r+1]):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\nsticks = list(map(int, data[2:]))\n\ndef can_form_two_triangles(l, r):\n    sticks_range = sticks[l-1:r]\n    sticks_range.sort()\n    for i in range(len(sticks_range) - 5):\n        a, b, c, d, e, f = sticks_range[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            if a + d > e and a + e > d and d + e > a and b + d > f and b + f > d and d + f > b:\n                return \"YES\"\n    return \"NO\"\n\nfor i in range(q):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    print(can_form_two_triangles(l, r))\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        if sticks[i] + sticks[i + 1] > sticks[i + 2] and sticks[i + 2] + sticks[i + 3] > sticks[i + 4] and sticks[i + 4] + sticks[i + 5] > sticks[i]:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n+i*2]) - 1\n        r = int(data[2+n+i*2+1]) - 1\n        if can_form_two_triangles(sticks[l:r+1]):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        a, b, c, d, e, f = sticks[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n + 2*i])\n        r = int(data[2+n + 2*i + 1])\n        query_sticks = sticks[l-1:r]\n        if can_form_two_triangles(query_sticks):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\nsticks = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(q):\n    l = int(data[index])\n    r = int(data[index + 1])\n    queries.append((l, r))\n    index += 2\n\ndef can_form_two_triangles(l, r):\n    sticks_range = sticks[l-1:r]\n    sticks_range.sort()\n    for i in range(len(sticks_range) - 5):\n        a, b, c, d, e, f = sticks_range[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            if a + d > e and a + e > d and d + e > a and b + d > f and b + f > d and d + f > b:\n                return True\n    return False\n\nfor l, r in queries:\n    if can_form_two_triangles(l, r):\n        print(\"YES\")\n    else:\n        print(\"NO\")",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\nsticks = list(map(int, data[2:]))\n\ndef can_form_two_triangles(l, r):\n    sticks_range = sticks[l-1:r]\n    sticks_range.sort()\n    for i in range(len(sticks_range) - 5):\n        a, b, c, d, e, f = sticks_range[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            if a + d > e and a + e > d and d + e > a and b + d > f and b + f > d and d + f > b:\n                return True\n    return False\n\nresults = []\nfor i in range(q):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    if can_form_two_triangles(l, r):\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nfor result in results:\n    print(result)",
            "import sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        if sticks[i] + sticks[i + 1] > sticks[i + 2] and sticks[i + 2] + sticks[i + 3] > sticks[i + 4] and sticks[i + 4] + sticks[i + 5] > sticks[i]:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n+i*2]) - 1\n        r = int(data[2+n+i*2+1]) - 1\n        if can_form_two_triangles(sticks[l:r+1]):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        a, b, c, d, e, f = sticks[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n+i*2]) - 1\n        r = int(data[2+n+i*2+1]) - 1\n        if can_form_two_triangles(sticks[l:r+1]):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom typing import List\n\ndef can_form_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        if sticks[i] + sticks[i + 1] > sticks[i + 2] and sticks[i + 2] + sticks[i + 3] > sticks[i + 4] and sticks[i + 4] + sticks[i + 5] > sticks[i]:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n + 2*i])\n        r = int(data[2+n + 2*i + 1])\n        selected_sticks = sticks[l-1:r]\n        if can_form_triangles(selected_sticks):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        a, b, c, d, e, f = sticks[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    queries = []\n    for i in range(q):\n        l = int(data[2+n+2*i])\n        r = int(data[2+n+2*i+1])\n        queries.append((l-1, r))\n    \n    for l, r in queries:\n        selected_sticks = sticks[l:r]\n        if can_form_two_triangles(selected_sticks):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        a, b, c, d, e, f = sticks[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n + 2*i]) - 1\n        r = int(data[2+n + 2*i + 1]) - 1\n        if can_form_two_triangles(sticks[l:r+1]):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\nsticks = list(map(int, data[2:]))\n\ndef can_form_two_triangles(l, r):\n    sticks_range = sticks[l-1:r]\n    sticks_range.sort()\n    for i in range(len(sticks_range) - 5):\n        a, b, c, d, e, f = sticks_range[i:i+6]\n        if a + b > c and a + c > b and b + c > a and d + e > f and d + f > e and e + f > d:\n            if a + d > e and a + e > d and d + e > a and b + d > f and b + f > d and d + f > b:\n                return \"YES\"\n    return \"NO\"\n\nfor i in range(q):\n    l = int(data[2 + 2 * i])\n    r = int(data[3 + 2 * i])\n    print(can_form_two_triangles(l, r))",
            "import sys\nfrom typing import List\n\ndef can_form_two_triangles(sticks: List[int]) -> bool:\n    sticks.sort()\n    n = len(sticks)\n    for i in range(n - 5):\n        if sticks[i] + sticks[i + 1] > sticks[i + 2] and sticks[i + 2] + sticks[i + 3] > sticks[i + 4] and sticks[i + 4] + sticks[i + 5] > sticks[i]:\n            return True\n    return False\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    sticks = list(map(int, data[2:2+n]))\n    \n    for i in range(q):\n        l = int(data[2+n+i*2]) - 1\n        r = int(data[2+n+i*2+1]) - 1\n        if can_form_two_triangles(sticks[l:r+1]):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Stripe 2",
        "question_content": "Once Bob took a paper stripe of n squares (the height of the stripe is 1 square). In each square he wrote an integer number, possibly negative. He became interested in how many ways exist to cut this stripe into three pieces so that the sum of numbers from each piece is equal to the sum of numbers from any other piece, and each piece contains positive integer amount of squares. Would you help Bob solve this problem?\n\n\nInput Format\nThe first input line contains integer n (1 \u2264 n \u2264 105) \u2014 amount of squares in the stripe. The second line contains n space-separated numbers \u2014 they are the numbers written in the squares of the stripe. These numbers are integer and do not exceed 10000 in absolute value.\n\n\nOutput Format\nOutput the amount of ways to cut the stripe into three non-empty pieces so that the sum of numbers from each piece is equal to the sum of numbers from any other piece. Don't forget that it's allowed to cut the stripe along the squares' borders only.\n\n\nSample Input 1\n\n4\n1 2 3 3\n\nSample Output 1\n\n1\n\n\nSample Input 2\n\n5\n1 2 3 4 5\n\nSample Output 2\n\n0",
        "platform": "codeforces",
        "question_id": "21/C",
        "contest_id": "21",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit(0)\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Dictionary to store the number of ways to get a certain sum\nsum_ways = defaultdict(int)\nsum_ways[0] = 1\n\n# Variables to store the number of ways to get the first and second target sums\nfirst_target_ways = 0\nsecond_target_ways = 0\n\n# Iterate through the numbers to find the number of ways to get the target sums\ncurrent_sum = 0\nfor i in range(n):\n    current_sum += numbers[i]\n    if current_sum == target_sum:\n        first_target_ways += sum_ways[current_sum]\n    if current_sum == 2 * target_sum:\n        second_target_ways += sum_ways[current_sum]\n    sum_ways[current_sum] += 1\n\n# The number of ways to cut the stripe into three pieces with equal sums\nresult = first_target_ways * second_target_ways\n\n# Output the result\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit()\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Initialize variables\ncount = 0\nprefix_sum = 0\nprefix_sums = [0] * (n + 1)\n\n# Calculate prefix sums\nfor i in range(n):\n    prefix_sum += numbers[i]\n    prefix_sums[i + 1] = prefix_sum\n\n# Iterate through the array to find valid cuts\nfor i in range(1, n - 1):\n    if prefix_sums[i] == target_sum:\n        for j in range(i + 1, n):\n            if prefix_sums[j] - prefix_sums[i] == target_sum:\n                count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit()\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Dictionary to store the number of ways to get a certain sum\nsum_ways = defaultdict(int)\nsum_ways[0] = 1\n\n# Variables to store the number of ways to get the first and second target sums\nfirst_target_ways = 0\nsecond_target_ways = 0\n\n# Iterate through the numbers to find the number of ways to get the target sums\ncurrent_sum = 0\nfor i in range(n):\n    current_sum += numbers[i]\n    if current_sum == target_sum:\n        first_target_ways += sum_ways[current_sum]\n    if current_sum == 2 * target_sum:\n        second_target_ways += sum_ways[current_sum]\n    sum_ways[current_sum] += 1\n\n# The number of ways to cut the stripe into three pieces with equal sums\nresult = first_target_ways * second_target_ways\n\n# Output the result\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit(0)\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Initialize variables\ncount = 0\ncurrent_sum = 0\nprefix_sums = [0] * (n + 1)\n\n# Calculate prefix sums\nfor i in range(n):\n    current_sum += numbers[i]\n    prefix_sums[i + 1] = current_sum\n\n# Iterate through the prefix sums to find valid cuts\nfor i in range(1, n - 1):\n    if prefix_sums[i] == target_sum:\n        for j in range(i + 1, n):\n            if prefix_sums[j] - prefix_sums[i] == target_sum:\n                count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit(0)\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Initialize variables\ncount = 0\ncurrent_sum = 0\nprefix_sums = [0] * (n + 1)\n\n# Calculate prefix sums\nfor i in range(n):\n    current_sum += numbers[i]\n    prefix_sums[i + 1] = current_sum\n\n# Iterate through the prefix sums to find valid cuts\nfor i in range(1, n - 1):\n    if prefix_sums[i] == target_sum:\n        for j in range(i + 1, n):\n            if prefix_sums[j] - prefix_sums[i] == target_sum:\n                count += 1\n\n# Output the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate total sum\ntotal_sum = sum(numbers)\n\n# Check if total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit(0)\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Dictionary to store the number of ways to get a certain sum\nsum_ways = defaultdict(int)\nsum_ways[0] = 1\n\n# Variables to store the number of ways to get the first and second target sums\nfirst_target_ways = 0\nsecond_target_ways = 0\n\n# Iterate through the numbers to find the number of ways to get the target sums\ncurrent_sum = 0\nfor i in range(n):\n    current_sum += numbers[i]\n    if current_sum == target_sum:\n        first_target_ways += sum_ways[current_sum - target_sum]\n    if current_sum == 2 * target_sum:\n        second_target_ways += sum_ways[current_sum - 2 * target_sum]\n    sum_ways[current_sum] += 1\n\n# Output the number of ways to cut the stripe into three pieces\nprint(first_target_ways * second_target_ways)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\nelse:\n    target_sum = total_sum // 3\n    count = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += numbers[i]\n        if current_sum == target_sum:\n            count += 1\n    print(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate total sum\ntotal_sum = sum(numbers)\n\n# Check if total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit()\n\n# Target sum for each piece\ntarget = total_sum // 3\n\n# Function to count the number of ways to partition the array into three parts with the given target sum\ndef count_partitions(nums, target):\n    count = 0\n    prefix_sum = 0\n    prefix_sum_count = defaultdict(int)\n    prefix_sum_count[0] = 1\n    \n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sum_count:\n            count += prefix_sum_count[prefix_sum - target]\n        prefix_sum_count[prefix_sum] += 1\n    \n    return count\n\n# Count the number of ways to partition the array into three parts with the target sum\nways = count_partitions(numbers, target)\n\n# Output the result\nprint(ways)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\nelse:\n    target_sum = total_sum // 3\n    count = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += numbers[i]\n        if current_sum == target_sum:\n            count += 1\n    print(count)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit()\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Initialize variables\ncount = 0\nprefix_sum = 0\nprefix_sums = {0: [-1]}  # To handle the case when the first piece starts from the beginning\n\n# Iterate through the numbers to find valid cuts\nfor i in range(n):\n    prefix_sum += numbers[i]\n    if prefix_sum == target_sum:\n        count += len(prefix_sums[prefix_sum - target_sum])\n    if prefix_sum not in prefix_sums:\n        prefix_sums[prefix_sum] = []\n    prefix_sums[prefix_sum].append(i)\n\n# Output the result\nprint(count)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit(0)\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Dictionary to store the number of ways to get a certain sum\nsum_ways = defaultdict(int)\nsum_ways[0] = 1\n\n# Variables to store the number of ways to get the first and second target sums\nfirst_target_ways = 0\nsecond_target_ways = 0\n\n# Iterate through the numbers to find the number of ways to get the target sums\ncurrent_sum = 0\nfor i in range(n):\n    current_sum += numbers[i]\n    if current_sum == target_sum:\n        first_target_ways += sum_ways[current_sum]\n    if current_sum == 2 * target_sum:\n        second_target_ways += sum_ways[current_sum]\n    sum_ways[current_sum] += 1\n\n# The number of ways to cut the stripe into three pieces with equal sums\nresult = first_target_ways * second_target_ways\n\n# Output the result\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit()\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Initialize variables\ncount = 0\nprefix_sum = 0\nprefix_sums = [0] * (n + 1)\n\n# Calculate prefix sums\nfor i in range(n):\n    prefix_sum += numbers[i]\n    prefix_sums[i + 1] = prefix_sum\n\n# Iterate through the array to find valid cuts\nfor i in range(1, n - 1):\n    if prefix_sums[i] == target_sum:\n        for j in range(i + 1, n):\n            if prefix_sums[j] - prefix_sums[i] == target_sum:\n                count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit()\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Dictionary to store the number of ways to get a certain sum\nsum_ways = defaultdict(int)\nsum_ways[0] = 1\n\n# Variables to store the number of ways to get the first and second target sums\nfirst_target_ways = 0\nsecond_target_ways = 0\n\n# Iterate through the numbers to find the number of ways to get the target sums\ncurrent_sum = 0\nfor i in range(n):\n    current_sum += numbers[i]\n    if current_sum == target_sum:\n        first_target_ways += sum_ways[current_sum]\n    if current_sum == 2 * target_sum:\n        second_target_ways += sum_ways[current_sum]\n    sum_ways[current_sum] += 1\n\n# The number of ways to cut the stripe into three pieces with equal sums\nresult = first_target_ways * second_target_ways\n\n# Output the result\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit(0)\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Initialize variables\ncount = 0\ncurrent_sum = 0\nprefix_sums = [0] * (n + 1)\n\n# Calculate prefix sums\nfor i in range(n):\n    current_sum += numbers[i]\n    prefix_sums[i + 1] = current_sum\n\n# Iterate through the prefix sums to find valid cuts\nfor i in range(1, n - 1):\n    if prefix_sums[i] == target_sum:\n        for j in range(i + 1, n):\n            if prefix_sums[j] - prefix_sums[i] == target_sum:\n                count += 1\n\n# Output the result\nprint(count)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit(0)\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Initialize variables\ncount = 0\ncurrent_sum = 0\nprefix_sums = [0] * (n + 1)\n\n# Calculate prefix sums\nfor i in range(n):\n    current_sum += numbers[i]\n    prefix_sums[i + 1] = current_sum\n\n# Iterate through the prefix sums to find valid cuts\nfor i in range(1, n - 1):\n    if prefix_sums[i] == target_sum:\n        for j in range(i + 1, n):\n            if prefix_sums[j] - prefix_sums[i] == target_sum:\n                count += 1\n\n# Output the result\nprint(count)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate total sum\ntotal_sum = sum(numbers)\n\n# Check if total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit(0)\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Dictionary to store the number of ways to get a certain sum\nsum_ways = defaultdict(int)\nsum_ways[0] = 1\n\n# Variables to store the number of ways to get the first and second target sums\nfirst_target_ways = 0\nsecond_target_ways = 0\n\n# Iterate through the numbers to find the number of ways to get the target sums\ncurrent_sum = 0\nfor i in range(n):\n    current_sum += numbers[i]\n    if current_sum == target_sum:\n        first_target_ways += sum_ways[current_sum - target_sum]\n    if current_sum == 2 * target_sum:\n        second_target_ways += sum_ways[current_sum - 2 * target_sum]\n    sum_ways[current_sum] += 1\n\n# Output the number of ways to cut the stripe into three pieces\nprint(first_target_ways * second_target_ways)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\nelse:\n    target_sum = total_sum // 3\n    count = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += numbers[i]\n        if current_sum == target_sum:\n            count += 1\n    print(count)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate total sum\ntotal_sum = sum(numbers)\n\n# Check if total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit()\n\n# Target sum for each piece\ntarget = total_sum // 3\n\n# Function to count the number of ways to partition the array into three parts with the given target sum\ndef count_partitions(nums, target):\n    count = 0\n    prefix_sum = 0\n    prefix_sum_count = defaultdict(int)\n    prefix_sum_count[0] = 1\n    \n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - target in prefix_sum_count:\n            count += prefix_sum_count[prefix_sum - target]\n        prefix_sum_count[prefix_sum] += 1\n    \n    return count\n\n# Count the number of ways to partition the array into three parts with the target sum\nways = count_partitions(numbers, target)\n\n# Output the result\nprint(ways)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\nelse:\n    target_sum = total_sum // 3\n    count = 0\n    current_sum = 0\n    for i in range(n):\n        current_sum += numbers[i]\n        if current_sum == target_sum:\n            count += 1\n    print(count)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\n# Calculate the total sum of the numbers\ntotal_sum = sum(numbers)\n\n# Check if the total sum is divisible by 3\nif total_sum % 3 != 0:\n    print(0)\n    sys.exit()\n\n# Target sum for each piece\ntarget_sum = total_sum // 3\n\n# Initialize variables\ncount = 0\nprefix_sum = 0\nprefix_sums = {0: [-1]}  # To handle the case when the first piece starts from the beginning\n\n# Iterate through the numbers to find valid cuts\nfor i in range(n):\n    prefix_sum += numbers[i]\n    if prefix_sum == target_sum:\n        count += len(prefix_sums[prefix_sum - target_sum])\n    if prefix_sum not in prefix_sums:\n        prefix_sums[prefix_sum] = []\n    prefix_sums[prefix_sum].append(i)\n\n# Output the result\nprint(count)"
        ]
    },
    {
        "question_title": "The table",
        "question_content": "Harry Potter has a difficult homework. Given a rectangular table, consisting of n x m cells. Each cell of the table contains the integer. Harry knows how to use two spells: the first spell change the sign of the integers in the selected row, the second \u2014 in the selected column. Harry's task is to make non-negative the sum of the numbers in each row and each column using these spells.\n\nAlone, the boy can not cope. Help the young magician!\n\n\nInput Format\nThe first line contains two integers n and m (1 \u2264 n, \u00a0m \u2264 100) \u2014 the number of rows and the number of columns.\n\nNext n lines follow, each contains m integers: j-th integer in the i-th line is ai, j (|ai, j| \u2264 100), the number in the i-th row and j-th column of the table.\n\nThe rows of the table numbered from 1 to n. The columns of the table numbered from 1 to m.\n\n\nOutput Format\nIn the first line print the number a \u2014 the number of required applications of the first spell. Next print a space-separated integers \u2014 the row numbers, you want to apply a spell. These row numbers must be distinct!\n\nIn the second line print the number b \u2014 the number of required applications of the second spell. Next print b space-separated integers \u2014 the column numbers, you want to apply a spell. These column numbers must be distinct!\n\nIf there are several solutions are allowed to print any of them.\n\n\nSample Input 1\n\n4 1\n-1\n-1\n-1\n-1\n\nSample Output 1\n\n4 1 2 3 4\n0\n\n\nSample Input 2\n\n2 4\n-1 -1 -1 2\n1 1 1 1\n\nSample Output 2\n\n1 1\n1 4",
        "platform": "codeforces",
        "question_id": "226/D",
        "contest_id": "226",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ngrid = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    grid.append(row)\n    index += m\n\n# Count negative numbers in each row and column\nrow_negatives = [sum(1 for x in row if x < 0) for row in grid]\ncol_negatives = [sum(1 for row in grid if row[j] < 0) for j in range(m)]\n\n# Determine rows to flip\nrows_to_flip = [i + 1 for i, count in enumerate(row_negatives) if count % 2 != 0]\n\n# Determine columns to flip\ncols_to_flip = [j + 1 for j, count in enumerate(col_negatives) if count % 2 != 0]\n\n# Output the results\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    if sum(table[i][j] for i in range(n)) < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    col_sum = sum(table[i][j] for i in range(n))\n    if col_sum < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    col_sum = sum(table[i][j] for i in range(n))\n    if col_sum < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    col_sum = sum(table[i][j] for i in range(n))\n    if col_sum < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = []\n\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\n# Determine rows to flip\nrows_to_flip = [i + 1 for i in range(n) if sum(table[i]) < 0]\n\n# Determine columns to flip\ncolumns_to_flip = [j + 1 for j in range(m) if sum(table[i][j] for i in range(n)) < 0]\n\n# Output the results\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(columns_to_flip), *columns_to_flip)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = []\n\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\n# Determine which rows and columns to flip\nrows_to_flip = []\ncolumns_to_flip = []\n\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\nfor j in range(m):\n    if sum(table[row][j] for row in range(n)) < 0:\n        columns_to_flip.append(j + 1)\n\n# Output the results\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(columns_to_flip), *columns_to_flip)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    col_sum = sum(table[i][j] for i in range(n))\n    if col_sum < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    if sum(table[i][j] for i in range(n)) < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    col_sum = sum(table[i][j] for i in range(n))\n    if col_sum < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ngrid = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    grid.append(row)\n    index += m\n\n# Count negative numbers in each row and column\nrow_negatives = [sum(1 for x in row if x < 0) for row in grid]\ncol_negatives = [sum(1 for row in grid if row[j] < 0) for j in range(m)]\n\n# Determine rows to flip\nrows_to_flip = [i + 1 for i, count in enumerate(row_negatives) if count % 2 != 0]\n\n# Determine columns to flip\ncols_to_flip = [j + 1 for j, count in enumerate(col_negatives) if count % 2 != 0]\n\n# Output the results\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    if sum(table[i][j] for i in range(n)) < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    col_sum = sum(table[i][j] for i in range(n))\n    if col_sum < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    col_sum = sum(table[i][j] for i in range(n))\n    if col_sum < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    col_sum = sum(table[i][j] for i in range(n))\n    if col_sum < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = []\n\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\n# Determine rows to flip\nrows_to_flip = [i + 1 for i in range(n) if sum(table[i]) < 0]\n\n# Determine columns to flip\ncolumns_to_flip = [j + 1 for j in range(m) if sum(table[i][j] for i in range(n)) < 0]\n\n# Output the results\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(columns_to_flip), *columns_to_flip)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = []\n\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\n# Determine which rows and columns to flip\nrows_to_flip = []\ncolumns_to_flip = []\n\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\nfor j in range(m):\n    if sum(table[row][j] for row in range(n)) < 0:\n        columns_to_flip.append(j + 1)\n\n# Output the results\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(columns_to_flip), *columns_to_flip)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    col_sum = sum(table[i][j] for i in range(n))\n    if col_sum < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    if sum(table[i][j] for i in range(n)) < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ntable = []\nindex = 2\nfor i in range(n):\n    row = list(map(int, data[index:index + m]))\n    table.append(row)\n    index += m\n\nrows_to_flip = []\nfor i in range(n):\n    if sum(table[i]) < 0:\n        rows_to_flip.append(i + 1)\n\ncols_to_flip = []\nfor j in range(m):\n    col_sum = sum(table[i][j] for i in range(n))\n    if col_sum < 0:\n        cols_to_flip.append(j + 1)\n\nprint(len(rows_to_flip), *rows_to_flip)\nprint(len(cols_to_flip), *cols_to_flip)"
        ]
    },
    {
        "question_title": "Tree",
        "question_content": "Recently Bob invented a new game with a tree (we should remind you, that a tree is a connected graph without cycles): he deletes any (possibly, zero) amount of edges of the tree, and counts the product of sizes of the connected components left after the deletion. Your task is to find out the maximum number that Bob can get in his new game for a given tree.\n\n\nInput Format\nThe first input line contains integer number n (1 \u2264 n \u2264 700) \u2014 amount of vertices in the tree. The following n - 1 lines contain the description of the edges. Each line contains the pair of vertices' indexes, joined by an edge, ai, bi (1 \u2264 ai, bi \u2264 n). It's guaranteed that the graph described in the input is a tree.\n\n\nOutput Format\nOutput the only number \u2014 the maximum product of sizes of the connected components, that Bob can get after deleting some of the tree's edges.\n\n\nSample Input 1\n\n5\n1 2\n2 3\n3 4\n4 5\n\nSample Output 1\n\n6\n\n\nSample Input 2\n\n8\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n6 8\n\nSample Output 2\n\n18\n\n\nSample Input 3\n\n3\n1 2\n1 3\n\nSample Output 3\n\n3",
        "platform": "codeforces",
        "question_id": "23/E",
        "contest_id": "23",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = max_product_of_components(n, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        return size\n    \n    def dfs_max_product(node, parent, total_size):\n        size = dfs(node, parent)\n        remaining_size = total_size - size\n        product = size * remaining_size\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                product = max(product, dfs_max_product(neighbor, node, total_size))\n        return product\n    \n    total_size = dfs(1, -1)\n    return dfs_max_product(1, -1, total_size)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        return size\n    \n    def find_max_product(node, parent, total_size):\n        size = dfs(node, parent)\n        remaining_size = total_size - size\n        product = size * remaining_size\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                product = max(product, find_max_product(neighbor, node, total_size))\n        return product\n    \n    total_size = dfs(1, -1)\n    return find_max_product(1, -1, total_size)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        return size\n    \n    def find_max_product(node, parent, total_size):\n        size = dfs(node, parent)\n        remaining_size = total_size - size\n        product = size * remaining_size\n        max_product = product\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                max_product = max(max_product, find_max_product(neighbor, node, total_size))\n        return max_product\n    \n    total_size = dfs(1, -1)\n    return find_max_product(1, -1, total_size)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        return size\n    \n    def find_max_product(node, parent, total_size):\n        size = dfs(node, parent)\n        remaining_size = total_size - size\n        product = size * remaining_size\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                product = max(product, find_max_product(neighbor, node, total_size))\n        return product\n    \n    total_size = dfs(1, -1)\n    return find_max_product(1, -1, total_size)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Calculate and print the result\nresult = max_product_of_components(n, edges)\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        return size\n    \n    def dfs_max_product(node, parent, total_size):\n        size = dfs(node, parent)\n        remaining_size = total_size - size\n        product = size * remaining_size\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                product = max(product, dfs_max_product(neighbor, node, total_size))\n        return product\n    \n    total_size = dfs(1, -1)\n    return dfs_max_product(1, -1, total_size)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        return size\n    \n    def find_max_product(node, parent, total_size):\n        size = dfs(node, parent)\n        remaining_size = total_size - size\n        product = size * remaining_size\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                product = max(product, find_max_product(neighbor, node, total_size))\n        return product\n    \n    total_size = dfs(1, -1)\n    return find_max_product(1, -1, total_size)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        return size\n    \n    def find_max_product(node, parent, total_size):\n        size = dfs(node, parent)\n        remaining_size = total_size - size\n        product = size * remaining_size\n        max_product = product\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                max_product = max(max_product, find_max_product(neighbor, node, total_size))\n        return max_product\n    \n    total_size = dfs(1, -1)\n    return find_max_product(1, -1, total_size)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        sizes.append(size)\n        return size\n    \n    sizes = []\n    dfs(1, -1)\n    \n    sizes.sort(reverse=True)\n    product = 1\n    for size in sizes:\n        product *= size\n    \n    return product\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef max_product_of_components(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent):\n        size = 1\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                size += dfs(neighbor, node)\n        return size\n    \n    def find_max_product(node, parent, total_size):\n        size = dfs(node, parent)\n        remaining_size = total_size - size\n        product = size * remaining_size\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                product = max(product, find_max_product(neighbor, node, total_size))\n        return product\n    \n    total_size = dfs(1, -1)\n    return find_max_product(1, -1, total_size)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\nfor i in range(n - 1):\n    u = int(data[2 * i + 1])\n    v = int(data[2 * i + 2])\n    edges.append((u, v))\n\n# Solve the problem\nresult = max_product_of_components(n, edges)\n\n# Write output\nprint(result)"
        ]
    },
    {
        "question_title": "HQ",
        "question_content": "The famous joke programming language HQ9+ has only 4 commands. In this problem we will explore its subset \u2014 a language called HQ...\n\n\nInput Format\nThe only line of the input is a string between 1 and 106 characters long.\n\n\nOutput Format\nOutput \"Yes\" or \"No\".\n\n\nSample Input 1\n\nHHHH\n\nSample Output 1\n\nYes\n\n\nSample Input 2\n\nHQHQH\n\nSample Output 2\n\nNo\n\n\nSample Input 3\n\nHHQHHQH\n\nSample Output 3\n\nNo\n\n\nSample Input 4\n\nHHQQHHQQHH\n\nSample Output 4\n\nYes\n\n\nNote\nThe rest of the problem statement was destroyed by a stray raccoon. We are terribly sorry for the inconvenience.",
        "platform": "codeforces",
        "question_id": "290/E",
        "contest_id": "290",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H' and 'Q'\nif all(char in 'HQ' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    # Check if the input string contains at least one 'Q'\n    if 'Q' in input_string:\n        # Check if the input string contains at least one '9'\n        if '9' in input_string:\n            # Check if the input string contains at least one 'H'\n            if 'H' in input_string:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H' and 'Q'\nif all(char in 'HQ' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    # Check if the input string contains at least one 'Q'\n    if 'Q' in input_string:\n        # Check if the input string contains at least one '9'\n        if '9' in input_string:\n            # Check if the input string contains at least one 'H'\n            if 'H' in input_string:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    # Check if the input string contains at least one 'Q'\n    if 'Q' in input_string:\n        # Check if the input string contains at least one '9'\n        if '9' in input_string:\n            # Check if the input string contains at least one 'H'\n            if 'H' in input_string:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    # Check if the input string contains at least one 'Q'\n    if 'Q' in input_string:\n        # Check if the input string contains at least one '9'\n        if '9' in input_string:\n            # Check if the input string contains at least one 'H'\n            if 'H' in input_string:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")",
            "import sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H' and 'Q'\nif all(char in 'HQ' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    # Check if the input string contains at least one 'Q'\n    if 'Q' in input_string:\n        # Check if the input string contains at least one '9'\n        if '9' in input_string:\n            # Check if the input string contains at least one 'H'\n            if 'H' in input_string:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H' and 'Q'\nif all(char in 'HQ' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    print(\"Yes\")\nelse:\n    print(\"No\")",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    # Check if the input string contains at least one 'Q'\n    if 'Q' in input_string:\n        # Check if the input string contains at least one '9'\n        if '9' in input_string:\n            # Check if the input string contains at least one 'H'\n            if 'H' in input_string:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    # Check if the input string contains at least one 'Q'\n    if 'Q' in input_string:\n        # Check if the input string contains at least one '9'\n        if '9' in input_string:\n            # Check if the input string contains at least one 'H'\n            if 'H' in input_string:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Check if the input string contains only 'H', 'Q', and '9'\nif all(char in 'HQ9' for char in input_string):\n    # Check if the input string contains at least one 'Q'\n    if 'Q' in input_string:\n        # Check if the input string contains at least one '9'\n        if '9' in input_string:\n            # Check if the input string contains at least one 'H'\n            if 'H' in input_string:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")"
        ]
    },
    {
        "question_title": "Close Vertices",
        "question_content": "You've got a weighted tree, consisting of n vertices. Each edge has a non-negative weight. The length of the path between any two vertices of the tree is the number of edges in the path. The weight of the path is the total weight of all edges it contains.\n\nTwo vertices are close if there exists a path of length at most l between them and a path of weight at most w between them. Count the number of pairs of vertices v, u (v < u), such that vertices v and u are close.\n\n\nInput Format\nThe first line contains three integers n, l and w (1 \u2264 n \u2264 105, 1 \u2264 l \u2264 n, 0 \u2264 w \u2264 109). The next n - 1 lines contain the descriptions of the tree edges. The i-th line contains two integers pi, wi (1 \u2264 pi < (i + 1), 0 \u2264 wi \u2264 104), that mean that the i-th edge connects vertex (i + 1) and pi and has weight wi.\n\nConsider the tree vertices indexed from 1 to n in some way.\n\n\nOutput Format\nPrint a single integer \u2014 the number of close pairs.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\nSample Input 1\n\n4 4 6\n1 3\n1 4\n1 3\n\nSample Output 1\n\n4\n\n\nSample Input 2\n\n6 2 17\n1 3\n2 5\n2 13\n1 6\n5 9\n\nSample Output 2\n\n9",
        "platform": "codeforces",
        "question_id": "293/E",
        "contest_id": "293",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    n = int(data[index])\n    l = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    edges = []\n    for _ in range(n - 1):\n        pi = int(data[index])\n        wi = int(data[index + 1])\n        edges.append((pi, wi))\n        index += 2\n    return n, l, w, edges\n\ndef count_close_pairs(n, l, w, edges):\n    tree = defaultdict(list)\n    for pi, wi in edges:\n        tree[pi].append((pi, wi))\n        tree[pi + 1].append((pi + 1, wi))\n    \n    def bfs(start, max_length, max_weight):\n        queue = deque([(start, 0, 0)])\n        visited = set([start])\n        count = 0\n        while queue:\n            current, length, weight = queue.popleft()\n            if length > max_length or weight > max_weight:\n                continue\n            for neighbor, edge_weight in tree[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, length + 1, weight + edge_weight))\n                    count += 1\n        return count\n    \n    close_pairs = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if abs(i - j) <= l:\n                close_pairs += 1\n            else:\n                length = abs(i - j)\n                weight = bfs(i, length, w) + bfs(j, length, w)\n                if length <= l and weight <= w:\n                    close_pairs += 1\n    \n    return close_pairs\n\ndef main():\n    n, l, w, edges = read_input()\n    result = count_close_pairs(n, l, w, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i]) - 1\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the maximum depth of the tree\ndef max_depth(node, parent):\n    depth = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth = max(depth, max_depth(neighbor, node))\n    return depth + 1\n\n# Find the maximum depth of the tree\nmax_depth = max_depth(0, -1)\n\n# Function to find the maximum weight path from a node to a leaf\ndef max_weight_path(node, parent):\n    if not tree[node]:\n        return 0\n    max_weight = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            max_weight = max(max_weight, max_weight_path(neighbor, node))\n    return max_weight + 1\n\n# Find the maximum weight path from each node to a leaf\nmax_weight_paths = [0] * n\nfor i in range(n):\n    max_weight_paths[i] = max_weight_path(i, -1)\n\n# Count the number of close pairs\nclose_pairs = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if abs(max_depth - max_depth_paths[i] - max_depth_paths[j]) <= l and max_weight_paths[i] + max_weight_paths[j] <= w:\n            close_pairs += 1\n\n# Print the result\nprint(close_pairs)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    l = int(data[1])\n    w = int(data[2])\n    edges = []\n    index = 3\n    for _ in range(n - 1):\n        pi = int(data[index])\n        wi = int(data[index + 1])\n        edges.append((pi, wi))\n        index += 2\n    return n, l, w, edges\n\ndef count_close_pairs(n, l, w, edges):\n    graph = defaultdict(list)\n    for pi, wi in edges:\n        graph[pi].append((n - pi, wi))\n        graph[n - pi].append((pi, wi))\n    \n    def bfs(start, max_length, max_weight):\n        queue = deque([(start, 0, 0)])\n        visited = set([start])\n        count = 0\n        while queue:\n            current, length, weight = queue.popleft()\n            if length > max_length or weight > max_weight:\n                continue\n            for neighbor, edge_weight in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, length + 1, weight + edge_weight))\n                    count += 1\n        return count\n    \n    close_pairs = 0\n    for i in range(1, n + 1):\n        close_pairs += bfs(i, l, w)\n    \n    return close_pairs\n\ndef main():\n    n, l, w, edges = read_input()\n    result = count_close_pairs(n, l, w, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i])\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the maximum depth of the tree\ndef max_depth(node, parent):\n    depth = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth = max(depth, max_depth(neighbor, node))\n    return depth + 1\n\n# Find the maximum depth of the tree\nmax_depth = max_depth(1, -1)\n\n# Function to find the maximum weight path from a node to a leaf\ndef max_weight_path(node, parent):\n    max_weight = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            max_weight = max(max_weight, max_weight_path(neighbor, node))\n    return max_weight + 1\n\n# Find the maximum weight path from a node to a leaf\nmax_weight_path = max_weight_path(1, -1)\n\n# Function to find the number of close pairs\ndef count_close_pairs():\n    count = 0\n    for u in range(1, n + 1):\n        for v in range(u + 1, n + 1):\n            if abs(u - v) <= l and abs(max_weight_path(u, -1) - max_weight_path(v, -1)) <= w:\n                count += 1\n    return count\n\n# Print the number of close pairs\nprint(count_close_pairs())\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    n = int(data[index])\n    l = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    edges = []\n    for _ in range(n - 1):\n        pi = int(data[index])\n        wi = int(data[index + 1])\n        edges.append((pi, wi))\n        index += 2\n    return n, l, w, edges\n\ndef count_close_pairs(n, l, w, edges):\n    graph = defaultdict(list)\n    for pi, wi in edges:\n        graph[pi].append((n - pi, wi))\n        graph[n - pi].append((pi, wi))\n    \n    def bfs(start, max_length, max_weight):\n        queue = deque([(start, 0, 0)])\n        visited = set([start])\n        count = 0\n        while queue:\n            current, length, weight = queue.popleft()\n            if length > max_length or weight > max_weight:\n                continue\n            for neighbor, edge_weight in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, length + 1, weight + edge_weight))\n                    count += 1\n        return count\n    \n    close_pairs = 0\n    for i in range(1, n + 1):\n        close_pairs += bfs(i, l, w)\n    \n    return close_pairs\n\ndef main():\n    n, l, w, edges = read_input()\n    result = count_close_pairs(n, l, w, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i])\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v, w in edges:\n    tree[u].append((v, w))\n    tree[v].append((u, w))\n\n# Function to find the maximum distance from a node to all other nodes\ndef bfs_max_distance(start):\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    queue = deque([start])\n    while queue:\n        u = queue.popleft()\n        for v, w in tree[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                queue.append(v)\n    return dist\n\n# Function to find the maximum weight path from a node to all other nodes\ndef dfs_max_weight(start, parent):\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    stack = [(start, 0)]\n    while stack:\n        u, w = stack.pop()\n        for v, wv in tree[u]:\n            if v != parent:\n                if dist[v] == -1 or dist[v] < dist[u] + wv:\n                    dist[v] = dist[u] + wv\n                    stack.append((v, wv))\n    return dist\n\n# Find the maximum distance and weight for each node\nmax_distance = [0] * (n + 1)\nmax_weight = [0] * (n + 1)\nfor i in range(1, n + 1):\n    max_distance[i] = bfs_max_distance(i)\n    max_weight[i] = dfs_max_weight(i, -1)\n\n# Count the number of close pairs\nclose_pairs = 0\nfor i in range(1, n):\n    for j in range(i + 1, n + 1):\n        if max_distance[i][j] <= l and max_weight[i][j] <= w:\n            close_pairs += 1\n\n# Print the result\nprint(close_pairs)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i])\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the maximum depth of the tree\ndef max_depth(node, parent):\n    depth = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth = max(depth, max_depth(neighbor, node))\n    return depth + 1\n\n# Find the maximum depth of the tree\nmax_depth_value = max_depth(1, -1)\n\n# Function to find the maximum weight path from a node to a leaf\ndef max_weight_path(node, parent):\n    max_weight = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            max_weight = max(max_weight, max_weight_path(neighbor, node))\n    return max_weight + 1\n\n# Find the maximum weight path from a node to a leaf\nmax_weight_path_value = max_weight_path(1, -1)\n\n# Function to find the number of close pairs\ndef count_close_pairs():\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if abs(i - j) <= l and abs(max_weight_path(i, -1) - max_weight_path(j, -1)) <= w:\n                count += 1\n    return count\n\n# Print the number of close pairs\nprint(count_close_pairs())\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i])\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v, w in edges:\n    tree[u].append((v, w))\n    tree[v].append((u, w))\n\n# Function to find the maximum depth and maximum weight path from a node\ndef dfs(node, parent):\n    max_depth = 0\n    max_weight = 0\n    for neighbor, weight in tree[node]:\n        if neighbor != parent:\n            depth, weight_sum = dfs(neighbor, node)\n            max_depth = max(max_depth, depth + 1)\n            max_weight = max(max_weight, weight_sum + weight)\n    return max_depth, max_weight\n\n# Count the number of close pairs\nclose_pairs = 0\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        if abs(i - j) <= l:\n            max_depth_i, max_weight_i = dfs(i, -1)\n            max_depth_j, max_weight_j = dfs(j, -1)\n            if max_depth_i + max_depth_j <= l and max_weight_i + max_weight_j <= w:\n                close_pairs += 1\n\nprint(close_pairs)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i]) - 1\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v, w in enumerate(edges, start=1):\n    tree[u].append((v, w))\n    tree[v].append((u, w))\n\n# Function to find the maximum depth and maximum weight path from a node\ndef dfs(node, parent):\n    max_depth = 0\n    max_weight = 0\n    for neighbor, weight in tree[node]:\n        if neighbor != parent:\n            depth, weight_sum = dfs(neighbor, node)\n            max_depth = max(max_depth, depth + 1)\n            max_weight = max(max_weight, weight_sum + weight)\n    return max_depth, max_weight\n\n# Count the number of close pairs\nclose_pairs = 0\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        if abs(i - j) <= l:\n            depth_i, weight_i = dfs(i, -1)\n            depth_j, weight_j = dfs(j, -1)\n            if depth_i + depth_j <= l and weight_i + weight_j <= w:\n                close_pairs += 1\n\n# Output the result\nprint(close_pairs)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i])\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v, w in edges:\n    tree[u].append((v, w))\n    tree[v].append((u, w))\n\n# Function to find the maximum depth and maximum weight path from a node\ndef dfs(node, parent):\n    max_depth = 0\n    max_weight = 0\n    for neighbor, weight in tree[node]:\n        if neighbor != parent:\n            depth, weight_sum = dfs(neighbor, node)\n            max_depth = max(max_depth, depth + 1)\n            max_weight = max(max_weight, weight_sum + weight)\n    return max_depth, max_weight\n\n# Count close pairs\nclose_pairs = 0\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        if abs(i - j) <= l:\n            if i < j:\n                close_pairs += 1\n            else:\n                close_pairs += 1\n\nprint(close_pairs)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    n = int(data[index])\n    l = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    edges = []\n    for _ in range(n - 1):\n        pi = int(data[index])\n        wi = int(data[index + 1])\n        edges.append((pi, wi))\n        index += 2\n    return n, l, w, edges\n\ndef count_close_pairs(n, l, w, edges):\n    tree = defaultdict(list)\n    for pi, wi in edges:\n        tree[pi].append((pi, wi))\n        tree[pi + 1].append((pi + 1, wi))\n    \n    def bfs(start, max_length, max_weight):\n        queue = deque([(start, 0, 0)])\n        visited = set([start])\n        count = 0\n        while queue:\n            current, length, weight = queue.popleft()\n            if length > max_length or weight > max_weight:\n                continue\n            for neighbor, edge_weight in tree[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, length + 1, weight + edge_weight))\n                    count += 1\n        return count\n    \n    close_pairs = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if abs(i - j) <= l:\n                close_pairs += 1\n            else:\n                length = abs(i - j)\n                weight = bfs(i, length, w) + bfs(j, length, w)\n                if length <= l and weight <= w:\n                    close_pairs += 1\n    \n    return close_pairs\n\ndef main():\n    n, l, w, edges = read_input()\n    result = count_close_pairs(n, l, w, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i]) - 1\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the maximum depth of the tree\ndef max_depth(node, parent):\n    depth = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth = max(depth, max_depth(neighbor, node))\n    return depth + 1\n\n# Find the maximum depth of the tree\nmax_depth = max_depth(0, -1)\n\n# Function to find the maximum weight path from a node to a leaf\ndef max_weight_path(node, parent):\n    if not tree[node]:\n        return 0\n    max_weight = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            max_weight = max(max_weight, max_weight_path(neighbor, node))\n    return max_weight + 1\n\n# Find the maximum weight path from each node to a leaf\nmax_weight_paths = [0] * n\nfor i in range(n):\n    max_weight_paths[i] = max_weight_path(i, -1)\n\n# Count the number of close pairs\nclose_pairs = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if abs(max_depth - max_depth_paths[i] - max_depth_paths[j]) <= l and max_weight_paths[i] + max_weight_paths[j] <= w:\n            close_pairs += 1\n\n# Print the result\nprint(close_pairs)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    l = int(data[1])\n    w = int(data[2])\n    edges = []\n    index = 3\n    for _ in range(n - 1):\n        pi = int(data[index])\n        wi = int(data[index + 1])\n        edges.append((pi, wi))\n        index += 2\n    return n, l, w, edges\n\ndef count_close_pairs(n, l, w, edges):\n    graph = defaultdict(list)\n    for pi, wi in edges:\n        graph[pi].append((n - pi, wi))\n        graph[n - pi].append((pi, wi))\n    \n    def bfs(start, max_length, max_weight):\n        queue = deque([(start, 0, 0)])\n        visited = set([start])\n        count = 0\n        while queue:\n            current, length, weight = queue.popleft()\n            if length > max_length or weight > max_weight:\n                continue\n            for neighbor, edge_weight in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, length + 1, weight + edge_weight))\n                    count += 1\n        return count\n    \n    close_pairs = 0\n    for i in range(1, n + 1):\n        close_pairs += bfs(i, l, w)\n    \n    return close_pairs\n\ndef main():\n    n, l, w, edges = read_input()\n    result = count_close_pairs(n, l, w, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i])\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the maximum depth of the tree\ndef max_depth(node, parent):\n    depth = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth = max(depth, max_depth(neighbor, node))\n    return depth + 1\n\n# Find the maximum depth of the tree\nmax_depth = max_depth(1, -1)\n\n# Function to find the maximum weight path from a node to a leaf\ndef max_weight_path(node, parent):\n    max_weight = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            max_weight = max(max_weight, max_weight_path(neighbor, node))\n    return max_weight + 1\n\n# Find the maximum weight path from a node to a leaf\nmax_weight_path = max_weight_path(1, -1)\n\n# Function to find the number of close pairs\ndef count_close_pairs():\n    count = 0\n    for u in range(1, n + 1):\n        for v in range(u + 1, n + 1):\n            if abs(u - v) <= l and abs(max_weight_path(u, -1) - max_weight_path(v, -1)) <= w:\n                count += 1\n    return count\n\n# Print the number of close pairs\nprint(count_close_pairs())",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    n = int(data[index])\n    l = int(data[index + 1])\n    w = int(data[index + 2])\n    index += 3\n    edges = []\n    for _ in range(n - 1):\n        pi = int(data[index])\n        wi = int(data[index + 1])\n        edges.append((pi, wi))\n        index += 2\n    return n, l, w, edges\n\ndef count_close_pairs(n, l, w, edges):\n    graph = defaultdict(list)\n    for pi, wi in edges:\n        graph[pi].append((n - pi, wi))\n        graph[n - pi].append((pi, wi))\n    \n    def bfs(start, max_length, max_weight):\n        queue = deque([(start, 0, 0)])\n        visited = set([start])\n        count = 0\n        while queue:\n            current, length, weight = queue.popleft()\n            if length > max_length or weight > max_weight:\n                continue\n            for neighbor, edge_weight in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, length + 1, weight + edge_weight))\n                    count += 1\n        return count\n    \n    close_pairs = 0\n    for i in range(1, n + 1):\n        close_pairs += bfs(i, l, w)\n    \n    return close_pairs\n\ndef main():\n    n, l, w, edges = read_input()\n    result = count_close_pairs(n, l, w, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i])\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v, w in edges:\n    tree[u].append((v, w))\n    tree[v].append((u, w))\n\n# Function to find the maximum distance from a node to all other nodes\ndef bfs_max_distance(start):\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    queue = deque([start])\n    while queue:\n        u = queue.popleft()\n        for v, w in tree[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                queue.append(v)\n    return dist\n\n# Function to find the maximum weight path from a node to all other nodes\ndef dfs_max_weight(start, parent):\n    dist = [-1] * (n + 1)\n    dist[start] = 0\n    stack = [(start, 0)]\n    while stack:\n        u, w = stack.pop()\n        for v, wv in tree[u]:\n            if v != parent:\n                if dist[v] == -1 or dist[v] < dist[u] + wv:\n                    dist[v] = dist[u] + wv\n                    stack.append((v, wv))\n    return dist\n\n# Find the maximum distance and weight for each node\nmax_distance = [0] * (n + 1)\nmax_weight = [0] * (n + 1)\nfor i in range(1, n + 1):\n    max_distance[i] = bfs_max_distance(i)\n    max_weight[i] = dfs_max_weight(i, -1)\n\n# Count the number of close pairs\nclose_pairs = 0\nfor i in range(1, n):\n    for j in range(i + 1, n + 1):\n        if max_distance[i][j] <= l and max_weight[i][j] <= w:\n            close_pairs += 1\n\n# Print the result\nprint(close_pairs)",
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i])\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the maximum depth of the tree\ndef max_depth(node, parent):\n    depth = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            depth = max(depth, max_depth(neighbor, node))\n    return depth + 1\n\n# Find the maximum depth of the tree\nmax_depth_value = max_depth(1, -1)\n\n# Function to find the maximum weight path from a node to a leaf\ndef max_weight_path(node, parent):\n    max_weight = 0\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            max_weight = max(max_weight, max_weight_path(neighbor, node))\n    return max_weight + 1\n\n# Find the maximum weight path from a node to a leaf\nmax_weight_path_value = max_weight_path(1, -1)\n\n# Function to find the number of close pairs\ndef count_close_pairs():\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if abs(i - j) <= l and abs(max_weight_path(i, -1) - max_weight_path(j, -1)) <= w:\n                count += 1\n    return count\n\n# Print the number of close pairs\nprint(count_close_pairs())",
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i])\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v, w in edges:\n    tree[u].append((v, w))\n    tree[v].append((u, w))\n\n# Function to find the maximum depth and maximum weight path from a node\ndef dfs(node, parent):\n    max_depth = 0\n    max_weight = 0\n    for neighbor, weight in tree[node]:\n        if neighbor != parent:\n            depth, weight_sum = dfs(neighbor, node)\n            max_depth = max(max_depth, depth + 1)\n            max_weight = max(max_weight, weight_sum + weight)\n    return max_depth, max_weight\n\n# Count the number of close pairs\nclose_pairs = 0\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        if abs(i - j) <= l:\n            max_depth_i, max_weight_i = dfs(i, -1)\n            max_depth_j, max_weight_j = dfs(j, -1)\n            if max_depth_i + max_depth_j <= l and max_weight_i + max_weight_j <= w:\n                close_pairs += 1\n\nprint(close_pairs)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i]) - 1\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v, w in enumerate(edges, start=1):\n    tree[u].append((v, w))\n    tree[v].append((u, w))\n\n# Function to find the maximum depth and maximum weight path from a node\ndef dfs(node, parent):\n    max_depth = 0\n    max_weight = 0\n    for neighbor, weight in tree[node]:\n        if neighbor != parent:\n            depth, weight_sum = dfs(neighbor, node)\n            max_depth = max(max_depth, depth + 1)\n            max_weight = max(max_weight, weight_sum + weight)\n    return max_depth, max_weight\n\n# Count the number of close pairs\nclose_pairs = 0\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        if abs(i - j) <= l:\n            depth_i, weight_i = dfs(i, -1)\n            depth_j, weight_j = dfs(j, -1)\n            if depth_i + depth_j <= l and weight_i + weight_j <= w:\n                close_pairs += 1\n\n# Output the result\nprint(close_pairs)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nw = int(data[2])\n\nedges = []\nfor i in range(n - 1):\n    pi = int(data[3 + 2 * i])\n    wi = int(data[4 + 2 * i])\n    edges.append((pi, wi))\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v, w in edges:\n    tree[u].append((v, w))\n    tree[v].append((u, w))\n\n# Function to find the maximum depth and maximum weight path from a node\ndef dfs(node, parent):\n    max_depth = 0\n    max_weight = 0\n    for neighbor, weight in tree[node]:\n        if neighbor != parent:\n            depth, weight_sum = dfs(neighbor, node)\n            max_depth = max(max_depth, depth + 1)\n            max_weight = max(max_weight, weight_sum + weight)\n    return max_depth, max_weight\n\n# Count close pairs\nclose_pairs = 0\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        if abs(i - j) <= l:\n            if i < j:\n                close_pairs += 1\n            else:\n                close_pairs += 1\n\nprint(close_pairs)"
        ]
    },
    {
        "question_title": "Yaroslav and Divisors",
        "question_content": "Yaroslav has an array p = p1, p2, ..., pn (1 \u2264 pi \u2264 n), consisting of n distinct integers. Also, he has m queries:\n\n- Query number i is represented as a pair of integers li, ri (1 \u2264 li \u2264 ri \u2264 n).\n- The answer to the query li, ri is the number of pairs of integers q, w (li \u2264 q, w \u2264 ri) such that pq is the divisor of pw.\n\nHelp Yaroslav, answer all his queries.\n\n\nInput Format\nThe first line contains the integers n and m (1 \u2264 n, m \u2264 2\u00b7105). The second line contains n distinct integers p1, p2, ..., pn (1 \u2264 pi \u2264 n). The following m lines contain Yaroslav's queries. The i-th line contains integers li, ri (1 \u2264 li \u2264 ri \u2264 n).\n\n\nOutput Format\nPrint m integers \u2014 the answers to Yaroslav's queries in the order they appear in the input.\n\nPlease, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\nSample Input 1\n\n1 1\n1\n1 1\n\nSample Output 1\n\n1\n\n\nSample Input 2\n\n10 9\n1 2 3 4 5 6 7 8 9 10\n1 10\n2 9\n3 8\n4 7\n5 6\n2 2\n9 10\n5 10\n4 10\n\nSample Output 2\n\n27\n14\n8\n4\n2\n1\n2\n7\n9",
        "platform": "codeforces",
        "question_id": "301/D",
        "contest_id": "301",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to count divisors\ndef count_divisors(arr, l, r):\n    count = 0\n    for i in range(l-1, r):\n        for j in range(i, r):\n            if arr[j] % arr[i] == 0:\n                count += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    results.append(count_divisors(p, l, r))\n\n# Output results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    li = int(data[index])\n    ri = int(data[index + 1])\n    queries.append((li, ri))\n    index += 2\n\ndef count_divisor_pairs(p, li, ri):\n    count = 0\n    for q in range(li - 1, ri):\n        for w in range(q, ri):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = []\nfor li, ri in queries:\n    results.append(count_divisor_pairs(p, li, ri))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    li = int(data[index])\n    ri = int(data[index + 1])\n    queries.append((li, ri))\n    index += 2\n\ndef count_divisor_pairs(p, li, ri):\n    count = 0\n    for q in range(li - 1, ri):\n        for w in range(q, ri):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = []\nfor li, ri in queries:\n    results.append(count_divisor_pairs(p, li, ri))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Create a dictionary to store the prime factors of each number\nprime_factors = defaultdict(list)\nfor i in range(1, n+1):\n    for j in range(1, i+1):\n        if i % j == 0:\n            prime_factors[i].append(j)\n\n# Function to count the number of valid pairs for a given query\ndef count_pairs(l, r):\n    count = 0\n    for q in range(l-1, r):\n        for w in range(q, r):\n            if all(x in prime_factors[p[w]] for x in prime_factors[p[q]]):\n                count += 1\n    return count\n\n# Process each query and print the result\nresults = [count_pairs(l, r) for l, r in queries]\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    li = int(data[index])\n    ri = int(data[index + 1])\n    queries.append((li, ri))\n    index += 2\n\ndef count_divisor_pairs(p, li, ri):\n    count = 0\n    for q in range(li - 1, ri):\n        for w in range(q, ri):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = []\nfor li, ri in queries:\n    results.append(count_divisor_pairs(p, li, ri))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef count_divisor_pairs(p, l, r):\n    count = 0\n    for q in range(l-1, r):\n        for w in range(q, r):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = [count_divisor_pairs(p, li, ri) for li, ri in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to count divisors\ndef count_divisors(arr, l, r):\n    count = 0\n    for i in range(l-1, r):\n        for j in range(i, r):\n            if arr[j] % arr[i] == 0:\n                count += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    results.append(count_divisors(p, l, r))\n\n# Output results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef count_divisor_pairs(p, l, r):\n    count = 0\n    for q in range(l-1, r):\n        for w in range(q, r):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = [count_divisor_pairs(p, li, ri) for li, ri in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    li = int(data[index])\n    ri = int(data[index + 1])\n    queries.append((li, ri))\n    index += 2\n\ndef count_divisor_pairs(p, li, ri):\n    count = 0\n    for q in range(li - 1, ri):\n        for w in range(q, ri):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = []\nfor li, ri in queries:\n    results.append(count_divisor_pairs(p, li, ri))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    li = int(data[index])\n    ri = int(data[index + 1])\n    queries.append((li, ri))\n    index += 2\n\ndef count_divisor_pairs(p, li, ri):\n    count = 0\n    for q in range(li - 1, ri):\n        for w in range(q, ri):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = []\nfor li, ri in queries:\n    results.append(count_divisor_pairs(p, li, ri))\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to count divisors\ndef count_divisors(arr, l, r):\n    count = 0\n    for i in range(l-1, r):\n        for j in range(i, r):\n            if arr[j] % arr[i] == 0:\n                count += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    results.append(count_divisors(p, l, r))\n\n# Output results\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    li = int(data[index])\n    ri = int(data[index + 1])\n    queries.append((li, ri))\n    index += 2\n\ndef count_divisor_pairs(p, li, ri):\n    count = 0\n    for q in range(li - 1, ri):\n        for w in range(q, ri):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = []\nfor li, ri in queries:\n    results.append(count_divisor_pairs(p, li, ri))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    li = int(data[index])\n    ri = int(data[index + 1])\n    queries.append((li, ri))\n    index += 2\n\ndef count_divisor_pairs(p, li, ri):\n    count = 0\n    for q in range(li - 1, ri):\n        for w in range(q, ri):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = []\nfor li, ri in queries:\n    results.append(count_divisor_pairs(p, li, ri))\n\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Create a dictionary to store the prime factors of each number\nprime_factors = defaultdict(list)\nfor i in range(1, n+1):\n    for j in range(1, i+1):\n        if i % j == 0:\n            prime_factors[i].append(j)\n\n# Function to count the number of valid pairs for a given query\ndef count_pairs(l, r):\n    count = 0\n    for q in range(l-1, r):\n        for w in range(q, r):\n            if all(x in prime_factors[p[w]] for x in prime_factors[p[q]]):\n                count += 1\n    return count\n\n# Process each query and print the result\nresults = [count_pairs(l, r) for l, r in queries]\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    li = int(data[index])\n    ri = int(data[index + 1])\n    queries.append((li, ri))\n    index += 2\n\ndef count_divisor_pairs(p, li, ri):\n    count = 0\n    for q in range(li - 1, ri):\n        for w in range(q, ri):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = []\nfor li, ri in queries:\n    results.append(count_divisor_pairs(p, li, ri))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef count_divisor_pairs(p, l, r):\n    count = 0\n    for q in range(l-1, r):\n        for w in range(q, r):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = [count_divisor_pairs(p, li, ri) for li, ri in queries]\n\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to count divisors\ndef count_divisors(arr, l, r):\n    count = 0\n    for i in range(l-1, r):\n        for j in range(i, r):\n            if arr[j] % arr[i] == 0:\n                count += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    results.append(count_divisors(p, l, r))\n\n# Output results\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef count_divisor_pairs(p, l, r):\n    count = 0\n    for q in range(l-1, r):\n        for w in range(q, r):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = [count_divisor_pairs(p, li, ri) for li, ri in queries]\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    li = int(data[index])\n    ri = int(data[index + 1])\n    queries.append((li, ri))\n    index += 2\n\ndef count_divisor_pairs(p, li, ri):\n    count = 0\n    for q in range(li - 1, ri):\n        for w in range(q, ri):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = []\nfor li, ri in queries:\n    results.append(count_divisor_pairs(p, li, ri))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\np = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    li = int(data[index])\n    ri = int(data[index + 1])\n    queries.append((li, ri))\n    index += 2\n\ndef count_divisor_pairs(p, li, ri):\n    count = 0\n    for q in range(li - 1, ri):\n        for w in range(q, ri):\n            if p[w] % p[q] == 0:\n                count += 1\n    return count\n\nresults = []\nfor li, ri in queries:\n    results.append(count_divisor_pairs(p, li, ri))\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Minimum Modular",
        "question_content": "You have been given n distinct integers a1, a2, ..., an. You can remove at most k of them. Find the minimum modular m (m > 0), so that for every pair of the remaining integers (ai, aj), the following unequality holds: a_{i} \\not\\equiv a_{j} \\mod m.\n\n\nInput Format\nThe first line contains two integers n and k (1 \u2264 n \u2264 5000, 0 \u2264 k \u2264 4), which we have mentioned above.\n\nThe second line contains n distinct integers a1, a2, ..., an (0 \u2264 ai \u2264 106).\n\n\nOutput Format\nPrint a single positive integer \u2014 the minimum m.\n\n\nSample Input 1\n\n7 0\n0 2 3 6 7 12 18\n\nSample Output 1\n\n13\n\n\nSample Input 2\n\n7 1\n0 2 3 6 7 12 18\n\nSample Output 2\n\n7",
        "platform": "codeforces",
        "question_id": "303/C",
        "contest_id": "303",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a) + 1\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a)\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a)\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a) + 1\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a) + 1\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a) + 1\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a) + 1\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)\n```",
            "```python\nimport sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a)\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a)\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a)\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a) + 1\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a)\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a)\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a) + 1\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a) + 1\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a) + 1\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a) + 1\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)",
            "import sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a)\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a)\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Function to check if a given m is valid\ndef is_valid(m):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (a[i] % m == a[j] % m):\n                return False\n    return True\n\n# Binary search for the minimum m\nleft, right = 1, max(a)\nwhile left < right:\n    mid = (left + right) // 2\n    if is_valid(mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# Output the result\nprint(left)"
        ]
    },
    {
        "question_title": "Ciel and Flipboard",
        "question_content": "Fox Ciel has a board with n rows and n columns, there is one integer in each cell.\n\nIt's known that n is an odd number, so let's introduce x = \\frac{n+1}{2}. Fox Ciel can do the following operation many times: she choose a sub-board with size x rows and x columns, then all numbers in it will be multiplied by -1.\n\nReturn the maximal sum of numbers in the board that she can get by these operations.\n\n\nInput Format\nThe first line contains an integer n, (1 \u2264 n \u2264 33, and n is an odd integer) \u2014 the size of the board.\n\nEach of the next n lines contains n integers \u2014 the numbers in the board. Each number doesn't exceed 1000 by its absolute value.\n\n\nOutput Format\nOutput a single integer: the maximal sum of numbers in the board that can be accomplished.\n\n\nSample Input 1\n\n3\n-1 -1 1\n-1 1 -1\n1 -1 -1\n\nSample Output 1\n\n9\n\n\nSample Input 2\n\n5\n-2 0 0 0 -2\n0 -2 0 -2 0\n0 0 -2 0 0\n0 -2 0 -2 0\n-2 0 0 0 -2\n\nSample Output 2\n\n18\n\n\nNote\nIn the first test, we can apply this operation twice: first on the top left 2 x 2 sub-board, then on the bottom right 2 x 2 sub-board. Then all numbers will become positive.",
        "platform": "codeforces",
        "question_id": "321/D",
        "contest_id": "321",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip(sub_board):\n    for i in range(x):\n        for j in range(x):\n            sub_board[i][j] *= -1\n\ndef calculate_sum(board):\n    total_sum = 0\n    for row in board:\n        total_sum += sum(row)\n    return total_sum\n\nmax_sum = float('-inf')\n\ndef dfs(board, depth):\n    global max_sum\n    if depth == 0:\n        max_sum = max(max_sum, calculate_sum(board))\n        return\n    \n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            sub_board = [row[j:j + x] for row in board[i:i + x]]\n            flip(sub_board)\n            dfs(board, depth - 1)\n            flip(sub_board)\n\ndfs(board, (n + 1) // 2)\n\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip_subboard(board, x):\n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            for k in range(x):\n                for l in range(x):\n                    board[i + k][j + l] = -board[i + k][j + l]\n\nmax_sum = float('-inf')\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        flipped_board = [row[:] for row in board]\n        flip_subboard(flipped_board, x)\n        current_sum = sum(sum(row) for row in flipped_board)\n        max_sum = max(max_sum, current_sum)\n\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip_subboard(board, x):\n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            for k in range(x):\n                for l in range(x):\n                    board[i + k][j + l] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\n\ndef dfs(board, depth):\n    global max_sum\n    if depth == 0:\n        max_sum = max(max_sum, calculate_sum(board))\n        return\n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            new_board = [row[:] for row in board]\n            flip_subboard(new_board, x)\n            dfs(new_board, depth - 1)\n\ndfs(board, (n + 1) // 2)\n\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip(sub_board):\n    for i in range(x):\n        for j in range(x):\n            sub_board[i][j] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\n\ndef dfs(board, depth):\n    global max_sum\n    if depth == 0:\n        max_sum = max(max_sum, calculate_sum(board))\n        return\n    \n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            sub_board = [row[j:j + x] for row in board[i:i + x]]\n            flip(sub_board)\n            dfs(board, depth - 1)\n            flip(sub_board)\n\ndfs(board, (n + 1) // 2)\n\nprint(max_sum)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nboard = []\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\n# Function to calculate the sum of the board\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\n# Function to flip a sub-board of size x x x\ndef flip_sub_board(board, x):\n    for i in range(x):\n        for j in range(x):\n            board[i][j] *= -1\n\n# Calculate the maximal sum\nmax_sum = calculate_sum(board)\nx = (n + 1) // 2\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        flip_sub_board(board, x)\n        current_sum = calculate_sum(board)\n        if current_sum > max_sum:\n            max_sum = current_sum\n        flip_sub_board(board, x)  # Flip back to original\n\n# Output the result\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip_subboard(board, x, y):\n    for i in range(x):\n        for j in range(x):\n            board[i + y][j + y] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\n\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        new_board = [row[:] for row in board]\n        flip_subboard(new_board, x, i)\n        flip_subboard(new_board, x, j)\n        max_sum = max(max_sum, calculate_sum(new_board))\n\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip_subboard(board, x):\n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            for k in range(x):\n                for l in range(x):\n                    board[i + k][j + l] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        flipped_board = [row[:] for row in board]\n        flip_subboard(flipped_board, x)\n        max_sum = max(max_sum, calculate_sum(flipped_board))\n\nprint(max_sum)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nboard = []\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\n# Function to calculate the sum of the board\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\n# Function to flip a sub-board of size x x x\ndef flip_sub_board(board, x):\n    for i in range(x):\n        for j in range(x):\n            board[i][j] = -board[i][j]\n\n# Calculate the maximal sum\nx = (n + 1) // 2\nmax_sum = calculate_sum(board)\n\n# Try flipping all possible sub-boards\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        flip_sub_board(board, x)\n        current_sum = calculate_sum(board)\n        if current_sum > max_sum:\n            max_sum = current_sum\n        flip_sub_board(board, x)  # Flip back to original\n\n# Output the result\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = [list(map(int, data[1+n*i:n+1+(i+1)*n])) for i in range(n)]\n\nx = (n + 1) // 2\n\ndef flip(sub_board):\n    for i in range(x):\n        for j in range(x):\n            sub_board[i][j] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\n\ndef dfs(board, depth):\n    global max_sum\n    if depth == n // 2:\n        current_sum = calculate_sum(board)\n        if current_sum > max_sum:\n            max_sum = current_sum\n        return\n    \n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            sub_board = [row[j:j+x] for row in board[i:i+x]]\n            flip(sub_board)\n            dfs(board, depth + 1)\n            flip(sub_board)\n\ndfs(board, 0)\n\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip_subboard(board, x, y):\n    for i in range(x):\n        for j in range(x):\n            board[i + y][j + y] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\n\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        flipped_board = [row[:] for row in board]\n        flip_subboard(flipped_board, x, i, j)\n        max_sum = max(max_sum, calculate_sum(flipped_board))\n\nprint(max_sum)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip(sub_board):\n    for i in range(x):\n        for j in range(x):\n            sub_board[i][j] *= -1\n\ndef calculate_sum(board):\n    total_sum = 0\n    for row in board:\n        total_sum += sum(row)\n    return total_sum\n\nmax_sum = float('-inf')\n\ndef dfs(board, depth):\n    global max_sum\n    if depth == 0:\n        max_sum = max(max_sum, calculate_sum(board))\n        return\n    \n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            sub_board = [row[j:j + x] for row in board[i:i + x]]\n            flip(sub_board)\n            dfs(board, depth - 1)\n            flip(sub_board)\n\ndfs(board, (n + 1) // 2)\n\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip_subboard(board, x):\n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            for k in range(x):\n                for l in range(x):\n                    board[i + k][j + l] = -board[i + k][j + l]\n\nmax_sum = float('-inf')\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        flipped_board = [row[:] for row in board]\n        flip_subboard(flipped_board, x)\n        current_sum = sum(sum(row) for row in flipped_board)\n        max_sum = max(max_sum, current_sum)\n\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip_subboard(board, x):\n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            for k in range(x):\n                for l in range(x):\n                    board[i + k][j + l] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\n\ndef dfs(board, depth):\n    global max_sum\n    if depth == 0:\n        max_sum = max(max_sum, calculate_sum(board))\n        return\n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            new_board = [row[:] for row in board]\n            flip_subboard(new_board, x)\n            dfs(new_board, depth - 1)\n\ndfs(board, (n + 1) // 2)\n\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip(sub_board):\n    for i in range(x):\n        for j in range(x):\n            sub_board[i][j] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\n\ndef dfs(board, depth):\n    global max_sum\n    if depth == 0:\n        max_sum = max(max_sum, calculate_sum(board))\n        return\n    \n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            sub_board = [row[j:j + x] for row in board[i:i + x]]\n            flip(sub_board)\n            dfs(board, depth - 1)\n            flip(sub_board)\n\ndfs(board, (n + 1) // 2)\n\nprint(max_sum)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nboard = []\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\n# Function to calculate the sum of the board\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\n# Function to flip a sub-board of size x x x\ndef flip_sub_board(board, x):\n    for i in range(x):\n        for j in range(x):\n            board[i][j] *= -1\n\n# Calculate the maximal sum\nmax_sum = calculate_sum(board)\nx = (n + 1) // 2\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        flip_sub_board(board, x)\n        current_sum = calculate_sum(board)\n        if current_sum > max_sum:\n            max_sum = current_sum\n        flip_sub_board(board, x)  # Flip back to original\n\n# Output the result\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip_subboard(board, x, y):\n    for i in range(x):\n        for j in range(x):\n            board[i + y][j + y] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\n\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        new_board = [row[:] for row in board]\n        flip_subboard(new_board, x, i)\n        flip_subboard(new_board, x, j)\n        max_sum = max(max_sum, calculate_sum(new_board))\n\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip_subboard(board, x):\n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            for k in range(x):\n                for l in range(x):\n                    board[i + k][j + l] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        flipped_board = [row[:] for row in board]\n        flip_subboard(flipped_board, x)\n        max_sum = max(max_sum, calculate_sum(flipped_board))\n\nprint(max_sum)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nboard = []\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\n# Function to calculate the sum of the board\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\n# Function to flip a sub-board of size x x x\ndef flip_sub_board(board, x):\n    for i in range(x):\n        for j in range(x):\n            board[i][j] = -board[i][j]\n\n# Calculate the maximal sum\nx = (n + 1) // 2\nmax_sum = calculate_sum(board)\n\n# Try flipping all possible sub-boards\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        flip_sub_board(board, x)\n        current_sum = calculate_sum(board)\n        if current_sum > max_sum:\n            max_sum = current_sum\n        flip_sub_board(board, x)  # Flip back to original\n\n# Output the result\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = [list(map(int, data[1+n*i:n+1+(i+1)*n])) for i in range(n)]\n\nx = (n + 1) // 2\n\ndef flip(sub_board):\n    for i in range(x):\n        for j in range(x):\n            sub_board[i][j] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\n\ndef dfs(board, depth):\n    global max_sum\n    if depth == n // 2:\n        current_sum = calculate_sum(board)\n        if current_sum > max_sum:\n            max_sum = current_sum\n        return\n    \n    for i in range(n - x + 1):\n        for j in range(n - x + 1):\n            sub_board = [row[j:j+x] for row in board[i:i+x]]\n            flip(sub_board)\n            dfs(board, depth + 1)\n            flip(sub_board)\n\ndfs(board, 0)\n\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nboard = []\n\nindex = 1\nfor i in range(n):\n    row = list(map(int, data[index:index + n]))\n    board.append(row)\n    index += n\n\nx = (n + 1) // 2\n\ndef flip_subboard(board, x, y):\n    for i in range(x):\n        for j in range(x):\n            board[i + y][j + y] *= -1\n\ndef calculate_sum(board):\n    return sum(sum(row) for row in board)\n\nmax_sum = float('-inf')\n\nfor i in range(n - x + 1):\n    for j in range(n - x + 1):\n        flipped_board = [row[:] for row in board]\n        flip_subboard(flipped_board, x, i, j)\n        max_sum = max(max_sum, calculate_sum(flipped_board))\n\nprint(max_sum)"
        ]
    },
    {
        "question_title": "Optimize!",
        "question_content": "Manao is solving a problem with the following statement:\n\nHe came up with a solution that produces the correct answers but is too slow. You are given the pseudocode of his solution, where the function getAnswer calculates the answer to the problem:\n\nYour task is to help Manao optimize his algorithm.\n\n\nInput Format\nThe first line contains space-separated integers n, len and h (1 \u2264 len \u2264 n \u2264 150000;\u00a01 \u2264 h \u2264 109). The second line contains len space-separated integers b1, b2, ..., blen (1 \u2264 bi \u2264 109). The third line contains n space-separated integers a1, a2, ..., an (1 \u2264 ai \u2264 109).\n\n\nOutput Format\nPrint a single number \u2014 the answer to Manao's problem.\n\n\nSample Input 1\n\n5 2 10\n5 3\n1 8 5 5 7\n\nSample Output 1\n\n2",
        "platform": "codeforces",
        "question_id": "338/E",
        "contest_id": "338",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to perform binary search\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n# Calculate the number of elements in a that are greater than or equal to h - b[i]\ncount = 0\nfor i in range(len):\n    index = binary_search(a, h - b[i])\n    if index != -1:\n        count += len - index\n\nprint(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count the number of elements in b that are less than or equal to x\ndef count_b(x):\n    return len([y for y in b if y <= x])\n\n# Function to count the number of elements in a that are greater than or equal to x\ndef count_a(x):\n    return len([y for y in a if y >= x])\n\n# Binary search to find the maximum value of x such that count_b(x) + count_a(x) <= h\nleft, right = 0, max(max(b), max(a))\nresult = 0\n\nwhile left <= right:\n    mid = (left + right) // 2\n    if count_b(mid) + count_a(mid) <= h:\n        result = mid\n        left = mid + 1\n    else:\n        right = mid - 1\n\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count the number of elements in b that are less than or equal to x\ndef count_b(x):\n    return len([y for y in b if y <= x])\n\n# Function to count the number of elements in a that are greater than or equal to x\ndef count_a(x):\n    return len([y for y in a if y >= x])\n\n# Binary search to find the maximum value of x such that count_b(x) + count_a(x) <= h\nleft, right = 0, max(max(b), max(a))\nresult = 0\n\nwhile left <= right:\n    mid = (left + right) // 2\n    if count_b(mid) + count_a(mid) <= h:\n        result = mid\n        left = mid + 1\n    else:\n        right = mid - 1\n\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef getAnswer(n: int, len: int, h: int, b: List[int], a: List[int]) -> int:\n    # Sort the array a to facilitate the binary search\n    a.sort()\n    \n    # Function to check if a given number of cuts can be made\n    def canMakeCuts(cuts: int) -> bool:\n        remaining = n\n        for i in range(len):\n            if a[i] + cuts * b[i] <= h:\n                remaining -= 1\n            if remaining == 0:\n                return True\n        return False\n    \n    # Binary search to find the maximum number of cuts\n    left, right = 0, h\n    while left < right:\n        mid = (left + right + 1) // 2\n        if canMakeCuts(mid):\n            left = mid\n        else:\n            right = mid - 1\n    \n    return left\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Calculate and print the answer\nanswer = getAnswer(n, len, h, b, a)\nprint(answer)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count the number of elements in a that are less than or equal to x\ndef count_less_than_or_equal(x):\n    return len([y for y in a if y <= x])\n\n# Binary search to find the minimum number of elements in a that are less than or equal to h\nleft, right = 0, h\nwhile left < right:\n    mid = (left + right) // 2\n    if count_less_than_or_equal(mid) >= len:\n        right = mid\n    else:\n        left = mid + 1\n\nprint(left)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count the number of elements in b that are less than or equal to x\ndef count_b(x):\n    return len([y for y in b if y <= x])\n\n# Function to count the number of elements in a that are greater than or equal to x\ndef count_a(x):\n    return len([y for y in a if y >= x])\n\n# Binary search to find the maximum value of x such that count_b(x) + count_a(x) <= h\nleft, right = 0, max(max(b), max(a))\nresult = 0\n\nwhile left <= right:\n    mid = (left + right) // 2\n    if count_b(mid) + count_a(mid) <= h:\n        result = mid\n        left = mid + 1\n    else:\n        right = mid - 1\n\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count the number of elements in a that are less than or equal to x\ndef countLessOrEqual(x):\n    return len([y for y in a if y <= x])\n\n# Binary search to find the minimum value of x such that there are at least len elements in a that are less than or equal to x\nleft, right = 1, h\nwhile left < right:\n    mid = (left + right) // 2\n    if countLessOrEqual(mid) >= len:\n        right = mid\n    else:\n        left = mid + 1\n\n# Check if the final value of left satisfies the condition\nif countLessOrEqual(left) >= len:\n    print(left)\nelse:\n    print(-1)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count how many elements in a are less than or equal to x\ndef count_less_or_equal(x):\n    return len([y for y in a if y <= x])\n\n# Binary search to find the minimum x such that count_less_or_equal(x) >= len\nleft, right = 0, h\nwhile left < right:\n    mid = (left + right) // 2\n    if count_less_or_equal(mid) >= len:\n        right = mid\n    else:\n        left = mid + 1\n\nprint(left)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over each element in a\nfor ai in a:\n    # Find the number of elements in b that are less than or equal to ai - h\n    left = 0\n    right = len - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if b[mid] <= ai - h:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # The number of elements in b that are less than or equal to ai - h is left\n    answer += left\n\n# Print the answer\nprint(answer)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to check if a given number of blocks can be placed\ndef can_place_blocks(k):\n    i = 0\n    for j in range(n):\n        if i == len:\n            return True\n        if a[j] - b[i] >= h:\n            i += 1\n    return i == len\n\n# Binary search to find the maximum number of blocks that can be placed\nleft, right = 0, len\nwhile left < right:\n    mid = (left + right + 1) // 2\n    if can_place_blocks(mid):\n        left = mid\n    else:\n        right = mid - 1\n\nprint(left)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to perform binary search\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n# Calculate the number of elements in a that are greater than or equal to h - b[i]\ncount = 0\nfor i in range(len):\n    index = binary_search(a, h - b[i])\n    if index != -1:\n        count += len - index\n\nprint(count)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count the number of elements in b that are less than or equal to x\ndef count_b(x):\n    return len([y for y in b if y <= x])\n\n# Function to count the number of elements in a that are greater than or equal to x\ndef count_a(x):\n    return len([y for y in a if y >= x])\n\n# Binary search to find the maximum value of x such that count_b(x) + count_a(x) <= h\nleft, right = 0, max(max(b), max(a))\nresult = 0\n\nwhile left <= right:\n    mid = (left + right) // 2\n    if count_b(mid) + count_a(mid) <= h:\n        result = mid\n        left = mid + 1\n    else:\n        right = mid - 1\n\nprint(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count the number of elements in b that are less than or equal to x\ndef count_b(x):\n    return len([y for y in b if y <= x])\n\n# Function to count the number of elements in a that are greater than or equal to x\ndef count_a(x):\n    return len([y for y in a if y >= x])\n\n# Binary search to find the maximum value of x such that count_b(x) + count_a(x) <= h\nleft, right = 0, max(max(b), max(a))\nresult = 0\n\nwhile left <= right:\n    mid = (left + right) // 2\n    if count_b(mid) + count_a(mid) <= h:\n        result = mid\n        left = mid + 1\n    else:\n        right = mid - 1\n\nprint(result)",
            "import sys\nfrom typing import List\n\ndef getAnswer(n: int, len: int, h: int, b: List[int], a: List[int]) -> int:\n    # Sort the array a to facilitate the binary search\n    a.sort()\n    \n    # Function to check if a given number of cuts can be made\n    def canMakeCuts(cuts: int) -> bool:\n        remaining = n\n        for i in range(len):\n            if a[i] + cuts * b[i] <= h:\n                remaining -= 1\n            if remaining == 0:\n                return True\n        return False\n    \n    # Binary search to find the maximum number of cuts\n    left, right = 0, h\n    while left < right:\n        mid = (left + right + 1) // 2\n        if canMakeCuts(mid):\n            left = mid\n        else:\n            right = mid - 1\n    \n    return left\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Calculate and print the answer\nanswer = getAnswer(n, len, h, b, a)\nprint(answer)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count the number of elements in a that are less than or equal to x\ndef count_less_than_or_equal(x):\n    return len([y for y in a if y <= x])\n\n# Binary search to find the minimum number of elements in a that are less than or equal to h\nleft, right = 0, h\nwhile left < right:\n    mid = (left + right) // 2\n    if count_less_than_or_equal(mid) >= len:\n        right = mid\n    else:\n        left = mid + 1\n\nprint(left)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count the number of elements in b that are less than or equal to x\ndef count_b(x):\n    return len([y for y in b if y <= x])\n\n# Function to count the number of elements in a that are greater than or equal to x\ndef count_a(x):\n    return len([y for y in a if y >= x])\n\n# Binary search to find the maximum value of x such that count_b(x) + count_a(x) <= h\nleft, right = 0, max(max(b), max(a))\nresult = 0\n\nwhile left <= right:\n    mid = (left + right) // 2\n    if count_b(mid) + count_a(mid) <= h:\n        result = mid\n        left = mid + 1\n    else:\n        right = mid - 1\n\nprint(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count the number of elements in a that are less than or equal to x\ndef countLessOrEqual(x):\n    return len([y for y in a if y <= x])\n\n# Binary search to find the minimum value of x such that there are at least len elements in a that are less than or equal to x\nleft, right = 1, h\nwhile left < right:\n    mid = (left + right) // 2\n    if countLessOrEqual(mid) >= len:\n        right = mid\n    else:\n        left = mid + 1\n\n# Check if the final value of left satisfies the condition\nif countLessOrEqual(left) >= len:\n    print(left)\nelse:\n    print(-1)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to count how many elements in a are less than or equal to x\ndef count_less_or_equal(x):\n    return len([y for y in a if y <= x])\n\n# Binary search to find the minimum x such that count_less_or_equal(x) >= len\nleft, right = 0, h\nwhile left < right:\n    mid = (left + right) // 2\n    if count_less_or_equal(mid) >= len:\n        right = mid\n    else:\n        left = mid + 1\n\nprint(left)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over each element in a\nfor ai in a:\n    # Find the number of elements in b that are less than or equal to ai - h\n    left = 0\n    right = len - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if b[mid] <= ai - h:\n            left = mid + 1\n        else:\n            right = mid - 1\n    # The number of elements in b that are less than or equal to ai - h is left\n    answer += left\n\n# Print the answer\nprint(answer)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nlen = int(data[1])\nh = int(data[2])\nb = list(map(int, data[3:3+len]))\na = list(map(int, data[3+len:]))\n\n# Sort the arrays to use binary search\nb.sort()\na.sort()\n\n# Function to check if a given number of blocks can be placed\ndef can_place_blocks(k):\n    i = 0\n    for j in range(n):\n        if i == len:\n            return True\n        if a[j] - b[i] >= h:\n            i += 1\n    return i == len\n\n# Binary search to find the maximum number of blocks that can be placed\nleft, right = 0, len\nwhile left < right:\n    mid = (left + right + 1) // 2\n    if can_place_blocks(mid):\n        left = mid\n    else:\n        right = mid - 1\n\nprint(left)"
        ]
    },
    {
        "question_title": "Number Transformation II",
        "question_content": "You are given a sequence of positive integers x1, x2, ..., xn and two non-negative integers a and b. Your task is to transform a into b. To do that, you can perform the following moves:\n\n- subtract 1 from the current a;\n- subtract a mod xi (1 \u2264 i \u2264 n) from the current a.\n\nOperation a mod xi means taking the remainder after division of number a by number xi.\n\nNow you want to know the minimum number of moves needed to transform a into b.\n\n\nInput Format\nThe first line contains a single integer n (1 \u2264 n \u2264 105). The second line contains n space-separated integers x1, x2, ..., xn (2 \u2264 xi \u2264 109). The third line contains two integers a and b (0 \u2264 b \u2264 a \u2264 109, a - b \u2264 106).\n\n\nOutput Format\nPrint a single integer \u2014 the required minimum number of moves needed to transform number a into number b.\n\n\nSample Input 1\n\n3\n3 4 5\n30 17\n\nSample Output 1\n\n6\n\n\nSample Input 2\n\n3\n5 6 7\n1000 200\n\nSample Output 2\n\n206",
        "platform": "codeforces",
        "question_id": "346/C",
        "contest_id": "346",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a - b\nmin_moves = a - b\n\n# Iterate over each xi to find the minimum number of moves\nfor xi in x:\n    current_a = a\n    current_moves = 0\n    while current_a > b:\n        if current_a >= xi:\n            current_a -= xi\n            current_moves += 1\n        else:\n            current_a -= 1\n            current_moves += 1\n    min_moves = min(min_moves, current_moves)\n\nprint(min_moves)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the dp array\ndp = [float('inf')] * (a + 1)\ndp[b] = 0\n\n# Fill the dp array\nfor i in range(b, a + 1):\n    dp[i] = min(dp[i], dp[i - 1] + 1)\n    for xi in x:\n        if i >= xi:\n            dp[i] = min(dp[i], dp[i - xi] + 1)\n\n# Output the result\nprint(dp[a])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a large number\nmin_moves = float('inf')\n\n# Iterate over all possible values of the last move\nfor last_move in range(a - b + 1):\n    current_a = a - last_move\n    moves = last_move\n    \n    # Iterate over all possible values of the second last move\n    for second_last_move in range(current_a):\n        current_a -= second_last_move\n        moves += second_last_move\n        \n        # Check if we can reach b with the remaining moves\n        if current_a % x[0] == b:\n            moves += current_a // x[0]\n            min_moves = min(min_moves, moves)\n            break\n        elif current_a % x[1] == b:\n            moves += current_a // x[1]\n            min_moves = min(min_moves, moves)\n            break\n        elif current_a % x[2] == b:\n            moves += current_a // x[2]\n            min_moves = min(min_moves, moves)\n            break\n\nprint(min_moves)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a large number\nmin_moves = float('inf')\n\n# Iterate over all possible values of a mod xi\nfor xi in x:\n    moves = 0\n    current_a = a\n    # Perform moves to transform current_a to b\n    while current_a > b:\n        if current_a % xi == 0:\n            moves += 1\n            current_a -= 1\n        else:\n            moves += 1\n            current_a -= current_a % xi\n    # Update the minimum number of moves\n    min_moves = min(min_moves, moves)\n\n# Print the minimum number of moves\nprint(min_moves)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the dp array where dp[i] represents the minimum moves to transform a to i\ndp = [float('inf')] * (a + 1)\ndp[a] = 0\n\n# Fill the dp array\nfor i in range(a, b - 1, -1):\n    dp[i] = min(dp[i], dp[i - 1] + 1)\n    for xi in x:\n        if i >= xi:\n            dp[i] = min(dp[i], dp[i - xi] + 1)\n\n# The answer is the minimum moves to transform a to b\nprint(dp[b])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a large number\nmin_moves = float('inf')\n\n# Iterate over all possible values of a mod xi\nfor xi in x:\n    # Calculate the number of moves needed to transform a into b using the current xi\n    moves = (a - b) // xi\n    # If the current xi is greater than or equal to a - b, we can transform a into b in one move\n    if xi >= a - b:\n        moves = 1\n    # Update the minimum number of moves\n    min_moves = min(min_moves, moves)\n\n# Print the minimum number of moves needed to transform a into b\nprint(min_moves)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_moves_to_transform_a_to_b(n: int, x: List[int], a: int, b: int) -> int:\n    moves = 0\n    while a > b:\n        if a % x[0] == 0:\n            a -= 1\n        else:\n            a -= a % x[0]\n        moves += 1\n    return moves\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = list(map(int, data[1:n+1]))\n    a = int(data[n+1])\n    b = int(data[n+2])\n    \n    result = min_moves_to_transform_a_to_b(n, x, a, b)\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the dp array\ndp = [float('inf')] * (a + 1)\ndp[b] = 0\n\n# Fill the dp array\nfor i in range(b, a + 1):\n    dp[i] = min(dp[i], dp[i - 1] + 1)\n    for xi in x:\n        if i >= xi:\n            dp[i] = min(dp[i], dp[i - xi] + 1)\n\n# Output the result\nprint(dp[a])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a large number\nmin_moves = float('inf')\n\n# Iterate over all possible values of a mod xi\nfor xi in x:\n    # Calculate the number of moves needed to transform a to b using the current xi\n    moves = (a - b) // xi\n    # If the current xi is greater than or equal to a - b, we can transform a to b in one move\n    if xi >= a - b:\n        moves = 1\n    # Update the minimum number of moves\n    min_moves = min(min_moves, moves)\n\n# Print the minimum number of moves\nprint(min_moves)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a large number\nmin_moves = float('inf')\n\n# Iterate over all possible values of the last move\nfor last_move in range(a - b + 1):\n    current_a = a\n    moves = last_move\n    # Perform the moves in reverse order\n    for i in range(n-1, -1, -1):\n        if current_a >= x[i]:\n            current_a -= x[i]\n            moves += 1\n    # Check if we can reach b with the remaining moves\n    if current_a == b:\n        min_moves = min(min_moves, moves)\n\n# Print the minimum number of moves\nprint(min_moves)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a - b\nmin_moves = a - b\n\n# Iterate over each xi to find the minimum number of moves\nfor xi in x:\n    current_a = a\n    current_moves = 0\n    while current_a > b:\n        if current_a >= xi:\n            current_a -= xi\n            current_moves += 1\n        else:\n            current_a -= 1\n            current_moves += 1\n    min_moves = min(min_moves, current_moves)\n\nprint(min_moves)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the dp array\ndp = [float('inf')] * (a + 1)\ndp[b] = 0\n\n# Fill the dp array\nfor i in range(b, a + 1):\n    dp[i] = min(dp[i], dp[i - 1] + 1)\n    for xi in x:\n        if i >= xi:\n            dp[i] = min(dp[i], dp[i - xi] + 1)\n\n# Output the result\nprint(dp[a])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a large number\nmin_moves = float('inf')\n\n# Iterate over all possible values of the last move\nfor last_move in range(a - b + 1):\n    current_a = a - last_move\n    moves = last_move\n    \n    # Iterate over all possible values of the second last move\n    for second_last_move in range(current_a):\n        current_a -= second_last_move\n        moves += second_last_move\n        \n        # Check if we can reach b with the remaining moves\n        if current_a % x[0] == b:\n            moves += current_a // x[0]\n            min_moves = min(min_moves, moves)\n            break\n        elif current_a % x[1] == b:\n            moves += current_a // x[1]\n            min_moves = min(min_moves, moves)\n            break\n        elif current_a % x[2] == b:\n            moves += current_a // x[2]\n            min_moves = min(min_moves, moves)\n            break\n\nprint(min_moves)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a large number\nmin_moves = float('inf')\n\n# Iterate over all possible values of a mod xi\nfor xi in x:\n    moves = 0\n    current_a = a\n    # Perform moves to transform current_a to b\n    while current_a > b:\n        if current_a % xi == 0:\n            moves += 1\n            current_a -= 1\n        else:\n            moves += 1\n            current_a -= current_a % xi\n    # Update the minimum number of moves\n    min_moves = min(min_moves, moves)\n\n# Print the minimum number of moves\nprint(min_moves)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the dp array where dp[i] represents the minimum moves to transform a to i\ndp = [float('inf')] * (a + 1)\ndp[a] = 0\n\n# Fill the dp array\nfor i in range(a, b - 1, -1):\n    dp[i] = min(dp[i], dp[i - 1] + 1)\n    for xi in x:\n        if i >= xi:\n            dp[i] = min(dp[i], dp[i - xi] + 1)\n\n# The answer is the minimum moves to transform a to b\nprint(dp[b])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a large number\nmin_moves = float('inf')\n\n# Iterate over all possible values of a mod xi\nfor xi in x:\n    # Calculate the number of moves needed to transform a into b using the current xi\n    moves = (a - b) // xi\n    # If the current xi is greater than or equal to a - b, we can transform a into b in one move\n    if xi >= a - b:\n        moves = 1\n    # Update the minimum number of moves\n    min_moves = min(min_moves, moves)\n\n# Print the minimum number of moves needed to transform a into b\nprint(min_moves)",
            "import sys\nfrom typing import List\n\ndef min_moves_to_transform_a_to_b(n: int, x: List[int], a: int, b: int) -> int:\n    moves = 0\n    while a > b:\n        if a % x[0] == 0:\n            a -= 1\n        else:\n            a -= a % x[0]\n        moves += 1\n    return moves\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    x = list(map(int, data[1:n+1]))\n    a = int(data[n+1])\n    b = int(data[n+2])\n    \n    result = min_moves_to_transform_a_to_b(n, x, a, b)\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the dp array\ndp = [float('inf')] * (a + 1)\ndp[b] = 0\n\n# Fill the dp array\nfor i in range(b, a + 1):\n    dp[i] = min(dp[i], dp[i - 1] + 1)\n    for xi in x:\n        if i >= xi:\n            dp[i] = min(dp[i], dp[i - xi] + 1)\n\n# Output the result\nprint(dp[a])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a large number\nmin_moves = float('inf')\n\n# Iterate over all possible values of a mod xi\nfor xi in x:\n    # Calculate the number of moves needed to transform a to b using the current xi\n    moves = (a - b) // xi\n    # If the current xi is greater than or equal to a - b, we can transform a to b in one move\n    if xi >= a - b:\n        moves = 1\n    # Update the minimum number of moves\n    min_moves = min(min_moves, moves)\n\n# Print the minimum number of moves\nprint(min_moves)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:n+1]))\na = int(data[n+1])\nb = int(data[n+2])\n\n# Initialize the minimum number of moves to a large number\nmin_moves = float('inf')\n\n# Iterate over all possible values of the last move\nfor last_move in range(a - b + 1):\n    current_a = a\n    moves = last_move\n    # Perform the moves in reverse order\n    for i in range(n-1, -1, -1):\n        if current_a >= x[i]:\n            current_a -= x[i]\n            moves += 1\n    # Check if we can reach b with the remaining moves\n    if current_a == b:\n        min_moves = min(min_moves, moves)\n\n# Print the minimum number of moves\nprint(min_moves)"
        ]
    },
    {
        "question_title": "Pair of Numbers",
        "question_content": "Simon has an array a1, a2, ..., an, consisting of n positive integers. Today Simon asked you to find a pair of integers l, r (1 \u2264 l \u2264 r \u2264 n), such that the following conditions hold:\n\n1. there is integer j (l \u2264 j \u2264 r), such that all integers al, al + 1, ..., ar are divisible by aj;\n2. value r - l takes the maximum value among all pairs for which condition 1 is true;\n\nHelp Simon, find the required pair of numbers (l, r). If there are multiple required pairs find all of them.\n\n\nInput Format\nThe first line contains integer n (1 \u2264 n \u2264 3\u00b7105).\n\nThe second line contains n space-separated integers a1, a2, ..., an (1 \u2264 ai \u2264 106).\n\n\nOutput Format\nPrint two integers in the first line \u2014 the number of required pairs and the maximum value of r - l. On the following line print all l values from optimal pairs in increasing order.\n\n\nSample Input 1\n\n5\n4 6 9 3 6\n\nSample Output 1\n\n1 3\n2\n\n\nSample Input 2\n\n5\n1 3 5 7 9\n\nSample Output 2\n\n1 4\n1\n\n\nSample Input 3\n\n5\n2 3 5 7 11\n\nSample Output 3\n\n5 0\n1 2 3 4 5\n\n\nNote\nIn the first sample the pair of numbers is right, as numbers 6, 9, 3 are divisible by 3.\n\nIn the second sample all numbers are divisible by number 1.\n\nIn the third sample all numbers are prime, so conditions 1 and 2 are true only for pairs of numbers (1, 1), (2, 2), (3, 3), (4, 4), (5, 5).",
        "platform": "codeforces",
        "question_id": "359/D",
        "contest_id": "359",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom typing import List\n\ndef find_max_divisible_pairs(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    l = 0\n    r = 0\n    current_l = 0\n    current_r = 0\n    \n    for i in range(n):\n        current_r = i\n        for j in range(i, -1, -1):\n            if all(a[k] % a[j] == 0 for k in range(j, i + 1)):\n                current_l = j\n                break\n        if current_r - current_l > max_length:\n            max_length = current_r - current_l\n            l = current_l\n            r = current_r\n            count = 1\n        elif current_r - current_l == max_length:\n            count += 1\n    \n    print(count, max_length)\n    for i in range(l, r + 1):\n        print(i + 1, end=' ')\n    print()\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Call the function with the input data\nfind_max_divisible_pairs(n, a)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef find_max_divisible_subarray(n: int, a: List[int]) -> None:\n    max_length = 0\n    max_l = []\n    current_l = 0\n    current_max = 0\n    \n    for i in range(n):\n        if i == 0 or a[i] % a[i-1] == 0:\n            current_l = i\n            current_max = a[i]\n        else:\n            current_max = max(current_max, a[i])\n        \n        if current_max == a[current_l]:\n            length = i - current_l + 1\n            if length > max_length:\n                max_length = length\n                max_l = [current_l + 1]\n            elif length == max_length:\n                max_l.append(current_l + 1)\n    \n    print(len(max_l), max_length)\n    print(*max_l)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nfind_max_divisible_subarray(n, a)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to find the greatest common divisor (GCD) of two numbers\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Function to find the GCD of a list of numbers\ndef gcd_list(lst):\n    return reduce(gcd, lst)\n\n# Initialize variables\nmax_length = 0\nresult_pairs = []\n\n# Iterate over all possible starting points\nfor i in range(n):\n    current_gcd = a[i]\n    for j in range(i, n):\n        current_gcd = gcd(current_gcd, a[j])\n        if current_gcd == 1:\n            break\n        if j - i + 1 > max_length:\n            max_length = j - i + 1\n            result_pairs = [i + 1]\n        elif j - i + 1 == max_length:\n            result_pairs.append(i + 1)\n\n# Output the result\nprint(len(result_pairs), max_length)\nprint(*result_pairs)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize variables\nmax_length = 0\nresult_pairs = []\n\n# Iterate over each possible starting point\nfor l in range(n):\n    current_divisor = a[l]\n    r = l\n    while r < n and a[r] % current_divisor == 0:\n        r += 1\n    if r - l > max_length:\n        max_length = r - l\n        result_pairs = [l]\n    elif r - l == max_length:\n        result_pairs.append(l)\n\n# Output the result\nprint(len(result_pairs), max_length)\nprint(*result_pairs)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef find_max_divisible_pairs(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    l = 0\n    results = []\n\n    for r in range(n):\n        for j in range(l, r + 1):\n            if all(a[j] % a[l] == 0 for j in range(l, r + 1)):\n                if r - l + 1 > max_length:\n                    max_length = r - l + 1\n                    count = 1\n                    results = [l]\n                elif r - l + 1 == max_length:\n                    results.append(l)\n                break\n\n    print(count, max_length)\n    print(*results)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nfind_max_divisible_pairs(n, a)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef find_max_divisible_pairs(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    start = 0\n    end = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            if all(a[j] % a[i] == 0 for k in range(i, j + 1)):\n                if j - i + 1 > max_length:\n                    max_length = j - i + 1\n                    count = 1\n                    start = i\n                elif j - i + 1 == max_length:\n                    count += 1\n    \n    print(count, max_length)\n    for i in range(start, start + count):\n        print(i + 1, end=' ')\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nfind_max_divisible_pairs(n, a)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef find_max_divisible_subarray(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    start_indices = []\n\n    for i in range(n):\n        current_length = 1\n        for j in range(i + 1, n):\n            if all(a[j] % a[i] == 0 for k in range(i, j + 1)):\n                current_length += 1\n            else:\n                break\n        if current_length > max_length:\n            max_length = current_length\n            count = 1\n            start_indices = [i + 1]\n        elif current_length == max_length:\n            count += 1\n            start_indices.append(i + 1)\n\n    print(count, max_length)\n    print(*start_indices)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nfind_max_divisible_subarray(n, a)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef find_max_divisible_subarray(n: int, a: List[int]) -> None:\n    max_length = 0\n    max_start = []\n    current_length = 0\n    current_start = 0\n    current_divisor = 1\n\n    for i in range(n):\n        if a[i] % current_divisor == 0:\n            current_length += 1\n        else:\n            if current_length > max_length:\n                max_length = current_length\n                max_start = [current_start]\n            elif current_length == max_length:\n                max_start.append(current_start)\n            current_length = 1\n            current_start = i\n            current_divisor = a[i]\n\n    if current_length > max_length:\n        max_length = current_length\n        max_start = [current_start]\n    elif current_length == max_length:\n        max_start.append(current_start)\n\n    print(len(max_start), max_length)\n    for start in max_start:\n        print(start + 1, end=' ')\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nfind_max_divisible_subarray(n, a)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef find_max_divisible_subarray(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    start_indices = []\n    \n    for i in range(n):\n        current_length = 1\n        for j in range(i + 1, n):\n            if all(a[j] % a[i] == 0 for a[j] in a[i:j+1]):\n                current_length += 1\n            else:\n                break\n        if current_length > max_length:\n            max_length = current_length\n            count = 1\n            start_indices = [i + 1]\n        elif current_length == max_length:\n            count += 1\n            start_indices.append(i + 1)\n    \n    print(count, max_length)\n    print(*start_indices)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Call the function with the input data\nfind_max_divisible_subarray(n, a)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef find_max_divisible_pairs(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    start_indices = []\n    \n    for i in range(n):\n        current_length = 1\n        for j in range(i + 1, n):\n            if all(a[j] % a[i] == 0 for k in range(i, j + 1)):\n                current_length += 1\n            else:\n                break\n        if current_length > max_length:\n            max_length = current_length\n            count = 1\n            start_indices = [i + 1]\n        elif current_length == max_length:\n            count += 1\n            start_indices.append(i + 1)\n    \n    print(count, max_length)\n    print(*start_indices)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Call the function with the input data\nfind_max_divisible_pairs(n, a)\n```"
        ],
        "code_list": [
            "import sys\nfrom typing import List\n\ndef find_max_divisible_pairs(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    l = 0\n    r = 0\n    current_l = 0\n    current_r = 0\n    \n    for i in range(n):\n        current_r = i\n        for j in range(i, -1, -1):\n            if all(a[k] % a[j] == 0 for k in range(j, i + 1)):\n                current_l = j\n                break\n        if current_r - current_l > max_length:\n            max_length = current_r - current_l\n            l = current_l\n            r = current_r\n            count = 1\n        elif current_r - current_l == max_length:\n            count += 1\n    \n    print(count, max_length)\n    for i in range(l, r + 1):\n        print(i + 1, end=' ')\n    print()\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Call the function with the input data\nfind_max_divisible_pairs(n, a)",
            "import sys\nfrom typing import List\n\ndef find_max_divisible_subarray(n: int, a: List[int]) -> None:\n    max_length = 0\n    max_l = []\n    current_l = 0\n    current_max = 0\n    \n    for i in range(n):\n        if i == 0 or a[i] % a[i-1] == 0:\n            current_l = i\n            current_max = a[i]\n        else:\n            current_max = max(current_max, a[i])\n        \n        if current_max == a[current_l]:\n            length = i - current_l + 1\n            if length > max_length:\n                max_length = length\n                max_l = [current_l + 1]\n            elif length == max_length:\n                max_l.append(current_l + 1)\n    \n    print(len(max_l), max_length)\n    print(*max_l)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nfind_max_divisible_subarray(n, a)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to find the greatest common divisor (GCD) of two numbers\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\n# Function to find the GCD of a list of numbers\ndef gcd_list(lst):\n    return reduce(gcd, lst)\n\n# Initialize variables\nmax_length = 0\nresult_pairs = []\n\n# Iterate over all possible starting points\nfor i in range(n):\n    current_gcd = a[i]\n    for j in range(i, n):\n        current_gcd = gcd(current_gcd, a[j])\n        if current_gcd == 1:\n            break\n        if j - i + 1 > max_length:\n            max_length = j - i + 1\n            result_pairs = [i + 1]\n        elif j - i + 1 == max_length:\n            result_pairs.append(i + 1)\n\n# Output the result\nprint(len(result_pairs), max_length)\nprint(*result_pairs)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize variables\nmax_length = 0\nresult_pairs = []\n\n# Iterate over each possible starting point\nfor l in range(n):\n    current_divisor = a[l]\n    r = l\n    while r < n and a[r] % current_divisor == 0:\n        r += 1\n    if r - l > max_length:\n        max_length = r - l\n        result_pairs = [l]\n    elif r - l == max_length:\n        result_pairs.append(l)\n\n# Output the result\nprint(len(result_pairs), max_length)\nprint(*result_pairs)",
            "import sys\nfrom typing import List\n\ndef find_max_divisible_pairs(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    l = 0\n    results = []\n\n    for r in range(n):\n        for j in range(l, r + 1):\n            if all(a[j] % a[l] == 0 for j in range(l, r + 1)):\n                if r - l + 1 > max_length:\n                    max_length = r - l + 1\n                    count = 1\n                    results = [l]\n                elif r - l + 1 == max_length:\n                    results.append(l)\n                break\n\n    print(count, max_length)\n    print(*results)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nfind_max_divisible_pairs(n, a)",
            "import sys\nfrom typing import List\n\ndef find_max_divisible_pairs(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    start = 0\n    end = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            if all(a[j] % a[i] == 0 for k in range(i, j + 1)):\n                if j - i + 1 > max_length:\n                    max_length = j - i + 1\n                    count = 1\n                    start = i\n                elif j - i + 1 == max_length:\n                    count += 1\n    \n    print(count, max_length)\n    for i in range(start, start + count):\n        print(i + 1, end=' ')\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nfind_max_divisible_pairs(n, a)",
            "import sys\nfrom typing import List\n\ndef find_max_divisible_subarray(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    start_indices = []\n\n    for i in range(n):\n        current_length = 1\n        for j in range(i + 1, n):\n            if all(a[j] % a[i] == 0 for k in range(i, j + 1)):\n                current_length += 1\n            else:\n                break\n        if current_length > max_length:\n            max_length = current_length\n            count = 1\n            start_indices = [i + 1]\n        elif current_length == max_length:\n            count += 1\n            start_indices.append(i + 1)\n\n    print(count, max_length)\n    print(*start_indices)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nfind_max_divisible_subarray(n, a)",
            "import sys\nfrom typing import List\n\ndef find_max_divisible_subarray(n: int, a: List[int]) -> None:\n    max_length = 0\n    max_start = []\n    current_length = 0\n    current_start = 0\n    current_divisor = 1\n\n    for i in range(n):\n        if a[i] % current_divisor == 0:\n            current_length += 1\n        else:\n            if current_length > max_length:\n                max_length = current_length\n                max_start = [current_start]\n            elif current_length == max_length:\n                max_start.append(current_start)\n            current_length = 1\n            current_start = i\n            current_divisor = a[i]\n\n    if current_length > max_length:\n        max_length = current_length\n        max_start = [current_start]\n    elif current_length == max_length:\n        max_start.append(current_start)\n\n    print(len(max_start), max_length)\n    for start in max_start:\n        print(start + 1, end=' ')\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nfind_max_divisible_subarray(n, a)",
            "import sys\nfrom typing import List\n\ndef find_max_divisible_subarray(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    start_indices = []\n    \n    for i in range(n):\n        current_length = 1\n        for j in range(i + 1, n):\n            if all(a[j] % a[i] == 0 for a[j] in a[i:j+1]):\n                current_length += 1\n            else:\n                break\n        if current_length > max_length:\n            max_length = current_length\n            count = 1\n            start_indices = [i + 1]\n        elif current_length == max_length:\n            count += 1\n            start_indices.append(i + 1)\n    \n    print(count, max_length)\n    print(*start_indices)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Call the function with the input data\nfind_max_divisible_subarray(n, a)",
            "import sys\nfrom typing import List\n\ndef find_max_divisible_pairs(n: int, a: List[int]) -> None:\n    max_length = 0\n    count = 0\n    start_indices = []\n    \n    for i in range(n):\n        current_length = 1\n        for j in range(i + 1, n):\n            if all(a[j] % a[i] == 0 for k in range(i, j + 1)):\n                current_length += 1\n            else:\n                break\n        if current_length > max_length:\n            max_length = current_length\n            count = 1\n            start_indices = [i + 1]\n        elif current_length == max_length:\n            count += 1\n            start_indices.append(i + 1)\n    \n    print(count, max_length)\n    print(*start_indices)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Call the function with the input data\nfind_max_divisible_pairs(n, a)"
        ]
    },
    {
        "question_title": "Empty Rectangles",
        "question_content": "You've got an n x m table (n rows and m columns), each cell of the table contains a \"0\" or a \"1\".\n\nYour task is to calculate the number of rectangles with the sides that are parallel to the sides of the table and go along the cell borders, such that the number one occurs exactly k times in the rectangle.\n\n\nInput Format\nThe first line contains three space-separated integers n, m and k (1 \u2264 n, m \u2264 2500, 0 \u2264 k \u2264 6) \u2014 the sizes of the table and the required number of numbers one.\n\nNext n lines each contains m characters \"0\" or \"1\". The i-th character of the j-th line corresponds to the character that is in the j-th row and the i-th column of the table.\n\n\nOutput Format\nPrint a single number \u2014 the number of rectangles that contain exactly k numbers one.\n\nPlease, do not write the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams or the %I64d specifier.\n\n\nSample Input 1\n\n3 3 2\n101\n000\n101\n\nSample Output 1\n\n8\n\n\nSample Input 2\n\n5 5 1\n00000\n00000\n00100\n00000\n00000\n\nSample Output 2\n\n81\n\n\nSample Input 3\n\n5 5 6\n01010\n10101\n01010\n10101\n01010\n\nSample Output 3\n\n12\n\n\nSample Input 4\n\n3 3 0\n001\n010\n000\n\nSample Output 4\n\n15\n\n\nSample Input 5\n\n4 4 0\n0000\n0101\n0000\n0000\n\nSample Output 5\n\n52",
        "platform": "codeforces",
        "question_id": "364/E",
        "contest_id": "364",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ntable = []\nfor i in range(n):\n    table.append(list(data[3 + i]))\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if table[i][j] == '1':\n                count += 1\n    return count\n\ndef count_rectangles():\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            for p in range(i, n):\n                for q in range(j, m):\n                    if count_ones((i, j, p, q)) == k:\n                        count += 1\n    return count\n\nprint(count_rectangles())\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ntable = []\nfor i in range(n):\n    table.append(list(data[3 + i]))\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if table[i][j] == '1':\n                count += 1\n    return count\n\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        for ii in range(i, n):\n            for jj in range(j, m):\n                if count_ones((i, j, ii, jj)) == k:\n                    count += 1\n\nprint(count)\n```",
            "```python\nimport sys\n\ndef count_rectangles(n, m, k, grid):\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            ones = 0\n            for x in range(i, n):\n                for y in range(j, m):\n                    if grid[x][y] == '1':\n                        ones += 1\n                    if ones == k:\n                        count += 1\n                    elif ones > k:\n                        break\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\ngrid = data[3:]\n\n# Calculate the number of rectangles\nresult = count_rectangles(n, m, k, grid)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ntable = []\nfor i in range(n):\n    table.append(list(data[3 + i]))\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if table[i][j] == '1':\n                count += 1\n    return count\n\ndef count_rectangles():\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            for x in range(i, n):\n                for y in range(j, m):\n                    if count_ones((i, j, x, y)) == k:\n                        count += 1\n    return count\n\nprint(count_rectangles())\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef count_rectangles(n, m, k, grid):\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            ones = defaultdict(int)\n            for x in range(i, n):\n                for y in range(j, m):\n                    ones[grid[x][y]] += 1\n                    if ones['1'] == k:\n                        count += 1\n                    elif ones['1'] > k:\n                        break\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\ngrid = [data[3 + i] for i in range(n)]\n\n# Solve the problem\nresult = count_rectangles(n, m, k, grid)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\n\ndef count_rectangles(n, m, k, grid):\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            ones = 0\n            for x in range(i, n):\n                for y in range(j, m):\n                    if grid[x][y] == '1':\n                        ones += 1\n                    if ones == k:\n                        count += 1\n                    elif ones > k:\n                        break\n    return count\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    \n    grid = []\n    for i in range(n):\n        grid.append(data[3 + i])\n    \n    result = count_rectangles(n, m, k, grid)\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ntable = [data[i + 3] for i in range(n)]\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if table[i][j] == '1':\n                count += 1\n    return count\n\ndef count_rectangles():\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            for ii in range(i, n):\n                for jj in range(j, m):\n                    if count_ones((i, j, ii, jj)) == k:\n                        count += 1\n    return count\n\nprint(count_rectangles())\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ngrid = []\nfor i in range(n):\n    grid.append(list(data[3 + i]))\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if grid[i][j] == '1':\n                count += 1\n    return count\n\ndef count_rectangles():\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            for x in range(i, n):\n                for y in range(j, m):\n                    if count_ones((i, j, x, y)) == k:\n                        count += 1\n    return count\n\nprint(count_rectangles())\n```",
            "```python\nimport sys\n\ndef count_rectangles(n, m, k, grid):\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            ones = 0\n            for x in range(i, n):\n                for y in range(j, m):\n                    if grid[x][y] == '1':\n                        ones += 1\n                    if ones == k:\n                        count += 1\n                    elif ones > k:\n                        break\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\ngrid = data[3:]\n\n# Calculate and print the result\nresult = count_rectangles(n, m, k, grid)\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ntable = []\nfor i in range(n):\n    table.append(list(data[3 + i]))\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if table[i][j] == '1':\n                count += 1\n    return count\n\ndef count_rectangles():\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            for ii in range(i, n):\n                for jj in range(j, m):\n                    if count_ones((i, j, ii, jj)) == k:\n                        count += 1\n    return count\n\nprint(count_rectangles())\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ntable = []\nfor i in range(n):\n    table.append(list(data[3 + i]))\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if table[i][j] == '1':\n                count += 1\n    return count\n\ndef count_rectangles():\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            for p in range(i, n):\n                for q in range(j, m):\n                    if count_ones((i, j, p, q)) == k:\n                        count += 1\n    return count\n\nprint(count_rectangles())",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ntable = []\nfor i in range(n):\n    table.append(list(data[3 + i]))\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if table[i][j] == '1':\n                count += 1\n    return count\n\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        for ii in range(i, n):\n            for jj in range(j, m):\n                if count_ones((i, j, ii, jj)) == k:\n                    count += 1\n\nprint(count)",
            "import sys\n\ndef count_rectangles(n, m, k, grid):\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            ones = 0\n            for x in range(i, n):\n                for y in range(j, m):\n                    if grid[x][y] == '1':\n                        ones += 1\n                    if ones == k:\n                        count += 1\n                    elif ones > k:\n                        break\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\ngrid = data[3:]\n\n# Calculate the number of rectangles\nresult = count_rectangles(n, m, k, grid)\n\n# Print the result\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ntable = []\nfor i in range(n):\n    table.append(list(data[3 + i]))\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if table[i][j] == '1':\n                count += 1\n    return count\n\ndef count_rectangles():\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            for x in range(i, n):\n                for y in range(j, m):\n                    if count_ones((i, j, x, y)) == k:\n                        count += 1\n    return count\n\nprint(count_rectangles())",
            "import sys\nfrom collections import defaultdict\n\ndef count_rectangles(n, m, k, grid):\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            ones = defaultdict(int)\n            for x in range(i, n):\n                for y in range(j, m):\n                    ones[grid[x][y]] += 1\n                    if ones['1'] == k:\n                        count += 1\n                    elif ones['1'] > k:\n                        break\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\ngrid = [data[3 + i] for i in range(n)]\n\n# Solve the problem\nresult = count_rectangles(n, m, k, grid)\n\n# Print the result\nprint(result)",
            "import sys\n\ndef count_rectangles(n, m, k, grid):\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            ones = 0\n            for x in range(i, n):\n                for y in range(j, m):\n                    if grid[x][y] == '1':\n                        ones += 1\n                    if ones == k:\n                        count += 1\n                    elif ones > k:\n                        break\n    return count\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    \n    grid = []\n    for i in range(n):\n        grid.append(data[3 + i])\n    \n    result = count_rectangles(n, m, k, grid)\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ntable = [data[i + 3] for i in range(n)]\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if table[i][j] == '1':\n                count += 1\n    return count\n\ndef count_rectangles():\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            for ii in range(i, n):\n                for jj in range(j, m):\n                    if count_ones((i, j, ii, jj)) == k:\n                        count += 1\n    return count\n\nprint(count_rectangles())",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ngrid = []\nfor i in range(n):\n    grid.append(list(data[3 + i]))\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if grid[i][j] == '1':\n                count += 1\n    return count\n\ndef count_rectangles():\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            for x in range(i, n):\n                for y in range(j, m):\n                    if count_ones((i, j, x, y)) == k:\n                        count += 1\n    return count\n\nprint(count_rectangles())",
            "import sys\n\ndef count_rectangles(n, m, k, grid):\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            ones = 0\n            for x in range(i, n):\n                for y in range(j, m):\n                    if grid[x][y] == '1':\n                        ones += 1\n                    if ones == k:\n                        count += 1\n                    elif ones > k:\n                        break\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\ngrid = data[3:]\n\n# Calculate and print the result\nresult = count_rectangles(n, m, k, grid)\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ntable = []\nfor i in range(n):\n    table.append(list(data[3 + i]))\n\ndef count_ones(rect):\n    count = 0\n    for i in range(rect[0], rect[2] + 1):\n        for j in range(rect[1], rect[3] + 1):\n            if table[i][j] == '1':\n                count += 1\n    return count\n\ndef count_rectangles():\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            for ii in range(i, n):\n                for jj in range(j, m):\n                    if count_ones((i, j, ii, jj)) == k:\n                        count += 1\n    return count\n\nprint(count_rectangles())"
        ]
    },
    {
        "question_title": "Sereja and Brackets",
        "question_content": "Sereja has a bracket sequence s1, s2, ..., sn, or, in other words, a string s of length n, consisting of characters \"(\" and \")\".\n\nSereja needs to answer m queries, each of them is described by two integers li, ri (1 \u2264 li \u2264 ri \u2264 n). The answer to the i-th query is the length of the maximum correct bracket subsequence of sequence sli, sli + 1, ..., sri. Help Sereja answer all queries.\n\nYou can find the definitions for a subsequence and a correct bracket sequence in the notes.\n\n\nInput Format\nThe first line contains a sequence of characters s1, s2, ..., sn (1 \u2264 n \u2264 106) without any spaces. Each character is either a \"(\" or a \")\". The second line contains integer m (1 \u2264 m \u2264 105) \u2014 the number of queries. Each of the next m lines contains a pair of integers. The i-th line contains integers li, ri (1 \u2264 li \u2264 ri \u2264 n) \u2014 the description of the i-th query.\n\n\nOutput Format\nPrint the answer to each question on a single line. Print the answers in the order they go in the input.\n\n\nSample Input 1\n\n())(())(())(\n7\n1 1\n2 3\n1 2\n1 12\n8 12\n5 11\n2 10\n\nSample Output 1\n\n0\n0\n2\n10\n4\n6\n6\n\n\nNote\nA subsequence of length |x| of string s = s1s2... s|s| (where |s| is the length of string s) is string x = sk1sk2... sk|x| (1 \u2264 k1 < k2 < ... < k|x| \u2264 |s|).\n\nA correct bracket sequence is a bracket sequence that can be transformed into a correct aryphmetic expression by inserting characters \"1\" and \"+\" between the characters of the string. For example, bracket sequences \"()()\", \"(())\" are correct (the resulting expressions \"(1)+(1)\", \"((1+1)+1)\"), and \")(\" and \"(\" are not.\n\nFor the third query required sequence will be \u00ab()\u00bb.\n\nFor the fourth query required sequence will be \u00ab()(())(())\u00bb.",
        "platform": "codeforces",
        "question_id": "380/C",
        "contest_id": "380",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef preprocess(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1 if s[i] == '(' else 0\n            elif s[i] == '(' and s[j] == ')':\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp\n\ndef query(dp, i, j):\n    return dp[i][j]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    s = data[0]\n    m = int(data[1])\n    queries = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n    \n    dp = preprocess(s)\n    \n    for li, ri in queries:\n        print(query(dp, li - 1, ri - 1))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    balance = 0\n    max_balance = 0\n    for char in s:\n        if char == '(':\n            stack.append(char)\n            balance += 1\n        elif char == ')' and balance > 0:\n            stack.pop()\n            balance -= 1\n            max_balance = max(max_balance, balance)\n    return max_balance * 2\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    s = data[0]\n    m = int(data[1])\n    queries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n    \n    results = []\n    for li, ri in queries:\n        subsequence = s[li:ri + 1]\n        results.append(max_correct_bracket_subsequence(subsequence))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    n = len(s)\n    dp = [[0] * 2 for _ in range(n + 1)]\n    stack = []\n    for i in range(n):\n        if s[i] == '(':\n            stack.append(i)\n        else:\n            if stack:\n                dp[stack[-1] + 1][0] += 2\n                dp[stack[-1] + 1][1] = dp[i][1]\n                stack.pop()\n            else:\n                dp[i + 1][1] = dp[i][1]\n    return dp[-1][0]\n\nresults = []\nfor l, r in queries:\n    subseq = s[l:r + 1]\n    results.append(max_correct_bracket_subsequence(subseq))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef preprocess(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1 if s[i] == '(' else 0\n            elif s[i] == '(' and s[j] == ')' and dp[i + 1][j - 1] > 0:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp\n\ndef answer_queries(s, queries, dp):\n    results = []\n    for li, ri in queries:\n        results.append(dp[li - 1][ri - 1])\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Preprocess the string\ndp = preprocess(s)\n\n# Answer the queries\nresults = answer_queries(s, queries, dp)\n\n# Print the results\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\nresults = []\nfor li, ri in queries:\n    subsequence = s[li:ri + 1]\n    results.append(max_correct_bracket_subsequence(subsequence))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef query_max_correct_bracket_subsequence(s, l, r):\n    return max_correct_bracket_subsequence(s[l:r+1])\n\nresults = [query_max_correct_bracket_subsequence(s, l, r) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef query_max_correct_bracket_subsequence(s, l, r):\n    return max_correct_bracket_subsequence(s[l:r+1])\n\nresults = [query_max_correct_bracket_subsequence(s, l, r) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef query_max_correct_bracket_subsequence(s, l, r):\n    return max_correct_bracket_subsequence(s[l:r+1])\n\nresults = [query_max_correct_bracket_subsequence(s, l, r) for l, r in queries]\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef preprocess(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1 if s[i] == '(' else 0\n            else:\n                if s[i] == '(' and s[j] == ')' and dp[i + 1][j - 1] > 0:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp\n\ndef answer_queries(s, queries, dp):\n    results = []\n    for li, ri in queries:\n        results.append(dp[li - 1][ri - 1])\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Preprocess the string\ndp = preprocess(s)\n\n# Answer the queries\nresults = answer_queries(s, queries, dp)\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef query_max_correct_bracket_subsequence(s, l, r):\n    return max_correct_bracket_subsequence(s[l:r+1])\n\nresults = [query_max_correct_bracket_subsequence(s, l, r) for l, r in queries]\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef preprocess(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1 if s[i] == '(' else 0\n            elif s[i] == '(' and s[j] == ')':\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp\n\ndef query(dp, i, j):\n    return dp[i][j]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    s = data[0]\n    m = int(data[1])\n    queries = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(m)]\n    \n    dp = preprocess(s)\n    \n    for li, ri in queries:\n        print(query(dp, li - 1, ri - 1))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    balance = 0\n    max_balance = 0\n    for char in s:\n        if char == '(':\n            stack.append(char)\n            balance += 1\n        elif char == ')' and balance > 0:\n            stack.pop()\n            balance -= 1\n            max_balance = max(max_balance, balance)\n    return max_balance * 2\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    s = data[0]\n    m = int(data[1])\n    queries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n    \n    results = []\n    for li, ri in queries:\n        subsequence = s[li:ri + 1]\n        results.append(max_correct_bracket_subsequence(subsequence))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    n = len(s)\n    dp = [[0] * 2 for _ in range(n + 1)]\n    stack = []\n    for i in range(n):\n        if s[i] == '(':\n            stack.append(i)\n        else:\n            if stack:\n                dp[stack[-1] + 1][0] += 2\n                dp[stack[-1] + 1][1] = dp[i][1]\n                stack.pop()\n            else:\n                dp[i + 1][1] = dp[i][1]\n    return dp[-1][0]\n\nresults = []\nfor l, r in queries:\n    subseq = s[l:r + 1]\n    results.append(max_correct_bracket_subsequence(subseq))\n\nfor result in results:\n    print(result)",
            "import sys\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef preprocess(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1 if s[i] == '(' else 0\n            elif s[i] == '(' and s[j] == ')' and dp[i + 1][j - 1] > 0:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp\n\ndef answer_queries(s, queries, dp):\n    results = []\n    for li, ri in queries:\n        results.append(dp[li - 1][ri - 1])\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Preprocess the string\ndp = preprocess(s)\n\n# Answer the queries\nresults = answer_queries(s, queries, dp)\n\n# Print the results\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\nresults = []\nfor li, ri in queries:\n    subsequence = s[li:ri + 1]\n    results.append(max_correct_bracket_subsequence(subsequence))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef query_max_correct_bracket_subsequence(s, l, r):\n    return max_correct_bracket_subsequence(s[l:r+1])\n\nresults = [query_max_correct_bracket_subsequence(s, l, r) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef query_max_correct_bracket_subsequence(s, l, r):\n    return max_correct_bracket_subsequence(s[l:r+1])\n\nresults = [query_max_correct_bracket_subsequence(s, l, r) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef query_max_correct_bracket_subsequence(s, l, r):\n    return max_correct_bracket_subsequence(s[l:r+1])\n\nresults = [query_max_correct_bracket_subsequence(s, l, r) for l, r in queries]\n\nfor result in results:\n    print(result)",
            "import sys\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef preprocess(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1 if s[i] == '(' else 0\n            else:\n                if s[i] == '(' and s[j] == ')' and dp[i + 1][j - 1] > 0:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp\n\ndef answer_queries(s, queries, dp):\n    results = []\n    for li, ri in queries:\n        results.append(dp[li - 1][ri - 1])\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\n# Preprocess the string\ndp = preprocess(s)\n\n# Answer the queries\nresults = answer_queries(s, queries, dp)\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nm = int(data[1])\nqueries = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n\ndef max_correct_bracket_subsequence(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif stack and stack[-1] == '(':\n            stack.pop()\n    return len(stack)\n\ndef query_max_correct_bracket_subsequence(s, l, r):\n    return max_correct_bracket_subsequence(s[l:r+1])\n\nresults = [query_max_correct_bracket_subsequence(s, l, r) for l, r in queries]\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Beautiful Pairs of Numbers",
        "question_content": "The sequence of integer pairs (a1, b1), (a2, b2), ..., (ak, bk) is beautiful, if the following statements are fulfilled:\n\n- 1 \u2264 a1 \u2264 b1 < a2 \u2264 b2 < ... < ak \u2264 bk \u2264 n, where n is a given positive integer;\n- all numbers b1 - a1, b2 - a2, ..., bk - ak are distinct.\n\nFor the given number n find the number of beautiful sequences of length k. As the answer can be rather large, print the remainder after dividing it by 1000000007 (109 + 7).\n\n\nInput Format\nThe first line contains integer t (1 \u2264 t \u2264 2\u00b7105) \u2014 the number of the test data.\n\nEach of the next t lines contains two integers n and k (1 \u2264 k \u2264 n \u2264 1000).\n\n\nOutput Format\nFor each test from the input print the answer to the problem modulo 1000000007 (109 + 7). Print the answers to the tests in the order in which the tests are given in the input.\n\n\nSample Input 1\n\n6\n1 1\n2 1\n2 2\n3 1\n3 2\n3 3\n\nSample Output 1\n\n1\n3\n0\n6\n2\n0\n\n\nNote\nIn the first test sample there is exactly one beautiful sequence: (1, 1).\n\nIn the second test sample, the following sequences are beautiful:\n\n- (1, 1);\n- (1, 2);\n- (2, 2).\n\nIn the fourth test sample, the following sequences are beautiful:\n\n- (1, 1);\n- (1, 2);\n- (1, 3);\n- (2, 2);\n- (2, 3);\n- (3, 3).\n\nIn the fifth test sample, the following sequences are beautiful:\n\n- (1, 1), (2, 3);\n- (1, 2), (3, 3).\n\nIn the third and sixth samples, there are no beautiful sequences.",
        "platform": "codeforces",
        "question_id": "403/D",
        "contest_id": "403",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][1] = i\n        for j in range(2, k + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * (i - 1)) % MOD\n    return dp[n][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        results.append(count_beautiful_sequences(n, k))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    k = int(data[index + 1])\n    index += 2\n    \n    if k == 1:\n        results.append(1)\n    elif k == n:\n        results.append(1)\n    else:\n        results.append(0)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    return comb(n, k) * comb(n - k, k - 1) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        results.append(count_beautiful_sequences(n, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][1] = i\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * (i - 1)) % MOD\n    return dp[n][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        results.append(count_beautiful_sequences(n, k))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    k = int(data[index + 1])\n    index += 2\n    \n    if k == 1:\n        results.append(n)\n    elif k == n:\n        results.append(1)\n    else:\n        results.append(0)\n\nfor result in results:\n    print(result % 1000000007)\n```",
            "```python\nimport sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * (i - 1)) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        results.append(count_beautiful_sequences(n, k))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k > n:\n        return 0\n    return comb(n - k + 1, k) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        results.append(count_beautiful_sequences(n, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * (i - 1)) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        results.append(count_beautiful_sequences(n, k))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * (i - 1)) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        result = count_beautiful_sequences(n, k)\n        results.append(result)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][1] = i\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * (i - 1)) % MOD\n    return dp[n][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        results.append(count_beautiful_sequences(n, k))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][1] = i\n        for j in range(2, k + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * (i - 1)) % MOD\n    return dp[n][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        results.append(count_beautiful_sequences(n, k))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    k = int(data[index + 1])\n    index += 2\n    \n    if k == 1:\n        results.append(1)\n    elif k == n:\n        results.append(1)\n    else:\n        results.append(0)\n\nfor result in results:\n    print(result)",
            "import sys\nfrom math import comb\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    return comb(n, k) * comb(n - k, k - 1) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        results.append(count_beautiful_sequences(n, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][1] = i\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * (i - 1)) % MOD\n    return dp[n][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        results.append(count_beautiful_sequences(n, k))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    k = int(data[index + 1])\n    index += 2\n    \n    if k == 1:\n        results.append(n)\n    elif k == n:\n        results.append(1)\n    else:\n        results.append(0)\n\nfor result in results:\n    print(result % 1000000007)",
            "import sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * (i - 1)) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        results.append(count_beautiful_sequences(n, k))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import comb\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k > n:\n        return 0\n    return comb(n - k + 1, k) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        results.append(count_beautiful_sequences(n, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * (i - 1)) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        results.append(count_beautiful_sequences(n, k))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * (i - 1)) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        k = int(data[index])\n        index += 1\n        result = count_beautiful_sequences(n, k)\n        results.append(result)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\nMOD = 1000000007\n\ndef count_beautiful_sequences(n, k):\n    if k == 1:\n        return n\n    if k > n:\n        return 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][1] = i\n    for i in range(2, n + 1):\n        for j in range(2, k + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * (i - 1)) % MOD\n    return dp[n][k]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        results.append(count_beautiful_sequences(n, k))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Sereja and Squares",
        "question_content": "Sereja has painted n distinct points on the plane. The coordinates of each point are integers. Now he is wondering: how many squares are there with sides parallel to the coordinate axes and with points painted in all its four vertexes? Help him, calculate this number.\n\n\nInput Format\nThe first line contains integer n (1 \u2264 n \u2264 105). Each of the next n lines contains two integers xi, yi (0 \u2264 xi, yi \u2264 105), the integers represent the coordinates of the i-th point. It is guaranteed that all the given points are distinct.\n\n\nOutput Format\nIn a single line print the required number of squares.\n\n\nSample Input 1\n\n5\n0 0\n0 2\n2 0\n2 2\n1 1\n\nSample Output 1\n\n1\n\n\nSample Input 2\n\n9\n0 0\n1 1\n2 2\n0 1\n1 0\n0 2\n2 0\n1 2\n2 1\n\nSample Output 2\n\n5",
        "platform": "codeforces",
        "question_id": "425/D",
        "contest_id": "425",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Count occurrences of each x and y coordinate\nx_count = defaultdict(int)\ny_count = defaultdict(int)\n\nfor x, y in points:\n    x_count[x] += 1\n    y_count[y] += 1\n\n# Calculate the number of squares\nsquares = 0\n\nfor x, count in x_count.items():\n    for y, count in y_count.items():\n        if count >= 2 and x_count[x] >= 2 and y_count[y] >= 2:\n            squares += (count - 1) * (x_count[x] - 1) * (count - 1) * (y_count[y] - 1)\n\n# Output the result\nprint(squares)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(list)\ny_points = defaultdict(list)\n\nfor x, y in points:\n    x_points[x].append(y)\n    y_points[y].append(x)\n\n# Function to count the number of squares with sides parallel to the coordinate axes\ndef count_squares(points):\n    count = 0\n    for x in x_points:\n        y_list = x_points[x]\n        y_list.sort()\n        for i in range(len(y_list)):\n            for j in range(i+1, len(y_list)):\n                dy = y_list[j] - y_list[i]\n                if y_list[j] + dy in y_list and y_list[i] - dy in y_list:\n                    count += 1\n    return count\n\n# Calculate the number of squares\nresult = count_squares(points)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(set)\ny_points = defaultdict(set)\n\n# Populate the dictionaries\nfor x, y in points:\n    x_points[x].add(y)\n    y_points[y].add(x)\n\n# Function to count squares\ndef count_squares():\n    count = 0\n    for x, ys in x_points.items():\n        for y in ys:\n            for y2 in ys:\n                if y2 == y:\n                    continue\n                if y2 - y in y_points[x]:\n                    if y + (y2 - y) in y_points[x]:\n                        count += 1\n    return count\n\n# Calculate and print the number of squares\nprint(count_squares())\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(list)\ny_points = defaultdict(list)\n\n# Populate dictionaries\nfor x, y in points:\n    x_points[x].append(y)\n    y_points[y].append(x)\n\n# Function to count squares\ndef count_squares(points, axis_points):\n    count = 0\n    for x in points:\n        for y in axis_points[x]:\n            if y in points and (x, y) in axis_points:\n                count += 1\n    return count // 4\n\n# Count squares with sides parallel to the x-axis\nsquares_x = count_squares(x_points, y_points)\n\n# Count squares with sides parallel to the y-axis\nsquares_y = count_squares(y_points, x_points)\n\n# Total number of squares\ntotal_squares = squares_x + squares_y\n\n# Output the result\nprint(total_squares)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# List to store points\npoints = []\n\n# Read points\nindex = 1\nfor _ in range(n):\n    x = int(data[index])\n    y = int(data[index + 1])\n    points.append((x, y))\n    index += 2\n\n# Dictionary to store points by their x and y coordinates\nx_dict = {}\ny_dict = {}\n\n# Populate dictionaries\nfor x, y in points:\n    if x not in x_dict:\n        x_dict[x] = []\n    x_dict[x].append(y)\n    if y not in y_dict:\n        y_dict[y] = []\n    y_dict[y].append(x)\n\n# Function to count squares\ndef count_squares(points):\n    count = 0\n    for x, y in points:\n        # Check for squares with side length 1\n        if (x + 1, y) in points and (x, y + 1) in points and (x + 1, y + 1) in points:\n            count += 1\n        # Check for squares with side length greater than 1\n        for dx in range(2, 100001):\n            if (x + dx, y) in points and (x, y + dx) in points and (x + dx, y + dx) in points:\n                count += 1\n            else:\n                break\n    return count\n\n# Count squares\nresult = count_squares(points)\n\n# Write output to stdout\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Coordinates of points\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(list)\ny_points = defaultdict(list)\n\n# Populate the dictionaries\nfor x, y in points:\n    x_points[x].append(y)\n    y_points[y].append(x)\n\n# Function to count the number of squares\ndef count_squares(points, axis_points):\n    count = 0\n    for point in points:\n        x, y = point\n        # Check for squares with side length 1\n        if (x+1 in axis_points and y+1 in axis_points[x+1]) and (x+1 in axis_points and y-1 in axis_points[x+1]):\n            count += 1\n        # Check for squares with side length 2\n        if (x+2 in axis_points and y+2 in axis_points[x+2]) and (x+2 in axis_points and y-2 in axis_points[x+2]):\n            count += 1\n        # Check for squares with side length 3\n        if (x+3 in axis_points and y+3 in axis_points[x+3]) and (x+3 in axis_points and y-3 in axis_points[x+3]):\n            count += 1\n    return count\n\n# Count squares with sides parallel to the x-axis\nsquares_x = count_squares(points, x_points)\n\n# Count squares with sides parallel to the y-axis\nsquares_y = count_squares(points, y_points)\n\n# Total number of squares\ntotal_squares = squares_x + squares_y\n\n# Output the result\nprint(total_squares)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Coordinates of points\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(set)\ny_points = defaultdict(set)\n\n# Populate the dictionaries\nfor x, y in points:\n    x_points[x].add(y)\n    y_points[y].add(x)\n\n# Function to count squares\ndef count_squares():\n    count = 0\n    for x, ys in x_points.items():\n        for y in ys:\n            # Check for points (x+dx, y+dx) and (x-dx, y-dx)\n            dx = 1\n            while x + dx <= 105 and x - dx >= 0:\n                if (x + dx, y + dx) in points and (x - dx, y - dx) in points:\n                    count += 1\n                dx += 1\n    return count\n\n# Output the result\nprint(count_squares())\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(set)\ny_points = defaultdict(set)\n\n# Populate the dictionaries\nfor x, y in points:\n    x_points[x].add(y)\n    y_points[y].add(x)\n\n# Function to count squares\ndef count_squares():\n    count = 0\n    for x, ys in x_points.items():\n        for y in ys:\n            # Check for points (x-d, y) and (x, y-d)\n            if y - 1 in ys and x - 1 in y_points[y - 1]:\n                count += 1\n    return count\n\n# Output the result\nprint(count_squares())\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Coordinates of points\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(list)\ny_points = defaultdict(list)\n\nfor x, y in points:\n    x_points[x].append(y)\n    y_points[y].append(x)\n\n# Function to count squares\ndef count_squares(points, axis_points):\n    count = 0\n    for x in points:\n        for y in axis_points[x]:\n            if y in axis_points and x in axis_points[y]:\n                count += 1\n    return count // 4\n\n# Count squares with sides parallel to the x-axis\nsquares_x = count_squares(x_points, y_points)\n\n# Count squares with sides parallel to the y-axis\nsquares_y = count_squares(y_points, x_points)\n\n# Total number of squares\ntotal_squares = squares_x + squares_y\n\n# Output the result\nprint(total_squares)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(set)\ny_points = defaultdict(set)\n\nfor x, y in points:\n    x_points[x].add(y)\n    y_points[y].add(x)\n\n# Function to count the number of squares\ndef count_squares():\n    count = 0\n    for x, ys in x_points.items():\n        for y in ys:\n            for x2 in x_points:\n                if x2 == x:\n                    continue\n                if y in y_points[x2]:\n                    y2 = y_points[x2].intersection(ys)\n                    if len(y2) > 0:\n                        count += len(y2)\n    return count // 4\n\n# Output the result\nprint(count_squares())\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Count occurrences of each x and y coordinate\nx_count = defaultdict(int)\ny_count = defaultdict(int)\n\nfor x, y in points:\n    x_count[x] += 1\n    y_count[y] += 1\n\n# Calculate the number of squares\nsquares = 0\n\nfor x, count in x_count.items():\n    for y, count in y_count.items():\n        if count >= 2 and x_count[x] >= 2 and y_count[y] >= 2:\n            squares += (count - 1) * (x_count[x] - 1) * (count - 1) * (y_count[y] - 1)\n\n# Output the result\nprint(squares)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(list)\ny_points = defaultdict(list)\n\nfor x, y in points:\n    x_points[x].append(y)\n    y_points[y].append(x)\n\n# Function to count the number of squares with sides parallel to the coordinate axes\ndef count_squares(points):\n    count = 0\n    for x in x_points:\n        y_list = x_points[x]\n        y_list.sort()\n        for i in range(len(y_list)):\n            for j in range(i+1, len(y_list)):\n                dy = y_list[j] - y_list[i]\n                if y_list[j] + dy in y_list and y_list[i] - dy in y_list:\n                    count += 1\n    return count\n\n# Calculate the number of squares\nresult = count_squares(points)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(set)\ny_points = defaultdict(set)\n\n# Populate the dictionaries\nfor x, y in points:\n    x_points[x].add(y)\n    y_points[y].add(x)\n\n# Function to count squares\ndef count_squares():\n    count = 0\n    for x, ys in x_points.items():\n        for y in ys:\n            for y2 in ys:\n                if y2 == y:\n                    continue\n                if y2 - y in y_points[x]:\n                    if y + (y2 - y) in y_points[x]:\n                        count += 1\n    return count\n\n# Calculate and print the number of squares\nprint(count_squares())",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(list)\ny_points = defaultdict(list)\n\n# Populate dictionaries\nfor x, y in points:\n    x_points[x].append(y)\n    y_points[y].append(x)\n\n# Function to count squares\ndef count_squares(points, axis_points):\n    count = 0\n    for x in points:\n        for y in axis_points[x]:\n            if y in points and (x, y) in axis_points:\n                count += 1\n    return count // 4\n\n# Count squares with sides parallel to the x-axis\nsquares_x = count_squares(x_points, y_points)\n\n# Count squares with sides parallel to the y-axis\nsquares_y = count_squares(y_points, x_points)\n\n# Total number of squares\ntotal_squares = squares_x + squares_y\n\n# Output the result\nprint(total_squares)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# List to store points\npoints = []\n\n# Read points\nindex = 1\nfor _ in range(n):\n    x = int(data[index])\n    y = int(data[index + 1])\n    points.append((x, y))\n    index += 2\n\n# Dictionary to store points by their x and y coordinates\nx_dict = {}\ny_dict = {}\n\n# Populate dictionaries\nfor x, y in points:\n    if x not in x_dict:\n        x_dict[x] = []\n    x_dict[x].append(y)\n    if y not in y_dict:\n        y_dict[y] = []\n    y_dict[y].append(x)\n\n# Function to count squares\ndef count_squares(points):\n    count = 0\n    for x, y in points:\n        # Check for squares with side length 1\n        if (x + 1, y) in points and (x, y + 1) in points and (x + 1, y + 1) in points:\n            count += 1\n        # Check for squares with side length greater than 1\n        for dx in range(2, 100001):\n            if (x + dx, y) in points and (x, y + dx) in points and (x + dx, y + dx) in points:\n                count += 1\n            else:\n                break\n    return count\n\n# Count squares\nresult = count_squares(points)\n\n# Write output to stdout\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Coordinates of points\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(list)\ny_points = defaultdict(list)\n\n# Populate the dictionaries\nfor x, y in points:\n    x_points[x].append(y)\n    y_points[y].append(x)\n\n# Function to count the number of squares\ndef count_squares(points, axis_points):\n    count = 0\n    for point in points:\n        x, y = point\n        # Check for squares with side length 1\n        if (x+1 in axis_points and y+1 in axis_points[x+1]) and (x+1 in axis_points and y-1 in axis_points[x+1]):\n            count += 1\n        # Check for squares with side length 2\n        if (x+2 in axis_points and y+2 in axis_points[x+2]) and (x+2 in axis_points and y-2 in axis_points[x+2]):\n            count += 1\n        # Check for squares with side length 3\n        if (x+3 in axis_points and y+3 in axis_points[x+3]) and (x+3 in axis_points and y-3 in axis_points[x+3]):\n            count += 1\n    return count\n\n# Count squares with sides parallel to the x-axis\nsquares_x = count_squares(points, x_points)\n\n# Count squares with sides parallel to the y-axis\nsquares_y = count_squares(points, y_points)\n\n# Total number of squares\ntotal_squares = squares_x + squares_y\n\n# Output the result\nprint(total_squares)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Coordinates of points\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(set)\ny_points = defaultdict(set)\n\n# Populate the dictionaries\nfor x, y in points:\n    x_points[x].add(y)\n    y_points[y].add(x)\n\n# Function to count squares\ndef count_squares():\n    count = 0\n    for x, ys in x_points.items():\n        for y in ys:\n            # Check for points (x+dx, y+dx) and (x-dx, y-dx)\n            dx = 1\n            while x + dx <= 105 and x - dx >= 0:\n                if (x + dx, y + dx) in points and (x - dx, y - dx) in points:\n                    count += 1\n                dx += 1\n    return count\n\n# Output the result\nprint(count_squares())",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(set)\ny_points = defaultdict(set)\n\n# Populate the dictionaries\nfor x, y in points:\n    x_points[x].add(y)\n    y_points[y].add(x)\n\n# Function to count squares\ndef count_squares():\n    count = 0\n    for x, ys in x_points.items():\n        for y in ys:\n            # Check for points (x-d, y) and (x, y-d)\n            if y - 1 in ys and x - 1 in y_points[y - 1]:\n                count += 1\n    return count\n\n# Output the result\nprint(count_squares())",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Coordinates of points\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(list)\ny_points = defaultdict(list)\n\nfor x, y in points:\n    x_points[x].append(y)\n    y_points[y].append(x)\n\n# Function to count squares\ndef count_squares(points, axis_points):\n    count = 0\n    for x in points:\n        for y in axis_points[x]:\n            if y in axis_points and x in axis_points[y]:\n                count += 1\n    return count // 4\n\n# Count squares with sides parallel to the x-axis\nsquares_x = count_squares(x_points, y_points)\n\n# Count squares with sides parallel to the y-axis\nsquares_y = count_squares(y_points, x_points)\n\n# Total number of squares\ntotal_squares = squares_x + squares_y\n\n# Output the result\nprint(total_squares)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Dictionary to store points by their x and y coordinates\nx_points = defaultdict(set)\ny_points = defaultdict(set)\n\nfor x, y in points:\n    x_points[x].add(y)\n    y_points[y].add(x)\n\n# Function to count the number of squares\ndef count_squares():\n    count = 0\n    for x, ys in x_points.items():\n        for y in ys:\n            for x2 in x_points:\n                if x2 == x:\n                    continue\n                if y in y_points[x2]:\n                    y2 = y_points[x2].intersection(ys)\n                    if len(y2) > 0:\n                        count += len(y2)\n    return count // 4\n\n# Output the result\nprint(count_squares())"
        ]
    },
    {
        "question_title": "Jzzhu and Numbers",
        "question_content": "Jzzhu have n non-negative integers a1, a2, ..., an. We will call a sequence of indexes i1, i2, ..., ik (1 \u2264 i1 < i2 < ... < ik \u2264 n) a group of size k.\n\nJzzhu wonders, how many groups exists such that ai1 & ai2 & ... & aik = 0 (1 \u2264 k \u2264 n)? Help him and print this number modulo 1000000007 (109 + 7). Operation x & y denotes bitwise AND operation of two numbers.\n\n\nInput Format\nThe first line contains a single integer n (1 \u2264 n \u2264 106). The second line contains n integers a1, a2, ..., an (0 \u2264 ai \u2264 106).\n\n\nOutput Format\nOutput a single integer representing the number of required groups modulo 1000000007 (109 + 7).\n\n\nSample Input 1\n\n3\n2 3 3\n\nSample Output 1\n\n0\n\n\nSample Input 2\n\n4\n0 1 2 3\n\nSample Output 2\n\n10\n\n\nSample Input 3\n\n6\n5 2 0 5 2 1\n\nSample Output 3\n\n53",
        "platform": "codeforces",
        "question_id": "449/D",
        "contest_id": "449",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = defaultdict(int)\n    count[0] = 1\n    total = 0\n    \n    for num in a:\n        new_count = defaultdict(int)\n        for mask, cnt in count.items():\n            new_count[mask & num] += cnt\n        new_count[num] += 1\n        total = (total + sum(new_count.values()) - 1) % MOD\n        count = new_count\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = defaultdict(int)\n    count[0] = 1\n    total = 0\n    \n    for num in a:\n        new_count = defaultdict(int)\n        for key in count:\n            new_key = key & num\n            new_count[new_key] = (new_count[new_key] + count[key]) % MOD\n        new_count[num] = (new_count[num] + 1) % MOD\n        total = (total + new_count[0]) % MOD\n        count = new_count\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = [0] * 20\n    for num in a:\n        for i in range(20):\n            if (num >> i) & 1 == 0:\n                count[i] += 1\n    result = 0\n    for i in range(20):\n        result = (result + count[i]) % MOD\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nMOD = 1000000007\n\ndef count_groups(n, a):\n    from collections import defaultdict\n    \n    # Dictionary to store the count of numbers with a given prefix\n    prefix_count = defaultdict(int)\n    prefix_count[0] = 1\n    \n    total_groups = 0\n    current_prefix = 0\n    \n    for num in a:\n        # Update the current prefix by performing bitwise AND with the number\n        current_prefix &= num\n        \n        # Add the count of groups that can be formed with the current prefix\n        total_groups = (total_groups + prefix_count[current_prefix]) % MOD\n        \n        # Update the count of numbers with the current prefix\n        prefix_count[current_prefix] += 1\n    \n    return total_groups\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_groups(n, a)\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = defaultdict(int)\n    count[0] = 1\n    total = 0\n    \n    for num in a:\n        new_count = defaultdict(int)\n        for key in count:\n            new_key = key & num\n            new_count[new_key] = (new_count[new_key] + count[key]) % MOD\n        new_count[num] = (new_count[num] + 1) % MOD\n        total = (total + new_count[0]) % MOD\n        count = new_count\n    \n    return total\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = defaultdict(int)\n    count[0] = 1\n    total = 0\n    \n    for num in a:\n        new_count = defaultdict(int)\n        for key in count:\n            new_key = key & num\n            new_count[new_key] = (new_count[new_key] + count[key]) % MOD\n        new_count[num] = (new_count[num] + 1) % MOD\n        total = (total + new_count[0]) % MOD\n        count = new_count\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = [0] * 20\n    for num in a:\n        for i in range(20):\n            if (num >> i) & 1:\n                count[i] += 1\n            else:\n                count[i] = 0\n    result = 0\n    for i in range(20):\n        result = (result + count[i]) % MOD\n    return result\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    print(count_groups(n, a))\n```",
            "```python\nimport sys\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = [0] * 20\n    for num in a:\n        for i in range(20):\n            if (num >> i) & 1:\n                count[i] += 1\n            else:\n                count[i] = 0\n    result = 0\n    for i in range(20):\n        result = (result + count[i]) % MOD\n    return result\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    print(count_groups(n, a))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 1000000007\n\n# Count the number of groups\ncount = 0\nfor i in range(n):\n    current_and = a[i]\n    for j in range(i, n):\n        current_and &= a[j]\n        if current_and == 0:\n            count += 1\n\n# Output the result modulo 1000000007\nprint(count % MOD)\n```",
            "```python\nimport sys\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = [0] * 20\n    for num in a:\n        for i in range(20):\n            if (num >> i) & 1 == 0:\n                count[i] += 1\n    result = 0\n    for i in range(20):\n        result = (result + count[i]) % MOD\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Write output\nprint(result)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = defaultdict(int)\n    count[0] = 1\n    total = 0\n    \n    for num in a:\n        new_count = defaultdict(int)\n        for mask, cnt in count.items():\n            new_count[mask & num] += cnt\n        new_count[num] += 1\n        total = (total + sum(new_count.values()) - 1) % MOD\n        count = new_count\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = defaultdict(int)\n    count[0] = 1\n    total = 0\n    \n    for num in a:\n        new_count = defaultdict(int)\n        for key in count:\n            new_key = key & num\n            new_count[new_key] = (new_count[new_key] + count[key]) % MOD\n        new_count[num] = (new_count[num] + 1) % MOD\n        total = (total + new_count[0]) % MOD\n        count = new_count\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Write output\nprint(result)",
            "import sys\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = [0] * 20\n    for num in a:\n        for i in range(20):\n            if (num >> i) & 1 == 0:\n                count[i] += 1\n    result = 0\n    for i in range(20):\n        result = (result + count[i]) % MOD\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Write output\nprint(result)",
            "MOD = 1000000007\n\ndef count_groups(n, a):\n    from collections import defaultdict\n    \n    # Dictionary to store the count of numbers with a given prefix\n    prefix_count = defaultdict(int)\n    prefix_count[0] = 1\n    \n    total_groups = 0\n    current_prefix = 0\n    \n    for num in a:\n        # Update the current prefix by performing bitwise AND with the number\n        current_prefix &= num\n        \n        # Add the count of groups that can be formed with the current prefix\n        total_groups = (total_groups + prefix_count[current_prefix]) % MOD\n        \n        # Update the count of numbers with the current prefix\n        prefix_count[current_prefix] += 1\n    \n    return total_groups\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_groups(n, a)\nprint(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = defaultdict(int)\n    count[0] = 1\n    total = 0\n    \n    for num in a:\n        new_count = defaultdict(int)\n        for key in count:\n            new_key = key & num\n            new_count[new_key] = (new_count[new_key] + count[key]) % MOD\n        new_count[num] = (new_count[num] + 1) % MOD\n        total = (total + new_count[0]) % MOD\n        count = new_count\n    \n    return total\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Write output\nprint(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = defaultdict(int)\n    count[0] = 1\n    total = 0\n    \n    for num in a:\n        new_count = defaultdict(int)\n        for key in count:\n            new_key = key & num\n            new_count[new_key] = (new_count[new_key] + count[key]) % MOD\n        new_count[num] = (new_count[num] + 1) % MOD\n        total = (total + new_count[0]) % MOD\n        count = new_count\n    \n    return total\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Write output\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = [0] * 20\n    for num in a:\n        for i in range(20):\n            if (num >> i) & 1:\n                count[i] += 1\n            else:\n                count[i] = 0\n    result = 0\n    for i in range(20):\n        result = (result + count[i]) % MOD\n    return result\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    print(count_groups(n, a))",
            "import sys\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = [0] * 20\n    for num in a:\n        for i in range(20):\n            if (num >> i) & 1:\n                count[i] += 1\n            else:\n                count[i] = 0\n    result = 0\n    for i in range(20):\n        result = (result + count[i]) % MOD\n    return result\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    print(count_groups(n, a))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nMOD = 1000000007\n\n# Count the number of groups\ncount = 0\nfor i in range(n):\n    current_and = a[i]\n    for j in range(i, n):\n        current_and &= a[j]\n        if current_and == 0:\n            count += 1\n\n# Output the result modulo 1000000007\nprint(count % MOD)",
            "import sys\n\nMOD = 1000000007\n\ndef count_groups(n, a):\n    count = [0] * 20\n    for num in a:\n        for i in range(20):\n            if (num >> i) & 1 == 0:\n                count[i] += 1\n    result = 0\n    for i in range(20):\n        result = (result + count[i]) % MOD\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = count_groups(n, a)\n\n# Write output\nprint(result)"
        ]
    },
    {
        "question_title": "Count Good Substrings",
        "question_content": "We call a string good, if after merging all the consecutive equal characters, the resulting string is palindrome. For example, \"aabba\" is good, because after the merging step it will become \"aba\".\n\nGiven a string, you have to find two values:\n\n1. the number of good substrings of even length;\n2. the number of good substrings of odd length.\n\n\nInput Format\nThe first line of the input contains a single string of length n (1 \u2264 n \u2264 105). Each character of the string will be either 'a' or 'b'.\n\n\nOutput Format\nPrint two space-separated integers: the number of good substrings of even length and the number of good substrings of odd length.\n\n\nSample Input 1\n\nbb\n\nSample Output 1\n\n1 2\n\n\nSample Input 2\n\nbaab\n\nSample Output 2\n\n2 4\n\n\nSample Input 3\n\nbabb\n\nSample Output 3\n\n2 5\n\n\nSample Input 4\n\nbabaa\n\nSample Output 4\n\n2 7\n\n\nNote\nIn example 1, there are three good substrings (\"b\", \"b\", and \"bb\"). One of them has even length and two of them have odd length.\n\nIn example 2, there are six good substrings (i.e. \"b\", \"a\", \"a\", \"b\", \"aa\", \"baab\"). Two of them have even length and four of them have odd length.\n\nIn example 3, there are seven good substrings (i.e. \"b\", \"a\", \"b\", \"b\", \"bb\", \"bab\", \"babb\"). Two of them have even length and five of them have odd length.\n\nDefinitions\n\nA substring s[l, r] (1 \u2264 l \u2264 r \u2264 n) of string s = s1s2... sn is string slsl + 1... sr.\n\nA string s = s1s2... sn is a palindrome if it is equal to string snsn - 1... s1.",
        "platform": "codeforces",
        "question_id": "451/D",
        "contest_id": "451",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length // 2) + 1\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Call the function with the input string\ncount_good_substrings(input_string)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        count = 1\n        while i + 1 < n and s[i] == s[i + 1]:\n            i += 1\n            count += 1\n        if count % 2 == 0:\n            even_count += count // 2\n        else:\n            odd_count += (count + 1) // 2\n        i += 1\n    \n    return even_count, odd_count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nfor s in data:\n    even, odd = count_good_substrings(s)\n    print(even, odd)\n```",
            "```python\nimport sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length // 2) + 1\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)\n```",
            "```python\nimport sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length + 1) // 2\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Call the function with the input string\ncount_good_substrings(input_string)\n```",
            "```python\nimport sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length // 2) + 1\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)\n```",
            "```python\nimport sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length + 1) // 2\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)\n```",
            "```python\nimport sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length // 2) + 1\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    i = 0\n    while i < n:\n        j = i\n        while j < n and s[j] == s[i]:\n            j += 1\n        length = j - i\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length // 2) + 1\n        i = j\n    return even_count, odd_count\n\neven_count, odd_count = count_good_substrings(s)\nprint(even_count, odd_count)\n```",
            "```python\nimport sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length + 1) // 2\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)\n```",
            "```python\nimport sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length + 1) // 2\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)\n```"
        ],
        "code_list": [
            "import sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length // 2) + 1\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Call the function with the input string\ncount_good_substrings(input_string)",
            "# YOUR CODE HERE\nimport sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        count = 1\n        while i + 1 < n and s[i] == s[i + 1]:\n            i += 1\n            count += 1\n        if count % 2 == 0:\n            even_count += count // 2\n        else:\n            odd_count += (count + 1) // 2\n        i += 1\n    \n    return even_count, odd_count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Process each test case\nfor s in data:\n    even, odd = count_good_substrings(s)\n    print(even, odd)",
            "import sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length // 2) + 1\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)",
            "import sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length + 1) // 2\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput_string = sys.stdin.read().strip()\n\n# Call the function with the input string\ncount_good_substrings(input_string)",
            "import sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length // 2) + 1\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)",
            "import sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length + 1) // 2\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)",
            "import sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length // 2) + 1\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    i = 0\n    while i < n:\n        j = i\n        while j < n and s[j] == s[i]:\n            j += 1\n        length = j - i\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length // 2) + 1\n        i = j\n    return even_count, odd_count\n\neven_count, odd_count = count_good_substrings(s)\nprint(even_count, odd_count)",
            "import sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length + 1) // 2\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)",
            "import sys\n\ndef count_good_substrings(s):\n    n = len(s)\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(n):\n        length = 1\n        while i + length < n and s[i + length] == s[i]:\n            length += 1\n        if length % 2 == 0:\n            even_count += length // 2\n        else:\n            odd_count += (length + 1) // 2\n        i += length - 1\n    \n    print(even_count, odd_count)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\n# Call the function with the input string\ncount_good_substrings(s)"
        ]
    },
    {
        "question_title": "Three strings",
        "question_content": "You are given three strings (s1, s2, s3). For each integer l (1 \u2264 l \u2264 min(|s1|, |s2|, |s3|) you need to find how many triples (i1, i2, i3) exist such that three strings sk[ik... ik + l - 1] (k = 1, 2, 3) are pairwise equal. Print all found numbers modulo 1000000007\u00a0(109 + 7).\n\nSee notes if you are not sure about some of the denotions used in the statement.\n\n\nInput Format\nFirst three lines contain three non-empty input strings. The sum of lengths of all strings is no more than 3\u00b7105. All strings consist only of lowercase English letters.\n\n\nOutput Format\nYou need to output min(|s1|, |s2|, |s3|) numbers separated by spaces \u2014 answers for the problem modulo 1000000007\u00a0(109 + 7).\n\n\nSample Input 1\n\nabc\nbc\ncbc\n\nSample Output 1\n\n3 1\n\n\nSample Input 2\n\nabacaba\nabac\nabcd\n\nSample Output 2\n\n11 2 0 0\n\n\nNote\nConsider a string t = t1t2... t|t|, where ti denotes the i-th character of the string, and |t| denotes the length of the string.\n\nThen t[i... j] (1 \u2264 i \u2264 j \u2264 |t|) represents the string titi + 1... tj (substring of t from position i to position j inclusive).",
        "platform": "codeforces",
        "question_id": "452/E",
        "contest_id": "452",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\ndef count_common_substrings(s1, s2, s3):\n    MOD = 1000000007\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n\n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            for j in range(len(s2) - l + 1):\n                for k in range(len(s3) - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        for key, value in count.items():\n            result[l-1] = (result[l-1] + value) % MOD\n\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\ns1 = data[0]\ns2 = data[1]\ns3 = data[2]\n\n# Calculate and print the result\nresult = count_common_substrings(s1, s2, s3)\nprint(' '.join(map(str, result)))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    n1, n2, n3 = len(s1), len(s2), len(s3)\n    min_len = min(n1, n2, n3)\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(n1 - l + 1):\n            for j in range(n2 - l + 1):\n                for k in range(n3 - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        for key, value in count.items():\n            result[l-1] = (result[l-1] + value) % MOD\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_equal_substrings(s1, s2, s3):\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            for j in range(len(s2) - l + 1):\n                for k in range(len(s3) - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        result[l-1] = sum(count.values()) % MOD\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_equal_substrings(s1, s2, s3)\n\n# Print the result\nprint(\" \".join(map(str, result)))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            for j in range(len(s2) - l + 1):\n                for k in range(len(s3) - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        \n        for key in count:\n            result[l-1] = (result[l-1] + count[key]) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\ns1 = data[0]\ns2 = data[1]\ns3 = data[2]\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            substring = s1[i:i+l]\n            count[substring] += 1\n        \n        for i in range(len(s2) - l + 1):\n            substring = s2[i:i+l]\n            if substring in count:\n                count[substring] -= 1\n                if count[substring] == 0:\n                    del count[substring]\n        \n        for i in range(len(s3) - l + 1):\n            substring = s3[i:i+l]\n            if substring in count:\n                count[substring] -= 1\n                if count[substring] == 0:\n                    del count[substring]\n        \n        result[l-1] = len(count)\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(\" \".join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            for j in range(len(s2) - l + 1):\n                for k in range(len(s3) - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        \n        for key, value in count.items():\n            result[l-1] = (result[l-1] + value) % MOD\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(\" \".join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    n1, n2, n3 = len(s1), len(s2), len(s3)\n    min_len = min(n1, n2, n3)\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(n1 - l + 1):\n            for j in range(n2 - l + 1):\n                for k in range(n3 - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        for key, value in count.items():\n            result[l-1] = (result[l-1] + value) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\ns1, s2, s3 = data[0], data[1], data[2]\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    n1, n2, n3 = len(s1), len(s2), len(s3)\n    min_len = min(n1, n2, n3)\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(n1 - l + 1):\n            for j in range(n2 - l + 1):\n                for k in range(n3 - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        result[l-1] = sum(count.values()) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\ns1, s2, s3 = data[0], data[1], data[2]\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            substring = s1[i:i+l]\n            count[substring] += 1\n        for i in range(len(s2) - l + 1):\n            substring = s2[i:i+l]\n            if substring in count:\n                count[substring] -= 1\n        for i in range(len(s3) - l + 1):\n            substring = s3[i:i+l]\n            if substring in count:\n                count[substring] -= 1\n        for key in count:\n            if count[key] == 0:\n                result[l-1] += 1\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    n1, n2, n3 = len(s1), len(s2), len(s3)\n    min_len = min(n1, n2, n3)\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(n1 - l + 1):\n            for j in range(n2 - l + 1):\n                for k in range(n3 - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        for key in count:\n            result[l-1] = (result[l-1] + count[key]) % MOD\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\ndef count_common_substrings(s1, s2, s3):\n    MOD = 1000000007\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n\n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            for j in range(len(s2) - l + 1):\n                for k in range(len(s3) - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        for key, value in count.items():\n            result[l-1] = (result[l-1] + value) % MOD\n\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\ns1 = data[0]\ns2 = data[1]\ns3 = data[2]\n\n# Calculate and print the result\nresult = count_common_substrings(s1, s2, s3)\nprint(' '.join(map(str, result)))",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    n1, n2, n3 = len(s1), len(s2), len(s3)\n    min_len = min(n1, n2, n3)\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(n1 - l + 1):\n            for j in range(n2 - l + 1):\n                for k in range(n3 - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        for key, value in count.items():\n            result[l-1] = (result[l-1] + value) % MOD\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_equal_substrings(s1, s2, s3):\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            for j in range(len(s2) - l + 1):\n                for k in range(len(s3) - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        result[l-1] = sum(count.values()) % MOD\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_equal_substrings(s1, s2, s3)\n\n# Print the result\nprint(\" \".join(map(str, result)))",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            for j in range(len(s2) - l + 1):\n                for k in range(len(s3) - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        \n        for key in count:\n            result[l-1] = (result[l-1] + count[key]) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\ns1 = data[0]\ns2 = data[1]\ns3 = data[2]\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            substring = s1[i:i+l]\n            count[substring] += 1\n        \n        for i in range(len(s2) - l + 1):\n            substring = s2[i:i+l]\n            if substring in count:\n                count[substring] -= 1\n                if count[substring] == 0:\n                    del count[substring]\n        \n        for i in range(len(s3) - l + 1):\n            substring = s3[i:i+l]\n            if substring in count:\n                count[substring] -= 1\n                if count[substring] == 0:\n                    del count[substring]\n        \n        result[l-1] = len(count)\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(\" \".join(map(str, result)))",
            "import sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            for j in range(len(s2) - l + 1):\n                for k in range(len(s3) - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        \n        for key, value in count.items():\n            result[l-1] = (result[l-1] + value) % MOD\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(\" \".join(map(str, result)))",
            "import sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    n1, n2, n3 = len(s1), len(s2), len(s3)\n    min_len = min(n1, n2, n3)\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(n1 - l + 1):\n            for j in range(n2 - l + 1):\n                for k in range(n3 - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        for key, value in count.items():\n            result[l-1] = (result[l-1] + value) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\ns1, s2, s3 = data[0], data[1], data[2]\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))",
            "import sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    n1, n2, n3 = len(s1), len(s2), len(s3)\n    min_len = min(n1, n2, n3)\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(n1 - l + 1):\n            for j in range(n2 - l + 1):\n                for k in range(n3 - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        result[l-1] = sum(count.values()) % MOD\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\ns1, s2, s3 = data[0], data[1], data[2]\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    min_len = min(len(s1), len(s2), len(s3))\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(len(s1) - l + 1):\n            substring = s1[i:i+l]\n            count[substring] += 1\n        for i in range(len(s2) - l + 1):\n            substring = s2[i:i+l]\n            if substring in count:\n                count[substring] -= 1\n        for i in range(len(s3) - l + 1):\n            substring = s3[i:i+l]\n            if substring in count:\n                count[substring] -= 1\n        for key in count:\n            if count[key] == 0:\n                result[l-1] += 1\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 1000000007\n\ndef count_common_substrings(s1, s2, s3):\n    n1, n2, n3 = len(s1), len(s2), len(s3)\n    min_len = min(n1, n2, n3)\n    result = [0] * min_len\n    \n    for l in range(1, min_len + 1):\n        count = defaultdict(int)\n        for i in range(n1 - l + 1):\n            for j in range(n2 - l + 1):\n                for k in range(n3 - l + 1):\n                    if s1[i:i+l] == s2[j:j+l] == s3[k:k+l]:\n                        count[(s1[i:i+l], s2[j:j+l], s3[k:k+l])] += 1\n        for key in count:\n            result[l-1] = (result[l-1] + count[key]) % MOD\n    \n    return result\n\n# Read input\ns1 = sys.stdin.readline().strip()\ns2 = sys.stdin.readline().strip()\ns3 = sys.stdin.readline().strip()\n\n# Get the result\nresult = count_common_substrings(s1, s2, s3)\n\n# Print the result\nprint(' '.join(map(str, result)))"
        ]
    },
    {
        "question_title": "Function",
        "question_content": "Serega and Fedor play with functions. One day they came across a very interesting function. It looks like that:\n\n- f(1, j) = a[j], 1 \u2264 j \u2264 n.\n- f(i, j) = min(f(i - 1, j), f(i - 1, j - 1)) + a[j], 2 \u2264 i \u2264 n, i \u2264 j \u2264 n.\n\nHere a is an integer array of length n.\n\nSerega and Fedya want to know what values this function takes at some points. But they don't want to calculate the values manually. So they ask you to help them.\n\n\nInput Format\nThe first line contains integer n (1 \u2264 n \u2264 105) \u2014 the length of array a. The next line contains n integers: a[1], a[2], ..., a[n] (0 \u2264 a[i] \u2264 104).\n\nThe next line contains integer m (1 \u2264 m \u2264 105) \u2014 the number of queries. Each of the next m lines contains two integers: xi, yi (1 \u2264 xi \u2264 yi \u2264 n). Each line means that Fedor and Serega want to know the value of f(xi, yi).\n\n\nOutput Format\nPrint m lines \u2014 the answers to the guys' queries.\n\n\nSample Input 1\n\n6\n2 2 3 4 3 4\n4\n4 5\n3 4\n3 4\n2 3\n\nSample Output 1\n\n12\n9\n9\n5\n\n\nSample Input 2\n\n7\n1 3 2 3 4 0 2\n4\n4 5\n2 3\n1 4\n4 6\n\nSample Output 2\n\n11\n4\n3\n0",
        "platform": "codeforces",
        "question_id": "455/E",
        "contest_id": "455",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(m)]\n\n# Initialize the dp array\ndp = [[0] * (n + 1) for _ in range(n + 1)]\n\n# Fill the dp array\nfor i in range(1, n + 1):\n    dp[i][1] = a[0]\n    for j in range(2, i + 1):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j-1]\n\n# Answer the queries\nresults = []\nfor xi, yi in queries:\n    results.append(dp[yi][xi])\n\n# Write the results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+2+2*i+1])-1) for i in range(m)]\n\ndp = [[0] * n for _ in range(n)]\nfor j in range(n):\n    dp[0][j] = a[j]\n\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\nfor x, y in queries:\n    print(dp[x][y])\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(m)]\n\n# Initialize the dp array\ndp = [[0] * (n + 1) for _ in range(n + 1)]\n\n# Fill the dp array\nfor i in range(1, n + 1):\n    dp[i][1] = a[i-1]\n    for j in range(2, i + 1):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j-1]\n\n# Answer the queries\nresults = []\nfor xi, yi in queries:\n    results.append(dp[yi][xi])\n\n# Print the results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\ndp = [[0] * (n+1) for _ in range(n+1)]\n\nfor i in range(1, n+1):\n    dp[i][1] = a[i-1]\n\nfor i in range(2, n+1):\n    for j in range(i, n+1):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j-1]\n\nfor x, y in queries:\n    print(dp[y][x])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\ndp = [[0] * n for _ in range(n)]\nfor j in range(n):\n    dp[0][j] = a[j]\n\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\nfor x, y in queries:\n    print(dp[y][x])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+2+2*i+1])-1) for i in range(m)]\n\ndp = [[0] * n for _ in range(n)]\nfor j in range(n):\n    dp[0][j] = a[j]\n\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\nfor x, y in queries:\n    print(dp[x][y])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\ndp = [[0] * n for _ in range(n)]\nfor j in range(n):\n    dp[0][j] = a[j]\n\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\nfor x, y in queries:\n    print(dp[y][x])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\ndp = [[0] * (n+1) for _ in range(n+1)]\n\nfor i in range(1, n+1):\n    dp[i][1] = a[i-1]\n\nfor i in range(2, n+1):\n    for j in range(i, n+1):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j-1]\n\nfor x, y in queries:\n    print(dp[y][x])\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\n# Initialize the DP table\ndp = [[0] * n for _ in range(n)]\n\n# Fill the DP table\nfor i in range(n):\n    dp[0][i] = a[i]\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\n# Process the queries\nresults = []\nfor x, y in queries:\n    results.append(dp[y][x])\n\n# Print the results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\ndp = [[0] * n for _ in range(n)]\nfor j in range(n):\n    dp[0][j] = a[j]\n\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\nfor x, y in queries:\n    print(dp[y][x])\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(m)]\n\n# Initialize the dp array\ndp = [[0] * (n + 1) for _ in range(n + 1)]\n\n# Fill the dp array\nfor i in range(1, n + 1):\n    dp[i][1] = a[0]\n    for j in range(2, i + 1):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j-1]\n\n# Answer the queries\nresults = []\nfor xi, yi in queries:\n    results.append(dp[yi][xi])\n\n# Write the results to stdout\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+2+2*i+1])-1) for i in range(m)]\n\ndp = [[0] * n for _ in range(n)]\nfor j in range(n):\n    dp[0][j] = a[j]\n\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\nfor x, y in queries:\n    print(dp[x][y])",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(m)]\n\n# Initialize the dp array\ndp = [[0] * (n + 1) for _ in range(n + 1)]\n\n# Fill the dp array\nfor i in range(1, n + 1):\n    dp[i][1] = a[i-1]\n    for j in range(2, i + 1):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j-1]\n\n# Answer the queries\nresults = []\nfor xi, yi in queries:\n    results.append(dp[yi][xi])\n\n# Print the results\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\ndp = [[0] * (n+1) for _ in range(n+1)]\n\nfor i in range(1, n+1):\n    dp[i][1] = a[i-1]\n\nfor i in range(2, n+1):\n    for j in range(i, n+1):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j-1]\n\nfor x, y in queries:\n    print(dp[y][x])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\ndp = [[0] * n for _ in range(n)]\nfor j in range(n):\n    dp[0][j] = a[j]\n\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\nfor x, y in queries:\n    print(dp[y][x])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+2+2*i+1])-1) for i in range(m)]\n\ndp = [[0] * n for _ in range(n)]\nfor j in range(n):\n    dp[0][j] = a[j]\n\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\nfor x, y in queries:\n    print(dp[x][y])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\ndp = [[0] * n for _ in range(n)]\nfor j in range(n):\n    dp[0][j] = a[j]\n\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\nfor x, y in queries:\n    print(dp[y][x])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\ndp = [[0] * (n+1) for _ in range(n+1)]\n\nfor i in range(1, n+1):\n    dp[i][1] = a[i-1]\n\nfor i in range(2, n+1):\n    for j in range(i, n+1):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j-1]\n\nfor x, y in queries:\n    print(dp[y][x])",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\n# Initialize the DP table\ndp = [[0] * n for _ in range(n)]\n\n# Fill the DP table\nfor i in range(n):\n    dp[0][i] = a[i]\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\n# Process the queries\nresults = []\nfor x, y in queries:\n    results.append(dp[y][x])\n\n# Print the results\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nqueries = [(int(data[n+2+2*i])-1, int(data[n+3+2*i])-1) for i in range(m)]\n\ndp = [[0] * n for _ in range(n)]\nfor j in range(n):\n    dp[0][j] = a[j]\n\nfor i in range(1, n):\n    for j in range(i, n):\n        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + a[j]\n\nfor x, y in queries:\n    print(dp[y][x])"
        ]
    },
    {
        "question_title": "Elections",
        "question_content": "You are running for a governor in a small city in Russia. You ran some polls and did some research, and for every person in the city you know whom he will vote for, and how much it will cost to bribe that person to vote for you instead of whomever he wants to vote for right now. You are curious, what is the smallest amount of money you need to spend on bribing to win the elections. To win elections you need to have strictly more votes than any other candidate.\n\n\nInput Format\nFirst line contains one integer n (1 \u2264 n \u2264 105) \u2014 number of voters in the city. Each of the next n lines describes one voter and contains two integers ai and bi (0 \u2264 ai \u2264 105;\u00a00 \u2264 bi \u2264 104) \u2014 number of the candidate that voter is going to vote for and amount of money you need to pay him to change his mind. You are the candidate 0 (so if a voter wants to vote for you, ai is equal to zero, in which case bi will also be equal to zero).\n\n\nOutput Format\nPrint one integer \u2014 smallest amount of money you need to spend to win the elections.\n\n\nSample Input 1\n\n5\n1 2\n1 2\n1 2\n2 1\n0 0\n\nSample Output 1\n\n3\n\n\nSample Input 2\n\n4\n1 2\n1 2\n2 1\n0 0\n\nSample Output 2\n\n2\n\n\nSample Input 3\n\n1\n100000 0\n\nSample Output 3\n\n0",
        "platform": "codeforces",
        "question_id": "457/C",
        "contest_id": "457",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of voters\nn = int(data[0])\n\n# Initialize variables\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\n# Read voter data\nindex = 1\nfor i in range(n):\n    ai = int(data[index])\n    bi = int(data[index + 1])\n    votes[ai] += 1\n    costs[ai] += bi\n    index += 2\n\n# Calculate the minimum cost to win\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\n# Output the result\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\ntotal_cost = 0\n\nfor i in range(1, n + 1):\n    if votes[i] == max_votes:\n        total_cost += costs[i]\n\nprint(total_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\nprint(min_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(1, 2 * n + 1, 2):\n    ai = int(data[i])\n    bi = int(data[i + 1])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nwinning_votes = max_votes + 1\ntotal_cost = 0\n\nfor i in range(1, n + 1):\n    if votes[i] < winning_votes:\n        needed = winning_votes - votes[i]\n        if needed <= costs[i]:\n            total_cost += needed\n            votes[i] += needed\n\nprint(total_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\nprint(min_cost if min_cost != float('inf') else 0)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\ntotal_cost = 0\n\nfor i in range(1, n + 1):\n    if votes[i] == max_votes:\n        total_cost += costs[i]\n\nprint(total_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\nprint(min_cost if min_cost != float('inf') else 0)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\ntotal_cost = 0\n\nfor i in range(1, n + 1):\n    if votes[i] == max_votes:\n        total_cost += costs[i]\n\nprint(total_cost)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of voters\nn = int(data[0])\n\n# Initialize variables\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\n# Read voter data\nindex = 1\nfor i in range(n):\n    ai = int(data[index])\n    bi = int(data[index + 1])\n    votes[ai] += 1\n    costs[ai] += bi\n    index += 2\n\n# Calculate the minimum cost to win\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\n# Output the result\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\ntotal_cost = 0\n\nfor i in range(1, n + 1):\n    if votes[i] == max_votes:\n        total_cost += costs[i]\n\nprint(total_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\nprint(min_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(1, 2 * n + 1, 2):\n    ai = int(data[i])\n    bi = int(data[i + 1])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nwinning_votes = max_votes + 1\ntotal_cost = 0\n\nfor i in range(1, n + 1):\n    if votes[i] < winning_votes:\n        needed = winning_votes - votes[i]\n        if needed <= costs[i]:\n            total_cost += needed\n            votes[i] += needed\n\nprint(total_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\nprint(min_cost if min_cost != float('inf') else 0)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\ntotal_cost = 0\n\nfor i in range(1, n + 1):\n    if votes[i] == max_votes:\n        total_cost += costs[i]\n\nprint(total_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\nmin_cost = float('inf')\n\nfor i in range(n + 1):\n    if votes[i] == max_votes:\n        continue\n    if votes[i] + 1 > max_votes:\n        min_cost = min(min_cost, costs[i])\n\nprint(min_cost if min_cost != float('inf') else 0)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvotes = [0] * (n + 1)\ncosts = [0] * (n + 1)\n\nfor i in range(n):\n    ai = int(data[2 * i + 1])\n    bi = int(data[2 * i + 2])\n    votes[ai] += 1\n    costs[ai] += bi\n\nmax_votes = max(votes)\ntotal_cost = 0\n\nfor i in range(1, n + 1):\n    if votes[i] == max_votes:\n        total_cost += costs[i]\n\nprint(total_cost)"
        ]
    },
    {
        "question_title": "The Classic Problem",
        "question_content": "You are given a weighted undirected graph on n vertices and m edges. Find the shortest path from vertex s to vertex t or else state that such path doesn't exist.\n\n\nInput Format\nThe first line of the input contains two space-separated integers \u2014 n and m (1 \u2264 n \u2264 105; 0 \u2264 m \u2264 105).\n\nNext m lines contain the description of the graph edges. The i-th line contains three space-separated integers \u2014 ui, vi, xi (1 \u2264 ui, vi \u2264 n; 0 \u2264 xi \u2264 105). That means that vertices with numbers ui and vi are connected by edge of length 2xi (2 to the power of xi).\n\nThe last line contains two space-separated integers \u2014 the numbers of vertices s and t.\n\nThe vertices are numbered from 1 to n. The graph contains no multiple edges and self-loops.\n\n\nOutput Format\nIn the first line print the remainder after dividing the length of the shortest path by 1000000007\u00a0(109 + 7) if the path exists, and -1 if the path doesn't exist.\n\nIf the path exists print in the second line integer k \u2014 the number of vertices in the shortest path from vertex s to vertex t; in the third line print k space-separated integers \u2014 the vertices of the shortest path in the visiting order. The first vertex should be vertex s, the last vertex should be vertex t. If there are multiple shortest paths, print any of them.\n\n\nSample Input 1\n\n4 4\n1 4 2\n1 2 0\n2 3 0\n3 4 0\n1 4\n\nSample Output 1\n\n3\n4\n1 2 3 4\n\n\nSample Input 2\n\n4 3\n1 2 4\n2 3 5\n3 4 6\n1 4\n\nSample Output 2\n\n112\n4\n1 2 3 4\n\n\nSample Input 3\n\n4 2\n1 2 0\n3 4 1\n1 4\n\nSample Output 3\n\n-1\n\n\nNote\nA path from vertex s to vertex t is a sequence v0, ..., vk, such that v0 = s, vk = t, and for any i from 0 to k - 1 vertices vi and vi + 1 are connected by an edge.\n\nThe length of the path is the sum of weights of edges between vi and vi + 1 for all i from 0 to k - 1.\n\nThe shortest path from s to t is the path which length is minimum among all possible paths from s to t.",
        "platform": "codeforces",
        "question_id": "464/E",
        "contest_id": "464",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1, []\n    \n    # Reconstruct the path\n    vertices = []\n    u = t\n    while u != -1:\n        vertices.append(u)\n        u = path[u]\n    vertices.reverse()\n    \n    return dist[t] % 1000000007, vertices\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((u, v, x))\n    index += 3\n\ns = int(data[index])\nt = int(data[index + 1])\n\n# Solve the problem\nresult, path = dijkstra(n, edges, s, t)\n\n# Write output\nprint(result)\nif result != -1:\n    print(len(path))\n    print(' '.join(map(str, path)))\n```",
            "```python\nimport sys\nimport heapq\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        if u == t:\n            break\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1\n    \n    path = []\n    current = t\n    while current != s:\n        path.append(current)\n        for prev, weight in graph[current]:\n            if dist[prev] == dist[current] - weight:\n                current = prev\n                break\n    path.append(s)\n    path.reverse()\n    \n    return dist[t] % 1000000007, len(path), path\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((u, v, x))\n    index += 3\ns = int(data[index])\nt = int(data[index + 1])\n\n# Solve the problem\nresult = dijkstra(n, edges, s, t)\n\n# Print the result\nprint(result[0])\nif result[0] != -1:\n    print(result[1])\n    print(' '.join(map(str, result[2])))\n```",
            "```python\nimport heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1\n    \n    # Reconstruct the path\n    vertices = []\n    u = t\n    while u != -1:\n        vertices.append(u)\n        u = path[u]\n    vertices.reverse()\n    \n    return dist[t], len(vertices), vertices\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((u, v, x))\n    index += 3\ns = int(data[index])\nt = int(data[index + 1])\n\n# Solve the problem\nresult = dijkstra(n, edges, s, t)\n\n# Write output\nif result == -1:\n    print(-1)\nelse:\n    print(result[0] % 1000000007)\n    print(result[1])\n    print(' '.join(map(str, result[2])))\n```",
            "```python\nimport heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1, []\n    \n    # Reconstruct the path\n    vertices = []\n    u = t\n    while u != -1:\n        vertices.append(u)\n        u = path[u]\n    vertices.reverse()\n    \n    return dist[t] % 1000000007, vertices\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((u, v, x))\n    index += 3\ns = int(data[index])\nt = int(data[index + 1])\n\n# Find the shortest path\nresult, path = dijkstra(n, edges, s, t)\n\n# Print the result\nprint(result)\nif result != -1:\n    print(len(path))\n    print(' '.join(map(str, path)))\n```",
            "```python\nimport heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1\n    \n    path_list = []\n    while t != -1:\n        path_list.append(t)\n        t = path[t]\n    path_list.reverse()\n    \n    return dist[t], len(path_list), path_list\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        x = int(data[index + 2])\n        edges.append((u, v, x))\n        index += 3\n    \n    s = int(data[index])\n    t = int(data[index + 1])\n    \n    result = dijkstra(n, edges, s, t)\n    \n    if result == -1:\n        print(result)\n    else:\n        print(result[0] % 1000000007)\n        print(result[1])\n        print(' '.join(map(str, result[2])))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1\n    \n    path = []\n    current = t\n    while current != s:\n        for neighbor, weight in graph[current]:\n            if dist[current] == dist[neighbor] + weight:\n                path.append(neighbor)\n                current = neighbor\n                break\n    path.append(s)\n    path.reverse()\n    \n    return dist[t] % 1000000007, len(path), path\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        x = int(data[index + 2])\n        edges.append((u, v, x))\n        index += 3\n    \n    s = int(data[index])\n    t = int(data[index + 1])\n    \n    result = dijkstra(n, edges, s, t)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(result[0])\n        print(result[1])\n        print(' '.join(map(str, result[2])))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1, []\n    \n    # Reconstruct the path\n    vertices = []\n    u = t\n    while u != -1:\n        vertices.append(u)\n        u = path[u]\n    vertices.reverse()\n    \n    return dist[t] % 1000000007, vertices\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((u, v, x))\n    index += 3\ns = int(data[index])\nt = int(data[index + 1])\n\n# Solve the problem\nresult, path = dijkstra(n, edges, s, t)\n\n# Write output\nprint(result)\nif path:\n    print(len(path))\n    print(' '.join(map(str, path)))\n```",
            "```python\nimport heapq\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    ui = int(data[index])\n    vi = int(data[index + 1])\n    xi = int(data[index + 2])\n    edges.append((ui, vi, 2 ** xi))\n    index += 3\ns = int(data[index])\nt = int(data[index + 1])\n\n# Initialize distances and previous vertices\ndist = [float('inf')] * (n + 1)\nprev = [-1] * (n + 1)\ndist[s] = 0\n\n# Priority queue for Dijkstra's algorithm\npq = [(0, s)]\n\nwhile pq:\n    current_dist, u = heapq.heappop(pq)\n    if current_dist > dist[u]:\n        continue\n    for v, weight in edges:\n        if u == v:\n            continue\n        distance = current_dist + weight\n        if distance < dist[v]:\n            dist[v] = distance\n            prev[v] = u\n            heapq.heappush(pq, (distance, v))\n\n# Check if path exists\nif dist[t] == float('inf'):\n    print(-1)\nelse:\n    path = []\n    u = t\n    while u != -1:\n        path.append(u)\n        u = prev[u]\n    path.reverse()\n    print(dist[t] % 1000000007)\n    print(len(path))\n    print(' '.join(map(str, path)))\n```",
            "```python\nimport heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1, []\n    \n    path_list = []\n    while t != -1:\n        path_list.append(t)\n        t = path[t]\n    path_list.reverse()\n    \n    return dist[t], path_list\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        x = int(data[index + 2])\n        edges.append((u, v, x))\n        index += 3\n    \n    s = int(data[index])\n    t = int(data[index + 1])\n    \n    result, path = dijkstra(n, edges, s, t)\n    \n    if result == -1:\n        print(result)\n    else:\n        print(result % 1000000007)\n        print(len(path))\n        print(' '.join(map(str, path)))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1\n    \n    path = []\n    current = t\n    while current != s:\n        for neighbor, weight in graph[current]:\n            if dist[current] == dist[neighbor] + weight:\n                path.append(neighbor)\n                current = neighbor\n                break\n    path.append(s)\n    path.reverse()\n    \n    return dist[t] % 1000000007, len(path), path\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        x = int(data[index + 2])\n        edges.append((u, v, x))\n        index += 3\n    \n    s = int(data[index])\n    t = int(data[index + 1])\n    \n    result = dijkstra(n, edges, s, t)\n    \n    if result == -1:\n        print(result)\n    else:\n        print(result[0])\n        print(result[1])\n        print(' '.join(map(str, result[2])))\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nimport heapq\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1, []\n    \n    # Reconstruct the path\n    vertices = []\n    u = t\n    while u != -1:\n        vertices.append(u)\n        u = path[u]\n    vertices.reverse()\n    \n    return dist[t] % 1000000007, vertices\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((u, v, x))\n    index += 3\n\ns = int(data[index])\nt = int(data[index + 1])\n\n# Solve the problem\nresult, path = dijkstra(n, edges, s, t)\n\n# Write output\nprint(result)\nif result != -1:\n    print(len(path))\n    print(' '.join(map(str, path)))",
            "import sys\nimport heapq\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        if u == t:\n            break\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1\n    \n    path = []\n    current = t\n    while current != s:\n        path.append(current)\n        for prev, weight in graph[current]:\n            if dist[prev] == dist[current] - weight:\n                current = prev\n                break\n    path.append(s)\n    path.reverse()\n    \n    return dist[t] % 1000000007, len(path), path\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((u, v, x))\n    index += 3\ns = int(data[index])\nt = int(data[index + 1])\n\n# Solve the problem\nresult = dijkstra(n, edges, s, t)\n\n# Print the result\nprint(result[0])\nif result[0] != -1:\n    print(result[1])\n    print(' '.join(map(str, result[2])))",
            "import heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1\n    \n    # Reconstruct the path\n    vertices = []\n    u = t\n    while u != -1:\n        vertices.append(u)\n        u = path[u]\n    vertices.reverse()\n    \n    return dist[t], len(vertices), vertices\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((u, v, x))\n    index += 3\ns = int(data[index])\nt = int(data[index + 1])\n\n# Solve the problem\nresult = dijkstra(n, edges, s, t)\n\n# Write output\nif result == -1:\n    print(-1)\nelse:\n    print(result[0] % 1000000007)\n    print(result[1])\n    print(' '.join(map(str, result[2])))",
            "import heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1, []\n    \n    # Reconstruct the path\n    vertices = []\n    u = t\n    while u != -1:\n        vertices.append(u)\n        u = path[u]\n    vertices.reverse()\n    \n    return dist[t] % 1000000007, vertices\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((u, v, x))\n    index += 3\ns = int(data[index])\nt = int(data[index + 1])\n\n# Find the shortest path\nresult, path = dijkstra(n, edges, s, t)\n\n# Print the result\nprint(result)\nif result != -1:\n    print(len(path))\n    print(' '.join(map(str, path)))",
            "import heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1\n    \n    path_list = []\n    while t != -1:\n        path_list.append(t)\n        t = path[t]\n    path_list.reverse()\n    \n    return dist[t], len(path_list), path_list\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        x = int(data[index + 2])\n        edges.append((u, v, x))\n        index += 3\n    \n    s = int(data[index])\n    t = int(data[index + 1])\n    \n    result = dijkstra(n, edges, s, t)\n    \n    if result == -1:\n        print(result)\n    else:\n        print(result[0] % 1000000007)\n        print(result[1])\n        print(' '.join(map(str, result[2])))\n\nif __name__ == \"__main__\":\n    main()",
            "import heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1\n    \n    path = []\n    current = t\n    while current != s:\n        for neighbor, weight in graph[current]:\n            if dist[current] == dist[neighbor] + weight:\n                path.append(neighbor)\n                current = neighbor\n                break\n    path.append(s)\n    path.reverse()\n    \n    return dist[t] % 1000000007, len(path), path\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        x = int(data[index + 2])\n        edges.append((u, v, x))\n        index += 3\n    \n    s = int(data[index])\n    t = int(data[index + 1])\n    \n    result = dijkstra(n, edges, s, t)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(result[0])\n        print(result[1])\n        print(' '.join(map(str, result[2])))\n\nif __name__ == \"__main__\":\n    main()",
            "import heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1, []\n    \n    # Reconstruct the path\n    vertices = []\n    u = t\n    while u != -1:\n        vertices.append(u)\n        u = path[u]\n    vertices.reverse()\n    \n    return dist[t] % 1000000007, vertices\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    x = int(data[index + 2])\n    edges.append((u, v, x))\n    index += 3\ns = int(data[index])\nt = int(data[index + 1])\n\n# Solve the problem\nresult, path = dijkstra(n, edges, s, t)\n\n# Write output\nprint(result)\nif path:\n    print(len(path))\n    print(' '.join(map(str, path)))",
            "import heapq\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    ui = int(data[index])\n    vi = int(data[index + 1])\n    xi = int(data[index + 2])\n    edges.append((ui, vi, 2 ** xi))\n    index += 3\ns = int(data[index])\nt = int(data[index + 1])\n\n# Initialize distances and previous vertices\ndist = [float('inf')] * (n + 1)\nprev = [-1] * (n + 1)\ndist[s] = 0\n\n# Priority queue for Dijkstra's algorithm\npq = [(0, s)]\n\nwhile pq:\n    current_dist, u = heapq.heappop(pq)\n    if current_dist > dist[u]:\n        continue\n    for v, weight in edges:\n        if u == v:\n            continue\n        distance = current_dist + weight\n        if distance < dist[v]:\n            dist[v] = distance\n            prev[v] = u\n            heapq.heappush(pq, (distance, v))\n\n# Check if path exists\nif dist[t] == float('inf'):\n    print(-1)\nelse:\n    path = []\n    u = t\n    while u != -1:\n        path.append(u)\n        u = prev[u]\n    path.reverse()\n    print(dist[t] % 1000000007)\n    print(len(path))\n    print(' '.join(map(str, path)))",
            "import heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    path = [-1] * (n + 1)\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                path[v] = u\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1, []\n    \n    path_list = []\n    while t != -1:\n        path_list.append(t)\n        t = path[t]\n    path_list.reverse()\n    \n    return dist[t], path_list\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        x = int(data[index + 2])\n        edges.append((u, v, x))\n        index += 3\n    \n    s = int(data[index])\n    t = int(data[index + 1])\n    \n    result, path = dijkstra(n, edges, s, t)\n    \n    if result == -1:\n        print(result)\n    else:\n        print(result % 1000000007)\n        print(len(path))\n        print(' '.join(map(str, path)))\n\nif __name__ == \"__main__\":\n    main()",
            "import heapq\nimport sys\n\ndef dijkstra(n, edges, s, t):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, x in edges:\n        graph[u].append((v, 2 ** x))\n        graph[v].append((u, 2 ** x))\n    \n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    pq = [(0, s)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                heapq.heappush(pq, (distance, v))\n    \n    if dist[t] == float('inf'):\n        return -1\n    \n    path = []\n    current = t\n    while current != s:\n        for neighbor, weight in graph[current]:\n            if dist[current] == dist[neighbor] + weight:\n                path.append(neighbor)\n                current = neighbor\n                break\n    path.append(s)\n    path.reverse()\n    \n    return dist[t] % 1000000007, len(path), path\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        x = int(data[index + 2])\n        edges.append((u, v, x))\n        index += 3\n    \n    s = int(data[index])\n    t = int(data[index + 1])\n    \n    result = dijkstra(n, edges, s, t)\n    \n    if result == -1:\n        print(result)\n    else:\n        print(result[0])\n        print(result[1])\n        print(' '.join(map(str, result[2])))\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Maximum Value",
        "question_content": "You are given a sequence a consisting of n integers. Find the maximum possible value of a_i \\bmod a_j (integer remainder of ai divided by aj), where 1 \u2264 i, j \u2264 n and ai \u2265 aj.\n\n\nInput Format\nThe first line contains integer n\u00a0\u2014 the length of the sequence (1 \u2264 n \u2264 2\u00b7105).\n\nThe second line contains n space-separated integers ai (1 \u2264 ai \u2264 106).\n\n\nOutput Format\nPrint the answer to the problem.\n\n\nSample Input 1\n\n3\n3 4 5\n\nSample Output 1\n\n2",
        "platform": "codeforces",
        "question_id": "484/B",
        "contest_id": "484",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\n\nmax_mod = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\nmax_mod = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array\na.sort()\n\n# The maximum possible value of a_i % a_j will be the remainder of the largest number divided by the second largest number\nmax_remainder = a[-1] % a[-2]\n\n# Print the result\nprint(max_remainder)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array\na.sort()\n\n# The maximum possible value of a_i % a_j will be the remainder of the largest number divided by the second largest number\nmax_remainder = a[-1] % a[-2]\n\n# Print the result\nprint(max_remainder)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\nmax_mod = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\nmax_mod = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array\na.sort()\n\n# The maximum possible value of a_i % a_j will be the remainder of the largest number divided by the second largest number\nmax_remainder = a[-1] % a[-2]\n\n# Print the result\nprint(max_remainder)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array\na.sort()\n\n# The maximum possible value of a_i % a_j will be the remainder of the largest number divided by the second largest number\nmax_remainder = a[-1] % a[-2]\n\n# Print the result\nprint(max_remainder)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\nmax_mod = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\nmax_mod = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\n\nmax_mod = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\nmax_mod = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array\na.sort()\n\n# The maximum possible value of a_i % a_j will be the remainder of the largest number divided by the second largest number\nmax_remainder = a[-1] % a[-2]\n\n# Print the result\nprint(max_remainder)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array\na.sort()\n\n# The maximum possible value of a_i % a_j will be the remainder of the largest number divided by the second largest number\nmax_remainder = a[-1] % a[-2]\n\n# Print the result\nprint(max_remainder)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\nmax_mod = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\nmax_mod = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array\na.sort()\n\n# The maximum possible value of a_i % a_j will be the remainder of the largest number divided by the second largest number\nmax_remainder = a[-1] % a[-2]\n\n# Print the result\nprint(max_remainder)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array\na.sort()\n\n# The maximum possible value of a_i % a_j will be the remainder of the largest number divided by the second largest number\nmax_remainder = a[-1] % a[-2]\n\n# Print the result\nprint(max_remainder)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\nmax_mod = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\na.sort(reverse=True)\nmax_mod = 0\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        mod = a[i] % a[j]\n        if mod > max_mod:\n            max_mod = mod\n\nprint(max_mod)"
        ]
    },
    {
        "question_title": "Strip",
        "question_content": "Alexandra has a paper strip with n numbers on it. Let's call them ai from left to right.\n\nNow Alexandra wants to split it into some pieces (possibly 1). For each piece of strip, it must satisfy:\n\n- Each piece should contain at least l numbers.\n- The difference between the maximal and the minimal number on the piece should be at most s.\n\nPlease help Alexandra to find the minimal number of pieces meeting the condition above.\n\n\nInput Format\nThe first line contains three space-separated integers n, s, l (1 \u2264 n \u2264 105, 0 \u2264 s \u2264 109, 1 \u2264 l \u2264 105).\n\nThe second line contains n integers ai separated by spaces ( - 109 \u2264 ai \u2264 109).\n\n\nOutput Format\nOutput the minimal number of strip pieces.\n\nIf there are no ways to split the strip, output -1.\n\n\nSample Input 1\n\n7 2 2\n1 3 1 2 4 1 2\n\nSample Output 1\n\n3\n\n\nSample Input 2\n\n7 2 2\n1 100 1 100 1 100 1\n\nSample Output 2\n\n-1\n\n\nNote\nFor the first sample, we can split the strip into 3 pieces: [1, 3, 1], [2, 4], [1, 2].\n\nFor the second sample, we can't let 1 and 100 be on the same piece, so no solution exists.",
        "platform": "codeforces",
        "question_id": "487/B",
        "contest_id": "487",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\nif s == 0:\n    if l == 1:\n        print(n)\n    else:\n        print(-1)\nelse:\n    pieces = 0\n    current_min = numbers[0]\n    current_max = numbers[0]\n    \n    for i in range(n):\n        current_min = min(current_min, numbers[i])\n        current_max = max(current_max, numbers[i])\n        \n        if current_max - current_min > s:\n            pieces += 1\n            current_min = numbers[i]\n            current_max = numbers[i]\n    \n    if current_max - current_min <= s:\n        pieces += 1\n    \n    if pieces == 0:\n        print(-1)\n    else:\n        print(pieces)\n```",
            "```python\nimport sys\n\ndef min_pieces(n, s, l, a):\n    pieces = 0\n    i = 0\n    while i < n:\n        min_val = a[i]\n        max_val = a[i]\n        j = i\n        while j < n and max_val - min_val <= s and j - i + 1 >= l:\n            min_val = min(min_val, a[j])\n            max_val = max(max_val, a[j])\n            j += 1\n        if j - i < l:\n            return -1\n        pieces += 1\n        i = j\n    return pieces\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\na = list(map(int, data[3:]))\n\n# Solve the problem\nresult = min_pieces(n, s, l, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\ndef min_pieces(n, s, l, numbers):\n    if l == 1:\n        return n\n    \n    numbers.sort()\n    pieces = 0\n    i = 0\n    \n    while i < n:\n        max_val = numbers[i]\n        min_val = numbers[i]\n        j = i + 1\n        \n        while j < n and numbers[j] - min_val <= s and j - i < l:\n            max_val = max(max_val, numbers[j])\n            min_val = min(min_val, numbers[j])\n            j += 1\n        \n        if j - i < l:\n            return -1\n        \n        pieces += 1\n        i = j\n    \n    return pieces\n\nresult = min_pieces(n, s, l, numbers)\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\n# Initialize variables\npieces = 0\ncurrent_min = numbers[0]\ncurrent_max = numbers[0]\n\n# Iterate through the numbers to determine the minimum number of pieces\nfor i in range(n):\n    current_min = min(current_min, numbers[i])\n    current_max = max(current_max, numbers[i])\n    \n    if i - pieces + 1 >= l and current_max - current_min <= s:\n        pieces += 1\n        if i < n - 1:\n            current_min = numbers[i + 1]\n            current_max = numbers[i + 1]\n\n# Check if the entire strip can be split\nif pieces == 0 and n >= l and max(numbers) - min(numbers) <= s:\n    pieces = 1\n\n# Output the result\nif pieces == 0:\n    print(-1)\nelse:\n    print(pieces)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\nif s == 0:\n    if l == 1:\n        print(n)\n    else:\n        print(-1)\nelse:\n    pieces = 0\n    i = 0\n    while i < n:\n        min_val = numbers[i]\n        max_val = numbers[i]\n        j = i\n        while j < n and max_val - min_val <= s and j - i + 1 >= l:\n            min_val = min(min_val, numbers[j])\n            max_val = max(max_val, numbers[j])\n            j += 1\n        if j - i < l:\n            print(-1)\n            break\n        pieces += 1\n        i = j\n    else:\n        print(pieces)\n```",
            "```python\nimport sys\n\ndef min_pieces(n, s, l, a):\n    pieces = 0\n    i = 0\n    while i < n:\n        min_val = a[i]\n        max_val = a[i]\n        j = i\n        while j < n and max_val - min_val <= s and j - i + 1 >= l:\n            min_val = min(min_val, a[j])\n            max_val = max(max_val, a[j])\n            j += 1\n        if j - i < l:\n            return -1\n        pieces += 1\n        i = j\n    return pieces\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    s = int(data[1])\n    l = int(data[2])\n    a = list(map(int, data[3:]))\n    result = min_pieces(n, s, l, a)\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\nif s == 0:\n    if max(numbers) - min(numbers) > l - 1:\n        print(-1)\n    else:\n        print(1)\nelse:\n    pieces = 1\n    current_min = numbers[0]\n    current_max = numbers[0]\n    \n    for i in range(1, n):\n        if numbers[i] - current_min > s or i - current_min + 1 < l:\n            pieces += 1\n            current_min = numbers[i]\n            current_max = numbers[i]\n        else:\n            current_max = max(current_max, numbers[i])\n    \n    print(pieces)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\nif s == 0:\n    if l == 1:\n        print(n)\n    else:\n        print(-1)\nelse:\n    pieces = 0\n    current_min = numbers[0]\n    current_max = numbers[0]\n    \n    for i in range(n):\n        current_min = min(current_min, numbers[i])\n        current_max = max(current_max, numbers[i])\n        \n        if i - pieces * l >= l - 1 and current_max - current_min > s:\n            pieces += 1\n            current_min = numbers[i]\n            current_max = numbers[i]\n    \n    if current_max - current_min > s:\n        pieces += 1\n    \n    if pieces * l < n:\n        pieces += 1\n    \n    print(pieces if pieces * l >= n else -1)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\n# Initialize variables\npieces = 0\ncurrent_min = numbers[0]\ncurrent_max = numbers[0]\n\n# Iterate through the numbers to determine the minimum number of pieces\nfor i in range(n):\n    current_min = min(current_min, numbers[i])\n    current_max = max(current_max, numbers[i])\n    \n    if i - pieces + 1 >= l and current_max - current_min <= s:\n        pieces += 1\n        if i < n - 1:\n            current_min = numbers[i + 1]\n            current_max = numbers[i + 1]\n\n# Check if the entire strip can be split\nif pieces == 0:\n    print(-1)\nelse:\n    print(pieces)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\n# Initialize variables\npieces = 0\ncurrent_min = numbers[0]\ncurrent_max = numbers[0]\n\n# Iterate through the numbers to determine the minimum number of pieces\nfor i in range(n):\n    current_min = min(current_min, numbers[i])\n    current_max = max(current_max, numbers[i])\n    \n    if i - pieces + 1 >= l and current_max - current_min <= s:\n        pieces += 1\n        if i < n - 1:\n            current_min = numbers[i + 1]\n            current_max = numbers[i + 1]\n\n# Check if the entire strip can be split\nif pieces == 0:\n    pieces = 1\n\n# Output the result\nif pieces > n:\n    print(-1)\nelse:\n    print(pieces)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\nif s == 0:\n    if l == 1:\n        print(n)\n    else:\n        print(-1)\nelse:\n    pieces = 0\n    current_min = numbers[0]\n    current_max = numbers[0]\n    \n    for i in range(n):\n        current_min = min(current_min, numbers[i])\n        current_max = max(current_max, numbers[i])\n        \n        if current_max - current_min > s:\n            pieces += 1\n            current_min = numbers[i]\n            current_max = numbers[i]\n    \n    if current_max - current_min <= s:\n        pieces += 1\n    \n    if pieces == 0:\n        print(-1)\n    else:\n        print(pieces)",
            "import sys\n\ndef min_pieces(n, s, l, a):\n    pieces = 0\n    i = 0\n    while i < n:\n        min_val = a[i]\n        max_val = a[i]\n        j = i\n        while j < n and max_val - min_val <= s and j - i + 1 >= l:\n            min_val = min(min_val, a[j])\n            max_val = max(max_val, a[j])\n            j += 1\n        if j - i < l:\n            return -1\n        pieces += 1\n        i = j\n    return pieces\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\na = list(map(int, data[3:]))\n\n# Solve the problem\nresult = min_pieces(n, s, l, a)\n\n# Write output\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\ndef min_pieces(n, s, l, numbers):\n    if l == 1:\n        return n\n    \n    numbers.sort()\n    pieces = 0\n    i = 0\n    \n    while i < n:\n        max_val = numbers[i]\n        min_val = numbers[i]\n        j = i + 1\n        \n        while j < n and numbers[j] - min_val <= s and j - i < l:\n            max_val = max(max_val, numbers[j])\n            min_val = min(min_val, numbers[j])\n            j += 1\n        \n        if j - i < l:\n            return -1\n        \n        pieces += 1\n        i = j\n    \n    return pieces\n\nresult = min_pieces(n, s, l, numbers)\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\n# Initialize variables\npieces = 0\ncurrent_min = numbers[0]\ncurrent_max = numbers[0]\n\n# Iterate through the numbers to determine the minimum number of pieces\nfor i in range(n):\n    current_min = min(current_min, numbers[i])\n    current_max = max(current_max, numbers[i])\n    \n    if i - pieces + 1 >= l and current_max - current_min <= s:\n        pieces += 1\n        if i < n - 1:\n            current_min = numbers[i + 1]\n            current_max = numbers[i + 1]\n\n# Check if the entire strip can be split\nif pieces == 0 and n >= l and max(numbers) - min(numbers) <= s:\n    pieces = 1\n\n# Output the result\nif pieces == 0:\n    print(-1)\nelse:\n    print(pieces)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\nif s == 0:\n    if l == 1:\n        print(n)\n    else:\n        print(-1)\nelse:\n    pieces = 0\n    i = 0\n    while i < n:\n        min_val = numbers[i]\n        max_val = numbers[i]\n        j = i\n        while j < n and max_val - min_val <= s and j - i + 1 >= l:\n            min_val = min(min_val, numbers[j])\n            max_val = max(max_val, numbers[j])\n            j += 1\n        if j - i < l:\n            print(-1)\n            break\n        pieces += 1\n        i = j\n    else:\n        print(pieces)",
            "import sys\n\ndef min_pieces(n, s, l, a):\n    pieces = 0\n    i = 0\n    while i < n:\n        min_val = a[i]\n        max_val = a[i]\n        j = i\n        while j < n and max_val - min_val <= s and j - i + 1 >= l:\n            min_val = min(min_val, a[j])\n            max_val = max(max_val, a[j])\n            j += 1\n        if j - i < l:\n            return -1\n        pieces += 1\n        i = j\n    return pieces\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    s = int(data[1])\n    l = int(data[2])\n    a = list(map(int, data[3:]))\n    result = min_pieces(n, s, l, a)\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\nif s == 0:\n    if max(numbers) - min(numbers) > l - 1:\n        print(-1)\n    else:\n        print(1)\nelse:\n    pieces = 1\n    current_min = numbers[0]\n    current_max = numbers[0]\n    \n    for i in range(1, n):\n        if numbers[i] - current_min > s or i - current_min + 1 < l:\n            pieces += 1\n            current_min = numbers[i]\n            current_max = numbers[i]\n        else:\n            current_max = max(current_max, numbers[i])\n    \n    print(pieces)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\nif s == 0:\n    if l == 1:\n        print(n)\n    else:\n        print(-1)\nelse:\n    pieces = 0\n    current_min = numbers[0]\n    current_max = numbers[0]\n    \n    for i in range(n):\n        current_min = min(current_min, numbers[i])\n        current_max = max(current_max, numbers[i])\n        \n        if i - pieces * l >= l - 1 and current_max - current_min > s:\n            pieces += 1\n            current_min = numbers[i]\n            current_max = numbers[i]\n    \n    if current_max - current_min > s:\n        pieces += 1\n    \n    if pieces * l < n:\n        pieces += 1\n    \n    print(pieces if pieces * l >= n else -1)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\n# Initialize variables\npieces = 0\ncurrent_min = numbers[0]\ncurrent_max = numbers[0]\n\n# Iterate through the numbers to determine the minimum number of pieces\nfor i in range(n):\n    current_min = min(current_min, numbers[i])\n    current_max = max(current_max, numbers[i])\n    \n    if i - pieces + 1 >= l and current_max - current_min <= s:\n        pieces += 1\n        if i < n - 1:\n            current_min = numbers[i + 1]\n            current_max = numbers[i + 1]\n\n# Check if the entire strip can be split\nif pieces == 0:\n    print(-1)\nelse:\n    print(pieces)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ns = int(data[1])\nl = int(data[2])\nnumbers = list(map(int, data[3:]))\n\n# Initialize variables\npieces = 0\ncurrent_min = numbers[0]\ncurrent_max = numbers[0]\n\n# Iterate through the numbers to determine the minimum number of pieces\nfor i in range(n):\n    current_min = min(current_min, numbers[i])\n    current_max = max(current_max, numbers[i])\n    \n    if i - pieces + 1 >= l and current_max - current_min <= s:\n        pieces += 1\n        if i < n - 1:\n            current_min = numbers[i + 1]\n            current_max = numbers[i + 1]\n\n# Check if the entire strip can be split\nif pieces == 0:\n    pieces = 1\n\n# Output the result\nif pieces > n:\n    print(-1)\nelse:\n    print(pieces)"
        ]
    },
    {
        "question_title": "Misha and LCP on Tree",
        "question_content": "Misha has a tree with characters written on the vertices. He can choose two vertices s and t of this tree and write down characters of vertices lying on a path from s to t. We'll say that such string corresponds to pair (s, t).\n\nMisha has m queries of type: you are given 4 vertices a, b, c, d; you need to find the largest common prefix of the strings that correspond to pairs (a, b) and (c, d). Your task is to help him.\n\n\nInput Format\nThe first line contains integer n (1 \u2264 n \u2264 300 000) \u2014 the number of vertices in the tree.\n\nNext follows a line consisting of n small English letters. The i-th character of the string corresponds to the character written on the i-th vertex.\n\nNext n - 1 lines contain information about edges. An edge is defined by a pair of integers u, v (1 \u2264 u, v \u2264 n, u \u2260 v), separated by spaces.\n\nThe next line contains integer m (1 \u2264 m \u2264 1 000 000) \u2014 the number of queries.\n\nNext m lines contain information about queries. A query is defined by four integers a, b, c, d (1 \u2264 a, b, c, d \u2264 n), separated by spaces.\n\n\nOutput Format\nFor each query print the length of the largest common prefix on a separate line.\n\n\nSample Input 1\n\n6\nbbbabb\n2 1\n3 2\n4 3\n5 2\n6 5\n6\n2 5 3 1\n1 5 2 3\n5 6 5 6\n6 3 4 1\n6 2 3 4\n2 2 4 5\n\nSample Output 1\n\n2\n2\n2\n0\n1\n0",
        "platform": "codeforces",
        "question_id": "504/E",
        "contest_id": "504",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(n - 1)]\nm = int(data[2 * n + 1])\nqueries = [(int(data[2 * n + 2 + 4 * i]) - 1, int(data[2 * n + 3 + 4 * i]) - 1, int(data[2 * n + 4 + 4 * i]) - 1, int(data[2 * n + 5 + 4 * i]) - 1) for i in range(m)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the lowest common ancestor (LCA) of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the root\ndef path_to_root(node):\n    path = []\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    return path[::-1]\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, prev):\n    depth[node] = depth[prev] + 1\n    parent[node] = prev\n    for neighbor in tree[node]:\n        if neighbor != prev:\n            dfs(neighbor, node)\n\n# Start DFS from the root (node 0)\ndfs(0, -1)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    lca_ac = lca(a, c)\n    lca_bd = lca(b, d)\n    \n    path_ab = path_to_root(lca_ab)\n    path_cd = path_to_root(lca_cd)\n    path_ac = path_to_root(lca_ac)\n    path_bd = path_to_root(lca_bd)\n    \n    common_prefix_length = 0\n    for i in range(min(len(path_ab), len(path_cd))):\n        if path_ab[i] == path_cd[i]:\n            common_prefix_length += 1\n        else:\n            break\n    \n    for i in range(min(len(path_ac), len(path_bd))):\n        if path_ac[i] == path_bd[i]:\n            common_prefix_length = max(common_prefix_length, i + 1)\n        else:\n            break\n    \n    results.append(common_prefix_length)\n\n# Write results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ncharacters = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the lowest common ancestor (LCA) using BFS\ndef find_lca(u, v):\n    visited = [False] * n\n    parent = [-1] * n\n    queue = deque([u])\n    visited[u] = True\n    parent[u] = u\n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = node\n                queue.append(neighbor)\n    path_to_u = []\n    while u != parent[u]:\n        path_to_u.append(u)\n        u = parent[u]\n    path_to_u.append(u)\n    path_to_u.reverse()\n    path_to_v = []\n    while v != parent[v]:\n        path_to_v.append(v)\n        v = parent[v]\n    path_to_v.append(v)\n    path_to_v.reverse()\n    lca = -1\n    for i in range(min(len(path_to_u), len(path_to_v))):\n        if path_to_u[i] == path_to_v[i]:\n            lca = path_to_u[i]\n        else:\n            break\n    return lca\n\n# Function to find the path from a node to the LCA\ndef find_path(node, lca):\n    path = []\n    while node != lca:\n        path.append(node)\n        node = parent[node]\n    path.append(lca)\n    return path\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = find_lca(a, b)\n    lca_cd = find_lca(c, d)\n    path_ab = find_path(a, lca_ab)\n    path_cd = find_path(c, lca_cd)\n    common_prefix_length = 0\n    for char_a, char_c in zip(characters[path_ab], characters[path_cd]):\n        if char_a == char_c:\n            common_prefix_length += 1\n        else:\n            break\n    results.append(common_prefix_length)\n\n# Write results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(n - 1)]\nm = int(data[2 * n + 1])\nqueries = [(int(data[2 * n + 2 + 4 * i]) - 1, int(data[2 * n + 3 + 4 * i]) - 1, int(data[2 * n + 4 + 4 * i]) - 1, int(data[2 * n + 5 + 4 * i]) - 1) for i in range(m)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the lowest common ancestor (LCA) using BFS\ndef lca(u, v):\n    parent = [None] * n\n    dist = [-1] * n\n    queue = deque([u])\n    dist[u] = 0\n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[node] + 1\n                parent[neighbor] = node\n                queue.append(neighbor)\n    while u != v:\n        if dist[u] > dist[v]:\n            u = parent[u]\n        else:\n            v = parent[v]\n    return u\n\n# Function to find the length of the largest common prefix of paths (u, v) and (x, y)\ndef largest_common_prefix(u, v, x, y):\n    lca_uv = lca(u, v)\n    lca_xy = lca(x, y)\n    lca_ux = lca(u, x)\n    lca_uy = lca(u, y)\n    lca_vx = lca(v, x)\n    lca_vy = lca(v, y)\n    \n    # Calculate the distances from the LCA to the vertices\n    dist_uv = dist[u] + dist[v] - 2 * dist[lca_uv]\n    dist_xy = dist[x] + dist[y] - 2 * dist[lca_xy]\n    dist_ux = dist[u] + dist[x] - 2 * dist[lca_ux]\n    dist_uy = dist[u] + dist[y] - 2 * dist[lca_uy]\n    dist_vx = dist[v] + dist[x] - 2 * dist[lca_vx]\n    dist_vy = dist[v] + dist[y] - 2 * dist[lca_vy]\n    \n    # Find the maximum common prefix length\n    max_prefix = 0\n    for i in range(min(dist_uv, dist_xy)):\n        if labels[lca_uv + i] == labels[lca_xy + i]:\n            max_prefix += 1\n        else:\n            break\n    for i in range(min(dist_ux, dist_uy)):\n        if labels[lca_ux + i] == labels[lca_uy + i]:\n            max_prefix += 1\n        else:\n            break\n    for i in range(min(dist_vx, dist_vy)):\n        if labels[lca_vx + i] == labels[lca_vy + i]:\n            max_prefix += 1\n        else:\n            break\n    \n    return max_prefix\n\n# Process each query and print the result\nfor a, b, c, d in queries:\n    print(largest_common_prefix(a, b, c, d))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\ncharacters = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the root\ndef path_to_root(node):\n    path = []\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    return path[::-1]\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, par):\n    depth[node] = depth[par] + 1\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\n# Start DFS from node 0 (root)\ndfs(0, -1)\n\n# Function to find the largest common prefix of two paths\ndef largest_common_prefix(a, b, c, d):\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_root(a)\n    path_cd = path_to_root(c)\n    \n    # Find the common prefix length between the paths\n    i = 0\n    while i < len(path_ab) and i < len(path_cd) and path_ab[i] == path_cd[i]:\n        i += 1\n    \n    # Check the characters on the path from a to b and c to d\n    prefix_length = 0\n    while a != lca_ab:\n        if characters[a] == characters[c]:\n            prefix_length += 1\n        a = parent[a]\n        c = parent[c]\n    \n    while b != lca_ab:\n        if characters[b] == characters[d]:\n            prefix_length += 1\n        b = parent[b]\n        d = parent[d]\n    \n    return prefix_length\n\n# Process each query and print the result\nfor a, b, c, d in queries:\n    result = largest_common_prefix(a, b, c, d)\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(n - 1)]\nm = int(data[2 * n + 1])\nqueries = [(int(data[2 * n + 2 + 4 * i]) - 1, int(data[2 * n + 3 + 4 * i]) - 1, int(data[2 * n + 4 + 4 * i]) - 1, int(data[2 * n + 5 + 4 * i]) - 1) for i in range(m)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the lowest common ancestor (LCA) using BFS\ndef find_lca(u, v):\n    parent = [None] * n\n    visited = [False] * n\n    queue = deque([u])\n    visited[u] = True\n    parent[u] = -1\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    while v != -1:\n        path.append(v)\n        v = parent[v]\n    \n    path.reverse()\n    \n    for i in range(min(len(path), len(path))):\n        if path[i] == path[len(path) - i - 1]:\n            return path[i]\n    return -1\n\n# Function to find the longest common prefix of two strings\ndef longest_common_prefix(s1, s2):\n    min_length = min(len(s1), len(s2))\n    for i in range(min_length):\n        if s1[i] != s2[i]:\n            return i\n    return min_length\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = find_lca(a, b)\n    lca_cd = find_lca(c, d)\n    \n    path_ab = []\n    path_cd = []\n    \n    node = a\n    while node != lca_ab:\n        path_ab.append(labels[node])\n        node = parent[node]\n    \n    path_ab.append(labels[lca_ab])\n    \n    node = c\n    while node != lca_cd:\n        path_cd.append(labels[node])\n        node = parent[node]\n    \n    path_cd.append(labels[lca_cd])\n    \n    if lca_ab == lca_cd:\n        results.append(longest_common_prefix(''.join(path_ab), ''.join(path_cd)))\n    else:\n        results.append(0)\n\n# Write results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the LCA\ndef path_to_lca(node, lca_node):\n    path = []\n    while node != lca_node:\n        path.append(node)\n        node = parent[node]\n    path.append(lca_node)\n    return path[::-1]\n\n# Function to find the largest common prefix of two strings\ndef longest_common_prefix(s1, s2):\n    min_length = min(len(s1), len(s2))\n    for i in range(min_length):\n        if s1[i] != s2[i]:\n            return i\n    return min_length\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Depth-first search to find depths and parents\ndef dfs(node, parent_node, depth_node):\n    depth[node] = depth_node\n    parent[node] = parent_node\n    for neighbor in tree[node]:\n        if neighbor != parent_node:\n            dfs(neighbor, node, depth_node + 1)\n\n# Start DFS from the root (node 0)\ndfs(0, -1, 0)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_lca(a, lca_ab)\n    path_cd = path_to_lca(c, lca_cd)\n    \n    # Find the common prefix of the paths\n    common_prefix_length = 0\n    for i in range(min(len(path_ab), len(path_cd))):\n        if labels[path_ab[i]] == labels[path_cd[i]]:\n            common_prefix_length += 1\n        else:\n            break\n    \n    results.append(common_prefix_length)\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the LCA\ndef path_to_lca(node, lca_node):\n    path = []\n    while node != lca_node:\n        path.append(node)\n        node = parent[node]\n    path.append(lca_node)\n    return path[::-1]\n\n# Function to find the largest common prefix of two strings\ndef lcp(s1, s2):\n    min_length = min(len(s1), len(s2))\n    for i in range(min_length):\n        if s1[i] != s2[i]:\n            return i\n    return min_length\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, parent_node, depth_node):\n    depth[node] = depth_node\n    parent[node] = parent_node\n    for neighbor in tree[node]:\n        if neighbor != parent_node:\n            dfs(neighbor, node, depth_node + 1)\n\n# Perform DFS to populate depth and parent arrays\ndfs(0, -1, 0)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_lca(a, lca_ab)\n    path_cd = path_to_lca(c, lca_cd)\n    common_prefix_length = 0\n    for i in range(min(len(path_ab), len(path_cd))):\n        if path_ab[i] == path_cd[i]:\n            common_prefix_length += 1\n        else:\n            break\n    results.append(common_prefix_length)\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the LCA\ndef path_to_lca(node, lca_node):\n    path = []\n    while node != lca_node:\n        path.append(node)\n        node = parent[node]\n    path.append(lca_node)\n    return path\n\n# Function to find the largest common prefix\ndef largest_common_prefix(path1, path2):\n    i = 0\n    while i < len(path1) and i < len(path2) and labels[path1[i]] == labels[path2[i]]:\n        i += 1\n    return i\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Depth-first search to find depths and parents\ndef dfs(node, par, d):\n    depth[node] = d\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node, d + 1)\n\n# Start DFS from the root (node 0)\ndfs(0, -1, 0)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_lca(a, lca_ab)\n    path_cd = path_to_lca(c, lca_cd)\n    results.append(max(largest_common_prefix(path_ab, path_cd), largest_common_prefix(path_ab[::-1], path_cd[::-1])))\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the LCA\ndef path_to_lca(node, lca_node):\n    path = []\n    while node != lca_node:\n        path.append(node)\n        node = parent[node]\n    path.append(lca_node)\n    return path[::-1]\n\n# Function to find the largest common prefix of two paths\ndef largest_common_prefix(path1, path2):\n    i = 0\n    while i < len(path1) and i < len(path2) and labels[path1[i]] == labels[path2[i]]:\n        i += 1\n    return i\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, parent_node, current_depth):\n    depth[node] = current_depth\n    parent[node] = parent_node\n    for neighbor in tree[node]:\n        if neighbor != parent_node:\n            dfs(neighbor, node, current_depth + 1)\n\n# Perform DFS to populate depth and parent arrays\ndfs(0, -1, 0)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_lca(a, lca_ab)\n    path_cd = path_to_lca(c, lca_cd)\n    lcp_ab = largest_common_prefix(path_ab, path_cd)\n    results.append(lcp_ab)\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the LCA\ndef path_to_lca(node, lca_node):\n    path = []\n    while node != lca_node:\n        path.append(node)\n        node = parent[node]\n    path.append(lca_node)\n    return path[::-1]\n\n# Function to find the largest common prefix\ndef largest_common_prefix(path1, path2):\n    i = 0\n    while i < len(path1) and i < len(path2) and labels[path1[i]] == labels[path2[i]]:\n        i += 1\n    return i\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, parent_node, depth_node):\n    depth[node] = depth_node\n    parent[node] = parent_node\n    for neighbor in tree[node]:\n        if neighbor != parent_node:\n            dfs(neighbor, node, depth_node + 1)\n\n# Perform DFS to populate depth and parent arrays\ndfs(0, -1, 0)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_lca(a, lca_ab)\n    path_cd = path_to_lca(c, lca_cd)\n    results.append(max(largest_common_prefix(path_ab, path_cd), largest_common_prefix(path_ab, path_cd[::-1]), largest_common_prefix(path_cd, path_ab[::-1])))\n\n# Print results\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(n - 1)]\nm = int(data[2 * n + 1])\nqueries = [(int(data[2 * n + 2 + 4 * i]) - 1, int(data[2 * n + 3 + 4 * i]) - 1, int(data[2 * n + 4 + 4 * i]) - 1, int(data[2 * n + 5 + 4 * i]) - 1) for i in range(m)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the lowest common ancestor (LCA) of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the root\ndef path_to_root(node):\n    path = []\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    return path[::-1]\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, prev):\n    depth[node] = depth[prev] + 1\n    parent[node] = prev\n    for neighbor in tree[node]:\n        if neighbor != prev:\n            dfs(neighbor, node)\n\n# Start DFS from the root (node 0)\ndfs(0, -1)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    lca_ac = lca(a, c)\n    lca_bd = lca(b, d)\n    \n    path_ab = path_to_root(lca_ab)\n    path_cd = path_to_root(lca_cd)\n    path_ac = path_to_root(lca_ac)\n    path_bd = path_to_root(lca_bd)\n    \n    common_prefix_length = 0\n    for i in range(min(len(path_ab), len(path_cd))):\n        if path_ab[i] == path_cd[i]:\n            common_prefix_length += 1\n        else:\n            break\n    \n    for i in range(min(len(path_ac), len(path_bd))):\n        if path_ac[i] == path_bd[i]:\n            common_prefix_length = max(common_prefix_length, i + 1)\n        else:\n            break\n    \n    results.append(common_prefix_length)\n\n# Write results to stdout\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ncharacters = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the lowest common ancestor (LCA) using BFS\ndef find_lca(u, v):\n    visited = [False] * n\n    parent = [-1] * n\n    queue = deque([u])\n    visited[u] = True\n    parent[u] = u\n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = node\n                queue.append(neighbor)\n    path_to_u = []\n    while u != parent[u]:\n        path_to_u.append(u)\n        u = parent[u]\n    path_to_u.append(u)\n    path_to_u.reverse()\n    path_to_v = []\n    while v != parent[v]:\n        path_to_v.append(v)\n        v = parent[v]\n    path_to_v.append(v)\n    path_to_v.reverse()\n    lca = -1\n    for i in range(min(len(path_to_u), len(path_to_v))):\n        if path_to_u[i] == path_to_v[i]:\n            lca = path_to_u[i]\n        else:\n            break\n    return lca\n\n# Function to find the path from a node to the LCA\ndef find_path(node, lca):\n    path = []\n    while node != lca:\n        path.append(node)\n        node = parent[node]\n    path.append(lca)\n    return path\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = find_lca(a, b)\n    lca_cd = find_lca(c, d)\n    path_ab = find_path(a, lca_ab)\n    path_cd = find_path(c, lca_cd)\n    common_prefix_length = 0\n    for char_a, char_c in zip(characters[path_ab], characters[path_cd]):\n        if char_a == char_c:\n            common_prefix_length += 1\n        else:\n            break\n    results.append(common_prefix_length)\n\n# Write results to stdout\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(n - 1)]\nm = int(data[2 * n + 1])\nqueries = [(int(data[2 * n + 2 + 4 * i]) - 1, int(data[2 * n + 3 + 4 * i]) - 1, int(data[2 * n + 4 + 4 * i]) - 1, int(data[2 * n + 5 + 4 * i]) - 1) for i in range(m)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the lowest common ancestor (LCA) using BFS\ndef lca(u, v):\n    parent = [None] * n\n    dist = [-1] * n\n    queue = deque([u])\n    dist[u] = 0\n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[node] + 1\n                parent[neighbor] = node\n                queue.append(neighbor)\n    while u != v:\n        if dist[u] > dist[v]:\n            u = parent[u]\n        else:\n            v = parent[v]\n    return u\n\n# Function to find the length of the largest common prefix of paths (u, v) and (x, y)\ndef largest_common_prefix(u, v, x, y):\n    lca_uv = lca(u, v)\n    lca_xy = lca(x, y)\n    lca_ux = lca(u, x)\n    lca_uy = lca(u, y)\n    lca_vx = lca(v, x)\n    lca_vy = lca(v, y)\n    \n    # Calculate the distances from the LCA to the vertices\n    dist_uv = dist[u] + dist[v] - 2 * dist[lca_uv]\n    dist_xy = dist[x] + dist[y] - 2 * dist[lca_xy]\n    dist_ux = dist[u] + dist[x] - 2 * dist[lca_ux]\n    dist_uy = dist[u] + dist[y] - 2 * dist[lca_uy]\n    dist_vx = dist[v] + dist[x] - 2 * dist[lca_vx]\n    dist_vy = dist[v] + dist[y] - 2 * dist[lca_vy]\n    \n    # Find the maximum common prefix length\n    max_prefix = 0\n    for i in range(min(dist_uv, dist_xy)):\n        if labels[lca_uv + i] == labels[lca_xy + i]:\n            max_prefix += 1\n        else:\n            break\n    for i in range(min(dist_ux, dist_uy)):\n        if labels[lca_ux + i] == labels[lca_uy + i]:\n            max_prefix += 1\n        else:\n            break\n    for i in range(min(dist_vx, dist_vy)):\n        if labels[lca_vx + i] == labels[lca_vy + i]:\n            max_prefix += 1\n        else:\n            break\n    \n    return max_prefix\n\n# Process each query and print the result\nfor a, b, c, d in queries:\n    print(largest_common_prefix(a, b, c, d))",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\ncharacters = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the root\ndef path_to_root(node):\n    path = []\n    while node != -1:\n        path.append(node)\n        node = parent[node]\n    return path[::-1]\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, par):\n    depth[node] = depth[par] + 1\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\n# Start DFS from node 0 (root)\ndfs(0, -1)\n\n# Function to find the largest common prefix of two paths\ndef largest_common_prefix(a, b, c, d):\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_root(a)\n    path_cd = path_to_root(c)\n    \n    # Find the common prefix length between the paths\n    i = 0\n    while i < len(path_ab) and i < len(path_cd) and path_ab[i] == path_cd[i]:\n        i += 1\n    \n    # Check the characters on the path from a to b and c to d\n    prefix_length = 0\n    while a != lca_ab:\n        if characters[a] == characters[c]:\n            prefix_length += 1\n        a = parent[a]\n        c = parent[c]\n    \n    while b != lca_ab:\n        if characters[b] == characters[d]:\n            prefix_length += 1\n        b = parent[b]\n        d = parent[d]\n    \n    return prefix_length\n\n# Process each query and print the result\nfor a, b, c, d in queries:\n    result = largest_common_prefix(a, b, c, d)\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(n - 1)]\nm = int(data[2 * n + 1])\nqueries = [(int(data[2 * n + 2 + 4 * i]) - 1, int(data[2 * n + 3 + 4 * i]) - 1, int(data[2 * n + 4 + 4 * i]) - 1, int(data[2 * n + 5 + 4 * i]) - 1) for i in range(m)]\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the lowest common ancestor (LCA) using BFS\ndef find_lca(u, v):\n    parent = [None] * n\n    visited = [False] * n\n    queue = deque([u])\n    visited[u] = True\n    parent[u] = -1\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = node\n                queue.append(neighbor)\n    \n    path = []\n    while v != -1:\n        path.append(v)\n        v = parent[v]\n    \n    path.reverse()\n    \n    for i in range(min(len(path), len(path))):\n        if path[i] == path[len(path) - i - 1]:\n            return path[i]\n    return -1\n\n# Function to find the longest common prefix of two strings\ndef longest_common_prefix(s1, s2):\n    min_length = min(len(s1), len(s2))\n    for i in range(min_length):\n        if s1[i] != s2[i]:\n            return i\n    return min_length\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = find_lca(a, b)\n    lca_cd = find_lca(c, d)\n    \n    path_ab = []\n    path_cd = []\n    \n    node = a\n    while node != lca_ab:\n        path_ab.append(labels[node])\n        node = parent[node]\n    \n    path_ab.append(labels[lca_ab])\n    \n    node = c\n    while node != lca_cd:\n        path_cd.append(labels[node])\n        node = parent[node]\n    \n    path_cd.append(labels[lca_cd])\n    \n    if lca_ab == lca_cd:\n        results.append(longest_common_prefix(''.join(path_ab), ''.join(path_cd)))\n    else:\n        results.append(0)\n\n# Write results to stdout\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the LCA\ndef path_to_lca(node, lca_node):\n    path = []\n    while node != lca_node:\n        path.append(node)\n        node = parent[node]\n    path.append(lca_node)\n    return path[::-1]\n\n# Function to find the largest common prefix of two strings\ndef longest_common_prefix(s1, s2):\n    min_length = min(len(s1), len(s2))\n    for i in range(min_length):\n        if s1[i] != s2[i]:\n            return i\n    return min_length\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Depth-first search to find depths and parents\ndef dfs(node, parent_node, depth_node):\n    depth[node] = depth_node\n    parent[node] = parent_node\n    for neighbor in tree[node]:\n        if neighbor != parent_node:\n            dfs(neighbor, node, depth_node + 1)\n\n# Start DFS from the root (node 0)\ndfs(0, -1, 0)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_lca(a, lca_ab)\n    path_cd = path_to_lca(c, lca_cd)\n    \n    # Find the common prefix of the paths\n    common_prefix_length = 0\n    for i in range(min(len(path_ab), len(path_cd))):\n        if labels[path_ab[i]] == labels[path_cd[i]]:\n            common_prefix_length += 1\n        else:\n            break\n    \n    results.append(common_prefix_length)\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the LCA\ndef path_to_lca(node, lca_node):\n    path = []\n    while node != lca_node:\n        path.append(node)\n        node = parent[node]\n    path.append(lca_node)\n    return path[::-1]\n\n# Function to find the largest common prefix of two strings\ndef lcp(s1, s2):\n    min_length = min(len(s1), len(s2))\n    for i in range(min_length):\n        if s1[i] != s2[i]:\n            return i\n    return min_length\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, parent_node, depth_node):\n    depth[node] = depth_node\n    parent[node] = parent_node\n    for neighbor in tree[node]:\n        if neighbor != parent_node:\n            dfs(neighbor, node, depth_node + 1)\n\n# Perform DFS to populate depth and parent arrays\ndfs(0, -1, 0)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_lca(a, lca_ab)\n    path_cd = path_to_lca(c, lca_cd)\n    common_prefix_length = 0\n    for i in range(min(len(path_ab), len(path_cd))):\n        if path_ab[i] == path_cd[i]:\n            common_prefix_length += 1\n        else:\n            break\n    results.append(common_prefix_length)\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the LCA\ndef path_to_lca(node, lca_node):\n    path = []\n    while node != lca_node:\n        path.append(node)\n        node = parent[node]\n    path.append(lca_node)\n    return path\n\n# Function to find the largest common prefix\ndef largest_common_prefix(path1, path2):\n    i = 0\n    while i < len(path1) and i < len(path2) and labels[path1[i]] == labels[path2[i]]:\n        i += 1\n    return i\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Depth-first search to find depths and parents\ndef dfs(node, par, d):\n    depth[node] = d\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node, d + 1)\n\n# Start DFS from the root (node 0)\ndfs(0, -1, 0)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_lca(a, lca_ab)\n    path_cd = path_to_lca(c, lca_cd)\n    results.append(max(largest_common_prefix(path_ab, path_cd), largest_common_prefix(path_ab[::-1], path_cd[::-1])))\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the LCA\ndef path_to_lca(node, lca_node):\n    path = []\n    while node != lca_node:\n        path.append(node)\n        node = parent[node]\n    path.append(lca_node)\n    return path[::-1]\n\n# Function to find the largest common prefix of two paths\ndef largest_common_prefix(path1, path2):\n    i = 0\n    while i < len(path1) and i < len(path2) and labels[path1[i]] == labels[path2[i]]:\n        i += 1\n    return i\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, parent_node, current_depth):\n    depth[node] = current_depth\n    parent[node] = parent_node\n    for neighbor in tree[node]:\n        if neighbor != parent_node:\n            dfs(neighbor, node, current_depth + 1)\n\n# Perform DFS to populate depth and parent arrays\ndfs(0, -1, 0)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_lca(a, lca_ab)\n    path_cd = path_to_lca(c, lca_cd)\n    lcp_ab = largest_common_prefix(path_ab, path_cd)\n    results.append(lcp_ab)\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nlabels = data[1]\nedges = []\nindex = 2\nfor _ in range(n - 1):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\nm = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(m):\n    a = int(data[index]) - 1\n    b = int(data[index + 1]) - 1\n    c = int(data[index + 2]) - 1\n    d = int(data[index + 3]) - 1\n    queries.append((a, b, c, d))\n    index += 4\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to find the LCA of two nodes\ndef lca(u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    while depth[u] > depth[v]:\n        u = parent[u]\n    while u != v:\n        u = parent[u]\n        v = parent[v]\n    return u\n\n# Function to find the path from a node to the LCA\ndef path_to_lca(node, lca_node):\n    path = []\n    while node != lca_node:\n        path.append(node)\n        node = parent[node]\n    path.append(lca_node)\n    return path[::-1]\n\n# Function to find the largest common prefix\ndef largest_common_prefix(path1, path2):\n    i = 0\n    while i < len(path1) and i < len(path2) and labels[path1[i]] == labels[path2[i]]:\n        i += 1\n    return i\n\n# Initialize depth and parent arrays\ndepth = [-1] * n\nparent = [-1] * n\n\n# Function to perform DFS and populate depth and parent arrays\ndef dfs(node, parent_node, depth_node):\n    depth[node] = depth_node\n    parent[node] = parent_node\n    for neighbor in tree[node]:\n        if neighbor != parent_node:\n            dfs(neighbor, node, depth_node + 1)\n\n# Perform DFS to populate depth and parent arrays\ndfs(0, -1, 0)\n\n# Process each query\nresults = []\nfor a, b, c, d in queries:\n    lca_ab = lca(a, b)\n    lca_cd = lca(c, d)\n    path_ab = path_to_lca(a, lca_ab)\n    path_cd = path_to_lca(c, lca_cd)\n    results.append(max(largest_common_prefix(path_ab, path_cd), largest_common_prefix(path_ab, path_cd[::-1]), largest_common_prefix(path_cd, path_ab[::-1])))\n\n# Print results\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Mr. Kitayuta's Colorful Graph",
        "question_content": "Mr. Kitayuta has just bought an undirected graph with n vertices and m edges. The vertices of the graph are numbered from 1 to n. Each edge, namely edge i, has a color ci, connecting vertex ai and bi.\n\nMr. Kitayuta wants you to process the following q queries.\n\nIn the i-th query, he gives you two integers - ui and vi.\n\nFind the number of the colors that satisfy the following condition: the edges of that color connect vertex ui and vertex vi directly or indirectly.\n\n\nInput Format\nThe first line of the input contains space-separated two integers - n and m(2 \u2264 n \u2264 105, 1 \u2264 m \u2264 105), denoting the number of the vertices and the number of the edges, respectively.\n\nThe next m lines contain space-separated three integers - ai, bi(1 \u2264 ai < bi \u2264 n) and ci(1 \u2264 ci \u2264 m). Note that there can be multiple edges between two vertices. However, there are no multiple edges of the same color between two vertices, that is, if i \u2260 j, (ai, bi, ci) \u2260 (aj, bj, cj).\n\nThe next line contains a integer- q(1 \u2264 q \u2264 105), denoting the number of the queries.\n\nThen follows q lines, containing space-separated two integers - ui and vi(1 \u2264 ui, vi \u2264 n). It is guaranteed that ui \u2260 vi.\n\n\nOutput Format\nFor each query, print the answer in a separate line.\n\n\nSample Input 1\n\n4 5\n1 2 1\n1 2 2\n2 3 1\n2 3 3\n2 4 3\n3\n1 2\n3 4\n1 4\n\nSample Output 1\n\n2\n1\n0\n\n\nSample Input 2\n\n5 7\n1 5 1\n2 5 1\n3 5 1\n4 5 1\n1 2 2\n2 3 2\n3 4 2\n5\n1 5\n5 1\n2 5\n1 5\n1 4\n\nSample Output 2\n\n1\n1\n1\n1\n2\n\n\nNote\nLet's consider the first sample.\n\nThe figure above shows the first sample.\n\n- Vertex 1 and vertex 2 are connected by color 1 and 2.\n- Vertex 3 and vertex 4 are connected by color 3.\n- Vertex 1 and vertex 4 are not connected by any single color.",
        "platform": "codeforces",
        "question_id": "506/D",
        "contest_id": "506",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    ai = int(data[index])\n    bi = int(data[index + 1])\n    ci = int(data[index + 2])\n    edges.append((ai, bi, ci))\n    index += 3\n\nq = int(data[index])\nindex += 1\nqueries = []\nfor _ in range(q):\n    ui = int(data[index])\n    vi = int(data[index + 1])\n    queries.append((ui, vi))\n    index += 2\n\n# Build the graph\ngraph = defaultdict(list)\nfor ai, bi, ci in edges:\n    graph[ai].append((bi, ci))\n    graph[bi].append((ai, ci))\n\n# Function to find all colors connecting u and v\ndef find_colors(u, v):\n    colors = set()\n    visited = set()\n    queue = deque([(u, set())])\n    \n    while queue:\n        node, current_colors = queue.popleft()\n        if node == v:\n            colors.update(current_colors)\n            continue\n        if node in visited:\n            continue\n        visited.add(node)\n        for neighbor, color in graph[node]:\n            if color not in current_colors:\n                queue.append((neighbor, current_colors.union({color})))\n    \n    return colors\n\n# Process each query\nresults = []\nfor ui, vi in queries:\n    results.append(len(find_colors(ui, vi)))\n\n# Output the results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nm = int(data[index + 1])\nindex += 2\n\nedges = defaultdict(list)\ncolor_map = defaultdict(list)\n\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    color_map[(ai, bi)].append(ci)\n    color_map[(bi, ai)].append(ci)\n    index += 3\n\nq = int(data[index])\nindex += 1\n\nqueries = []\nfor _ in range(q):\n    ui = int(data[index]) - 1\n    vi = int(data[index + 1]) - 1\n    queries.append((ui, vi))\n    index += 2\n\n# Function to find all colors connecting u and v\ndef find_colors(u, v):\n    visited = set()\n    colors = set()\n    queue = deque([u])\n    visited.add(u)\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in edges[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                for color in color_map[(node, neighbor)]:\n                    colors.add(color)\n    \n    return colors\n\n# Process each query\nresults = []\nfor u, v in queries:\n    colors = find_colors(u, v)\n    results.append(len(colors))\n\n# Output results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nm = int(data[index + 1])\nindex += 2\n\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ci].add(ai)\n    colors[ci].add(bi)\n    index += 3\n\nq = int(data[index])\nindex += 1\n\n# Process queries\nresults = []\nfor _ in range(q):\n    ui = int(data[index]) - 1\n    vi = int(data[index + 1]) - 1\n    index += 2\n    \n    connected_colors = set()\n    visited = set()\n    \n    def bfs(start):\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in edges[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    connected_colors.update(colors[neighbor])\n    \n    bfs(ui)\n    results.append(len(connected_colors - {ui, vi}))\n\n# Output results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = defaultdict(list)\nfor i in range(m):\n    ai = int(data[3 + 3 * i]) - 1\n    bi = int(data[4 + 3 * i]) - 1\n    ci = int(data[5 + 3 * i])\n    edges[ai].append((bi, ci))\n    edges[bi].append((ai, ci))\n\nq = int(data[3 + 3 * m])\nqueries = [(int(data[4 + 3 * m + 2 * i]) - 1, int(data[5 + 3 * m + 2 * i]) - 1) for i in range(q)]\n\nresults = []\n\nfor ui, vi in queries:\n    visited = set()\n    color_count = defaultdict(int)\n    queue = deque([(ui, None)])\n    \n    while queue:\n        node, color = queue.popleft()\n        if node in visited:\n            continue\n        visited.add(node)\n        if color is not None:\n            color_count[color] += 1\n        \n        for neighbor, edge_color in edges[node]:\n            if neighbor not in visited:\n                queue.append((neighbor, edge_color))\n    \n    results.append(len(color_count))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nm = int(data[index + 1])\nindex += 2\n\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ci].add(ai)\n    colors[ci].add(bi)\n    index += 3\n\nq = int(data[index])\nindex += 1\n\n# Process queries\nresults = []\nfor _ in range(q):\n    ui = int(data[index]) - 1\n    vi = int(data[index + 1]) - 1\n    index += 2\n    \n    # Find all colors that connect ui and vi directly or indirectly\n    visited = set()\n    queue = deque([ui])\n    connected_colors = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node in visited:\n            continue\n        visited.add(node)\n        \n        for neighbor in edges[node]:\n            if neighbor == vi:\n                connected_colors.update(colors)\n                break\n            if neighbor not in visited:\n                queue.append(neighbor)\n    \n    results.append(len(connected_colors))\n\n# Write output to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nindex = 2\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ci].add(ai)\n    colors[ci].add(bi)\n    index += 3\n\nq = int(data[index])\nqueries = []\nfor _ in range(q):\n    ui = int(data[index + 1]) - 1\n    vi = int(data[index + 2]) - 1\n    queries.append((ui, vi))\n    index += 3\n\ndef bfs(start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in edges[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return False\n\nresults = []\nfor ui, vi in queries:\n    connected_colors = set()\n    for color in colors:\n        if bfs(ui, vi):\n            connected_colors.add(color)\n    results.append(len(connected_colors))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nm = int(data[index + 1])\nindex += 2\n\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ci].add(ai)\n    colors[ci].add(bi)\n    index += 3\n\nq = int(data[index])\nindex += 1\n\n# Process queries\nresults = []\nfor _ in range(q):\n    ui = int(data[index]) - 1\n    vi = int(data[index + 1]) - 1\n    index += 2\n    \n    # Find all colors that connect ui and vi directly or indirectly\n    visited = set()\n    queue = deque([ui])\n    connected_colors = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node in visited:\n            continue\n        visited.add(node)\n        \n        for neighbor in edges[node]:\n            if neighbor == vi:\n                connected_colors.update(colors)\n                break\n            if neighbor not in visited:\n                queue.append(neighbor)\n    \n    results.append(len(connected_colors))\n\n# Write output to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nindex = 2\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ai].add(ci)\n    colors[bi].add(ci)\n    index += 3\n\nq = int(data[index])\nqueries = []\nfor _ in range(q):\n    ui = int(data[index + 1]) - 1\n    vi = int(data[index + 2]) - 1\n    queries.append((ui, vi))\n    index += 3\n\ndef bfs(start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in edges[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return False\n\nresults = []\nfor ui, vi in queries:\n    common_colors = set(colors[ui]) & set(colors[vi])\n    count = 0\n    for color in common_colors:\n        if bfs(ui, vi, color):\n            count += 1\n    results.append(count)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = defaultdict(list)\n    colors = defaultdict(set)\n    \n    for _ in range(m):\n        ai = int(data[index]) - 1\n        bi = int(data[index + 1]) - 1\n        ci = int(data[index + 2])\n        edges[ai].append(bi)\n        edges[bi].append(ai)\n        colors[ci].add(ai)\n        colors[ci].add(bi)\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(q):\n        ui = int(data[index]) - 1\n        vi = int(data[index + 1]) - 1\n        index += 2\n        \n        visited = set()\n        queue = deque([ui])\n        connected_colors = set()\n        \n        while queue:\n            node = queue.popleft()\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in edges[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    connected_colors.update(colors[neighbor])\n        \n        results.append(len(connected_colors))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nindex = 2\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ai].add(ci)\n    colors[bi].add(ci)\n    index += 3\n\nq = int(data[index])\nqueries = [(int(data[index + 2 * i]) - 1, int(data[index + 2 * i + 1]) - 1) for i in range(q)]\n\ndef bfs(start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    color_set = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return color_set\n        for neighbor in edges[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                color_set.update(colors[neighbor])\n                queue.append(neighbor)\n    \n    return color_set\n\nresults = []\nfor u, v in queries:\n    result = bfs(u, v)\n    results.append(len(result))\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    ai = int(data[index])\n    bi = int(data[index + 1])\n    ci = int(data[index + 2])\n    edges.append((ai, bi, ci))\n    index += 3\n\nq = int(data[index])\nindex += 1\nqueries = []\nfor _ in range(q):\n    ui = int(data[index])\n    vi = int(data[index + 1])\n    queries.append((ui, vi))\n    index += 2\n\n# Build the graph\ngraph = defaultdict(list)\nfor ai, bi, ci in edges:\n    graph[ai].append((bi, ci))\n    graph[bi].append((ai, ci))\n\n# Function to find all colors connecting u and v\ndef find_colors(u, v):\n    colors = set()\n    visited = set()\n    queue = deque([(u, set())])\n    \n    while queue:\n        node, current_colors = queue.popleft()\n        if node == v:\n            colors.update(current_colors)\n            continue\n        if node in visited:\n            continue\n        visited.add(node)\n        for neighbor, color in graph[node]:\n            if color not in current_colors:\n                queue.append((neighbor, current_colors.union({color})))\n    \n    return colors\n\n# Process each query\nresults = []\nfor ui, vi in queries:\n    results.append(len(find_colors(ui, vi)))\n\n# Output the results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nm = int(data[index + 1])\nindex += 2\n\nedges = defaultdict(list)\ncolor_map = defaultdict(list)\n\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    color_map[(ai, bi)].append(ci)\n    color_map[(bi, ai)].append(ci)\n    index += 3\n\nq = int(data[index])\nindex += 1\n\nqueries = []\nfor _ in range(q):\n    ui = int(data[index]) - 1\n    vi = int(data[index + 1]) - 1\n    queries.append((ui, vi))\n    index += 2\n\n# Function to find all colors connecting u and v\ndef find_colors(u, v):\n    visited = set()\n    colors = set()\n    queue = deque([u])\n    visited.add(u)\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in edges[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                for color in color_map[(node, neighbor)]:\n                    colors.add(color)\n    \n    return colors\n\n# Process each query\nresults = []\nfor u, v in queries:\n    colors = find_colors(u, v)\n    results.append(len(colors))\n\n# Output results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nm = int(data[index + 1])\nindex += 2\n\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ci].add(ai)\n    colors[ci].add(bi)\n    index += 3\n\nq = int(data[index])\nindex += 1\n\n# Process queries\nresults = []\nfor _ in range(q):\n    ui = int(data[index]) - 1\n    vi = int(data[index + 1]) - 1\n    index += 2\n    \n    connected_colors = set()\n    visited = set()\n    \n    def bfs(start):\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in edges[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    connected_colors.update(colors[neighbor])\n    \n    bfs(ui)\n    results.append(len(connected_colors - {ui, vi}))\n\n# Output results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = defaultdict(list)\nfor i in range(m):\n    ai = int(data[3 + 3 * i]) - 1\n    bi = int(data[4 + 3 * i]) - 1\n    ci = int(data[5 + 3 * i])\n    edges[ai].append((bi, ci))\n    edges[bi].append((ai, ci))\n\nq = int(data[3 + 3 * m])\nqueries = [(int(data[4 + 3 * m + 2 * i]) - 1, int(data[5 + 3 * m + 2 * i]) - 1) for i in range(q)]\n\nresults = []\n\nfor ui, vi in queries:\n    visited = set()\n    color_count = defaultdict(int)\n    queue = deque([(ui, None)])\n    \n    while queue:\n        node, color = queue.popleft()\n        if node in visited:\n            continue\n        visited.add(node)\n        if color is not None:\n            color_count[color] += 1\n        \n        for neighbor, edge_color in edges[node]:\n            if neighbor not in visited:\n                queue.append((neighbor, edge_color))\n    \n    results.append(len(color_count))\n\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nm = int(data[index + 1])\nindex += 2\n\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ci].add(ai)\n    colors[ci].add(bi)\n    index += 3\n\nq = int(data[index])\nindex += 1\n\n# Process queries\nresults = []\nfor _ in range(q):\n    ui = int(data[index]) - 1\n    vi = int(data[index + 1]) - 1\n    index += 2\n    \n    # Find all colors that connect ui and vi directly or indirectly\n    visited = set()\n    queue = deque([ui])\n    connected_colors = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node in visited:\n            continue\n        visited.add(node)\n        \n        for neighbor in edges[node]:\n            if neighbor == vi:\n                connected_colors.update(colors)\n                break\n            if neighbor not in visited:\n                queue.append(neighbor)\n    \n    results.append(len(connected_colors))\n\n# Write output to stdout\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nindex = 2\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ci].add(ai)\n    colors[ci].add(bi)\n    index += 3\n\nq = int(data[index])\nqueries = []\nfor _ in range(q):\n    ui = int(data[index + 1]) - 1\n    vi = int(data[index + 2]) - 1\n    queries.append((ui, vi))\n    index += 3\n\ndef bfs(start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in edges[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return False\n\nresults = []\nfor ui, vi in queries:\n    connected_colors = set()\n    for color in colors:\n        if bfs(ui, vi):\n            connected_colors.add(color)\n    results.append(len(connected_colors))\n\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nindex = 0\nn = int(data[index])\nm = int(data[index + 1])\nindex += 2\n\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ci].add(ai)\n    colors[ci].add(bi)\n    index += 3\n\nq = int(data[index])\nindex += 1\n\n# Process queries\nresults = []\nfor _ in range(q):\n    ui = int(data[index]) - 1\n    vi = int(data[index + 1]) - 1\n    index += 2\n    \n    # Find all colors that connect ui and vi directly or indirectly\n    visited = set()\n    queue = deque([ui])\n    connected_colors = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node in visited:\n            continue\n        visited.add(node)\n        \n        for neighbor in edges[node]:\n            if neighbor == vi:\n                connected_colors.update(colors)\n                break\n            if neighbor not in visited:\n                queue.append(neighbor)\n    \n    results.append(len(connected_colors))\n\n# Write output to stdout\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nindex = 2\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ai].add(ci)\n    colors[bi].add(ci)\n    index += 3\n\nq = int(data[index])\nqueries = []\nfor _ in range(q):\n    ui = int(data[index + 1]) - 1\n    vi = int(data[index + 2]) - 1\n    queries.append((ui, vi))\n    index += 3\n\ndef bfs(start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        current = queue.popleft()\n        if current == end:\n            return True\n        for neighbor in edges[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return False\n\nresults = []\nfor ui, vi in queries:\n    common_colors = set(colors[ui]) & set(colors[vi])\n    count = 0\n    for color in common_colors:\n        if bfs(ui, vi, color):\n            count += 1\n    results.append(count)\n\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = defaultdict(list)\n    colors = defaultdict(set)\n    \n    for _ in range(m):\n        ai = int(data[index]) - 1\n        bi = int(data[index + 1]) - 1\n        ci = int(data[index + 2])\n        edges[ai].append(bi)\n        edges[bi].append(ai)\n        colors[ci].add(ai)\n        colors[ci].add(bi)\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(q):\n        ui = int(data[index]) - 1\n        vi = int(data[index + 1]) - 1\n        index += 2\n        \n        visited = set()\n        queue = deque([ui])\n        connected_colors = set()\n        \n        while queue:\n            node = queue.popleft()\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in edges[node]:\n                if neighbor not in visited:\n                    queue.append(neighbor)\n                    connected_colors.update(colors[neighbor])\n        \n        results.append(len(connected_colors))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = defaultdict(list)\ncolors = defaultdict(set)\n\nindex = 2\nfor _ in range(m):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2])\n    edges[ai].append(bi)\n    edges[bi].append(ai)\n    colors[ai].add(ci)\n    colors[bi].add(ci)\n    index += 3\n\nq = int(data[index])\nqueries = [(int(data[index + 2 * i]) - 1, int(data[index + 2 * i + 1]) - 1) for i in range(q)]\n\ndef bfs(start, end):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n    color_set = set()\n    \n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return color_set\n        for neighbor in edges[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                color_set.update(colors[neighbor])\n                queue.append(neighbor)\n    \n    return color_set\n\nresults = []\nfor u, v in queries:\n    result = bfs(u, v)\n    results.append(len(result))\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Sums of Digits",
        "question_content": "Vasya had a strictly increasing sequence of positive integers a1, ..., an. Vasya used it to build a new sequence b1, ..., bn, where bi is the sum of digits of ai's decimal representation. Then sequence ai got lost and all that remained is sequence bi.\n\nVasya wonders what the numbers ai could be like. Of all the possible options he likes the one sequence with the minimum possible last number an. Help Vasya restore the initial sequence.\n\nIt is guaranteed that such a sequence always exists.\n\n\nInput Format\nThe first line contains a single integer number n (1 \u2264 n \u2264 300).\n\nNext n lines contain integer numbers b1, ..., bn \u00a0\u2014 the required sums of digits. All bi belong to the range 1 \u2264 bi \u2264 300.\n\n\nOutput Format\nPrint n integer numbers, one per line\u00a0\u2014 the correct option for numbers ai, in order of following in sequence. The sequence should be strictly increasing. The sum of digits of the i-th number should be equal to bi.\n\nIf there are multiple sequences with least possible number an, print any of them. Print the numbers without leading zeroes.\n\n\nSample Input 1\n\n3\n1\n2\n3\n\nSample Output 1\n\n1\n2\n3\n\n\nSample Input 2\n\n3\n3\n2\n1\n\nSample Output 2\n\n3\n11\n100",
        "platform": "codeforces",
        "question_id": "509/C",
        "contest_id": "509",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements\nn = int(data[0])\n\n# List of sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the result list\na = []\n\n# Function to find the smallest number with a given sum of digits\ndef find_number_with_sum(sum_digits):\n    if sum_digits == 0:\n        return 0\n    num = 0\n    while sum_digits > 0:\n        num = num * 10 + 1\n        sum_digits -= 1\n    return num\n\n# Construct the sequence a\nfor sum_digits in b:\n    a.append(find_number_with_sum(sum_digits))\n\n# Print the result\nfor num in a:\n    print(num)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements\nn = int(data[0])\n\n# List of sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the result list\na = []\n\n# Function to find the smallest number with a given sum of digits\ndef smallest_number_with_sum(sum_digits):\n    if sum_digits == 0:\n        return 0\n    if sum_digits <= 9:\n        return sum_digits\n    num = 0\n    while sum_digits > 0:\n        num = num * 10 + 9\n        sum_digits -= 9\n    return num\n\n# Construct the sequence a\nfor sum_digits in b:\n    a.append(smallest_number_with_sum(sum_digits))\n\n# Print the result\nfor num in a:\n    print(num)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements in the sequence\nn = int(data[0])\n\n# List of sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the sequence a\na = [0] * n\n\n# Function to calculate the sum of digits of a number\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\n# Initialize the first element of the sequence\na[0] = b[0]\n\n# Fill the sequence a\nfor i in range(1, n):\n    # Start with the smallest possible number that has the required sum of digits\n    candidate = a[i-1] + 1\n    while sum_of_digits(candidate) != b[i]:\n        candidate += 1\n    a[i] = candidate\n\n# Print the sequence a\nfor num in a:\n    print(num)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef find_min_sequence(b):\n    n = len(b)\n    a = [0] * n\n    a[0] = b[0]\n    for i in range(1, n):\n        current_sum = b[i]\n        num = 0\n        while current_sum > 0:\n            num = num * 10 + 1\n            current_sum -= 1\n        a[i] = num\n    return a\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nb = list(map(int, data[1:]))\n\n# Find the minimum sequence\na = find_min_sequence(b)\n\n# Print the result\nfor num in a:\n    print(num)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements in the sequence\nn = int(data[0])\n\n# List to store the sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the sequence a with the first element being the smallest number with sum of digits b[0]\na = [b[0]]\n\n# Function to find the smallest number with a given sum of digits\ndef smallest_number_with_sum_of_digits(sum_of_digits):\n    if sum_of_digits == 0:\n        return 0\n    if sum_of_digits == 1:\n        return 1\n    num = 0\n    while sum_of_digits > 0:\n        num = num * 10 + 9\n        sum_of_digits -= 9\n    return num\n\n# Generate the sequence a\nfor i in range(1, n):\n    next_sum = b[i]\n    next_number = smallest_number_with_sum_of_digits(next_sum)\n    while not (a[-1] < next_number):\n        next_number += 1\n    a.append(next_number)\n\n# Print the sequence a\nfor num in a:\n    print(num)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef restore_sequence(b):\n    n = len(b)\n    a = [0] * n\n    a[0] = b[0]\n    for i in range(1, n):\n        current_sum = b[i]\n        current_number = 0\n        while current_sum > 0:\n            current_number = current_number * 10 + 1\n            current_sum -= 1\n        a[i] = current_number\n    return a\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nb = list(map(int, data[1:]))\n\n# Restore the sequence\na = restore_sequence(b)\n\n# Print the result\nfor num in a:\n    print(num)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements in the sequence\nn = int(data[0])\n\n# List of sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the sequence a\na = []\n\n# Function to find the smallest number with a given sum of digits\ndef find_number_with_sum(sum_of_digits):\n    if sum_of_digits == 1:\n        return 1\n    if sum_of_digits == 2:\n        return 2\n    if sum_of_digits == 3:\n        return 3\n    if sum_of_digits == 4:\n        return 4\n    if sum_of_digits == 5:\n        return 5\n    if sum_of_digits == 6:\n        return 6\n    if sum_of_digits == 7:\n        return 7\n    if sum_of_digits == 8:\n        return 8\n    if sum_of_digits == 9:\n        return 9\n    if sum_of_digits == 10:\n        return 11\n    if sum_of_digits == 11:\n        return 20\n    if sum_of_digits == 12:\n        return 30\n    if sum_of_digits == 13:\n        return 40\n    if sum_of_digits == 14:\n        return 50\n    if sum_of_digits == 15:\n        return 60\n    if sum_of_digits == 16:\n        return 70\n    if sum_of_digits == 17:\n        return 80\n    if sum_of_digits == 18:\n        return 90\n    if sum_of_digits == 19:\n        return 100\n    if sum_of_digits == 20:\n        return 110\n    if sum_of_digits == 21:\n        return 200\n    if sum_of_digits == 22:\n        return 300\n    if sum_of_digits == 23:\n        return 400\n    if sum_of_digits == 24:\n        return 500\n    if sum_of_digits == 25:\n        return 600\n    if sum_of_digits == 26:\n        return 700\n    if sum_of_digits == 27:\n        return 800\n    if sum_of_digits == 28:\n        return 900\n    if sum_of_digits == 29:\n        return 1000\n    if sum_of_digits == 30:\n        return 1100\n    if sum_of_digits == 31:\n        return 2000\n    if sum_of_digits == 32:\n        return 3000\n    if sum_of_digits == 33:\n        return 4000\n    if sum_of_digits == 34:\n        return 5000\n    if sum_of_digits == 35:\n        return 6000\n    if sum_of_digits == 36:\n        return 7000\n    if sum_of_digits == 37:\n        return 8000\n    if sum_of_digits == 38:\n        return 9000\n    if sum_of_digits == 39:\n        return 10000\n    if sum_of_digits == 40:\n        return 11000\n    if sum_of_digits == 41:\n        return 20000\n    if sum_of_digits == 42:\n        return 30000\n    if sum_of_digits == 43:\n        return 40000\n    if sum_of_digits == 44:\n        return 50000\n    if sum_of_digits == 45:\n        return 60000\n    if sum_of_digits == 46:\n        return 70000\n    if sum_of_digits == 47:\n        return 80000\n    if sum_of_digits == 48:\n        return 90000\n    if sum_of_digits == 49:\n        return 100000\n    if sum_of_digits == 50:\n        return 110000\n    if sum_of_digits == 51:\n        return 200000\n    if sum_of_digits == 52:\n        return 300000\n    if sum_of_digits == 53:\n        return 400000\n    if sum_of_digits == 54:\n        return 500000\n    if sum_of_digits == 55:\n        return 600000\n    if sum_of_digits == 56:\n        return 700000\n    if sum_of_digits == 57:\n        return 800000\n    if sum_of_digits == 58:\n        return 900000\n    if sum_of_digits == 59:\n        return 1000000\n    if sum_of_digits == 60:\n        return 1100000\n    if sum_of_digits == 61:\n        return 2000000\n    if sum_of_digits == 62:\n        return 3000000\n    if sum_of_digits == 63:\n        return 4000000\n    if sum_of_digits == 64:\n        return 5000000\n    if sum_of_digits == 65:\n        return 6000000\n    if sum_of_digits == 66:\n        return 7000000\n    if sum_of_digits == 67:\n        return 8000000\n    if sum_of_digits == 68:\n        return 9000000\n    if sum_of_digits == 69:\n        return 10000000\n    if sum_of_digits == 70:\n        return 11000000\n    if sum_of_digits == 71:\n        return 20000000\n    if sum_of_digits == 72:\n        return 30000000\n    if sum_of_digits == 73:\n        return 40000000\n    if sum_of_digits == 74:\n        return 50000000\n    if sum_of_digits == 75:\n        return 60000000\n    if sum_of_digits == 76:\n        return 70000000\n    if sum_of_digits == 77:\n        return 80000000\n    if sum_of_digits == 78:\n        return 90000000\n    if sum_of_digits == 79:\n        return 100000000\n    if sum_of_digits == 80:\n        return 110000000\n    if sum_of_digits == 81:\n        return 200000000\n    if sum_of_digits == 82:\n        return 300000000\n    if sum_of_digits == 83:\n        return 400000000\n    if sum_of_digits == 84:\n        return 500000000\n    if sum_of_digits == 85:\n        return 600000000\n    if sum_of_digits == 86:\n        return 700000000\n    if sum_of_digits == 87:\n        return 800000000\n    if sum_of_digits == 88:\n        return 900000000\n    if sum_of_digits == 89:\n        return 1000000000\n    if sum_of_digits == 90:\n        return 1100000000\n    if sum_of_digits == 91:\n        return 2000000000\n    if sum_of_digits == 92:\n        return 3000000000\n    if sum_of_digits == 93:\n        return 4000000000\n    if sum_of_digits == 94:\n        return 5000000000\n    if sum_of_digits == 95:\n        return 6000000000\n    if sum_of_digits == 96:\n        return 7000000000\n    if sum_of_digits == 97:\n        return 8000000000\n    if sum_of_digits == 98:\n        return 9000000",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements in the sequence\nn = int(data[0])\n\n# List to store the sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the sequence a with the smallest possible values\na = [0] * n\n\n# Function to calculate the sum of digits of a number\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\n# Iterate from the end of the sequence to the beginning\nfor i in range(n-1, -1, -1):\n    # Start with the smallest possible number whose sum of digits is b[i]\n    a[i] = b[i]\n    # Adjust the number to ensure the sequence is strictly increasing\n    while i > 0 and a[i] <= a[i-1]:\n        a[i] += 9\n        a[i-1] += 1\n\n# Print the sequence a\nfor num in a:\n    print(num)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements\nn = int(data[0])\n\n# List of sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the result list\na = []\n\n# Function to find the smallest number with a given sum of digits\ndef find_number_with_sum(sum_digits):\n    if sum_digits == 0:\n        return 0\n    if sum_digits <= 9:\n        return sum_digits\n    return 10 + find_number_with_sum(sum_digits - 10)\n\n# Fill the result list\nfor i in range(n):\n    a.append(find_number_with_sum(b[i]))\n\n# Print the result\nfor num in a:\n    print(num)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements in the sequence\nn = int(data[0])\n\n# List to store the sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the sequence a with the smallest possible values\na = [0] * n\n\n# Function to calculate the sum of digits of a number\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\n# Iterate to find the sequence a\nfor i in range(n):\n    # Start with the smallest possible number that has the required sum of digits\n    a[i] = b[i]\n    while sum_of_digits(a[i]) != b[i]:\n        a[i] += 1\n\n# Ensure the sequence is strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        a[i] = a[i - 1] + 1\n\n# Print the sequence a\nfor num in a:\n    print(num)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements\nn = int(data[0])\n\n# List of sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the result list\na = []\n\n# Function to find the smallest number with a given sum of digits\ndef find_number_with_sum(sum_digits):\n    if sum_digits == 0:\n        return 0\n    num = 0\n    while sum_digits > 0:\n        num = num * 10 + 1\n        sum_digits -= 1\n    return num\n\n# Construct the sequence a\nfor sum_digits in b:\n    a.append(find_number_with_sum(sum_digits))\n\n# Print the result\nfor num in a:\n    print(num)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements\nn = int(data[0])\n\n# List of sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the result list\na = []\n\n# Function to find the smallest number with a given sum of digits\ndef smallest_number_with_sum(sum_digits):\n    if sum_digits == 0:\n        return 0\n    if sum_digits <= 9:\n        return sum_digits\n    num = 0\n    while sum_digits > 0:\n        num = num * 10 + 9\n        sum_digits -= 9\n    return num\n\n# Construct the sequence a\nfor sum_digits in b:\n    a.append(smallest_number_with_sum(sum_digits))\n\n# Print the result\nfor num in a:\n    print(num)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements in the sequence\nn = int(data[0])\n\n# List of sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the sequence a\na = [0] * n\n\n# Function to calculate the sum of digits of a number\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\n# Initialize the first element of the sequence\na[0] = b[0]\n\n# Fill the sequence a\nfor i in range(1, n):\n    # Start with the smallest possible number that has the required sum of digits\n    candidate = a[i-1] + 1\n    while sum_of_digits(candidate) != b[i]:\n        candidate += 1\n    a[i] = candidate\n\n# Print the sequence a\nfor num in a:\n    print(num)",
            "# YOUR CODE HERE\nimport sys\n\ndef find_min_sequence(b):\n    n = len(b)\n    a = [0] * n\n    a[0] = b[0]\n    for i in range(1, n):\n        current_sum = b[i]\n        num = 0\n        while current_sum > 0:\n            num = num * 10 + 1\n            current_sum -= 1\n        a[i] = num\n    return a\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nb = list(map(int, data[1:]))\n\n# Find the minimum sequence\na = find_min_sequence(b)\n\n# Print the result\nfor num in a:\n    print(num)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements in the sequence\nn = int(data[0])\n\n# List to store the sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the sequence a with the first element being the smallest number with sum of digits b[0]\na = [b[0]]\n\n# Function to find the smallest number with a given sum of digits\ndef smallest_number_with_sum_of_digits(sum_of_digits):\n    if sum_of_digits == 0:\n        return 0\n    if sum_of_digits == 1:\n        return 1\n    num = 0\n    while sum_of_digits > 0:\n        num = num * 10 + 9\n        sum_of_digits -= 9\n    return num\n\n# Generate the sequence a\nfor i in range(1, n):\n    next_sum = b[i]\n    next_number = smallest_number_with_sum_of_digits(next_sum)\n    while not (a[-1] < next_number):\n        next_number += 1\n    a.append(next_number)\n\n# Print the sequence a\nfor num in a:\n    print(num)",
            "# YOUR CODE HERE\nimport sys\n\ndef restore_sequence(b):\n    n = len(b)\n    a = [0] * n\n    a[0] = b[0]\n    for i in range(1, n):\n        current_sum = b[i]\n        current_number = 0\n        while current_sum > 0:\n            current_number = current_number * 10 + 1\n            current_sum -= 1\n        a[i] = current_number\n    return a\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nb = list(map(int, data[1:]))\n\n# Restore the sequence\na = restore_sequence(b)\n\n# Print the result\nfor num in a:\n    print(num)",
            "",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements in the sequence\nn = int(data[0])\n\n# List to store the sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the sequence a with the smallest possible values\na = [0] * n\n\n# Function to calculate the sum of digits of a number\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\n# Iterate from the end of the sequence to the beginning\nfor i in range(n-1, -1, -1):\n    # Start with the smallest possible number whose sum of digits is b[i]\n    a[i] = b[i]\n    # Adjust the number to ensure the sequence is strictly increasing\n    while i > 0 and a[i] <= a[i-1]:\n        a[i] += 9\n        a[i-1] += 1\n\n# Print the sequence a\nfor num in a:\n    print(num)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements\nn = int(data[0])\n\n# List of sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the result list\na = []\n\n# Function to find the smallest number with a given sum of digits\ndef find_number_with_sum(sum_digits):\n    if sum_digits == 0:\n        return 0\n    if sum_digits <= 9:\n        return sum_digits\n    return 10 + find_number_with_sum(sum_digits - 10)\n\n# Fill the result list\nfor i in range(n):\n    a.append(find_number_with_sum(b[i]))\n\n# Print the result\nfor num in a:\n    print(num)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of elements in the sequence\nn = int(data[0])\n\n# List to store the sums of digits\nb = list(map(int, data[1:]))\n\n# Initialize the sequence a with the smallest possible values\na = [0] * n\n\n# Function to calculate the sum of digits of a number\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\n# Iterate to find the sequence a\nfor i in range(n):\n    # Start with the smallest possible number that has the required sum of digits\n    a[i] = b[i]\n    while sum_of_digits(a[i]) != b[i]:\n        a[i] += 1\n\n# Ensure the sequence is strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        a[i] = a[i - 1] + 1\n\n# Print the sequence a\nfor num in a:\n    print(num)"
        ]
    },
    {
        "question_title": "Closest Equals",
        "question_content": "You are given sequence a1, a2, ..., an and m queries lj, rj (1 \u2264 lj \u2264 rj \u2264 n). For each query you need to print the minimum distance between such pair of elements ax and ay (x \u2260 y), that:\n\n- both indexes of the elements lie within range [lj, rj], that is, lj \u2264 x, y \u2264 rj;\n- the values of the elements are equal, that is ax = ay.\n\nThe text above understands distance as |x - y|.\n\n\nInput Format\nThe first line of the input contains a pair of integers n, m (1 \u2264 n, m \u2264 5\u00b7105) \u2014 the length of the sequence and the number of queries, correspondingly.\n\nThe second line contains the sequence of integers a1, a2, ..., an ( - 109 \u2264 ai \u2264 109).\n\nNext m lines contain the queries, one per line. Each query is given by a pair of numbers lj, rj (1 \u2264 lj \u2264 rj \u2264 n) \u2014 the indexes of the query range limits.\n\n\nOutput Format\nPrint m integers \u2014 the answers to each query. If there is no valid match for some query, please print -1 as an answer to this query.\n\n\nSample Input 1\n\n5 3\n1 1 2 3 2\n1 5\n2 4\n3 5\n\nSample Output 1\n\n1\n-1\n2\n\n\nSample Input 2\n\n6 5\n1 2 1 3 2 3\n4 6\n1 3\n2 5\n2 4\n1 6\n\nSample Output 2\n\n2\n2\n3\n-1\n2",
        "platform": "codeforces",
        "question_id": "522/D",
        "contest_id": "522",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    found = False\n    \n    for i in range(lj-1, rj):\n        x = a[i]\n        if last_seen[x] != -1:\n            dist = i - last_seen[x]\n            if dist < min_dist:\n                min_dist = dist\n                found = True\n        last_seen[x] = i\n    \n    return min_dist if found else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Process each query\nresults = []\nfor lj, rj in queries:\n    # Find all occurrences of each element in the range [lj, rj]\n    element_indices = defaultdict(list)\n    for i in range(lj-1, rj):\n        element_indices[a[i]].append(i)\n    \n    # Calculate the minimum distance for each element\n    min_distance = float('inf')\n    for indices in element_indices.values():\n        if len(indices) > 1:\n            for i in range(len(indices)-1):\n                for j in range(i+1, len(indices)):\n                    min_distance = min(min_distance, abs(indices[i] - indices[j]))\n    \n    # If no valid match was found, set the result to -1\n    if min_distance == float('inf'):\n        results.append(-1)\n    else:\n        results.append(min_distance)\n\n# Print the results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    \n    for i in range(lj-1, rj):\n        x = a[i]\n        if last_seen[x] != -1:\n            min_dist = min(min_dist, i - last_seen[x])\n        last_seen[x] = i\n    \n    return min_dist if min_dist != float('inf') else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    \n    for i in range(lj-1, rj):\n        x = a[i]\n        if last_seen[x] != -1:\n            min_dist = min(min_dist, i - last_seen[x])\n        last_seen[x] = i\n    \n    return min_dist if min_dist != float('inf') else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    found = False\n    \n    for i in range(lj - 1, rj):\n        if a[i] in last_seen:\n            dist = i - last_seen[a[i]]\n            if dist < min_dist:\n                min_dist = dist\n                found = True\n        last_seen[a[i]] = i\n    \n    return min_dist if found else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    \n    for i in range(lj - 1, rj):\n        x = a[i]\n        if last_seen[x] != -1:\n            min_dist = min(min_dist, i - last_seen[x])\n        last_seen[x] = i\n    \n    return min_dist if min_dist != float('inf') else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\nsequence = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    \n    for i in range(lj - 1, rj):\n        x = sequence[i]\n        if last_seen[x] != -1:\n            min_dist = min(min_dist, i - last_seen[x])\n        last_seen[x] = i\n    \n    return min_dist if min_dist != float('inf') else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\nresults = []\n\nfor lj, rj in queries:\n    min_distance = float('inf')\n    seen = defaultdict(list)\n    \n    for i in range(lj-1, rj):\n        if a[i] in seen:\n            for prev_index in seen[a[i]]:\n                distance = abs(i - prev_index)\n                if distance < min_distance:\n                    min_distance = distance\n        seen[a[i]].append(i)\n    \n    if min_distance == float('inf'):\n        results.append(-1)\n    else:\n        results.append(min_distance)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\nsequence = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef find_min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_distance = float('inf')\n    \n    for i in range(lj-1, rj):\n        x = sequence[i]\n        if last_seen[x] != -1:\n            min_distance = min(min_distance, i - last_seen[x])\n        last_seen[x] = i\n    \n    return min_distance if min_distance != float('inf') else -1\n\n# Process each query and print the result\nresults = [find_min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    found = False\n    \n    for i in range(lj - 1, rj):\n        if a[i] in last_seen:\n            dist = i - last_seen[a[i]]\n            if dist < min_dist:\n                min_dist = dist\n                found = True\n        last_seen[a[i]] = i\n    \n    return min_dist if found else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    found = False\n    \n    for i in range(lj-1, rj):\n        x = a[i]\n        if last_seen[x] != -1:\n            dist = i - last_seen[x]\n            if dist < min_dist:\n                min_dist = dist\n                found = True\n        last_seen[x] = i\n    \n    return min_dist if found else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Process each query\nresults = []\nfor lj, rj in queries:\n    # Find all occurrences of each element in the range [lj, rj]\n    element_indices = defaultdict(list)\n    for i in range(lj-1, rj):\n        element_indices[a[i]].append(i)\n    \n    # Calculate the minimum distance for each element\n    min_distance = float('inf')\n    for indices in element_indices.values():\n        if len(indices) > 1:\n            for i in range(len(indices)-1):\n                for j in range(i+1, len(indices)):\n                    min_distance = min(min_distance, abs(indices[i] - indices[j]))\n    \n    # If no valid match was found, set the result to -1\n    if min_distance == float('inf'):\n        results.append(-1)\n    else:\n        results.append(min_distance)\n\n# Print the results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    \n    for i in range(lj-1, rj):\n        x = a[i]\n        if last_seen[x] != -1:\n            min_dist = min(min_dist, i - last_seen[x])\n        last_seen[x] = i\n    \n    return min_dist if min_dist != float('inf') else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    \n    for i in range(lj-1, rj):\n        x = a[i]\n        if last_seen[x] != -1:\n            min_dist = min(min_dist, i - last_seen[x])\n        last_seen[x] = i\n    \n    return min_dist if min_dist != float('inf') else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    found = False\n    \n    for i in range(lj - 1, rj):\n        if a[i] in last_seen:\n            dist = i - last_seen[a[i]]\n            if dist < min_dist:\n                min_dist = dist\n                found = True\n        last_seen[a[i]] = i\n    \n    return min_dist if found else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    \n    for i in range(lj - 1, rj):\n        x = a[i]\n        if last_seen[x] != -1:\n            min_dist = min(min_dist, i - last_seen[x])\n        last_seen[x] = i\n    \n    return min_dist if min_dist != float('inf') else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\nsequence = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    \n    for i in range(lj - 1, rj):\n        x = sequence[i]\n        if last_seen[x] != -1:\n            min_dist = min(min_dist, i - last_seen[x])\n        last_seen[x] = i\n    \n    return min_dist if min_dist != float('inf') else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\nresults = []\n\nfor lj, rj in queries:\n    min_distance = float('inf')\n    seen = defaultdict(list)\n    \n    for i in range(lj-1, rj):\n        if a[i] in seen:\n            for prev_index in seen[a[i]]:\n                distance = abs(i - prev_index)\n                if distance < min_distance:\n                    min_distance = distance\n        seen[a[i]].append(i)\n    \n    if min_distance == float('inf'):\n        results.append(-1)\n    else:\n        results.append(min_distance)\n\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\nsequence = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef find_min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_distance = float('inf')\n    \n    for i in range(lj-1, rj):\n        x = sequence[i]\n        if last_seen[x] != -1:\n            min_distance = min(min_distance, i - last_seen[x])\n        last_seen[x] = i\n    \n    return min_distance if min_distance != float('inf') else -1\n\n# Process each query and print the result\nresults = [find_min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\n# Function to find the minimum distance for a given query\ndef min_distance(lj, rj):\n    # Dictionary to store the last seen index of each element\n    last_seen = defaultdict(lambda: -1)\n    min_dist = float('inf')\n    found = False\n    \n    for i in range(lj - 1, rj):\n        if a[i] in last_seen:\n            dist = i - last_seen[a[i]]\n            if dist < min_dist:\n                min_dist = dist\n                found = True\n        last_seen[a[i]] = i\n    \n    return min_dist if found else -1\n\n# Process each query and print the result\nresults = [min_distance(lj, rj) for lj, rj in queries]\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "A Simple Task",
        "question_content": "This task is very simple. Given a string S of length n and q queries each query is on the format i j k which means sort the substring consisting of the characters from i to j in non-decreasing order if k = 1 or in non-increasing order if k = 0.\n\nOutput the final string after applying the queries.\n\n\nInput Format\nThe first line will contain two integers n, q (1 \u2264 n \u2264 105, 0 \u2264 q \u2264 50 000), the length of the string and the number of queries respectively.\n\nNext line contains a string S itself. It contains only lowercase English letters.\n\nNext q lines will contain three integers each i, j, k (1 \u2264 i \u2264 j \u2264 n, k \\in \\{0, 1\\}).\n\n\nOutput Format\nOutput one line, the string S after applying the queries.\n\n\nSample Input 1\n\n10 5\nabacdabcda\n7 10 0\n5 8 1\n1 4 0\n3 6 0\n7 10 1\n\nSample Output 1\n\ncbcaaaabdd\n\n\nSample Input 2\n\n10 1\nagjucbvdfk\n1 10 1\n\nSample Output 2\n\nabcdfgjkuv\n\n\nNote\nFirst sample test explanation:\n\nabacda \\rightarrow abacdacba\n\naba cd adc ba \\rightarrow aba cac dd d ba\n\nabacacddba \\rightarrow cbaaacaddbac\n\ncbaaacddba \\rightarrow cbcaaaadba\n\ncbcaaaadba \\rightarrow cbcaaaabdd",
        "platform": "codeforces",
        "question_id": "558/E",
        "contest_id": "558",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    if k == 1:\n        s = s[:i] + ''.join(sorted(s[i:j+1])) + s[j+1:]\n    else:\n        s = s[:i] + ''.join(sorted(s[i:j+1], reverse=True)) + s[j+1:]\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 0:\n        substring = ''.join(sorted(substring, reverse=True))\n    else:\n        substring = ''.join(sorted(substring))\n    s = s[:i] + substring + s[j+1:]\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 1:\n        sorted_substring = ''.join(sorted(substring))\n    else:\n        sorted_substring = ''.join(sorted(substring, reverse=True))\n    s = s[:i] + sorted_substring + s[j+1:]\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    if k == 1:\n        s = s[:i] + ''.join(sorted(s[i:j+1])) + s[j+1:]\n    else:\n        s = s[:i] + ''.join(sorted(s[i:j+1], reverse=True)) + s[j+1:]\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 0:\n        substring = ''.join(sorted(substring, reverse=True))\n    else:\n        substring = ''.join(sorted(substring))\n    s = s[:i] + substring + s[j+1:]\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    if k == 1:\n        s = s[:i] + ''.join(sorted(s[i:j+1])) + s[j+1:]\n    else:\n        s = s[:i] + ''.join(sorted(s[i:j+1], reverse=True)) + s[j+1:]\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 1:\n        substring = ''.join(sorted(substring))\n    else:\n        substring = ''.join(sorted(substring, reverse=True))\n    s = s[:i] + substring + s[j+1:]\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 1:\n        sorted_substring = ''.join(sorted(substring))\n    else:\n        sorted_substring = ''.join(sorted(substring, reverse=True))\n    s = s[:i] + sorted_substring + s[j+1:]\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 1:\n        sorted_substring = ''.join(sorted(substring))\n    else:\n        sorted_substring = ''.join(sorted(substring, reverse=True))\n    s = s[:i] + sorted_substring + s[j+1:]\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 0:\n        sorted_substring = ''.join(sorted(substring, reverse=True))\n    else:\n        sorted_substring = ''.join(sorted(substring))\n    s = s[:i] + sorted_substring + s[j+1:]\n\nprint(s)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    if k == 1:\n        s = s[:i] + ''.join(sorted(s[i:j+1])) + s[j+1:]\n    else:\n        s = s[:i] + ''.join(sorted(s[i:j+1], reverse=True)) + s[j+1:]\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 0:\n        substring = ''.join(sorted(substring, reverse=True))\n    else:\n        substring = ''.join(sorted(substring))\n    s = s[:i] + substring + s[j+1:]\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 1:\n        sorted_substring = ''.join(sorted(substring))\n    else:\n        sorted_substring = ''.join(sorted(substring, reverse=True))\n    s = s[:i] + sorted_substring + s[j+1:]\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    if k == 1:\n        s = s[:i] + ''.join(sorted(s[i:j+1])) + s[j+1:]\n    else:\n        s = s[:i] + ''.join(sorted(s[i:j+1], reverse=True)) + s[j+1:]\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 0:\n        substring = ''.join(sorted(substring, reverse=True))\n    else:\n        substring = ''.join(sorted(substring))\n    s = s[:i] + substring + s[j+1:]\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    if k == 1:\n        s = s[:i] + ''.join(sorted(s[i:j+1])) + s[j+1:]\n    else:\n        s = s[:i] + ''.join(sorted(s[i:j+1], reverse=True)) + s[j+1:]\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 1:\n        substring = ''.join(sorted(substring))\n    else:\n        substring = ''.join(sorted(substring, reverse=True))\n    s = s[:i] + substring + s[j+1:]\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 1:\n        sorted_substring = ''.join(sorted(substring))\n    else:\n        sorted_substring = ''.join(sorted(substring, reverse=True))\n    s = s[:i] + sorted_substring + s[j+1:]\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 1:\n        sorted_substring = ''.join(sorted(substring))\n    else:\n        sorted_substring = ''.join(sorted(substring, reverse=True))\n    s = s[:i] + sorted_substring + s[j+1:]\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\ns = data[2]\n\nqueries = []\nfor i in range(q):\n    i = int(data[3 + 3 * i]) - 1\n    j = int(data[4 + 3 * i]) - 1\n    k = int(data[5 + 3 * i])\n    queries.append((i, j, k))\n\nfor i, j, k in queries:\n    substring = s[i:j+1]\n    if k == 0:\n        sorted_substring = ''.join(sorted(substring, reverse=True))\n    else:\n        sorted_substring = ''.join(sorted(substring))\n    s = s[:i] + sorted_substring + s[j+1:]\n\nprint(s)"
        ]
    },
    {
        "question_title": "Minimization",
        "question_content": "You've got array A, consisting of n integers and a positive integer k. Array A is indexed by integers from 1 to n.\n\nYou need to permute the array elements so that value\n\n\\sum_{i=1}^{n-k}|A[i]-A[i+k]|\n\n\nInput Format\nThe first line contains two integers n, k (2 \u2264 n \u2264 3\u00b7105, 1 \u2264 k \u2264 min(5000, n - 1)).\n\nThe second line contains n integers A[1], A[2], ..., A[n] ( - 109 \u2264 A[i] \u2264 109), separate by spaces \u2014 elements of the array A.\n\n\nOutput Format\nPrint the minimum possible value of the sum described in the statement.\n\n\nSample Input 1\n\n3 2\n1 2 4\n\nSample Output 1\n\n1\n\n\nSample Input 2\n\n5 2\n3 -5 3 -5 3\n\nSample Output 2\n\n0\n\n\nSample Input 3\n\n6 3\n4 3 4 3 2 5\n\nSample Output 3\n\n3\n\n\nNote\nIn the first test one of the optimal permutations is 1\u00a04\u00a02.\n\nIn the second test the initial order is optimal.\n\nIn the third test one of the optimal permutations is 2\u00a03\u00a04\u00a04\u00a03\u00a05.",
        "platform": "codeforces",
        "question_id": "571/B",
        "contest_id": "571",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap based on the indices\n    heap = []\n    for i in range(n):\n        heapq.heappush(heap, (values[i][1], values[i][0]))\n    \n    # Calculate the initial sum\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Try to minimize the sum by swapping elements\n    min_sum = current_sum\n    for i in range(k, n):\n        # Remove the element at index i-k from the heap\n        _, value = heapq.heappop(heap)\n        # Add the element at index i to the heap\n        heapq.heappush(heap, (values[i][1], values[i][0]))\n        # Calculate the new sum\n        new_sum = current_sum - abs(value - values[i - k][0]) + abs(values[i][0] - values[i - k][0])\n        # Update the minimum sum\n        min_sum = min(min_sum, new_sum)\n        # Update the current sum for the next iteration\n        current_sum = new_sum\n    \n    return min_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Print the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap based on the indices\n    heap = []\n    for i in range(n):\n        heapq.heappush(heap, (values[i][1], values[i][0]))\n    \n    # Initialize the result\n    result = 0\n    \n    # Calculate the initial sum of absolute differences\n    for i in range(n - k):\n        result += abs(values[i][0] - values[i + k][0])\n    \n    # Sliding window to find the minimum sum\n    for i in range(n - k, n):\n        result += abs(values[i][0] - values[i - k][0])\n        result -= abs(values[i - k][0] - values[i - k + k][0])\n    \n    return result\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap to keep track of the k smallest elements\n    min_heap = []\n    for i in range(k):\n        heapq.heappush(min_heap, values[i])\n    \n    # Calculate the initial sum of absolute differences\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Try to find a better permutation by swapping elements\n    best_sum = current_sum\n    for i in range(k, n):\n        # Remove the smallest element from the heap\n        smallest = heapq.heappop(min_heap)\n        # Calculate the new sum of absolute differences\n        new_sum = current_sum - abs(smallest[0] - values[i - k][0]) + abs(values[i][0] - smallest[0])\n        # Update the best sum if the new sum is smaller\n        best_sum = min(best_sum, new_sum)\n        # Add the new element to the heap\n        heapq.heappush(min_heap, values[i])\n        # Update the current sum\n        current_sum = new_sum\n    \n    return best_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_permutation_sum(n: int, k: int, A: List[int]) -> int:\n    A.sort()\n    return sum(abs(A[i] - A[i + k]) for i in range(n - k))\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = min_permutation_sum(n, k, A)\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_permutation_sum(n: int, k: int, A: List[int]) -> int:\n    A.sort()\n    return sum(abs(A[i] - A[i + k]) for i in range(n - k))\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = min_permutation_sum(n, k, A)\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap to keep track of the k smallest elements\n    min_heap = []\n    for i in range(k):\n        heapq.heappush(min_heap, values[i])\n    \n    # Calculate the initial sum of absolute differences\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Try to find a better permutation by swapping elements\n    best_sum = current_sum\n    for i in range(k, n):\n        # Remove the smallest element from the heap\n        smallest = heapq.heappop(min_heap)\n        # Add the next element to the heap\n        heapq.heappush(min_heap, values[i])\n        # Update the current sum\n        current_sum += abs(values[i][0] - smallest[0]) - abs(values[i - k][0] - smallest[0])\n        # Update the best sum if the current sum is smaller\n        best_sum = min(best_sum, current_sum)\n    \n    return best_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap to keep track of the k smallest elements\n    min_heap = []\n    for i in range(k):\n        heapq.heappush(min_heap, values[i])\n    \n    # Calculate the initial sum of absolute differences\n    initial_sum = 0\n    for i in range(k, n):\n        initial_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Initialize the minimum sum to the initial sum\n    min_sum = initial_sum\n    \n    # Slide the window of size k across the array\n    for i in range(k, n):\n        # Remove the element that is no longer in the window\n        removed_value, removed_index = heapq.heappop(min_heap)\n        # Add the new element to the window\n        heapq.heappush(min_heap, values[i])\n        # Update the sum of absolute differences\n        new_sum = min_sum - abs(removed_value - values[removed_index + k - 1][0]) + abs(values[i][0] - values[i - k][0])\n        # Update the minimum sum\n        min_sum = min(min_sum, new_sum)\n    \n    return min_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap to keep track of the k smallest elements\n    min_heap = []\n    for i in range(k):\n        heapq.heappush(min_heap, values[i])\n    \n    # Calculate the initial sum of absolute differences\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Try to find a better permutation by swapping elements\n    best_sum = current_sum\n    for i in range(k, n):\n        # Remove the smallest element from the heap\n        smallest = heapq.heappop(min_heap)\n        # Add the next element to the heap\n        heapq.heappush(min_heap, values[i])\n        # Update the current sum\n        current_sum += abs(values[i][0] - smallest[0]) - abs(values[i - k][0] - smallest[0])\n        # Update the best sum\n        best_sum = min(best_sum, current_sum)\n    \n    return best_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap to keep track of the k smallest elements\n    min_heap = []\n    for i in range(k):\n        heapq.heappush(min_heap, values[i])\n    \n    # Calculate the initial sum of absolute differences\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i-k][0])\n    \n    # Initialize the result with the initial sum\n    result = current_sum\n    \n    # Slide the window of size k across the array\n    for i in range(k, n):\n        # Remove the element that is sliding out of the window\n        out_of_window = values[i-k]\n        heapq.heappush(min_heap, out_of_window)\n        \n        # Add the new element that is sliding into the window\n        in_of_window = values[i]\n        heapq.heappush(min_heap, in_of_window)\n        \n        # Calculate the new sum of absolute differences\n        new_sum = current_sum - abs(out_of_window[0] - out_of_window[1]) + abs(in_of_window[0] - in_of_window[1])\n        \n        # Update the result with the minimum sum\n        result = min(result, new_sum)\n        \n        # Update the current sum for the next iteration\n        current_sum = new_sum\n    \n    return result\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Print the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap based on the index\n    heap = []\n    for i in range(n):\n        heapq.heappush(heap, (values[i][1], values[i][0]))\n    \n    # Calculate the initial sum\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Try to minimize the sum by swapping elements\n    min_sum = current_sum\n    for i in range(k, n):\n        # Remove the element at index i-k from the heap\n        _, value = heapq.heappop(heap)\n        # Add the element at index i to the heap\n        heapq.heappush(heap, (values[i][1], values[i][0]))\n        # Calculate the new sum\n        new_sum = current_sum - abs(value - values[i - k][0]) + abs(values[i][0] - values[i - k][0])\n        # Update the minimum sum\n        min_sum = min(min_sum, new_sum)\n        # Update the current sum for the next iteration\n        current_sum = new_sum\n    \n    return min_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Print the result to stdout\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap based on the indices\n    heap = []\n    for i in range(n):\n        heapq.heappush(heap, (values[i][1], values[i][0]))\n    \n    # Calculate the initial sum\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Try to minimize the sum by swapping elements\n    min_sum = current_sum\n    for i in range(k, n):\n        # Remove the element at index i-k from the heap\n        _, value = heapq.heappop(heap)\n        # Add the element at index i to the heap\n        heapq.heappush(heap, (values[i][1], values[i][0]))\n        # Calculate the new sum\n        new_sum = current_sum - abs(value - values[i - k][0]) + abs(values[i][0] - values[i - k][0])\n        # Update the minimum sum\n        min_sum = min(min_sum, new_sum)\n        # Update the current sum for the next iteration\n        current_sum = new_sum\n    \n    return min_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Print the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap based on the indices\n    heap = []\n    for i in range(n):\n        heapq.heappush(heap, (values[i][1], values[i][0]))\n    \n    # Initialize the result\n    result = 0\n    \n    # Calculate the initial sum of absolute differences\n    for i in range(n - k):\n        result += abs(values[i][0] - values[i + k][0])\n    \n    # Sliding window to find the minimum sum\n    for i in range(n - k, n):\n        result += abs(values[i][0] - values[i - k][0])\n        result -= abs(values[i - k][0] - values[i - k + k][0])\n    \n    return result\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap to keep track of the k smallest elements\n    min_heap = []\n    for i in range(k):\n        heapq.heappush(min_heap, values[i])\n    \n    # Calculate the initial sum of absolute differences\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Try to find a better permutation by swapping elements\n    best_sum = current_sum\n    for i in range(k, n):\n        # Remove the smallest element from the heap\n        smallest = heapq.heappop(min_heap)\n        # Calculate the new sum of absolute differences\n        new_sum = current_sum - abs(smallest[0] - values[i - k][0]) + abs(values[i][0] - smallest[0])\n        # Update the best sum if the new sum is smaller\n        best_sum = min(best_sum, new_sum)\n        # Add the new element to the heap\n        heapq.heappush(min_heap, values[i])\n        # Update the current sum\n        current_sum = new_sum\n    \n    return best_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nfrom typing import List\n\ndef min_permutation_sum(n: int, k: int, A: List[int]) -> int:\n    A.sort()\n    return sum(abs(A[i] - A[i + k]) for i in range(n - k))\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = min_permutation_sum(n, k, A)\nprint(result)",
            "import sys\nfrom typing import List\n\ndef min_permutation_sum(n: int, k: int, A: List[int]) -> int:\n    A.sort()\n    return sum(abs(A[i] - A[i + k]) for i in range(n - k))\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = min_permutation_sum(n, k, A)\nprint(result)",
            "import sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap to keep track of the k smallest elements\n    min_heap = []\n    for i in range(k):\n        heapq.heappush(min_heap, values[i])\n    \n    # Calculate the initial sum of absolute differences\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Try to find a better permutation by swapping elements\n    best_sum = current_sum\n    for i in range(k, n):\n        # Remove the smallest element from the heap\n        smallest = heapq.heappop(min_heap)\n        # Add the next element to the heap\n        heapq.heappush(min_heap, values[i])\n        # Update the current sum\n        current_sum += abs(values[i][0] - smallest[0]) - abs(values[i - k][0] - smallest[0])\n        # Update the best sum if the current sum is smaller\n        best_sum = min(best_sum, current_sum)\n    \n    return best_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap to keep track of the k smallest elements\n    min_heap = []\n    for i in range(k):\n        heapq.heappush(min_heap, values[i])\n    \n    # Calculate the initial sum of absolute differences\n    initial_sum = 0\n    for i in range(k, n):\n        initial_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Initialize the minimum sum to the initial sum\n    min_sum = initial_sum\n    \n    # Slide the window of size k across the array\n    for i in range(k, n):\n        # Remove the element that is no longer in the window\n        removed_value, removed_index = heapq.heappop(min_heap)\n        # Add the new element to the window\n        heapq.heappush(min_heap, values[i])\n        # Update the sum of absolute differences\n        new_sum = min_sum - abs(removed_value - values[removed_index + k - 1][0]) + abs(values[i][0] - values[i - k][0])\n        # Update the minimum sum\n        min_sum = min(min_sum, new_sum)\n    \n    return min_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap to keep track of the k smallest elements\n    min_heap = []\n    for i in range(k):\n        heapq.heappush(min_heap, values[i])\n    \n    # Calculate the initial sum of absolute differences\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Try to find a better permutation by swapping elements\n    best_sum = current_sum\n    for i in range(k, n):\n        # Remove the smallest element from the heap\n        smallest = heapq.heappop(min_heap)\n        # Add the next element to the heap\n        heapq.heappush(min_heap, values[i])\n        # Update the current sum\n        current_sum += abs(values[i][0] - smallest[0]) - abs(values[i - k][0] - smallest[0])\n        # Update the best sum\n        best_sum = min(best_sum, current_sum)\n    \n    return best_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap to keep track of the k smallest elements\n    min_heap = []\n    for i in range(k):\n        heapq.heappush(min_heap, values[i])\n    \n    # Calculate the initial sum of absolute differences\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i-k][0])\n    \n    # Initialize the result with the initial sum\n    result = current_sum\n    \n    # Slide the window of size k across the array\n    for i in range(k, n):\n        # Remove the element that is sliding out of the window\n        out_of_window = values[i-k]\n        heapq.heappush(min_heap, out_of_window)\n        \n        # Add the new element that is sliding into the window\n        in_of_window = values[i]\n        heapq.heappush(min_heap, in_of_window)\n        \n        # Calculate the new sum of absolute differences\n        new_sum = current_sum - abs(out_of_window[0] - out_of_window[1]) + abs(in_of_window[0] - in_of_window[1])\n        \n        # Update the result with the minimum sum\n        result = min(result, new_sum)\n        \n        # Update the current sum for the next iteration\n        current_sum = new_sum\n    \n    return result\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Print the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\ndef min_permutation_sum(n, k, A):\n    # Create a list of tuples (value, index)\n    values = [(A[i], i) for i in range(n)]\n    # Sort the list by value\n    values.sort()\n    \n    # Create a min-heap based on the index\n    heap = []\n    for i in range(n):\n        heapq.heappush(heap, (values[i][1], values[i][0]))\n    \n    # Calculate the initial sum\n    current_sum = 0\n    for i in range(k, n):\n        current_sum += abs(values[i][0] - values[i - k][0])\n    \n    # Try to minimize the sum by swapping elements\n    min_sum = current_sum\n    for i in range(k, n):\n        # Remove the element at index i-k from the heap\n        _, value = heapq.heappop(heap)\n        # Add the element at index i to the heap\n        heapq.heappush(heap, (values[i][1], values[i][0]))\n        # Calculate the new sum\n        new_sum = current_sum - abs(value - values[i - k][0]) + abs(values[i][0] - values[i - k][0])\n        # Update the minimum sum\n        min_sum = min(min_sum, new_sum)\n        # Update the current sum for the next iteration\n        current_sum = new_sum\n    \n    return min_sum\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nA = list(map(int, data[2:]))\n\n# Calculate the minimum permutation sum\nresult = min_permutation_sum(n, k, A)\n\n# Print the result to stdout\nprint(result)"
        ]
    },
    {
        "question_title": "Robots protection",
        "question_content": "Company \"Robots industries\" produces robots for territory protection. Robots protect triangle territories \u2014 right isosceles triangles with catheti parallel to North-South and East-West directions.\n\nOwner of some land buys and sets robots on his territory to protect it. From time to time, businessmen want to build offices on that land and want to know how many robots will guard it. You are to handle these queries.\n\n\nInput Format\nThe first line contains integer N \u2014 width and height of the land, and integer Q \u2014 number of queries to handle.\n\nNext Q lines contain queries you need to process.\n\nTwo types of queries:\n\n1. 1 dir x y len \u2014 add a robot to protect a triangle. Depending on the value of dir, the values of x, y and len represent a different triangle: dir = 1: Triangle is defined by the points (x, y), (x + len, y), (x, y + len) dir = 2: Triangle is defined by the points (x, y), (x + len, y), (x, y - len) dir = 3: Triangle is defined by the points (x, y), (x - len, y), (x, y + len) dir = 4: Triangle is defined by the points (x, y), (x - len, y), (x, y - len)\n2. 2 x y \u2014 output how many robots guard this point (robot guards a point if the point is inside or on the border of its triangle)\n\n- 1 \u2264 N \u2264 5000\n- 1 \u2264 Q \u2264 105\n- 1 \u2264 dir \u2264 4\n- All points of triangles are within range [1, N]\n- All numbers are positive integers\n\n\nOutput Format\nFor each second type query output how many robots guard this point. Each answer should be in a separate line.\n\n\nSample Input 1\n\n17 10\n1 1 3 2 4\n1 3 10 3 7\n1 2 6 8 2\n1 3 9 4 2\n2 4 4\n1 4 15 10 6\n2 7 7\n2 9 4\n2 12 2\n2 13 8\n\nSample Output 1\n\n2\n2\n2\n0\n1",
        "platform": "codeforces",
        "question_id": "575/I",
        "contest_id": "575",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\n# Initialize a 2D array to keep track of robot coverage\ncoverage = [[0] * (N + 1) for _ in range(N + 1)]\n\n# Process each query\nfor query in queries:\n    query_type, *params = query\n    if query_type == 1:\n        dir, x, y, len = params\n        if dir == 1:\n            for i in range(x, x + len + 1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 2:\n            for i in range(x, x + len + 1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n        elif dir == 3:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 4:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n    elif query_type == 2:\n        x, y = params\n        print(coverage[x][y])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_inside_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobot_triangles = []\n\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robot_triangles.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robot_triangles.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robot_triangles.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robot_triangles.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for triangle in robot_triangles:\n            if is_inside_triangle(x, y, *triangle[0], *triangle[1], *triangle[2]):\n                count += 1\n        print(count)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_point_in_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobots = []\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robots.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robots.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robots.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robots.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for robot in robots:\n            if is_point_in_triangle(x, y, *robot):\n                count += 1\n        print(count)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_point_in_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\ndef process_queries(N, queries):\n    robots = []\n    for query in queries:\n        if query[0] == 1:\n            dir = query[1]\n            x = query[2]\n            y = query[3]\n            len = query[4]\n            if dir == 1:\n                robots.append(((x, y), (x + len, y), (x, y + len)))\n            elif dir == 2:\n                robots.append(((x, y), (x + len, y), (x, y - len)))\n            elif dir == 3:\n                robots.append(((x, y), (x - len, y), (x, y + len)))\n            elif dir == 4:\n                robots.append(((x, y), (x - len, y), (x, y - len)))\n        elif query[0] == 2:\n            x = query[1]\n            y = query[2]\n            count = 0\n            for robot in robots:\n                if is_point_in_triangle(x, y, *robot):\n                    count += 1\n            print(count)\n\nprocess_queries(N, queries)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_point_in_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobots = []\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robots.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robots.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robots.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robots.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for robot in robots:\n            if is_point_in_triangle(x, y, *robot):\n                count += 1\n        print(count)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_point_in_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobot_triangles = []\n\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robot_triangles.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robot_triangles.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robot_triangles.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robot_triangles.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for triangle in robot_triangles:\n            if is_point_in_triangle(x, y, *triangle[0], *triangle[1], *triangle[2]):\n                count += 1\n        print(count)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_inside_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobot_triangles = []\n\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robot_triangles.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robot_triangles.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robot_triangles.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robot_triangles.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for triangle in robot_triangles:\n            if is_inside_triangle(x, y, *triangle[0], *triangle[1], *triangle[2]):\n                count += 1\n        print(count)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\n# Initialize a 2D array to keep track of robot coverage\ncoverage = [[0] * (N + 1) for _ in range(N + 1)]\n\n# Process each query\nfor query in queries:\n    query_type, x, y, *params = query\n    if query_type == 1:\n        dir, len = params\n        if dir == 1:\n            for i in range(x, x + len + 1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 2:\n            for i in range(x, x + len + 1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n        elif dir == 3:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 4:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n    elif query_type == 2:\n        print(coverage[x][y])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\n# Initialize a 2D array to keep track of robot coverage\ncoverage = [[0] * (N + 1) for _ in range(N + 1)]\n\n# Process each query\nfor query in queries:\n    query_type, *params = query\n    if query_type == 1:\n        dir, x, y, len = params\n        if dir == 1:\n            for i in range(x, x + len + 1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 2:\n            for i in range(x, x + len + 1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n        elif dir == 3:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 4:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n    elif query_type == 2:\n        x, y = params\n        print(coverage[x][y])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_point_in_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobot_triangles = []\n\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robot_triangles.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robot_triangles.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robot_triangles.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robot_triangles.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for triangle in robot_triangles:\n            if is_point_in_triangle(x, y, *triangle[0], *triangle[1], *triangle[2]):\n                count += 1\n        print(count)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\n# Initialize a 2D array to keep track of robot coverage\ncoverage = [[0] * (N + 1) for _ in range(N + 1)]\n\n# Process each query\nfor query in queries:\n    query_type, *params = query\n    if query_type == 1:\n        dir, x, y, len = params\n        if dir == 1:\n            for i in range(x, x + len + 1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 2:\n            for i in range(x, x + len + 1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n        elif dir == 3:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 4:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n    elif query_type == 2:\n        x, y = params\n        print(coverage[x][y])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_inside_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobot_triangles = []\n\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robot_triangles.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robot_triangles.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robot_triangles.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robot_triangles.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for triangle in robot_triangles:\n            if is_inside_triangle(x, y, *triangle[0], *triangle[1], *triangle[2]):\n                count += 1\n        print(count)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_point_in_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobots = []\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robots.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robots.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robots.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robots.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for robot in robots:\n            if is_point_in_triangle(x, y, *robot):\n                count += 1\n        print(count)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_point_in_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\ndef process_queries(N, queries):\n    robots = []\n    for query in queries:\n        if query[0] == 1:\n            dir = query[1]\n            x = query[2]\n            y = query[3]\n            len = query[4]\n            if dir == 1:\n                robots.append(((x, y), (x + len, y), (x, y + len)))\n            elif dir == 2:\n                robots.append(((x, y), (x + len, y), (x, y - len)))\n            elif dir == 3:\n                robots.append(((x, y), (x - len, y), (x, y + len)))\n            elif dir == 4:\n                robots.append(((x, y), (x - len, y), (x, y - len)))\n        elif query[0] == 2:\n            x = query[1]\n            y = query[2]\n            count = 0\n            for robot in robots:\n                if is_point_in_triangle(x, y, *robot):\n                    count += 1\n            print(count)\n\nprocess_queries(N, queries)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_point_in_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobots = []\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robots.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robots.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robots.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robots.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for robot in robots:\n            if is_point_in_triangle(x, y, *robot):\n                count += 1\n        print(count)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_point_in_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobot_triangles = []\n\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robot_triangles.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robot_triangles.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robot_triangles.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robot_triangles.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for triangle in robot_triangles:\n            if is_point_in_triangle(x, y, *triangle[0], *triangle[1], *triangle[2]):\n                count += 1\n        print(count)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_inside_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobot_triangles = []\n\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robot_triangles.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robot_triangles.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robot_triangles.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robot_triangles.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for triangle in robot_triangles:\n            if is_inside_triangle(x, y, *triangle[0], *triangle[1], *triangle[2]):\n                count += 1\n        print(count)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\n# Initialize a 2D array to keep track of robot coverage\ncoverage = [[0] * (N + 1) for _ in range(N + 1)]\n\n# Process each query\nfor query in queries:\n    query_type, x, y, *params = query\n    if query_type == 1:\n        dir, len = params\n        if dir == 1:\n            for i in range(x, x + len + 1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 2:\n            for i in range(x, x + len + 1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n        elif dir == 3:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 4:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n    elif query_type == 2:\n        print(coverage[x][y])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\n# Initialize a 2D array to keep track of robot coverage\ncoverage = [[0] * (N + 1) for _ in range(N + 1)]\n\n# Process each query\nfor query in queries:\n    query_type, *params = query\n    if query_type == 1:\n        dir, x, y, len = params\n        if dir == 1:\n            for i in range(x, x + len + 1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 2:\n            for i in range(x, x + len + 1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n        elif dir == 3:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y + len + 1):\n                    coverage[i][j] += 1\n        elif dir == 4:\n            for i in range(x, x - len - 1, -1):\n                for j in range(y, y - len - 1, -1):\n                    coverage[i][j] += 1\n    elif query_type == 2:\n        x, y = params\n        print(coverage[x][y])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nQ = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(Q):\n    query_type = int(data[index])\n    if query_type == 1:\n        dir = int(data[index + 1])\n        x = int(data[index + 2])\n        y = int(data[index + 3])\n        len = int(data[index + 4])\n        queries.append((query_type, dir, x, y, len))\n        index += 5\n    elif query_type == 2:\n        x = int(data[index + 1])\n        y = int(data[index + 2])\n        queries.append((query_type, x, y))\n        index += 3\n\ndef is_point_in_triangle(x, y, x1, y1, x2, y2, x3, y3):\n    def sign(p1, p2, p3):\n        return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])\n    d1 = sign((x, y), (x1, y1), (x2, y2))\n    d2 = sign((x, y), (x2, y2), (x3, y3))\n    d3 = sign((x, y), (x3, y3), (x1, y1))\n    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)\n    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)\n    return not (has_neg and has_pos)\n\nrobot_triangles = []\n\nfor query in queries:\n    if query[0] == 1:\n        dir = query[1]\n        x = query[2]\n        y = query[3]\n        len = query[4]\n        if dir == 1:\n            robot_triangles.append(((x, y), (x + len, y), (x, y + len)))\n        elif dir == 2:\n            robot_triangles.append(((x, y), (x + len, y), (x, y - len)))\n        elif dir == 3:\n            robot_triangles.append(((x, y), (x - len, y), (x, y + len)))\n        elif dir == 4:\n            robot_triangles.append(((x, y), (x - len, y), (x, y - len)))\n    elif query[0] == 2:\n        x = query[1]\n        y = query[2]\n        count = 0\n        for triangle in robot_triangles:\n            if is_point_in_triangle(x, y, *triangle[0], *triangle[1], *triangle[2]):\n                count += 1\n        print(count)"
        ]
    },
    {
        "question_title": "LCS Again",
        "question_content": "You are given a string S of length n with each character being one of the first m lowercase English letters.\n\nCalculate how many different strings T of length n composed from the first m lowercase English letters exist such that the length of LCS (longest common subsequence) between S and T is n - 1.\n\nRecall that LCS of two strings S and T is the longest string C such that C both in S and T as a subsequence.\n\n\nInput Format\nThe first line contains two numbers n and m denoting the length of string S and number of first English lowercase characters forming the character set for strings (1 \u2264 n \u2264 100 000, 2 \u2264 m \u2264 26).\n\nThe second line contains string S.\n\n\nOutput Format\nPrint the only line containing the answer.\n\n\nSample Input 1\n\n3 3\naaa\n\nSample Output 1\n\n6\n\n\nSample Input 2\n\n3 3\naab\n\nSample Output 2\n\n11\n\n\nSample Input 3\n\n1 2\na\n\nSample Output 3\n\n1\n\n\nSample Input 4\n\n10 9\nabacadefgh\n\nSample Output 4\n\n789\n\n\nNote\nFor the first sample, the 6 possible strings T are: aab, aac, aba, aca, baa, caa.\n\nFor the second sample, the 11 possible strings T are: aaa, aac, aba, abb, abc, aca, acb, baa, bab, caa, cab.\n\nFor the third sample, the only possible string T is b.",
        "platform": "codeforces",
        "question_id": "578/D",
        "contest_id": "578",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Count the frequency of each character in S\nchar_count = Counter(S)\n\n# Calculate the number of valid strings T\nvalid_strings = 0\nfor char, count in char_count.items():\n    if count == 1:\n        valid_strings += m - 1\n    else:\n        valid_strings += m ** (count - 1)\n\n# Print the result\nprint(valid_strings)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(m):\n    # Count the number of occurrences of the last character in S\n    count = S.count(chr(ord('a') + last_char))\n    \n    # If the count is greater than 0, we can form a valid string T\n    if count > 0:\n        # The number of valid strings T is the number of ways to choose the first n-1 characters\n        # from the remaining characters in S, which is m^(n-1)\n        answer += m ** (n - 1)\n\n# Print the answer\nprint(answer)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize counter for characters in S\nchar_count = Counter(S)\n\n# Calculate the number of valid strings T\nvalid_strings = 0\nfor char in char_count:\n    if char_count[char] == 1:\n        valid_strings += m - 1\n    else:\n        valid_strings += m\n\n# Output the result\nprint(valid_strings)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Count the frequency of each character in S\nchar_count = Counter(S)\n\n# Calculate the number of valid strings T\nvalid_strings = 0\nfor char in char_count:\n    if char_count[char] == 1:\n        valid_strings += m - 1\n    else:\n        valid_strings += m\n\n# Print the result\nprint(valid_strings)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(m):\n    # Count the number of occurrences of each character in S\n    char_count = [0] * m\n    for char in S:\n        char_count[ord(char) - ord('a')] += 1\n    \n    # Calculate the number of valid strings T\n    valid_strings = 1\n    for count in char_count:\n        if count > 0:\n            valid_strings *= count\n    \n    # Add the number of valid strings to the answer\n    answer += valid_strings\n\n# Print the answer\nprint(answer)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(m):\n    # Count the number of occurrences of the last character in S\n    count_last_char = S.count(chr(ord('a') + last_char))\n    \n    # If the last character appears at least once in S, we can form valid strings T\n    if count_last_char > 0:\n        # The number of valid strings T is the number of ways to choose the first n-1 characters\n        # such that they do not contain the last character\n        answer += m ** (n - 1)\n\n# Print the answer\nprint(answer)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(1, m):\n    # Check if the last character of S is different from the current character\n    if S[-1] != chr(ord('a') + last_char):\n        # If different, then we can form a valid string T\n        answer += 1\n\n# Print the answer\nprint(answer)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Count the frequency of each character in S\nchar_count = Counter(S)\n\n# Calculate the number of valid strings T\nvalid_strings = 0\nfor char in char_count:\n    if char_count[char] == 1:\n        valid_strings += m - 1\n    else:\n        valid_strings += m\n\n# Print the result\nprint(valid_strings)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(m):\n    # Check if the last character of S is the same as the current character\n    if S[-1] == chr(ord('a') + last_char):\n        # If the last character is the same, we can have m-1 other characters\n        answer += m - 1\n    else:\n        # If the last character is different, we can have m choices for each position\n        answer += m ** (n - 1)\n\n# Print the answer\nprint(answer)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(m):\n    # Initialize a counter for valid strings T\n    valid_count = 0\n    \n    # Iterate over all possible characters for the first n-1 positions of T\n    for first_n_minus_1_chars in range(1 << (n-1)):\n        # Initialize the current string T\n        T = ''\n        \n        # Construct the string T based on the first n-1 positions and the last character\n        for i in range(n-1):\n            if first_n_minus_1_chars & (1 << i):\n                T += chr(ord('a') + last_char)\n            else:\n                T += S[i]\n        \n        # Check if the length of LCS between S and T is n-1\n        if len(T) == n-1 and T in S:\n            valid_count += 1\n    \n    # Add the number of valid strings T to the answer\n    answer += valid_count\n\n# Print the answer\nprint(answer)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Count the frequency of each character in S\nchar_count = Counter(S)\n\n# Calculate the number of valid strings T\nvalid_strings = 0\nfor char, count in char_count.items():\n    if count == 1:\n        valid_strings += m - 1\n    else:\n        valid_strings += m ** (count - 1)\n\n# Print the result\nprint(valid_strings)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(m):\n    # Count the number of occurrences of the last character in S\n    count = S.count(chr(ord('a') + last_char))\n    \n    # If the count is greater than 0, we can form a valid string T\n    if count > 0:\n        # The number of valid strings T is the number of ways to choose the first n-1 characters\n        # from the remaining characters in S, which is m^(n-1)\n        answer += m ** (n - 1)\n\n# Print the answer\nprint(answer)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize counter for characters in S\nchar_count = Counter(S)\n\n# Calculate the number of valid strings T\nvalid_strings = 0\nfor char in char_count:\n    if char_count[char] == 1:\n        valid_strings += m - 1\n    else:\n        valid_strings += m\n\n# Output the result\nprint(valid_strings)",
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Count the frequency of each character in S\nchar_count = Counter(S)\n\n# Calculate the number of valid strings T\nvalid_strings = 0\nfor char in char_count:\n    if char_count[char] == 1:\n        valid_strings += m - 1\n    else:\n        valid_strings += m\n\n# Print the result\nprint(valid_strings)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(m):\n    # Count the number of occurrences of each character in S\n    char_count = [0] * m\n    for char in S:\n        char_count[ord(char) - ord('a')] += 1\n    \n    # Calculate the number of valid strings T\n    valid_strings = 1\n    for count in char_count:\n        if count > 0:\n            valid_strings *= count\n    \n    # Add the number of valid strings to the answer\n    answer += valid_strings\n\n# Print the answer\nprint(answer)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(m):\n    # Count the number of occurrences of the last character in S\n    count_last_char = S.count(chr(ord('a') + last_char))\n    \n    # If the last character appears at least once in S, we can form valid strings T\n    if count_last_char > 0:\n        # The number of valid strings T is the number of ways to choose the first n-1 characters\n        # such that they do not contain the last character\n        answer += m ** (n - 1)\n\n# Print the answer\nprint(answer)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(1, m):\n    # Check if the last character of S is different from the current character\n    if S[-1] != chr(ord('a') + last_char):\n        # If different, then we can form a valid string T\n        answer += 1\n\n# Print the answer\nprint(answer)",
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Count the frequency of each character in S\nchar_count = Counter(S)\n\n# Calculate the number of valid strings T\nvalid_strings = 0\nfor char in char_count:\n    if char_count[char] == 1:\n        valid_strings += m - 1\n    else:\n        valid_strings += m\n\n# Print the result\nprint(valid_strings)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(m):\n    # Check if the last character of S is the same as the current character\n    if S[-1] == chr(ord('a') + last_char):\n        # If the last character is the same, we can have m-1 other characters\n        answer += m - 1\n    else:\n        # If the last character is different, we can have m choices for each position\n        answer += m ** (n - 1)\n\n# Print the answer\nprint(answer)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nS = data[2]\n\n# Initialize the answer\nanswer = 0\n\n# Iterate over all possible characters for the last position of T\nfor last_char in range(m):\n    # Initialize a counter for valid strings T\n    valid_count = 0\n    \n    # Iterate over all possible characters for the first n-1 positions of T\n    for first_n_minus_1_chars in range(1 << (n-1)):\n        # Initialize the current string T\n        T = ''\n        \n        # Construct the string T based on the first n-1 positions and the last character\n        for i in range(n-1):\n            if first_n_minus_1_chars & (1 << i):\n                T += chr(ord('a') + last_char)\n            else:\n                T += S[i]\n        \n        # Check if the length of LCS between S and T is n-1\n        if len(T) == n-1 and T in S:\n            valid_count += 1\n    \n    # Add the number of valid strings T to the answer\n    answer += valid_count\n\n# Print the answer\nprint(answer)"
        ]
    },
    {
        "question_title": "Minimum spanning tree for each edge",
        "question_content": "Connected undirected weighted graph without self-loops and multiple edges is given. Graph contains n vertices and m edges.\n\nFor each edge (u, v) find the minimal possible weight of the spanning tree that contains the edge (u, v).\n\nThe weight of the spanning tree is the sum of weights of all edges included in spanning tree.\n\n\nInput Format\nFirst line contains two integers n and m (1 \u2264 n \u2264 2\u00b7105, n - 1 \u2264 m \u2264 2\u00b7105) \u2014 the number of vertices and edges in graph.\n\nEach of the next m lines contains three integers ui, vi, wi (1 \u2264 ui, vi \u2264 n, ui \u2260 vi, 1 \u2264 wi \u2264 109) \u2014 the endpoints of the i-th edge and its weight.\n\n\nOutput Format\nPrint m lines. i-th line should contain the minimal possible weight of the spanning tree that contains i-th edge.\n\nThe edges are numbered from 1 to m in order of their appearing in input.\n\n\nSample Input 1\n\n5 7\n1 2 3\n1 3 1\n1 4 5\n2 3 2\n2 5 3\n3 4 2\n4 5 4\n\nSample Output 1\n\n9\n8\n11\n8\n8\n8\n9",
        "platform": "codeforces",
        "question_id": "609/E",
        "contest_id": "609",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nimport heapq\n\ndef kruskal(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    spanning_tree_weight = 0\n    result = [0] * len(edges)\n\n    for i, (u, v, w) in enumerate(edges):\n        u -= 1\n        v -= 1\n        if find(u) != find(v):\n            union(u, v)\n            spanning_tree_weight += w\n            result[i] = spanning_tree_weight\n\n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    result = kruskal(n, edges)\n    \n    for weight in result:\n        print(weight)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_to_exclude):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        edge_count = 0\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n\n        for u, v, w in edges:\n            if (u, v) == edge_to_exclude or (v, u) == edge_to_exclude:\n                continue\n            if union(u, v):\n                total_weight += w\n                edge_count += 1\n                if edge_count == n - 1:\n                    return total_weight\n        return float('inf')\n\n    results = []\n    for i, (u, v, w) in enumerate(edges, start=1):\n        result = kruskal_with_edge_exclusion((u, v))\n        results.append(result)\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresults = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_to_exclude):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        edge_count = 0\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n\n        for u, v, w in edges:\n            if (u, v) == edge_to_exclude or (v, u) == edge_to_exclude:\n                continue\n            if union(u, v):\n                total_weight += w\n                edge_count += 1\n                if edge_count == n - 1:\n                    break\n        return total_weight if edge_count == n - 1 else float('inf')\n\n    result = []\n    for i, (u, v, w) in enumerate(edges, start=1):\n        result.append(kruskal_with_edge_exclusion((u, v)))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\n\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresult = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor weight in result:\n    print(weight)\n```",
            "```python\nimport sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges, edge_index):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    min_spanning_tree_weight = 0\n    for u, v, w in edges:\n        if find(u) != find(v):\n            union(u, v)\n            min_spanning_tree_weight += w\n\n    # Remove the edge at edge_index from the graph\n    edges[edge_index - 1] = (0, 0, 0)\n    new_min_spanning_tree_weight = 0\n    for u, v, w in edges:\n        if find(u) != find(v):\n            union(u, v)\n            new_min_spanning_tree_weight += w\n\n    return new_min_spanning_tree_weight\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for i in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    results = []\n    for i in range(m):\n        original_weight = edges[i][2]\n        edges[i] = (0, 0, 0)\n        result = find_min_spanning_tree_weight(n, edges, i + 1)\n        edges[i] = (original_weight)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_index):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        edges_used = 0\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n        \n        for i, (u, v, w) in enumerate(edges):\n            if i == edge_index:\n                continue\n            if union(u, v):\n                total_weight += w\n                edges_used += 1\n                if edges_used == n - 1:\n                    break\n        return total_weight if edges_used == n - 1 else float('inf')\n    \n    result = []\n    for i in range(m):\n        result.append(kruskal_with_edge_exclusion(i))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresult = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor weight in result:\n    print(weight)\n```",
            "```python\nimport sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges, edge_index):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    def kruskal():\n        mst_weight = 0\n        for u, v, w in edges:\n            if find(u) != find(v):\n                union(u, v)\n                mst_weight += w\n        return mst_weight\n\n    # Remove the edge at edge_index\n    removed_edge = edges[edge_index]\n    edges[edge_index] = (0, 0, 0)\n\n    # Calculate the MST weight without the removed edge\n    mst_weight_without_edge = kruskal()\n\n    # Restore the removed edge\n    edges[edge_index] = removed_edge\n\n    # Calculate the MST weight with the removed edge included\n    mst_weight_with_edge = mst_weight_without_edge + removed_edge[2]\n\n    return mst_weight_with_edge\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    m = int(data[1])\n\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n\n    results = []\n    for i in range(m):\n        result = find_min_spanning_tree_weight(n, edges, i)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_to_exclude):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        included_edges = 0\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n\n        for u, v, w in edges:\n            if (u, v) == edge_to_exclude or (v, u) == edge_to_exclude:\n                continue\n            if union(u, v):\n                total_weight += w\n                included_edges += 1\n                if included_edges == n - 1:\n                    break\n        return total_weight\n\n    result = []\n    for edge in edges:\n        result.append(kruskal_with_edge_exclusion(edge))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresult = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor weight in result:\n    print(weight)\n```",
            "```python\nimport sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_to_exclude):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        edge_count = 0\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n\n        for u, v, w in edges:\n            if (u, v) == edge_to_exclude or (v, u) == edge_to_exclude:\n                continue\n            if union(u, v):\n                total_weight += w\n                edge_count += 1\n                if edge_count == n - 1:\n                    break\n        return total_weight if edge_count == n - 1 else float('inf')\n\n    result = []\n    for i, (u, v, w) in enumerate(edges, start=1):\n        result.append(kruskal_with_edge_exclusion((u, v)))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\n\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresult = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor weight in result:\n    print(weight)\n```",
            "```python\nimport sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges, edge_index):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    def kruskal():\n        mst_weight = 0\n        for u, v, w in edges:\n            if find(u) != find(v):\n                union(u, v)\n                mst_weight += w\n        return mst_weight\n\n    # Remove the edge at edge_index\n    removed_edge = edges[edge_index]\n    edges[edge_index] = (0, 0, 0)\n\n    # Calculate the MST weight without the removed edge\n    mst_weight_without_edge = kruskal()\n\n    # Restore the removed edge\n    edges[edge_index] = removed_edge\n\n    # Calculate the MST weight with the removed edge included\n    mst_weight_with_edge = mst_weight_without_edge + removed_edge[2]\n\n    return mst_weight_with_edge\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    results = []\n    for i in range(m):\n        result = find_min_spanning_tree_weight(n, edges, i)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_to_exclude):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        edge_count = 0\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n\n        for u, v, w in edges:\n            if (u, v) == edge_to_exclude or (v, u) == edge_to_exclude:\n                continue\n            if union(u, v):\n                total_weight += w\n                edge_count += 1\n                if edge_count == n - 1:\n                    return total_weight\n        return float('inf')\n\n    result = []\n    for i in range(m):\n        result.append(kruskal_with_edge_exclusion(edges[i]))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresult = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor weight in result:\n    print(weight)\n```"
        ],
        "code_list": [
            "import sys\nimport heapq\n\ndef kruskal(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    spanning_tree_weight = 0\n    result = [0] * len(edges)\n\n    for i, (u, v, w) in enumerate(edges):\n        u -= 1\n        v -= 1\n        if find(u) != find(v):\n            union(u, v)\n            spanning_tree_weight += w\n            result[i] = spanning_tree_weight\n\n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    result = kruskal(n, edges)\n    \n    for weight in result:\n        print(weight)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_to_exclude):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        edge_count = 0\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n\n        for u, v, w in edges:\n            if (u, v) == edge_to_exclude or (v, u) == edge_to_exclude:\n                continue\n            if union(u, v):\n                total_weight += w\n                edge_count += 1\n                if edge_count == n - 1:\n                    return total_weight\n        return float('inf')\n\n    results = []\n    for i, (u, v, w) in enumerate(edges, start=1):\n        result = kruskal_with_edge_exclusion((u, v))\n        results.append(result)\n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresults = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_to_exclude):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        edge_count = 0\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n\n        for u, v, w in edges:\n            if (u, v) == edge_to_exclude or (v, u) == edge_to_exclude:\n                continue\n            if union(u, v):\n                total_weight += w\n                edge_count += 1\n                if edge_count == n - 1:\n                    break\n        return total_weight if edge_count == n - 1 else float('inf')\n\n    result = []\n    for i, (u, v, w) in enumerate(edges, start=1):\n        result.append(kruskal_with_edge_exclusion((u, v)))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\n\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresult = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor weight in result:\n    print(weight)",
            "import sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges, edge_index):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    min_spanning_tree_weight = 0\n    for u, v, w in edges:\n        if find(u) != find(v):\n            union(u, v)\n            min_spanning_tree_weight += w\n\n    # Remove the edge at edge_index from the graph\n    edges[edge_index - 1] = (0, 0, 0)\n    new_min_spanning_tree_weight = 0\n    for u, v, w in edges:\n        if find(u) != find(v):\n            union(u, v)\n            new_min_spanning_tree_weight += w\n\n    return new_min_spanning_tree_weight\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for i in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    results = []\n    for i in range(m):\n        original_weight = edges[i][2]\n        edges[i] = (0, 0, 0)\n        result = find_min_spanning_tree_weight(n, edges, i + 1)\n        edges[i] = (original_weight)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_index):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        edges_used = 0\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n        \n        for i, (u, v, w) in enumerate(edges):\n            if i == edge_index:\n                continue\n            if union(u, v):\n                total_weight += w\n                edges_used += 1\n                if edges_used == n - 1:\n                    break\n        return total_weight if edges_used == n - 1 else float('inf')\n    \n    result = []\n    for i in range(m):\n        result.append(kruskal_with_edge_exclusion(i))\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresult = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor weight in result:\n    print(weight)",
            "import sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges, edge_index):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    def kruskal():\n        mst_weight = 0\n        for u, v, w in edges:\n            if find(u) != find(v):\n                union(u, v)\n                mst_weight += w\n        return mst_weight\n\n    # Remove the edge at edge_index\n    removed_edge = edges[edge_index]\n    edges[edge_index] = (0, 0, 0)\n\n    # Calculate the MST weight without the removed edge\n    mst_weight_without_edge = kruskal()\n\n    # Restore the removed edge\n    edges[edge_index] = removed_edge\n\n    # Calculate the MST weight with the removed edge included\n    mst_weight_with_edge = mst_weight_without_edge + removed_edge[2]\n\n    return mst_weight_with_edge\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    m = int(data[1])\n\n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n\n    results = []\n    for i in range(m):\n        result = find_min_spanning_tree_weight(n, edges, i)\n        results.append(result)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_to_exclude):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        included_edges = 0\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n\n        for u, v, w in edges:\n            if (u, v) == edge_to_exclude or (v, u) == edge_to_exclude:\n                continue\n            if union(u, v):\n                total_weight += w\n                included_edges += 1\n                if included_edges == n - 1:\n                    break\n        return total_weight\n\n    result = []\n    for edge in edges:\n        result.append(kruskal_with_edge_exclusion(edge))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresult = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor weight in result:\n    print(weight)",
            "import sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_to_exclude):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        edge_count = 0\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n\n        for u, v, w in edges:\n            if (u, v) == edge_to_exclude or (v, u) == edge_to_exclude:\n                continue\n            if union(u, v):\n                total_weight += w\n                edge_count += 1\n                if edge_count == n - 1:\n                    break\n        return total_weight if edge_count == n - 1 else float('inf')\n\n    result = []\n    for i, (u, v, w) in enumerate(edges, start=1):\n        result.append(kruskal_with_edge_exclusion((u, v)))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\n\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresult = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor weight in result:\n    print(weight)",
            "import sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges, edge_index):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    def kruskal():\n        mst_weight = 0\n        for u, v, w in edges:\n            if find(u) != find(v):\n                union(u, v)\n                mst_weight += w\n        return mst_weight\n\n    # Remove the edge at edge_index\n    removed_edge = edges[edge_index]\n    edges[edge_index] = (0, 0, 0)\n\n    # Calculate the MST weight without the removed edge\n    mst_weight_without_edge = kruskal()\n\n    # Restore the removed edge\n    edges[edge_index] = removed_edge\n\n    # Calculate the MST weight with the removed edge included\n    mst_weight_with_edge = mst_weight_without_edge + removed_edge[2]\n\n    return mst_weight_with_edge\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    results = []\n    for i in range(m):\n        result = find_min_spanning_tree_weight(n, edges, i)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport heapq\n\ndef find_min_spanning_tree_weight(n, edges):\n    def kruskal_with_edge_exclusion(edge_to_exclude):\n        parent = list(range(n + 1))\n        rank = [0] * (n + 1)\n        total_weight = 0\n        edge_count = 0\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX != rootY:\n                if rank[rootX] > rank[rootY]:\n                    parent[rootY] = rootX\n                elif rank[rootX] < rank[rootY]:\n                    parent[rootX] = rootY\n                else:\n                    parent[rootY] = rootX\n                    rank[rootX] += 1\n                return True\n            return False\n\n        for u, v, w in edges:\n            if (u, v) == edge_to_exclude or (v, u) == edge_to_exclude:\n                continue\n            if union(u, v):\n                total_weight += w\n                edge_count += 1\n                if edge_count == n - 1:\n                    return total_weight\n        return float('inf')\n\n    result = []\n    for i in range(m):\n        result.append(kruskal_with_edge_exclusion(edges[i]))\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\n# Solve the problem\nresult = find_min_spanning_tree_weight(n, edges)\n\n# Write output\nfor weight in result:\n    print(weight)"
        ]
    },
    {
        "question_title": "Vika and Segments",
        "question_content": "Vika has an infinite sheet of squared paper. Initially all squares are white. She introduced a two-dimensional coordinate system on this sheet and drew n black horizontal and vertical segments parallel to the coordinate axes. All segments have width equal to 1 square, that means every segment occupy some set of neighbouring squares situated in one row or one column.\n\nYour task is to calculate the number of painted cells. If a cell was painted more than once, it should be calculated exactly once.\n\n\nInput Format\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 100 000)\u00a0\u2014 the number of segments drawn by Vika.\n\nEach of the next n lines contains four integers x1, y1, x2 and y2 ( - 109 \u2264 x1, y1, x2, y2 \u2264 109)\u00a0\u2014 the coordinates of the endpoints of the segments drawn by Vika. It is guaranteed that all the segments are parallel to coordinate axes. Segments may touch, overlap and even completely coincide.\n\n\nOutput Format\nPrint the number of cells painted by Vika. If a cell was painted more than once, it should be calculated exactly once in the answer.\n\n\nSample Input 1\n\n3\n0 1 2 1\n1 4 1 2\n0 3 2 3\n\nSample Output 1\n\n8\n\n\nSample Input 2\n\n4\n-2 -1 2 -1\n2 1 -2 1\n-1 -2 -1 2\n1 2 1 -2\n\nSample Output 2\n\n16\n\n\nNote\nIn the first sample Vika will paint squares (0, 1), (1, 1), (2, 1), (1, 2), (1, 3), (1, 4), (0, 3) and (2, 3).",
        "platform": "codeforces",
        "question_id": "610/D",
        "contest_id": "610",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Process each segment\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Ensure x1 <= x2 and y1 <= y2\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Add all cells in the segment to the set\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Read each segment and mark the painted cells\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Determine the range of x and y coordinates\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Mark the cells in the range\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Index for reading the data\nindex = 1\n\n# Process each segment\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Determine the range of x and y coordinates\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Add all cells in the segment to the set\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Process each segment\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Determine the range of x and y coordinates\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Add all cells in the segment to the set\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Parse the segments\nsegments = []\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    segments.append((x1, y1, x2, y2))\n    index += 4\n\n# Calculate the number of painted cells\npainted_cells = set()\n\nfor x1, y1, x2, y2 in segments:\n    if x1 == x2:  # Vertical segment\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            painted_cells.add((x1, y))\n    else:  # Horizontal segment\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            painted_cells.add((x, y1))\n\n# Output the number of painted cells\nprint(len(painted_cells))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Process each segment\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Determine the range of x and y coordinates\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Add all cells in the segment to the set\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Parse the segments\nsegments = []\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    segments.append((x1, y1, x2, y2))\n    index += 4\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Iterate over each segment and mark the painted cells\nfor x1, y1, x2, y2 in segments:\n    if x1 == x2:  # Vertical segment\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            painted_cells.add((x1, y))\n    else:  # Horizontal segment\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            painted_cells.add((x, y1))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of segments\nn = int(data[0])\n\n# List to store the segments\nsegments = []\n\n# Read each segment\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    segments.append((x1, y1, x2, y2))\n    index += 4\n\n# Set to store unique painted cells\npainted_cells = set()\n\n# Process each segment\nfor x1, y1, x2, y2 in segments:\n    if x1 == x2:  # Vertical segment\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            painted_cells.add((x1, y))\n    else:  # Horizontal segment\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            painted_cells.add((x, y1))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Index to keep track of the current position in the data list\nindex = 1\n\n# Iterate over each segment\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Ensure x1 <= x2 and y1 <= y2\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Add all cells in the segment to the set\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Print the number of unique painted cells\nprint(len(painted_cells))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of segments\nn = int(data[0])\n\n# List to store the segments\nsegments = []\n\n# Read each segment\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    segments.append((x1, y1, x2, y2))\n    index += 4\n\n# Set to store unique painted cells\npainted_cells = set()\n\n# Process each segment\nfor x1, y1, x2, y2 in segments:\n    if x1 == x2:  # Vertical segment\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            painted_cells.add((x1, y))\n    else:  # Horizontal segment\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            painted_cells.add((x, y1))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Process each segment\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Ensure x1 <= x2 and y1 <= y2\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Add all cells in the segment to the set\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Read each segment and mark the painted cells\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Determine the range of x and y coordinates\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Mark the cells in the range\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Index for reading the data\nindex = 1\n\n# Process each segment\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Determine the range of x and y coordinates\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Add all cells in the segment to the set\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Process each segment\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Determine the range of x and y coordinates\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Add all cells in the segment to the set\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Parse the segments\nsegments = []\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    segments.append((x1, y1, x2, y2))\n    index += 4\n\n# Calculate the number of painted cells\npainted_cells = set()\n\nfor x1, y1, x2, y2 in segments:\n    if x1 == x2:  # Vertical segment\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            painted_cells.add((x1, y))\n    else:  # Horizontal segment\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            painted_cells.add((x, y1))\n\n# Output the number of painted cells\nprint(len(painted_cells))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Process each segment\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Determine the range of x and y coordinates\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Add all cells in the segment to the set\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Parse the segments\nsegments = []\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    segments.append((x1, y1, x2, y2))\n    index += 4\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Iterate over each segment and mark the painted cells\nfor x1, y1, x2, y2 in segments:\n    if x1 == x2:  # Vertical segment\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            painted_cells.add((x1, y))\n    else:  # Horizontal segment\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            painted_cells.add((x, y1))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of segments\nn = int(data[0])\n\n# List to store the segments\nsegments = []\n\n# Read each segment\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    segments.append((x1, y1, x2, y2))\n    index += 4\n\n# Set to store unique painted cells\npainted_cells = set()\n\n# Process each segment\nfor x1, y1, x2, y2 in segments:\n    if x1 == x2:  # Vertical segment\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            painted_cells.add((x1, y))\n    else:  # Horizontal segment\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            painted_cells.add((x, y1))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of segments\nn = int(data[0])\n\n# Initialize a set to keep track of painted cells\npainted_cells = set()\n\n# Index to keep track of the current position in the data list\nindex = 1\n\n# Iterate over each segment\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    index += 4\n    \n    # Ensure x1 <= x2 and y1 <= y2\n    if x1 > x2:\n        x1, x2 = x2, x1\n    if y1 > y2:\n        y1, y2 = y2, y1\n    \n    # Add all cells in the segment to the set\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            painted_cells.add((x, y))\n\n# Print the number of unique painted cells\nprint(len(painted_cells))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of segments\nn = int(data[0])\n\n# List to store the segments\nsegments = []\n\n# Read each segment\nindex = 1\nfor _ in range(n):\n    x1 = int(data[index])\n    y1 = int(data[index + 1])\n    x2 = int(data[index + 2])\n    y2 = int(data[index + 3])\n    segments.append((x1, y1, x2, y2))\n    index += 4\n\n# Set to store unique painted cells\npainted_cells = set()\n\n# Process each segment\nfor x1, y1, x2, y2 in segments:\n    if x1 == x2:  # Vertical segment\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            painted_cells.add((x1, y))\n    else:  # Horizontal segment\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            painted_cells.add((x, y1))\n\n# Output the number of unique painted cells\nprint(len(painted_cells))"
        ]
    },
    {
        "question_title": "Multipliers",
        "question_content": "Ayrat has number n, represented as it's prime factorization pi of size m, i.e. n = p1\u00b7p2\u00b7...\u00b7pm. Ayrat got secret information that that the product of all divisors of n taken modulo 109 + 7 is the password to the secret data base. Now he wants to calculate this value.\n\n\nInput Format\nThe first line of the input contains a single integer m (1 \u2264 m \u2264 200 000)\u00a0\u2014 the number of primes in factorization of n.\n\nThe second line contains m primes numbers pi (2 \u2264 pi \u2264 200 000).\n\n\nOutput Format\nPrint one integer\u00a0\u2014 the product of all divisors of n modulo 109 + 7.\n\n\nSample Input 1\n\n2\n2 3\n\nSample Output 1\n\n36\n\n\nSample Input 2\n\n3\n2 3 2\n\nSample Output 2\n\n1728\n\n\nNote\nIn the first sample n = 2\u00b73 = 6. The divisors of 6 are 1, 2, 3 and 6, their product is equal to 1\u00b72\u00b73\u00b76 = 36.\n\nIn the second sample 2\u00b73\u00b72 = 12. The divisors of 12 are 1, 2, 3, 4, 6 and 12. 1\u00b72\u00b73\u00b74\u00b76\u00b712 = 1728.",
        "platform": "codeforces",
        "question_id": "615/D",
        "contest_id": "615",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nmod = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# Calculate the product of all divisors\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % mod\n\n# Print the result\nprint(product)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of primes in the factorization\nm = int(data[0])\n\n# List of prime factors\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# Calculate the product of all divisors\nproduct = 1\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# For each prime factor, calculate its contribution to the product of divisors\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\nfor prime in primes:\n    count = primes.count(prime)\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# Calculate the product of all divisors\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of primes in factorization\nm = int(data[0])\n\n# List of prime numbers\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# For each prime factor, calculate its contribution to the product of divisors\nfor prime, count in prime_count.items():\n    # The number of divisors of n is (count1 + 1) * (count2 + 1) * ... * (countm + 1)\n    # The product of divisors of n is (prime^count1 * prime^count2 * ... * prime^countm)^(divisors_count / 2)\n    # Simplifying, we get (prime^(count1 * (count1 + 1) / 2) * prime^(count2 * (count2 + 1) / 2) * ... * prime^(countm * (countm + 1) / 2)) % MOD\n    product *= pow(prime, count * (count + 1) // 2, MOD)\n    product %= MOD\n\n# Print the result\nprint(product)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of primes in factorization\nm = int(data[0])\n\n# List of prime factors\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# For each prime factor, calculate its contribution to the product of divisors\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# Calculate the product of all divisors\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nmod = 10**9 + 7\nproduct = 1\nfor prime in primes:\n    count = Counter(primes)[prime]\n    product = (product * (prime ** (count * (count + 1) // 2))) % mod\n\n# Output the result\nprint(product)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# Calculate the product of all divisors\nfor prime, count in prime_count.items():\n    product = (product * (pow(prime, count * (count + 1) // 2, MOD) - 1) * pow(prime - 1, MOD - 2, MOD)) % MOD\n\n# Output the result\nprint(product)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nmod = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# Calculate the product of all divisors\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % mod\n\n# Print the result\nprint(product)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of primes in the factorization\nm = int(data[0])\n\n# List of prime factors\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# Calculate the product of all divisors\nproduct = 1\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# For each prime factor, calculate its contribution to the product of divisors\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\nfor prime in primes:\n    count = primes.count(prime)\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# Calculate the product of all divisors\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)",
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of primes in factorization\nm = int(data[0])\n\n# List of prime numbers\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# For each prime factor, calculate its contribution to the product of divisors\nfor prime, count in prime_count.items():\n    # The number of divisors of n is (count1 + 1) * (count2 + 1) * ... * (countm + 1)\n    # The product of divisors of n is (prime^count1 * prime^count2 * ... * prime^countm)^(divisors_count / 2)\n    # Simplifying, we get (prime^(count1 * (count1 + 1) / 2) * prime^(count2 * (count2 + 1) / 2) * ... * prime^(countm * (countm + 1) / 2)) % MOD\n    product *= pow(prime, count * (count + 1) // 2, MOD)\n    product %= MOD\n\n# Print the result\nprint(product)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of primes in factorization\nm = int(data[0])\n\n# List of prime factors\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# For each prime factor, calculate its contribution to the product of divisors\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# Calculate the product of all divisors\nfor prime, count in prime_count.items():\n    product = (product * (prime ** (count * (count + 1) // 2))) % MOD\n\n# Print the result\nprint(product)",
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nmod = 10**9 + 7\nproduct = 1\nfor prime in primes:\n    count = Counter(primes)[prime]\n    product = (product * (prime ** (count * (count + 1) // 2))) % mod\n\n# Output the result\nprint(product)",
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nm = int(data[0])\nprimes = list(map(int, data[1:]))\n\n# Calculate the product of all divisors modulo 10^9 + 7\nMOD = 10**9 + 7\nproduct = 1\n\n# Count the frequency of each prime factor\nprime_count = Counter(primes)\n\n# Calculate the product of all divisors\nfor prime, count in prime_count.items():\n    product = (product * (pow(prime, count * (count + 1) // 2, MOD) - 1) * pow(prime - 1, MOD - 2, MOD)) % MOD\n\n# Output the result\nprint(product)"
        ]
    },
    {
        "question_title": "Expensive Strings",
        "question_content": "You are given n strings ti. Each string has cost ci.\n\nLet's define the function of string s : f(s) = \\sum_{i=1}^{n} c_i \\cdot p_{s,i} \\cdot |s|, where ps, i is the number of occurrences of s in ti, |s| is the length of the string s. Find the maximal value of function f(s) over all strings.\n\nNote that the string s is not necessarily some string from t.\n\n\nInput Format\nThe first line contains the only integer n (1 \u2264 n \u2264 105) \u2014 the number of strings in t.\n\nEach of the next n lines contains contains a non-empty string ti. ti contains only lowercase English letters.\n\nIt is guaranteed that the sum of lengths of all strings in t is not greater than 5\u00b7105.\n\nThe last line contains n integers ci ( - 107 \u2264 ci \u2264 107) \u2014 the cost of the i-th string.\n\n\nOutput Format\nPrint the only integer a \u2014 the maximal value of the function f(s) over all strings s. Note one more time that the string s is not necessarily from t.\n\n\nSample Input 1\n\n2\naa\nbb\n2 1\n\nSample Output 1\n\n4\n\n\nSample Input 2\n\n2\naa\nab\n2 1\n\nSample Output 2\n\n5",
        "platform": "codeforces",
        "question_id": "616/F",
        "contest_id": "616",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of strings\nn = int(data[0])\n\n# Parse the strings\nstrings = data[1:n+1]\n\n# Parse the costs\ncosts = list(map(int, data[n+1:]))\n\n# Initialize a dictionary to store the frequency of each character\nchar_freq = {}\n\n# Calculate the frequency of each character in all strings\nfor s in strings:\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, freq in char_freq.items():\n    max_value += freq * costs[ord(char) - ord('a')]\n\n# Print the result\nprint(max_value)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nstrings = data[1:n+1]\ncosts = list(map(int, data[n+1:]))\n\n# Calculate the frequency of each character in all strings\nchar_freq = {}\nfor s in strings:\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, freq in char_freq.items():\n    max_value += freq * len(char) * costs[0]  # Assuming the cost of the first string is the maximum\n\n# Print the result\nprint(max_value)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of strings\nn = int(data[0])\n\n# Strings\nstrings = data[1:n+1]\n\n# Costs\ncosts = list(map(int, data[n+1:]))\n\n# Count occurrences of each character\nchar_count = Counter()\nfor s in strings:\n    for char in s:\n        char_count[char] += 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, count in char_count.items():\n    max_value += costs[ord(char) - ord('a')] * count * len(char)\n\n# Output the result\nprint(max_value)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of strings\nn = int(data[0])\n\n# Strings\nstrings = data[1:n+1]\n\n# Costs\ncosts = list(map(int, data[n+1:]))\n\n# Count occurrences of each character in all strings\nchar_count = Counter()\nfor s in strings:\n    for char in s:\n        char_count[char] += 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, count in char_count.items():\n    max_value += costs[ord(char) - ord('a')] * count * len(char)\n\n# Print the result\nprint(max_value)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of strings\nn = int(data[0])\n\n# Strings\nstrings = data[1:n+1]\n\n# Costs\ncosts = list(map(int, data[n+1:]))\n\n# Count occurrences of each character in all strings\nchar_count = Counter()\nfor s in strings:\n    for char in s:\n        char_count[char] += 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, count in char_count.items():\n    max_value += costs[ord(char) - ord('a')] * count * len(char)\n\n# Print the result\nprint(max_value)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of strings\nn = int(data[0])\n\n# Parse the strings\nstrings = data[1:n+1]\n\n# Parse the costs\ncosts = list(map(int, data[n+1:]))\n\n# Calculate the frequency of each character in all strings\nchar_freq = {}\nfor s in strings:\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, freq in char_freq.items():\n    max_value += freq * len(char) * max(costs)\n\n# Print the result\nprint(max_value)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of strings\nn = int(data[0])\n\n# Strings\nstrings = data[1:n+1]\n\n# Costs\ncosts = list(map(int, data[n+1:]))\n\n# Count occurrences of each character in all strings\nchar_count = Counter()\nfor s in strings:\n    for char in s:\n        char_count[char] += 1\n\n# Calculate the maximal value of the function f(s)\nmax_value = 0\nfor char, count in char_count.items():\n    max_value += costs[ord(char) - ord('a')] * count * len(char)\n\n# Print the result\nprint(max_value)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of strings\nn = int(data[0])\n\n# Parse the strings\nstrings = data[1:n+1]\n\n# Parse the costs\ncosts = list(map(int, data[n+1:]))\n\n# Calculate the frequency of each character in all strings\nchar_freq = Counter()\nfor s in strings:\n    for char in s:\n        char_freq[char] += 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, freq in char_freq.items():\n    max_value += freq * len(char) * max(costs)\n\n# Print the result\nprint(max_value)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of strings\nn = int(data[0])\n\n# Strings and their costs\nstrings = data[1:n+1]\ncosts = list(map(int, data[n+1:2*n+1]))\n\n# Dictionary to count occurrences of each character in each string\nchar_count = defaultdict(int)\n\n# Count occurrences of each character in each string\nfor i, s in enumerate(strings):\n    for char in s:\n        char_count[char] += 1\n\n# Calculate the maximal value of the function f(s)\nmax_value = 0\nfor char, count in char_count.items():\n    max_value += costs[ord(char) - ord('a')] * count * len(char)\n\n# Print the result\nprint(max_value)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nstrings = data[1:n+1]\ncosts = list(map(int, data[n+1:]))\n\n# Initialize variables\nmax_value = float('-inf')\n\n# Iterate over all possible strings\nfor s in set(''.join(strings)):\n    total_cost = 0\n    for i in range(n):\n        count = strings[i].count(s)\n        total_cost += costs[i] * count * len(s)\n    max_value = max(max_value, total_cost)\n\n# Print the result\nprint(max_value)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of strings\nn = int(data[0])\n\n# Parse the strings\nstrings = data[1:n+1]\n\n# Parse the costs\ncosts = list(map(int, data[n+1:]))\n\n# Initialize a dictionary to store the frequency of each character\nchar_freq = {}\n\n# Calculate the frequency of each character in all strings\nfor s in strings:\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, freq in char_freq.items():\n    max_value += freq * costs[ord(char) - ord('a')]\n\n# Print the result\nprint(max_value)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nstrings = data[1:n+1]\ncosts = list(map(int, data[n+1:]))\n\n# Calculate the frequency of each character in all strings\nchar_freq = {}\nfor s in strings:\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, freq in char_freq.items():\n    max_value += freq * len(char) * costs[0]  # Assuming the cost of the first string is the maximum\n\n# Print the result\nprint(max_value)",
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of strings\nn = int(data[0])\n\n# Strings\nstrings = data[1:n+1]\n\n# Costs\ncosts = list(map(int, data[n+1:]))\n\n# Count occurrences of each character\nchar_count = Counter()\nfor s in strings:\n    for char in s:\n        char_count[char] += 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, count in char_count.items():\n    max_value += costs[ord(char) - ord('a')] * count * len(char)\n\n# Output the result\nprint(max_value)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of strings\nn = int(data[0])\n\n# Strings\nstrings = data[1:n+1]\n\n# Costs\ncosts = list(map(int, data[n+1:]))\n\n# Count occurrences of each character in all strings\nchar_count = Counter()\nfor s in strings:\n    for char in s:\n        char_count[char] += 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, count in char_count.items():\n    max_value += costs[ord(char) - ord('a')] * count * len(char)\n\n# Print the result\nprint(max_value)",
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of strings\nn = int(data[0])\n\n# Strings\nstrings = data[1:n+1]\n\n# Costs\ncosts = list(map(int, data[n+1:]))\n\n# Count occurrences of each character in all strings\nchar_count = Counter()\nfor s in strings:\n    for char in s:\n        char_count[char] += 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, count in char_count.items():\n    max_value += costs[ord(char) - ord('a')] * count * len(char)\n\n# Print the result\nprint(max_value)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of strings\nn = int(data[0])\n\n# Parse the strings\nstrings = data[1:n+1]\n\n# Parse the costs\ncosts = list(map(int, data[n+1:]))\n\n# Calculate the frequency of each character in all strings\nchar_freq = {}\nfor s in strings:\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, freq in char_freq.items():\n    max_value += freq * len(char) * max(costs)\n\n# Print the result\nprint(max_value)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of strings\nn = int(data[0])\n\n# Strings\nstrings = data[1:n+1]\n\n# Costs\ncosts = list(map(int, data[n+1:]))\n\n# Count occurrences of each character in all strings\nchar_count = Counter()\nfor s in strings:\n    for char in s:\n        char_count[char] += 1\n\n# Calculate the maximal value of the function f(s)\nmax_value = 0\nfor char, count in char_count.items():\n    max_value += costs[ord(char) - ord('a')] * count * len(char)\n\n# Print the result\nprint(max_value)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of strings\nn = int(data[0])\n\n# Parse the strings\nstrings = data[1:n+1]\n\n# Parse the costs\ncosts = list(map(int, data[n+1:]))\n\n# Calculate the frequency of each character in all strings\nchar_freq = Counter()\nfor s in strings:\n    for char in s:\n        char_freq[char] += 1\n\n# Calculate the maximum value of the function f(s)\nmax_value = 0\nfor char, freq in char_freq.items():\n    max_value += freq * len(char) * max(costs)\n\n# Print the result\nprint(max_value)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of strings\nn = int(data[0])\n\n# Strings and their costs\nstrings = data[1:n+1]\ncosts = list(map(int, data[n+1:2*n+1]))\n\n# Dictionary to count occurrences of each character in each string\nchar_count = defaultdict(int)\n\n# Count occurrences of each character in each string\nfor i, s in enumerate(strings):\n    for char in s:\n        char_count[char] += 1\n\n# Calculate the maximal value of the function f(s)\nmax_value = 0\nfor char, count in char_count.items():\n    max_value += costs[ord(char) - ord('a')] * count * len(char)\n\n# Print the result\nprint(max_value)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nstrings = data[1:n+1]\ncosts = list(map(int, data[n+1:]))\n\n# Initialize variables\nmax_value = float('-inf')\n\n# Iterate over all possible strings\nfor s in set(''.join(strings)):\n    total_cost = 0\n    for i in range(n):\n        count = strings[i].count(s)\n        total_cost += costs[i] * count * len(s)\n    max_value = max(max_value, total_cost)\n\n# Print the result\nprint(max_value)"
        ]
    },
    {
        "question_title": "XOR and Favorite Number",
        "question_content": "Bob has a favorite number k and ai of length n. Now he asks you to answer m queries. Each query is given by a pair li and ri and asks you to count the number of pairs of integers i and j, such that l \u2264 i \u2264 j \u2264 r and the xor of the numbers ai, ai + 1, ..., aj is equal to k.\n\n\nInput Format\nThe first line of the input contains integers n, m and k (1 \u2264 n, m \u2264 100 000, 0 \u2264 k \u2264 1 000 000)\u00a0\u2014 the length of the array, the number of queries and Bob's favorite number respectively.\n\nThe second line contains n integers ai (0 \u2264 ai \u2264 1 000 000)\u00a0\u2014 Bob's array.\n\nThen m lines follow. The i-th line contains integers li and ri (1 \u2264 li \u2264 ri \u2264 n)\u00a0\u2014 the parameters of the i-th query.\n\n\nOutput Format\nPrint m lines, answer the queries in the order they appear in the input.\n\n\nSample Input 1\n\n6 2 3\n1 2 1 1 0 3\n1 6\n3 5\n\nSample Output 1\n\n7\n0\n\n\nSample Input 2\n\n5 3 1\n1 1 1 1 1\n1 5\n2 4\n1 3\n\nSample Output 2\n\n9\n4\n4\n\n\nNote\nIn the first sample the suitable pairs of i and j for the first query are: (1, 2), (1, 4), (1, 5), (2, 3), (3, 6), (5, 6), (6, 6). Not a single of these pairs is suitable for the second query.\n\nIn the second sample xor equals 1 for all subarrays of an odd length.",
        "platform": "codeforces",
        "question_id": "617/E",
        "contest_id": "617",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with xor equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor li, ri in queries:\n    subarray = a[li-1:ri]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with xor equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with xor equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Output results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with XOR equal to k\ndef count_pairs_with_xor(arr, k):\n    count = 0\n    prefix_xor = 0\n    xor_count = defaultdict(int)\n    xor_count[0] = 1\n    \n    for num in arr:\n        prefix_xor ^= num\n        target = prefix_xor ^ k\n        count += xor_count[target]\n        xor_count[prefix_xor] += 1\n    \n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef count_xor_pairs(n, m, k, a, queries):\n    prefix_xor = [0] * (n + 1)\n    xor_count = defaultdict(int)\n    xor_count[0] = 1\n    result = []\n\n    for i in range(1, n + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ a[i - 1]\n\n    for l, r in queries:\n        target_xor = prefix_xor[r] ^ prefix_xor[l - 1]\n        result.append(xor_count[target_xor])\n\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3 + n]))\nqueries = [(int(data[3 + n + 2 * i]), int(data[3 + n + 2 * i + 1])) for i in range(m)]\n\n# Solve the problem\nresult = count_xor_pairs(n, m, k, a, queries)\n\n# Write output\nfor res in result:\n    print(res)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with xor equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Write results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with XOR equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with XOR equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Output results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with xor equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Output results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with XOR equal to k\ndef count_pairs_with_xor(arr, k):\n    count = 0\n    xor_map = defaultdict(int)\n    xor_map[0] = 1\n    current_xor = 0\n    for num in arr:\n        current_xor ^= num\n        target = current_xor ^ k\n        count += xor_map[target]\n        xor_map[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Print results\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with xor equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor li, ri in queries:\n    subarray = a[li-1:ri]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with xor equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with xor equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Output results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with XOR equal to k\ndef count_pairs_with_xor(arr, k):\n    count = 0\n    prefix_xor = 0\n    xor_count = defaultdict(int)\n    xor_count[0] = 1\n    \n    for num in arr:\n        prefix_xor ^= num\n        target = prefix_xor ^ k\n        count += xor_count[target]\n        xor_count[prefix_xor] += 1\n    \n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\ndef count_xor_pairs(n, m, k, a, queries):\n    prefix_xor = [0] * (n + 1)\n    xor_count = defaultdict(int)\n    xor_count[0] = 1\n    result = []\n\n    for i in range(1, n + 1):\n        prefix_xor[i] = prefix_xor[i - 1] ^ a[i - 1]\n\n    for l, r in queries:\n        target_xor = prefix_xor[r] ^ prefix_xor[l - 1]\n        result.append(xor_count[target_xor])\n\n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3 + n]))\nqueries = [(int(data[3 + n + 2 * i]), int(data[3 + n + 2 * i + 1])) for i in range(m)]\n\n# Solve the problem\nresult = count_xor_pairs(n, m, k, a, queries)\n\n# Write output\nfor res in result:\n    print(res)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with xor equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Write results to stdout\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with XOR equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with XOR equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Output results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with xor equal to k\ndef count_pairs_with_xor(arr, k):\n    prefix_xor = defaultdict(int)\n    prefix_xor[0] = 1\n    current_xor = 0\n    count = 0\n    for num in arr:\n        current_xor ^= num\n        target_xor = current_xor ^ k\n        count += prefix_xor[target_xor]\n        prefix_xor[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Output results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\na = list(map(int, data[3:3+n]))\nqueries = [(int(data[3+n+2*i]), int(data[3+n+2*i+1])) for i in range(m)]\n\n# Function to count pairs with XOR equal to k\ndef count_pairs_with_xor(arr, k):\n    count = 0\n    xor_map = defaultdict(int)\n    xor_map[0] = 1\n    current_xor = 0\n    for num in arr:\n        current_xor ^= num\n        target = current_xor ^ k\n        count += xor_map[target]\n        xor_map[current_xor] += 1\n    return count\n\n# Process each query\nresults = []\nfor l, r in queries:\n    subarray = a[l-1:r]\n    results.append(count_pairs_with_xor(subarray, k))\n\n# Print results\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "New Year Tree",
        "question_content": "The New Year holidays are over, but Resha doesn't want to throw away the New Year tree. He invited his best friends Kerim and Gural to help him to redecorate the New Year tree.\n\nThe New Year tree is an undirected tree with n vertices and root in the vertex 1.\n\nYou should process the queries of the two types:\n\n1. Change the colours of all vertices in the subtree of the vertex v to the colour c.\n2. Find the number of different colours in the subtree of the vertex v.\n\n\nInput Format\nThe first line contains two integers n, m (1 \u2264 n, m \u2264 4\u00b7105) \u2014 the number of vertices in the tree and the number of the queries.\n\nThe second line contains n integers ci (1 \u2264 ci \u2264 60) \u2014 the colour of the i-th vertex.\n\nEach of the next n - 1 lines contains two integers xj, yj (1 \u2264 xj, yj \u2264 n) \u2014 the vertices of the j-th edge. It is guaranteed that you are given correct undirected tree.\n\nThe last m lines contains the description of the queries. Each description starts with the integer tk (1 \u2264 tk \u2264 2) \u2014 the type of the k-th query. For the queries of the first type then follows two integers vk, ck (1 \u2264 vk \u2264 n, 1 \u2264 ck \u2264 60) \u2014 the number of the vertex whose subtree will be recoloured with the colour ck. For the queries of the second type then follows integer vk (1 \u2264 vk \u2264 n) \u2014 the number of the vertex for which subtree you should find the number of different colours.\n\n\nOutput Format\nFor each query of the second type print the integer a \u2014 the number of different colours in the subtree of the vertex given in the query.\n\nEach of the numbers should be printed on a separate line in order of query appearing in the input.\n\n\nSample Input 1\n\n7 10\n1 1 1 1 1 1 1\n1 2\n1 3\n1 4\n3 5\n3 6\n3 7\n1 3 2\n2 1\n1 4 3\n2 1\n1 2 5\n2 1\n1 6 4\n2 1\n2 2\n2 3\n\nSample Output 1\n\n2\n3\n4\n5\n1\n2\n\n\nSample Input 2\n\n23 30\n1 2 2 6 5 3 2 1 1 1 2 4 5 3 4 4 3 3 3 3 3 4 6\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n4 11\n6 12\n6 13\n7 14\n7 15\n7 16\n8 17\n8 18\n10 19\n10 20\n10 21\n11 22\n11 23\n2 1\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 4\n1 12 1\n1 13 1\n1 14 1\n1 15 1\n1 16 1\n1 17 1\n1 18 1\n1 19 1\n1 20 1\n1 21 1\n1 22 1\n1 23 1\n2 1\n2 5\n2 6\n2 7\n2 8\n2 9\n2 10\n2 11\n2 4\n\nSample Output 2\n\n6\n1\n3\n3\n2\n1\n2\n3\n5\n5\n1\n2\n2\n1\n1\n1\n2\n3",
        "platform": "codeforces",
        "question_id": "620/E",
        "contest_id": "620",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nfor i in range(n-1):\n    x = int(data[2+n+2*i])\n    y = int(data[2+n+2*i+1])\n    edges.append((x, y))\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Initialize the color count for each node\ncolor_count = [defaultdict(int) for _ in range(n+1)]\n\n# Function to update the color count for a node and its subtree\ndef update_color(node, color):\n    color_count[node][color] += 1\n    for neighbor in tree[node]:\n        if neighbor != parent[node]:\n            update_color(neighbor, color)\n\n# Function to query the number of different colors in the subtree of a node\ndef query_color(node):\n    return len(color_count[node])\n\n# Initialize the parent array for DFS\nparent = [0] * (n+1)\n\n# DFS to initialize the color count and parent array\ndef dfs(node, par):\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n            for color, count in color_count[neighbor].items():\n                color_count[node][color] += count\n\n# Initialize the color count for the root node\nupdate_color(1, colors[0])\n\n# Perform DFS to initialize the color count and parent array\ndfs(1, -1)\n\n# Process the queries\nquery_index = 2 + n + 2 * (n - 1)\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        node = int(data[query_index])\n        query_index += 1\n        color = int(data[query_index])\n        query_index += 1\n        update_color(node, color)\n    elif query_type == 2:\n        node = int(data[query_index])\n        query_index += 1\n        answer.append(query_color(node))\n\n# Print the answers\nfor a in answer:\n    print(a)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize data structures\nsubtree_colors = [set() for _ in range(n + 1)]\nparent = [0] * (n + 1)\ndepth = [0] * (n + 1)\n\n# DFS to populate parent and depth arrays\ndef dfs(node, par):\n    parent[node] = par\n    depth[node] = depth[par] + 1\n    subtree_colors[node].add(colors[node - 1])\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\ndfs(1, 0)\n\n# Process queries\nqueries = []\nindex = 2 + n + (n - 1) * 2\nfor _ in range(m):\n    tk = int(data[index])\n    if tk == 1:\n        vk = int(data[index + 1])\n        ck = int(data[index + 2])\n        queries.append((tk, vk, ck))\n        index += 3\n    elif tk == 2:\n        vk = int(data[index])\n        queries.append((tk, vk))\n        index += 1\n\n# Function to update subtree colors\ndef update_subtree_colors(node, color):\n    subtree_colors[node].add(color)\n    for neighbor in tree[node]:\n        if neighbor != parent[node]:\n            update_subtree_colors(neighbor, color)\n\n# Function to get number of distinct colors in subtree\ndef get_distinct_colors(node):\n    return len(subtree_colors[node])\n\n# Process each query\nresults = []\nfor query in queries:\n    if query[0] == 1:\n        update_subtree_colors(query[1], query[2])\n    elif query[0] == 2:\n        results.append(get_distinct_colors(query[1]))\n\n# Write results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Function to perform DFS and update colors\ndef dfs(node, parent, color):\n    if colors[node] != color:\n        colors[node] = color\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, color)\n\n# Function to count distinct colors in the subtree\ndef count_distinct_colors(node, parent):\n    distinct_colors = set()\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            distinct_colors.update(count_distinct_colors(neighbor, node))\n    distinct_colors.add(colors[node])\n    return distinct_colors\n\n# Process queries\nquery_index = 2 + n + (n - 1) * 2\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        v = int(data[query_index])\n        c = int(data[query_index + 1])\n        query_index += 2\n        dfs(v, -1, c)\n    elif query_type == 2:\n        v = int(data[query_index])\n        query_index += 1\n        distinct_colors = count_distinct_colors(v, -1)\n        answer.append(len(distinct_colors))\n\n# Write the answer to stdout\nfor a in answer:\n    print(a)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nfor i in range(n-1):\n    x = int(data[2+n+2*i])\n    y = int(data[2+n+2*i+1])\n    edges.append((x, y))\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Function to perform DFS and update colors\ndef dfs(node, parent, color):\n    colors[node] = color\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, color)\n\n# Function to perform DFS and count unique colors\ndef count_unique_colors(node, parent):\n    unique_colors = set()\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            unique_colors.update(count_unique_colors(neighbor, node))\n    unique_colors.add(colors[node])\n    return unique_colors\n\n# Process queries\nquery_index = 2 + n + 2 * (n - 1)\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        v = int(data[query_index])\n        c = int(data[query_index + 1])\n        query_index += 2\n        dfs(v, -1, c)\n    elif query_type == 2:\n        v = int(data[query_index])\n        query_index += 1\n        unique_colors = count_unique_colors(v, -1)\n        answer.append(len(unique_colors))\n\n# Write the answer to stdout\nfor a in answer:\n    print(a)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nfor i in range(n-1):\n    x = int(data[2+n+2*i])\n    y = int(data[2+n+2*i+1])\n    edges.append((x, y))\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Initialize the color count for each node\ncolor_count = [defaultdict(int) for _ in range(n+1)]\n\n# Function to update the color count for a node and its subtree\ndef update_color(node, new_color):\n    color_count[node][new_color] += 1\n    for neighbor in tree[node]:\n        update_color(neighbor, new_color)\n\n# Function to query the number of different colors in the subtree of a node\ndef query_color(node):\n    return len(color_count[node])\n\n# Process the queries\nindex = 2 + n + 2 * (n - 1)\nfor _ in range(m):\n    query_type = int(data[index])\n    node = int(data[index + 1])\n    if query_type == 1:\n        new_color = int(data[index + 2])\n        update_color(node, new_color)\n    elif query_type == 2:\n        answer.append(query_color(node))\n    index += 3\n\n# Print the answers\nfor a in answer:\n    print(a)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\nqueries = []\nfor _ in range(m):\n    tk = int(data[index])\n    if tk == 1:\n        vk = int(data[index + 1])\n        ck = int(data[index + 2])\n        queries.append((tk, vk, ck))\n        index += 3\n    else:\n        vk = int(data[index])\n        queries.append((tk, vk))\n        index += 1\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize color count for each node\ncolor_count = [defaultdict(int) for _ in range(n + 1)]\n\n# Function to update the color count for a node and its subtree\ndef update_color(node, color):\n    color_count[node][color] += 1\n    for neighbor in tree[node]:\n        update_color(neighbor, color)\n\n# Function to get the number of distinct colors in the subtree of a node\ndef get_distinct_colors(node, parent):\n    distinct_colors = set()\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            distinct_colors.update(get_distinct_colors(neighbor, node))\n    distinct_colors.add(colors[node - 1])\n    return distinct_colors\n\n# Process queries\nresults = []\nfor query in queries:\n    if query[0] == 1:\n        update_color(query[1], query[2])\n    else:\n        distinct_colors = get_distinct_colors(query[1], -1)\n        results.append(len(distinct_colors))\n\n# Output results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswers = []\n\n# Function to perform DFS and update colors\ndef dfs(node, parent, color):\n    if node != 1:\n        colors[node] = color\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, color)\n\n# Function to count distinct colors in the subtree\ndef count_distinct_colors(node, parent):\n    distinct_colors = set()\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            distinct_colors.update(count_distinct_colors(neighbor, node))\n    distinct_colors.add(colors[node])\n    return distinct_colors\n\n# Process queries\nquery_index = 2 + n + (n - 1) * 2\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        v = int(data[query_index])\n        c = int(data[query_index + 1])\n        query_index += 2\n        dfs(v, -1, c)\n    elif query_type == 2:\n        v = int(data[query_index])\n        query_index += 1\n        distinct_colors = count_distinct_colors(v, -1)\n        answers.append(len(distinct_colors))\n\n# Write answers to stdout\nfor answer in answers:\n    print(answer)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nfor i in range(n-1):\n    x = int(data[2+n+2*i])\n    y = int(data[2+n+2*i+1])\n    edges.append((x, y))\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Initialize the color count for each node\ncolor_count = [defaultdict(int) for _ in range(n+1)]\n\n# Function to update the color count for a node and its subtree\ndef update_color(node, new_color):\n    color_count[node][new_color] += 1\n    for neighbor in tree[node]:\n        if neighbor != parent[node]:\n            update_color(neighbor, new_color)\n\n# Function to query the number of different colors in the subtree of a node\ndef query_color(node):\n    return sum(1 for count in color_count[node].values() if count > 0)\n\n# Initialize the parent array for DFS\nparent = [0] * (n+1)\n\n# DFS to initialize the color count for each node\ndef dfs(node, par):\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n            for color, count in color_count[neighbor].items():\n                color_count[node][color] += count\n\n# Initialize the color count for the root\nupdate_color(1, colors[0])\n\n# Run the DFS to initialize the color count for the entire tree\ndfs(1, -1)\n\n# Process the queries\nquery_index = 2 + n + 2 * (n-1)\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        node = int(data[query_index])\n        query_index += 1\n        new_color = int(data[query_index])\n        query_index += 1\n        # Update the color count for the node and its subtree\n        update_color(node, new_color)\n    elif query_type == 2:\n        node = int(data[query_index])\n        query_index += 1\n        # Query the number of different colors in the subtree of the node\n        answer.append(query_color(node))\n\n# Print the answers\nfor a in answer:\n    print(a)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize data structures\ncolor_count = [defaultdict(int) for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    color_count[i][colors[i - 1]] = 1\n\n# Function to update the color of a subtree\ndef update_subtree(v, c):\n    color_count[v][colors[v - 1]] -= 1\n    if color_count[v][colors[v - 1]] == 0:\n        del color_count[v][colors[v - 1]]\n    colors[v - 1] = c\n    color_count[v][c] += 1\n\n# Function to get the number of distinct colors in a subtree\ndef get_distinct_colors(v):\n    return len(color_count[v])\n\n# Process queries\nqueries = []\nindex = 2 + n + (n - 1) * 2\nfor _ in range(m):\n    tk = int(data[index])\n    if tk == 1:\n        vk = int(data[index + 1])\n        ck = int(data[index + 2])\n        update_subtree(vk, ck)\n    else:\n        vk = int(data[index + 1])\n        queries.append(vk)\n    index += 3\n\n# Answer the queries\nfor vk in queries:\n    print(get_distinct_colors(vk))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Function to perform DFS and update colors\ndef dfs_update(node, parent, color):\n    colors[node] = color\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs_update(neighbor, node, color)\n\n# Function to perform DFS and count unique colors\ndef dfs_count(node, parent):\n    unique_colors = set()\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            unique_colors.update(dfs_count(neighbor, node))\n    unique_colors.add(colors[node])\n    return unique_colors\n\n# Process each query\nquery_index = 2 + n + (n - 1) * 2\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        v = int(data[query_index])\n        c = int(data[query_index + 1])\n        query_index += 2\n        dfs_update(v, -1, c)\n    elif query_type == 2:\n        v = int(data[query_index])\n        query_index += 1\n        unique_colors = dfs_count(v, -1)\n        answer.append(len(unique_colors))\n\n# Write the answer to stdout\nfor a in answer:\n    print(a)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nfor i in range(n-1):\n    x = int(data[2+n+2*i])\n    y = int(data[2+n+2*i+1])\n    edges.append((x, y))\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Initialize the color count for each node\ncolor_count = [defaultdict(int) for _ in range(n+1)]\n\n# Function to update the color count for a node and its subtree\ndef update_color(node, color):\n    color_count[node][color] += 1\n    for neighbor in tree[node]:\n        if neighbor != parent[node]:\n            update_color(neighbor, color)\n\n# Function to query the number of different colors in the subtree of a node\ndef query_color(node):\n    return len(color_count[node])\n\n# Initialize the parent array for DFS\nparent = [0] * (n+1)\n\n# DFS to initialize the color count and parent array\ndef dfs(node, par):\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n            for color, count in color_count[neighbor].items():\n                color_count[node][color] += count\n\n# Initialize the color count for the root node\nupdate_color(1, colors[0])\n\n# Perform DFS to initialize the color count and parent array\ndfs(1, -1)\n\n# Process the queries\nquery_index = 2 + n + 2 * (n - 1)\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        node = int(data[query_index])\n        query_index += 1\n        color = int(data[query_index])\n        query_index += 1\n        update_color(node, color)\n    elif query_type == 2:\n        node = int(data[query_index])\n        query_index += 1\n        answer.append(query_color(node))\n\n# Print the answers\nfor a in answer:\n    print(a)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize data structures\nsubtree_colors = [set() for _ in range(n + 1)]\nparent = [0] * (n + 1)\ndepth = [0] * (n + 1)\n\n# DFS to populate parent and depth arrays\ndef dfs(node, par):\n    parent[node] = par\n    depth[node] = depth[par] + 1\n    subtree_colors[node].add(colors[node - 1])\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n\ndfs(1, 0)\n\n# Process queries\nqueries = []\nindex = 2 + n + (n - 1) * 2\nfor _ in range(m):\n    tk = int(data[index])\n    if tk == 1:\n        vk = int(data[index + 1])\n        ck = int(data[index + 2])\n        queries.append((tk, vk, ck))\n        index += 3\n    elif tk == 2:\n        vk = int(data[index])\n        queries.append((tk, vk))\n        index += 1\n\n# Function to update subtree colors\ndef update_subtree_colors(node, color):\n    subtree_colors[node].add(color)\n    for neighbor in tree[node]:\n        if neighbor != parent[node]:\n            update_subtree_colors(neighbor, color)\n\n# Function to get number of distinct colors in subtree\ndef get_distinct_colors(node):\n    return len(subtree_colors[node])\n\n# Process each query\nresults = []\nfor query in queries:\n    if query[0] == 1:\n        update_subtree_colors(query[1], query[2])\n    elif query[0] == 2:\n        results.append(get_distinct_colors(query[1]))\n\n# Write results to stdout\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Function to perform DFS and update colors\ndef dfs(node, parent, color):\n    if colors[node] != color:\n        colors[node] = color\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, color)\n\n# Function to count distinct colors in the subtree\ndef count_distinct_colors(node, parent):\n    distinct_colors = set()\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            distinct_colors.update(count_distinct_colors(neighbor, node))\n    distinct_colors.add(colors[node])\n    return distinct_colors\n\n# Process queries\nquery_index = 2 + n + (n - 1) * 2\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        v = int(data[query_index])\n        c = int(data[query_index + 1])\n        query_index += 2\n        dfs(v, -1, c)\n    elif query_type == 2:\n        v = int(data[query_index])\n        query_index += 1\n        distinct_colors = count_distinct_colors(v, -1)\n        answer.append(len(distinct_colors))\n\n# Write the answer to stdout\nfor a in answer:\n    print(a)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nfor i in range(n-1):\n    x = int(data[2+n+2*i])\n    y = int(data[2+n+2*i+1])\n    edges.append((x, y))\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Function to perform DFS and update colors\ndef dfs(node, parent, color):\n    colors[node] = color\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, color)\n\n# Function to perform DFS and count unique colors\ndef count_unique_colors(node, parent):\n    unique_colors = set()\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            unique_colors.update(count_unique_colors(neighbor, node))\n    unique_colors.add(colors[node])\n    return unique_colors\n\n# Process queries\nquery_index = 2 + n + 2 * (n - 1)\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        v = int(data[query_index])\n        c = int(data[query_index + 1])\n        query_index += 2\n        dfs(v, -1, c)\n    elif query_type == 2:\n        v = int(data[query_index])\n        query_index += 1\n        unique_colors = count_unique_colors(v, -1)\n        answer.append(len(unique_colors))\n\n# Write the answer to stdout\nfor a in answer:\n    print(a)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nfor i in range(n-1):\n    x = int(data[2+n+2*i])\n    y = int(data[2+n+2*i+1])\n    edges.append((x, y))\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Initialize the color count for each node\ncolor_count = [defaultdict(int) for _ in range(n+1)]\n\n# Function to update the color count for a node and its subtree\ndef update_color(node, new_color):\n    color_count[node][new_color] += 1\n    for neighbor in tree[node]:\n        update_color(neighbor, new_color)\n\n# Function to query the number of different colors in the subtree of a node\ndef query_color(node):\n    return len(color_count[node])\n\n# Process the queries\nindex = 2 + n + 2 * (n - 1)\nfor _ in range(m):\n    query_type = int(data[index])\n    node = int(data[index + 1])\n    if query_type == 1:\n        new_color = int(data[index + 2])\n        update_color(node, new_color)\n    elif query_type == 2:\n        answer.append(query_color(node))\n    index += 3\n\n# Print the answers\nfor a in answer:\n    print(a)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\nqueries = []\nfor _ in range(m):\n    tk = int(data[index])\n    if tk == 1:\n        vk = int(data[index + 1])\n        ck = int(data[index + 2])\n        queries.append((tk, vk, ck))\n        index += 3\n    else:\n        vk = int(data[index])\n        queries.append((tk, vk))\n        index += 1\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize color count for each node\ncolor_count = [defaultdict(int) for _ in range(n + 1)]\n\n# Function to update the color count for a node and its subtree\ndef update_color(node, color):\n    color_count[node][color] += 1\n    for neighbor in tree[node]:\n        update_color(neighbor, color)\n\n# Function to get the number of distinct colors in the subtree of a node\ndef get_distinct_colors(node, parent):\n    distinct_colors = set()\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            distinct_colors.update(get_distinct_colors(neighbor, node))\n    distinct_colors.add(colors[node - 1])\n    return distinct_colors\n\n# Process queries\nresults = []\nfor query in queries:\n    if query[0] == 1:\n        update_color(query[1], query[2])\n    else:\n        distinct_colors = get_distinct_colors(query[1], -1)\n        results.append(len(distinct_colors))\n\n# Output results\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswers = []\n\n# Function to perform DFS and update colors\ndef dfs(node, parent, color):\n    if node != 1:\n        colors[node] = color\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, color)\n\n# Function to count distinct colors in the subtree\ndef count_distinct_colors(node, parent):\n    distinct_colors = set()\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            distinct_colors.update(count_distinct_colors(neighbor, node))\n    distinct_colors.add(colors[node])\n    return distinct_colors\n\n# Process queries\nquery_index = 2 + n + (n - 1) * 2\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        v = int(data[query_index])\n        c = int(data[query_index + 1])\n        query_index += 2\n        dfs(v, -1, c)\n    elif query_type == 2:\n        v = int(data[query_index])\n        query_index += 1\n        distinct_colors = count_distinct_colors(v, -1)\n        answers.append(len(distinct_colors))\n\n# Write answers to stdout\nfor answer in answers:\n    print(answer)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nfor i in range(n-1):\n    x = int(data[2+n+2*i])\n    y = int(data[2+n+2*i+1])\n    edges.append((x, y))\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Initialize the color count for each node\ncolor_count = [defaultdict(int) for _ in range(n+1)]\n\n# Function to update the color count for a node and its subtree\ndef update_color(node, new_color):\n    color_count[node][new_color] += 1\n    for neighbor in tree[node]:\n        if neighbor != parent[node]:\n            update_color(neighbor, new_color)\n\n# Function to query the number of different colors in the subtree of a node\ndef query_color(node):\n    return sum(1 for count in color_count[node].values() if count > 0)\n\n# Initialize the parent array for DFS\nparent = [0] * (n+1)\n\n# DFS to initialize the color count for each node\ndef dfs(node, par):\n    parent[node] = par\n    for neighbor in tree[node]:\n        if neighbor != par:\n            dfs(neighbor, node)\n            for color, count in color_count[neighbor].items():\n                color_count[node][color] += count\n\n# Initialize the color count for the root\nupdate_color(1, colors[0])\n\n# Run the DFS to initialize the color count for the entire tree\ndfs(1, -1)\n\n# Process the queries\nquery_index = 2 + n + 2 * (n-1)\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        node = int(data[query_index])\n        query_index += 1\n        new_color = int(data[query_index])\n        query_index += 1\n        # Update the color count for the node and its subtree\n        update_color(node, new_color)\n    elif query_type == 2:\n        node = int(data[query_index])\n        query_index += 1\n        # Query the number of different colors in the subtree of the node\n        answer.append(query_color(node))\n\n# Print the answers\nfor a in answer:\n    print(a)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize data structures\ncolor_count = [defaultdict(int) for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    color_count[i][colors[i - 1]] = 1\n\n# Function to update the color of a subtree\ndef update_subtree(v, c):\n    color_count[v][colors[v - 1]] -= 1\n    if color_count[v][colors[v - 1]] == 0:\n        del color_count[v][colors[v - 1]]\n    colors[v - 1] = c\n    color_count[v][c] += 1\n\n# Function to get the number of distinct colors in a subtree\ndef get_distinct_colors(v):\n    return len(color_count[v])\n\n# Process queries\nqueries = []\nindex = 2 + n + (n - 1) * 2\nfor _ in range(m):\n    tk = int(data[index])\n    if tk == 1:\n        vk = int(data[index + 1])\n        ck = int(data[index + 2])\n        update_subtree(vk, ck)\n    else:\n        vk = int(data[index + 1])\n        queries.append(vk)\n    index += 3\n\n# Answer the queries\nfor vk in queries:\n    print(get_distinct_colors(vk))",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ncolors = list(map(int, data[2:2+n]))\nedges = []\nindex = 2 + n\nfor _ in range(n - 1):\n    x = int(data[index])\n    y = int(data[index + 1])\n    edges.append((x, y))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor x, y in edges:\n    tree[x].append(y)\n    tree[y].append(x)\n\n# Initialize the answer list\nanswer = []\n\n# Function to perform DFS and update colors\ndef dfs_update(node, parent, color):\n    colors[node] = color\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            dfs_update(neighbor, node, color)\n\n# Function to perform DFS and count unique colors\ndef dfs_count(node, parent):\n    unique_colors = set()\n    for neighbor in tree[node]:\n        if neighbor != parent:\n            unique_colors.update(dfs_count(neighbor, node))\n    unique_colors.add(colors[node])\n    return unique_colors\n\n# Process each query\nquery_index = 2 + n + (n - 1) * 2\nfor _ in range(m):\n    query_type = int(data[query_index])\n    query_index += 1\n    if query_type == 1:\n        v = int(data[query_index])\n        c = int(data[query_index + 1])\n        query_index += 2\n        dfs_update(v, -1, c)\n    elif query_type == 2:\n        v = int(data[query_index])\n        query_index += 1\n        unique_colors = dfs_count(v, -1)\n        answer.append(len(unique_colors))\n\n# Write the answer to stdout\nfor a in answer:\n    print(a)"
        ]
    },
    {
        "question_title": "Xors on Segments",
        "question_content": "You are given an array with n integers ai and m queries. Each query is described by two integers (lj, rj).\n\nLet's define the function f(u,v) = u \\oplus (u+1) \\oplus \\ldots \\oplus v. The function is defined for only u \u2264 v.\n\nFor each query print the maximal value of the function f(ax, ay) over all lj \u2264 x, y \u2264 rj, ax \u2264 ay.\n\n\nInput Format\nThe first line contains two integers n, m (1 \u2264 n \u2264 5\u00b7104, 1 \u2264 m \u2264 5\u00b7103) \u2014 the size of the array and the number of the queries.\n\nThe second line contains n integers ai (1 \u2264 ai \u2264 106) \u2014 the elements of the array a.\n\nEach of the next m lines contains two integers lj, rj (1 \u2264 lj \u2264 rj \u2264 n) - the parameters of the j-th query.\n\n\nOutput Format\nFor each query print the value aj on a separate line \u2014 the maximal value of the function f(ax, ay) over all lj \u2264 x, y \u2264 rj, ax \u2264 ay.\n\n\nSample Input 1\n\n6 3\n1 2 3 4 5 6\n1 6\n2 5\n3 4\n\nSample Output 1\n\n7\n7\n7\n\n\nSample Input 2\n\n1 1\n1\n1 1\n\nSample Output 2\n\n1\n\n\nSample Input 3\n\n6 20\n10 21312 2314 214 1 322\n1 1\n1 2\n1 3\n1 4\n1 5\n1 6\n2 2\n2 3\n2 4\n2 5\n2 6\n3 4\n3 5\n3 6\n4 4\n4 5\n4 6\n5 5\n5 6\n6 6\n\nSample Output 3\n\n10\n21313\n21313\n21313\n21313\n21313\n21312\n21313\n21313\n21313\n21313\n2314\n2315\n2315\n214\n215\n323\n1\n323\n322",
        "platform": "codeforces",
        "question_id": "620/F",
        "contest_id": "620",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return v\n    else:\n        return u ^ (u + 1) ^ v\n\nresults = []\nfor lj, rj in queries:\n    max_val = 0\n    for x in range(lj, rj + 1):\n        for y in range(x, rj + 1):\n            max_val = max(max_val, f(a[x-1], a[y-1]))\n    results.append(max_val)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return f(u+1, v)\n    else:\n        return u ^ f(u+1, v)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj+1):\n        for y in range(x, rj+1):\n            max_value = max(max_value, f(a[x-1], a[y-1]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return v\n    else:\n        return u ^ (u + 1) ^ f(u + 2, v)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj + 1):\n        for y in range(x, rj + 1):\n            max_value = max(max_value, f(a[x], a[y]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return f(u+1, v)\n    else:\n        return u ^ f(u+1, v)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj+1):\n        for y in range(x, rj+1):\n            max_value = max(max_value, f(a[x], a[y]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return v ^ (v - 1)\n    else:\n        return u ^ (u + 1)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj + 1):\n        for y in range(x, rj + 1):\n            max_value = max(max_value, f(a[x-1], a[y-1]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef f(u: int, v: int) -> int:\n    if u == v:\n        return u\n    elif u % 2 == 0 and v % 2 == 0:\n        return u + 1\n    elif u % 2 == 1 and v % 2 == 1:\n        return u\n    else:\n        return u + 1\n\ndef solve(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for lj, rj in queries:\n        max_value = 0\n        for x in range(lj, rj + 1):\n            for y in range(x, rj + 1):\n                max_value = max(max_value, f(a[x - 1], a[y - 1]))\n        results.append(max_value)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2 + n]))\n    queries = []\n    for i in range(m):\n        lj = int(data[2 + n + 2 * i])\n        rj = int(data[2 + n + 2 * i + 1])\n        queries.append([lj, rj])\n    \n    results = solve(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return f(u+1, v)\n    else:\n        return u ^ f(u+1, v)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj+1):\n        for y in range(x, rj+1):\n            max_value = max(max_value, f(a[x], a[y]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef f(u: int, v: int) -> int:\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return v\n    else:\n        return u ^ (u + 1) ^ f(u + 2, v)\n\ndef solve(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for lj, rj in queries:\n        max_value = 0\n        for x in range(lj, rj + 1):\n            for y in range(x, rj + 1):\n                max_value = max(max_value, f(a[x - 1], a[y - 1]))\n        results.append(max_value)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2 + n]))\n    queries = []\n    for i in range(m):\n        lj = int(data[2 + n + 2 * i])\n        rj = int(data[2 + n + 2 * i + 1])\n        queries.append([lj, rj])\n    \n    results = solve(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return v\n    else:\n        return u ^ (u + 1) ^ f(u + 2, v)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj + 1):\n        for y in range(x, rj + 1):\n            max_value = max(max_value, f(a[x-1], a[y-1]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    return u ^ (u + 1) ^ f(u + 1, v)\n\nresults = []\nfor lj, rj in queries:\n    max_val = 0\n    for x in range(lj, rj + 1):\n        for y in range(x, rj + 1):\n            max_val = max(max_val, f(a[x-1], a[y-1]))\n    results.append(max_val)\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return v\n    else:\n        return u ^ (u + 1) ^ v\n\nresults = []\nfor lj, rj in queries:\n    max_val = 0\n    for x in range(lj, rj + 1):\n        for y in range(x, rj + 1):\n            max_val = max(max_val, f(a[x-1], a[y-1]))\n    results.append(max_val)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return f(u+1, v)\n    else:\n        return u ^ f(u+1, v)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj+1):\n        for y in range(x, rj+1):\n            max_value = max(max_value, f(a[x-1], a[y-1]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return v\n    else:\n        return u ^ (u + 1) ^ f(u + 2, v)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj + 1):\n        for y in range(x, rj + 1):\n            max_value = max(max_value, f(a[x], a[y]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return f(u+1, v)\n    else:\n        return u ^ f(u+1, v)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj+1):\n        for y in range(x, rj+1):\n            max_value = max(max_value, f(a[x], a[y]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return v ^ (v - 1)\n    else:\n        return u ^ (u + 1)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj + 1):\n        for y in range(x, rj + 1):\n            max_value = max(max_value, f(a[x-1], a[y-1]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)",
            "import sys\nfrom typing import List\n\ndef f(u: int, v: int) -> int:\n    if u == v:\n        return u\n    elif u % 2 == 0 and v % 2 == 0:\n        return u + 1\n    elif u % 2 == 1 and v % 2 == 1:\n        return u\n    else:\n        return u + 1\n\ndef solve(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for lj, rj in queries:\n        max_value = 0\n        for x in range(lj, rj + 1):\n            for y in range(x, rj + 1):\n                max_value = max(max_value, f(a[x - 1], a[y - 1]))\n        results.append(max_value)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2 + n]))\n    queries = []\n    for i in range(m):\n        lj = int(data[2 + n + 2 * i])\n        rj = int(data[2 + n + 2 * i + 1])\n        queries.append([lj, rj])\n    \n    results = solve(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i])-1, int(data[2+n+2*i+1])-1) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return f(u+1, v)\n    else:\n        return u ^ f(u+1, v)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj+1):\n        for y in range(x, rj+1):\n            max_value = max(max_value, f(a[x], a[y]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)",
            "import sys\nfrom typing import List\n\ndef f(u: int, v: int) -> int:\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return v\n    else:\n        return u ^ (u + 1) ^ f(u + 2, v)\n\ndef solve(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for lj, rj in queries:\n        max_value = 0\n        for x in range(lj, rj + 1):\n            for y in range(x, rj + 1):\n                max_value = max(max_value, f(a[x - 1], a[y - 1]))\n        results.append(max_value)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2 + n]))\n    queries = []\n    for i in range(m):\n        lj = int(data[2 + n + 2 * i])\n        rj = int(data[2 + n + 2 * i + 1])\n        queries.append([lj, rj])\n    \n    results = solve(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    elif u % 2 == 0:\n        return v\n    else:\n        return u ^ (u + 1) ^ f(u + 2, v)\n\nresults = []\nfor lj, rj in queries:\n    max_value = 0\n    for x in range(lj, rj + 1):\n        for y in range(x, rj + 1):\n            max_value = max(max_value, f(a[x-1], a[y-1]))\n    results.append(max_value)\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+2*i]), int(data[2+n+2*i+1])) for i in range(m)]\n\ndef f(u, v):\n    if u == v:\n        return u\n    return u ^ (u + 1) ^ f(u + 1, v)\n\nresults = []\nfor lj, rj in queries:\n    max_val = 0\n    for x in range(lj, rj + 1):\n        for y in range(x, rj + 1):\n            max_val = max(max_val, f(a[x-1], a[y-1]))\n    results.append(max_val)\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Thief in a Shop",
        "question_content": "A thief made his way to a shop.\n\nAs usual he has his lucky knapsack with him. The knapsack can contain k objects. There are n kinds of products in the shop and an infinite number of products of each kind. The cost of one product of kind i is ai.\n\nThe thief is greedy, so he will take exactly k products (it's possible for some kinds to take several products of that kind).\n\nFind all the possible total costs of products the thief can nick into his knapsack.\n\n\nInput Format\nThe first line contains two integers n and k (1 \u2264 n, k \u2264 1000) \u2014 the number of kinds of products and the number of products the thief will take.\n\nThe second line contains n integers ai (1 \u2264 ai \u2264 1000) \u2014 the costs of products for kinds from 1 to n.\n\n\nOutput Format\nPrint the only line with all the possible total costs of stolen products, separated by a space. The numbers should be printed in the ascending order.\n\n\nSample Input 1\n\n3 2\n1 2 3\n\nSample Output 1\n\n2 3 4 5 6\n\n\nSample Input 2\n\n5 5\n1 1 1 1 1\n\nSample Output 2\n\n5\n\n\nSample Input 3\n\n3 3\n3 5 11\n\nSample Output 3\n\n9 11 13 15 17 19 21 25 27 33",
        "platform": "codeforces",
        "question_id": "632/E",
        "contest_id": "632",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Sort the possible costs and print them\nsorted_costs = sorted(possible_costs)\nprint(' '.join(map(str, sorted_costs)))\n```",
            "```python\nimport sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Print the sorted possible costs\nprint(' '.join(map(str, sorted(possible_costs))))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Initialize a set to store unique total costs\ntotal_costs = set()\n\n# Use a nested loop to generate all possible combinations of k products\nfor i in range(n):\n    for j in range(i, n):\n        for l in range(j, n):\n            for m in range(l, n):\n                for o in range(m, n):\n                    for p in range(o, n):\n                        total_costs.add(costs[i] + costs[j] + costs[l] + costs[m] + costs[o] + costs[p])\n\n# Convert the set to a sorted list\ntotal_costs = sorted(list(total_costs))\n\n# Print the total costs separated by a space\nprint(' '.join(map(str, total_costs)))\n```",
            "```python\nimport sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Sort the possible costs and print them\nsorted_costs = sorted(possible_costs)\nprint(' '.join(map(str, sorted_costs)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize a set to store unique possible total costs\npossible_costs = set()\n\n# Use a nested loop to generate all possible combinations of k products\nfor i in range(n):\n    for j in range(n):\n        for l in range(n):\n            for m in range(n):\n                for o in range(n):\n                    for p in range(n):\n                        if i + j + l + m + o + p == k:\n                            possible_costs.add(a[i] + a[j] + a[l] + a[m] + a[o] + a[p])\n\n# Convert the set to a sorted list\npossible_costs = sorted(list(possible_costs))\n\n# Print the possible total costs\nprint(' '.join(map(str, possible_costs)))\n```",
            "```python\nimport sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Sort the possible costs and print them\nsorted_costs = sorted(possible_costs)\nprint(' '.join(map(str, sorted_costs)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Initialize a set to store unique possible total costs\npossible_costs = set()\n\n# Use a recursive function to find all possible total costs\ndef find_costs(current_cost, count):\n    if count == k:\n        possible_costs.add(current_cost)\n        return\n    for cost in costs:\n        find_costs(current_cost + cost, count + 1)\n\n# Start the recursive function with initial cost 0 and count 0\nfind_costs(0, 0)\n\n# Sort the possible costs and print them\nsorted_costs = sorted(possible_costs)\nprint(' '.join(map(str, sorted_costs)))\n```",
            "```python\nimport sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Sort the possible costs and print them\nsorted_costs = sorted(possible_costs)\nprint(' '.join(map(str, sorted_costs)))\n```",
            "```python\nimport sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products with replacement\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Print the sorted possible costs\nprint(' '.join(map(str, sorted(possible_costs))))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Initialize a set to store unique total costs\ntotal_costs = set()\n\n# Use a nested loop to generate all possible combinations of k products\nfor i in range(n):\n    for j in range(i, n):\n        for l in range(j, n):\n            for m in range(l, n):\n                for o in range(m, n):\n                    total_costs.add(costs[i] + costs[j] + costs[l] + costs[m] + costs[o])\n\n# Convert the set to a sorted list\ntotal_costs = sorted(list(total_costs))\n\n# Print the total costs separated by a space\nprint(' '.join(map(str, total_costs)))\n```"
        ],
        "code_list": [
            "import sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Sort the possible costs and print them\nsorted_costs = sorted(possible_costs)\nprint(' '.join(map(str, sorted_costs)))",
            "import sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Print the sorted possible costs\nprint(' '.join(map(str, sorted(possible_costs))))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Initialize a set to store unique total costs\ntotal_costs = set()\n\n# Use a nested loop to generate all possible combinations of k products\nfor i in range(n):\n    for j in range(i, n):\n        for l in range(j, n):\n            for m in range(l, n):\n                for o in range(m, n):\n                    for p in range(o, n):\n                        total_costs.add(costs[i] + costs[j] + costs[l] + costs[m] + costs[o] + costs[p])\n\n# Convert the set to a sorted list\ntotal_costs = sorted(list(total_costs))\n\n# Print the total costs separated by a space\nprint(' '.join(map(str, total_costs)))",
            "import sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Sort the possible costs and print them\nsorted_costs = sorted(possible_costs)\nprint(' '.join(map(str, sorted_costs)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize a set to store unique possible total costs\npossible_costs = set()\n\n# Use a nested loop to generate all possible combinations of k products\nfor i in range(n):\n    for j in range(n):\n        for l in range(n):\n            for m in range(n):\n                for o in range(n):\n                    for p in range(n):\n                        if i + j + l + m + o + p == k:\n                            possible_costs.add(a[i] + a[j] + a[l] + a[m] + a[o] + a[p])\n\n# Convert the set to a sorted list\npossible_costs = sorted(list(possible_costs))\n\n# Print the possible total costs\nprint(' '.join(map(str, possible_costs)))",
            "import sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Sort the possible costs and print them\nsorted_costs = sorted(possible_costs)\nprint(' '.join(map(str, sorted_costs)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Initialize a set to store unique possible total costs\npossible_costs = set()\n\n# Use a recursive function to find all possible total costs\ndef find_costs(current_cost, count):\n    if count == k:\n        possible_costs.add(current_cost)\n        return\n    for cost in costs:\n        find_costs(current_cost + cost, count + 1)\n\n# Start the recursive function with initial cost 0 and count 0\nfind_costs(0, 0)\n\n# Sort the possible costs and print them\nsorted_costs = sorted(possible_costs)\nprint(' '.join(map(str, sorted_costs)))",
            "import sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Sort the possible costs and print them\nsorted_costs = sorted(possible_costs)\nprint(' '.join(map(str, sorted_costs)))",
            "import sys\nfrom itertools import combinations_with_replacement\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Generate all possible combinations of k products with replacement\npossible_costs = set()\nfor combo in combinations_with_replacement(costs, k):\n    possible_costs.add(sum(combo))\n\n# Print the sorted possible costs\nprint(' '.join(map(str, sorted(possible_costs))))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\ncosts = list(map(int, data[2:]))\n\n# Initialize a set to store unique total costs\ntotal_costs = set()\n\n# Use a nested loop to generate all possible combinations of k products\nfor i in range(n):\n    for j in range(i, n):\n        for l in range(j, n):\n            for m in range(l, n):\n                for o in range(m, n):\n                    total_costs.add(costs[i] + costs[j] + costs[l] + costs[m] + costs[o])\n\n# Convert the set to a sorted list\ntotal_costs = sorted(list(total_costs))\n\n# Print the total costs separated by a space\nprint(' '.join(map(str, total_costs)))"
        ]
    },
    {
        "question_title": "Fibonacci-ish",
        "question_content": "Yash has recently learnt about the Fibonacci sequence and is very excited about it. He calls a sequence Fibonacci-ish if\n\n1. the sequence consists of at least two elements\n2. f0 and f1 are arbitrary\n3. fn + 2 = fn + 1 + fn for all n \u2265 0.\n\nYou are given some sequence of integers a1, a2, ..., an. Your task is rearrange elements of this sequence in such a way that its longest possible prefix is Fibonacci-ish sequence.\n\n\nInput Format\nThe first line of the input contains a single integer n (2 \u2264 n \u2264 1000)\u00a0\u2014 the length of the sequence ai.\n\nThe second line contains n integers a1, a2, ..., an (|ai| \u2264 109).\n\n\nOutput Format\nPrint the length of the longest possible Fibonacci-ish prefix of the given sequence after rearrangement.\n\n\nSample Input 1\n\n3\n1 2 -1\n\nSample Output 1\n\n3\n\n\nSample Input 2\n\n5\n28 35 7 14 21\n\nSample Output 2\n\n4\n\n\nNote\nIn the first sample, if we rearrange elements of the sequence as - 1, 2, 1, the whole sequence ai would be Fibonacci-ish.\n\nIn the second sample, the optimal way to rearrange elements is 7, 14, 21, 35, 28.",
        "platform": "codeforces",
        "question_id": "633/D",
        "contest_id": "633",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to try and find the longest Fibonacci-ish prefix\na.sort()\n\n# Initialize the length of the Fibonacci-ish prefix\nfib_len = 0\n\n# Try to find the longest Fibonacci-ish prefix\nfor i in range(n):\n    if i == 0 or i == 1:\n        fib_len += 1\n    else:\n        if a[i] == a[i-1] + a[i-2]:\n            fib_len += 1\n        else:\n            break\n\n# Output the length of the longest Fibonacci-ish prefix\nprint(fib_len)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to make it easier to find the longest Fibonacci-ish prefix\na.sort()\n\n# Initialize the length of the longest Fibonacci-ish prefix\nmax_length = 0\n\n# Iterate through the array to find the longest Fibonacci-ish prefix\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Check if the sequence a[i], a[j], a[j+1], ... is Fibonacci-ish\n        if a[j] - a[i] == a[j + 1] - a[j]:\n            length = 2\n            while j + length < n and a[j + length] - a[j + length - 1] == a[j + length - 1] - a[j + length - 2]:\n                length += 1\n            max_length = max(max_length, length)\n\n# Print the length of the longest possible Fibonacci-ish prefix\nprint(max_length)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci_ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Try all possible pairs as the first two elements\nmax_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Create a new sequence with the first two elements fixed\n        new_seq = [sequence[i], sequence[j]]\n        # Add the rest of the elements in any order\n        remaining = [x for x in sequence if x != sequence[i] and x != sequence[j]]\n        new_seq.extend(remaining)\n        # Check if the new sequence is Fibonacci-ish\n        if is_fibonacci_ish(new_seq):\n            max_length = max(max_length, len(new_seq))\n\n# Print the length of the longest Fibonacci-ish prefix\nprint(max_length)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci_ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Try all possible pairs as the first two elements\nmax_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Create a new sequence with the first two elements as i and j\n        new_seq = [a[i], a[j]]\n        # Add the rest of the elements in any order\n        remaining = [x for x in a if x != a[i] and x != a[j]]\n        new_seq.extend(remaining)\n        # Check if the new sequence is Fibonacci-ish\n        if is_fibonacci_ish(new_seq):\n            max_length = max(max_length, len(new_seq))\n\nprint(max_length)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci_ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Try all possible pairs as the first two elements\nmax_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Create a new sequence with the first two elements as i and j\n        new_seq = [a[i], a[j]]\n        # Add the rest of the elements in any order\n        remaining = [x for x in a if x != a[i] and x != a[j]]\n        new_seq.extend(remaining)\n        # Check if the new sequence is Fibonacci-ish\n        if is_fibonacci_ish(new_seq):\n            max_length = max(max_length, len(new_seq))\n\nprint(max_length)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci-ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Sort the array to try and form the longest Fibonacci-ish prefix\na.sort()\n\n# Try to find the longest Fibonacci-ish prefix\nmax_length = 0\nfor i in range(2, n + 1):\n    prefix = a[:i]\n    if is_fibonacci-ish(prefix):\n        max_length = i\n\nprint(max_length)\n```",
            "```python\nimport sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci_ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Try all possible pairs as the first two elements\nmax_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Create a new sequence with i and j as the first two elements\n        new_sequence = [sequence[i], sequence[j]] + sorted([sequence[k] for k in range(n) if k != i and k != j])\n        # Check if the new sequence is Fibonacci-ish\n        if is_fibonacci_ish(new_sequence):\n            max_length = max(max_length, len(new_sequence))\n\n# Print the result\nprint(max_length)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci_ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Try all possible pairs as the first two elements\nmax_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Create a new sequence with the first two elements fixed\n        new_seq = [a[i], a[j]]\n        # Add the rest of the elements in any order\n        remaining = [x for x in a if x != a[i] and x != a[j]]\n        for perm in set(itertools.permutations(remaining)):\n            new_seq.extend(perm)\n            if is_fibonacci_ish(new_seq):\n                max_length = max(max_length, len(new_seq))\n            new_seq = [a[i], a[j]]  # Reset the sequence for the next permutation\n\n# Print the length of the longest Fibonacci-ish prefix\nprint(max_length)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci-ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Sort the array to maximize the chances of forming a longer Fibonacci-ish prefix\na.sort()\n\n# Try to find the longest Fibonacci-ish prefix\nmax_length = 0\nfor i in range(2, n + 1):\n    prefix = a[:i]\n    if is_fibonacci-ish(prefix):\n        max_length = i\n\nprint(max_length)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to make it easier to find the longest Fibonacci-ish prefix\na.sort()\n\n# Initialize the length of the longest Fibonacci-ish prefix\nmax_length = 0\n\n# Iterate through the array to find the longest Fibonacci-ish prefix\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Check if the sequence a[i], a[j], a[j+1], ... is Fibonacci-ish\n        if a[j] - a[i] == a[j + 1] - a[j]:\n            length = 2\n            k = j + 1\n            while k < n and a[k] - a[k - 1] == a[k - 1] - a[k - 2]:\n                length += 1\n                k += 1\n            max_length = max(max_length, length)\n\n# Print the length of the longest possible Fibonacci-ish prefix\nprint(max_length)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to try and find the longest Fibonacci-ish prefix\na.sort()\n\n# Initialize the length of the Fibonacci-ish prefix\nfib_len = 0\n\n# Try to find the longest Fibonacci-ish prefix\nfor i in range(n):\n    if i == 0 or i == 1:\n        fib_len += 1\n    else:\n        if a[i] == a[i-1] + a[i-2]:\n            fib_len += 1\n        else:\n            break\n\n# Output the length of the longest Fibonacci-ish prefix\nprint(fib_len)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to make it easier to find the longest Fibonacci-ish prefix\na.sort()\n\n# Initialize the length of the longest Fibonacci-ish prefix\nmax_length = 0\n\n# Iterate through the array to find the longest Fibonacci-ish prefix\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Check if the sequence a[i], a[j], a[j+1], ... is Fibonacci-ish\n        if a[j] - a[i] == a[j + 1] - a[j]:\n            length = 2\n            while j + length < n and a[j + length] - a[j + length - 1] == a[j + length - 1] - a[j + length - 2]:\n                length += 1\n            max_length = max(max_length, length)\n\n# Print the length of the longest possible Fibonacci-ish prefix\nprint(max_length)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci_ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Try all possible pairs as the first two elements\nmax_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Create a new sequence with the first two elements fixed\n        new_seq = [sequence[i], sequence[j]]\n        # Add the rest of the elements in any order\n        remaining = [x for x in sequence if x != sequence[i] and x != sequence[j]]\n        new_seq.extend(remaining)\n        # Check if the new sequence is Fibonacci-ish\n        if is_fibonacci_ish(new_seq):\n            max_length = max(max_length, len(new_seq))\n\n# Print the length of the longest Fibonacci-ish prefix\nprint(max_length)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci_ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Try all possible pairs as the first two elements\nmax_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Create a new sequence with the first two elements as i and j\n        new_seq = [a[i], a[j]]\n        # Add the rest of the elements in any order\n        remaining = [x for x in a if x != a[i] and x != a[j]]\n        new_seq.extend(remaining)\n        # Check if the new sequence is Fibonacci-ish\n        if is_fibonacci_ish(new_seq):\n            max_length = max(max_length, len(new_seq))\n\nprint(max_length)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci_ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Try all possible pairs as the first two elements\nmax_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Create a new sequence with the first two elements as i and j\n        new_seq = [a[i], a[j]]\n        # Add the rest of the elements in any order\n        remaining = [x for x in a if x != a[i] and x != a[j]]\n        new_seq.extend(remaining)\n        # Check if the new sequence is Fibonacci-ish\n        if is_fibonacci_ish(new_seq):\n            max_length = max(max_length, len(new_seq))\n\nprint(max_length)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci-ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Sort the array to try and form the longest Fibonacci-ish prefix\na.sort()\n\n# Try to find the longest Fibonacci-ish prefix\nmax_length = 0\nfor i in range(2, n + 1):\n    prefix = a[:i]\n    if is_fibonacci-ish(prefix):\n        max_length = i\n\nprint(max_length)",
            "import sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nsequence = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci_ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Try all possible pairs as the first two elements\nmax_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Create a new sequence with i and j as the first two elements\n        new_sequence = [sequence[i], sequence[j]] + sorted([sequence[k] for k in range(n) if k != i and k != j])\n        # Check if the new sequence is Fibonacci-ish\n        if is_fibonacci_ish(new_sequence):\n            max_length = max(max_length, len(new_sequence))\n\n# Print the result\nprint(max_length)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci_ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Try all possible pairs as the first two elements\nmax_length = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Create a new sequence with the first two elements fixed\n        new_seq = [a[i], a[j]]\n        # Add the rest of the elements in any order\n        remaining = [x for x in a if x != a[i] and x != a[j]]\n        for perm in set(itertools.permutations(remaining)):\n            new_seq.extend(perm)\n            if is_fibonacci_ish(new_seq):\n                max_length = max(max_length, len(new_seq))\n            new_seq = [a[i], a[j]]  # Reset the sequence for the next permutation\n\n# Print the length of the longest Fibonacci-ish prefix\nprint(max_length)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Function to check if a sequence is Fibonacci-ish\ndef is_fibonacci-ish(seq):\n    if len(seq) < 2:\n        return False\n    f0, f1 = seq[0], seq[1]\n    for i in range(2, len(seq)):\n        if seq[i] != f0 + f1:\n            return False\n        f0, f1 = f1, seq[i]\n    return True\n\n# Sort the array to maximize the chances of forming a longer Fibonacci-ish prefix\na.sort()\n\n# Try to find the longest Fibonacci-ish prefix\nmax_length = 0\nfor i in range(2, n + 1):\n    prefix = a[:i]\n    if is_fibonacci-ish(prefix):\n        max_length = i\n\nprint(max_length)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to make it easier to find the longest Fibonacci-ish prefix\na.sort()\n\n# Initialize the length of the longest Fibonacci-ish prefix\nmax_length = 0\n\n# Iterate through the array to find the longest Fibonacci-ish prefix\nfor i in range(n):\n    for j in range(i + 1, n):\n        # Check if the sequence a[i], a[j], a[j+1], ... is Fibonacci-ish\n        if a[j] - a[i] == a[j + 1] - a[j]:\n            length = 2\n            k = j + 1\n            while k < n and a[k] - a[k - 1] == a[k - 1] - a[k - 2]:\n                length += 1\n                k += 1\n            max_length = max(max_length, length)\n\n# Print the length of the longest possible Fibonacci-ish prefix\nprint(max_length)"
        ]
    },
    {
        "question_title": "Little Artem and Graph",
        "question_content": "Little Artem is given a graph, constructed as follows: start with some k-clique, then add new vertices one by one, connecting them to k already existing vertices that form a k-clique.\n\nArtem wants to count the number of spanning trees in this graph modulo 109 + 7.\n\n\nInput Format\nFirst line of the input contains two integers n and k (1 \u2264 n \u2264 10 000, 1 \u2264 k \u2264 min(n, 5))\u00a0\u2014 the total size of the graph and the size of the initial clique, respectively.\n\nNext n - k lines describe k + 1-th, k + 2-th, ..., i-th, ..., n-th vertices by listing k distinct vertex indices 1 \u2264 aij < i it is connected to. It is guaranteed that those vertices form a k-clique.\n\n\nOutput Format\nOutput a single integer\u00a0\u2014 the number of spanning trees in the given graph modulo 109 + 7.\n\n\nSample Input 1\n\n3 2\n1 2\n\nSample Output 1\n\n3\n\n\nSample Input 2\n\n4 3\n1 2 3\n\nSample Output 2\n\n16",
        "platform": "codeforces",
        "question_id": "641/G",
        "contest_id": "641",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    # Initialize the adjacency matrix\n    adj = [[0] * n for _ in range(n)]\n    for i in range(k, n):\n        for j in edges[i - k]:\n            adj[i][j - 1] = 1\n            adj[j - 1][i] = 1\n    \n    # Calculate the determinant of the adjacency matrix minus the identity matrix\n    def determinant(matrix):\n        if len(matrix) == 1:\n            return matrix[0][0]\n        det = 0\n        for j in range(len(matrix)):\n            det += (-1) ** j * matrix[0][j] * determinant([row[:j] + row[j+1:] for row in matrix[1:]])\n        return det\n    \n    # Calculate the number of spanning trees using Kirchhoff's theorem\n    det = determinant(adj)\n    num_spanning_trees = det % MOD\n    \n    return num_spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * k: 2 + (i + 1) * k])) for i in range(n - k)]\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    if n == k:\n        return 1\n    \n    # Calculate the number of ways to choose k vertices from n vertices\n    ways_to_choose_k = factorial(n) // (factorial(k) * factorial(n - k))\n    \n    # Calculate the number of ways to connect the remaining n-k vertices to the k-clique\n    ways_to_connect = 1\n    for i in range(k, n):\n        ways_to_connect *= len(edges[i])\n        ways_to_connect %= MOD\n    \n    # The total number of spanning trees is the product of the two values\n    total_spanning_trees = (ways_to_choose_k * ways_to_connect) % MOD\n    \n    return total_spanning_trees\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\n\nfor i in range(k, n):\n    edges.append(list(map(int, data[2 + (i - k) * (k + 1):2 + (i - k) * (k + 1) + k + 1])))\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    # Initialize the adjacency matrix\n    adj = [[0] * n for _ in range(n)]\n    for i in range(k, n):\n        for j in edges[i - k]:\n            adj[i][j - 1] = 1\n            adj[j - 1][i] = 1\n    \n    # Calculate the determinant of the adjacency matrix minus the identity matrix\n    det = 0\n    for p in range(n):\n        sign = (-1) ** p\n        sub_det = 1\n        for i in range(n):\n            sub_det *= adj[i][(i + p) % n]\n            sub_det %= MOD\n        det += sign * sub_det\n        det %= MOD\n    \n    # The number of spanning trees is the determinant divided by (n - k)!\n    num_spanning_trees = det * pow(factorial(n - k), MOD - 2, MOD)\n    num_spanning_trees %= MOD\n    \n    return num_spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\nfor i in range(k, n):\n    edges.append(list(map(int, data[2 + (i - k) * (k + 1):2 + (i - k + 1) * (k + 1)])))\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2 * (n - 2)\n    \n    # Calculate the number of ways to choose k vertices from n-1 vertices\n    choose_k_from_n_minus_1 = factorial(n - 1) // (factorial(k) * factorial(n - 1 - k))\n    \n    # Calculate the number of ways to connect the new vertex to k existing vertices\n    connect_new_vertex = k\n    \n    # Calculate the number of ways to connect the remaining n-k-1 vertices\n    remaining_vertices = n - k - 1\n    connect_remaining_vertices = 2 ** remaining_vertices\n    \n    # Calculate the total number of spanning trees\n    total_spanning_trees = (choose_k_from_n_minus_1 * connect_new_vertex * connect_remaining_vertices) % MOD\n    \n    return total_spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\n\nfor i in range(k, n):\n    edges.append(list(map(int, data[2 + (i - k) * (k + 1):2 + (i - k + 1) * (k + 1)])))\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    if k == 1:\n        return 1\n    \n    # Initialize the adjacency matrix\n    adj = [[0] * n for _ in range(n)]\n    for i in range(k, n):\n        for j in edges[i - k]:\n            adj[i][j - 1] = 1\n            adj[j - 1][i] = 1\n    \n    # Function to calculate the determinant of a matrix modulo MOD\n    def determinant(matrix, n):\n        if n == 1:\n            return matrix[0][0]\n        det = 0\n        for j in range(n):\n            det += ((-1) ** j) * matrix[0][j] * determinant(minor(matrix, 0, j), n - 1)\n        return det % MOD\n    \n    # Function to get the minor of a matrix\n    def minor(matrix, i, j):\n        return [row[:j] + row[j+1:] for row in matrix[1:]]\n    \n    # Calculate the determinant of the adjacency matrix\n    det = determinant(adj, n)\n    \n    # The number of spanning trees is given by the determinant of the reduced matrix\n    return det\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * (k + 1):2 + (i + 1) * (k + 1)])) for i in range(n - k)]\n\n# Calculate and print the number of spanning trees modulo 10^9 + 7\nprint(count_spanning_trees(n, k, edges))\n```",
            "```python\nimport sys\nfrom math import comb\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    # Initialize the adjacency matrix\n    adj = [[0] * n for _ in range(n)]\n    for i in range(k, n):\n        for j in edges[i - k]:\n            adj[i][j - 1] = 1\n            adj[j - 1][i] = 1\n    \n    # Function to calculate the determinant of a matrix modulo MOD\n    def determinant(matrix, n):\n        if n == 1:\n            return matrix[0][0]\n        det = 0\n        for j in range(n):\n            det += ((-1) ** j) * matrix[0][j] * determinant(minor(matrix, 0, j), n - 1)\n        return det % MOD\n    \n    # Function to get the minor of a matrix\n    def minor(matrix, i, j):\n        return [row[:j] + row[j+1:] for row in matrix[1:]]\n    \n    # Calculate the determinant of the adjacency matrix\n    det = determinant(adj, n)\n    \n    # The number of spanning trees is given by the determinant of the reduced matrix\n    # We need to subtract the k-clique part and add back the k-clique part\n    # The number of spanning trees in a k-clique is k^(k-2)\n    k_clique_trees = pow(k, k - 2, MOD)\n    \n    # The number of spanning trees in the graph is the determinant minus the k-clique part\n    # plus back the k-clique part\n    spanning_trees = (det - k_clique_trees + MOD) % MOD\n    \n    return spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * k:2 + (i + 1) * k])) for i in range(n - k)]\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    # Initialize the adjacency matrix\n    adj = [[0] * n for _ in range(n)]\n    for i in range(k, n):\n        for j in edges[i - k]:\n            adj[i][j - 1] = 1\n            adj[j - 1][i] = 1\n    \n    # Function to calculate the determinant of a matrix modulo MOD\n    def determinant(matrix, n):\n        if n == 1:\n            return matrix[0][0]\n        det = 0\n        for j in range(n):\n            det += (-1) ** j * matrix[0][j] * determinant([row[:j] + row[j+1:] for row in matrix[1:]], n - 1)\n        return det % MOD\n    \n    # Calculate the determinant of the adjacency matrix\n    det = determinant(adj, n)\n    \n    # The number of spanning trees is the determinant of the Laplacian matrix\n    # The Laplacian matrix is A - D, where A is the adjacency matrix and D is the degree matrix\n    degree_matrix = [[sum(row) for row in adj] for _ in range(n)]\n    laplacian_matrix = [[adj[i][j] - degree_matrix[i][j] if i == j else -adj[i][j] for j in range(n)] for i in range(n)]\n    \n    # Calculate the determinant of the Laplacian matrix\n    spanning_trees = determinant(laplacian_matrix, n)\n    \n    return spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * (k + 1):2 + (i + 1) * (k + 1)])) for i in range(n - k)]\n\n# Calculate and print the number of spanning trees\nprint(count_spanning_trees(n, k, edges))\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    if n == k:\n        return 1\n    \n    # Calculate the number of ways to choose k vertices from n-1 vertices\n    ways_to_choose_k = factorial(n-1) // (factorial(k) * factorial(n-1-k))\n    \n    # Calculate the number of ways to connect the new vertex to k existing vertices\n    ways_to_connect = 1\n    for i in range(k):\n        ways_to_connect *= len(edges[i])\n        ways_to_connect %= MOD\n    \n    # Total number of spanning trees\n    total_spanning_trees = (ways_to_choose_k * ways_to_connect) % MOD\n    return total_spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\n\nfor i in range(k, n):\n    edge = list(map(int, data[2 + (i-k) * (k+1): 2 + (i-k+1) * (k+1)]))\n    edges.append(edge)\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    # Initialize the adjacency list\n    adj = defaultdict(list)\n    for i in range(k, n):\n        for j in edges[i-k]:\n            adj[i].append(j)\n            adj[j].append(i)\n    \n    # Function to calculate the determinant of a matrix modulo MOD\n    def determinant(matrix):\n        if len(matrix) == 1:\n            return matrix[0][0]\n        det = 0\n        for j in range(len(matrix[0])):\n            minor = [row[:j] + row[j+1:] for row in matrix[1:]]\n            det += (-1) ** j * matrix[0][j] * determinant(minor)\n        return det % MOD\n    \n    # Laplacian matrix\n    laplacian = [[0] * n for _ in range(n)]\n    for i in range(n):\n        laplacian[i][i] = len(adj[i])\n        for j in adj[i]:\n            laplacian[i][j] -= 1\n    \n    # Calculate the determinant of the Laplacian matrix\n    return determinant(laplacian)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * k: 2 + (i + 1) * k])) for i in range(n - k)]\n\n# Output the result\nprint(count_spanning_trees(n, k, edges))\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    if k == 3:\n        return 6\n    if k == 4:\n        return 24\n    if k == 5:\n        return 120\n    \n    # Calculate the number of ways to choose k vertices from n vertices\n    def nCr(n, r):\n        return factorial(n) // (factorial(r) * factorial(n - r))\n    \n    # Calculate the number of spanning trees using Cayley's formula\n    return nCr(n, k) * factorial(k - 1) % MOD\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * (k + 1):2 + (i + 1) * (k + 1)])) for i in range(n - k)]\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    # Initialize the adjacency matrix\n    adj = [[0] * n for _ in range(n)]\n    for i in range(k, n):\n        for j in edges[i - k]:\n            adj[i][j - 1] = 1\n            adj[j - 1][i] = 1\n    \n    # Calculate the determinant of the adjacency matrix minus the identity matrix\n    def determinant(matrix):\n        if len(matrix) == 1:\n            return matrix[0][0]\n        det = 0\n        for j in range(len(matrix)):\n            det += (-1) ** j * matrix[0][j] * determinant([row[:j] + row[j+1:] for row in matrix[1:]])\n        return det\n    \n    # Calculate the number of spanning trees using Kirchhoff's theorem\n    det = determinant(adj)\n    num_spanning_trees = det % MOD\n    \n    return num_spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * k: 2 + (i + 1) * k])) for i in range(n - k)]\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    if n == k:\n        return 1\n    \n    # Calculate the number of ways to choose k vertices from n vertices\n    ways_to_choose_k = factorial(n) // (factorial(k) * factorial(n - k))\n    \n    # Calculate the number of ways to connect the remaining n-k vertices to the k-clique\n    ways_to_connect = 1\n    for i in range(k, n):\n        ways_to_connect *= len(edges[i])\n        ways_to_connect %= MOD\n    \n    # The total number of spanning trees is the product of the two values\n    total_spanning_trees = (ways_to_choose_k * ways_to_connect) % MOD\n    \n    return total_spanning_trees\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\n\nfor i in range(k, n):\n    edges.append(list(map(int, data[2 + (i - k) * (k + 1):2 + (i - k) * (k + 1) + k + 1])))\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    # Initialize the adjacency matrix\n    adj = [[0] * n for _ in range(n)]\n    for i in range(k, n):\n        for j in edges[i - k]:\n            adj[i][j - 1] = 1\n            adj[j - 1][i] = 1\n    \n    # Calculate the determinant of the adjacency matrix minus the identity matrix\n    det = 0\n    for p in range(n):\n        sign = (-1) ** p\n        sub_det = 1\n        for i in range(n):\n            sub_det *= adj[i][(i + p) % n]\n            sub_det %= MOD\n        det += sign * sub_det\n        det %= MOD\n    \n    # The number of spanning trees is the determinant divided by (n - k)!\n    num_spanning_trees = det * pow(factorial(n - k), MOD - 2, MOD)\n    num_spanning_trees %= MOD\n    \n    return num_spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\nfor i in range(k, n):\n    edges.append(list(map(int, data[2 + (i - k) * (k + 1):2 + (i - k + 1) * (k + 1)])))\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2 * (n - 2)\n    \n    # Calculate the number of ways to choose k vertices from n-1 vertices\n    choose_k_from_n_minus_1 = factorial(n - 1) // (factorial(k) * factorial(n - 1 - k))\n    \n    # Calculate the number of ways to connect the new vertex to k existing vertices\n    connect_new_vertex = k\n    \n    # Calculate the number of ways to connect the remaining n-k-1 vertices\n    remaining_vertices = n - k - 1\n    connect_remaining_vertices = 2 ** remaining_vertices\n    \n    # Calculate the total number of spanning trees\n    total_spanning_trees = (choose_k_from_n_minus_1 * connect_new_vertex * connect_remaining_vertices) % MOD\n    \n    return total_spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\n\nfor i in range(k, n):\n    edges.append(list(map(int, data[2 + (i - k) * (k + 1):2 + (i - k + 1) * (k + 1)])))\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)",
            "import sys\nfrom math import comb\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    if k == 1:\n        return 1\n    \n    # Initialize the adjacency matrix\n    adj = [[0] * n for _ in range(n)]\n    for i in range(k, n):\n        for j in edges[i - k]:\n            adj[i][j - 1] = 1\n            adj[j - 1][i] = 1\n    \n    # Function to calculate the determinant of a matrix modulo MOD\n    def determinant(matrix, n):\n        if n == 1:\n            return matrix[0][0]\n        det = 0\n        for j in range(n):\n            det += ((-1) ** j) * matrix[0][j] * determinant(minor(matrix, 0, j), n - 1)\n        return det % MOD\n    \n    # Function to get the minor of a matrix\n    def minor(matrix, i, j):\n        return [row[:j] + row[j+1:] for row in matrix[1:]]\n    \n    # Calculate the determinant of the adjacency matrix\n    det = determinant(adj, n)\n    \n    # The number of spanning trees is given by the determinant of the reduced matrix\n    return det\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * (k + 1):2 + (i + 1) * (k + 1)])) for i in range(n - k)]\n\n# Calculate and print the number of spanning trees modulo 10^9 + 7\nprint(count_spanning_trees(n, k, edges))",
            "import sys\nfrom math import comb\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    # Initialize the adjacency matrix\n    adj = [[0] * n for _ in range(n)]\n    for i in range(k, n):\n        for j in edges[i - k]:\n            adj[i][j - 1] = 1\n            adj[j - 1][i] = 1\n    \n    # Function to calculate the determinant of a matrix modulo MOD\n    def determinant(matrix, n):\n        if n == 1:\n            return matrix[0][0]\n        det = 0\n        for j in range(n):\n            det += ((-1) ** j) * matrix[0][j] * determinant(minor(matrix, 0, j), n - 1)\n        return det % MOD\n    \n    # Function to get the minor of a matrix\n    def minor(matrix, i, j):\n        return [row[:j] + row[j+1:] for row in matrix[1:]]\n    \n    # Calculate the determinant of the adjacency matrix\n    det = determinant(adj, n)\n    \n    # The number of spanning trees is given by the determinant of the reduced matrix\n    # We need to subtract the k-clique part and add back the k-clique part\n    # The number of spanning trees in a k-clique is k^(k-2)\n    k_clique_trees = pow(k, k - 2, MOD)\n    \n    # The number of spanning trees in the graph is the determinant minus the k-clique part\n    # plus back the k-clique part\n    spanning_trees = (det - k_clique_trees + MOD) % MOD\n    \n    return spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * k:2 + (i + 1) * k])) for i in range(n - k)]\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    # Initialize the adjacency matrix\n    adj = [[0] * n for _ in range(n)]\n    for i in range(k, n):\n        for j in edges[i - k]:\n            adj[i][j - 1] = 1\n            adj[j - 1][i] = 1\n    \n    # Function to calculate the determinant of a matrix modulo MOD\n    def determinant(matrix, n):\n        if n == 1:\n            return matrix[0][0]\n        det = 0\n        for j in range(n):\n            det += (-1) ** j * matrix[0][j] * determinant([row[:j] + row[j+1:] for row in matrix[1:]], n - 1)\n        return det % MOD\n    \n    # Calculate the determinant of the adjacency matrix\n    det = determinant(adj, n)\n    \n    # The number of spanning trees is the determinant of the Laplacian matrix\n    # The Laplacian matrix is A - D, where A is the adjacency matrix and D is the degree matrix\n    degree_matrix = [[sum(row) for row in adj] for _ in range(n)]\n    laplacian_matrix = [[adj[i][j] - degree_matrix[i][j] if i == j else -adj[i][j] for j in range(n)] for i in range(n)]\n    \n    # Calculate the determinant of the Laplacian matrix\n    spanning_trees = determinant(laplacian_matrix, n)\n    \n    return spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * (k + 1):2 + (i + 1) * (k + 1)])) for i in range(n - k)]\n\n# Calculate and print the number of spanning trees\nprint(count_spanning_trees(n, k, edges))",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    if n == k:\n        return 1\n    \n    # Calculate the number of ways to choose k vertices from n-1 vertices\n    ways_to_choose_k = factorial(n-1) // (factorial(k) * factorial(n-1-k))\n    \n    # Calculate the number of ways to connect the new vertex to k existing vertices\n    ways_to_connect = 1\n    for i in range(k):\n        ways_to_connect *= len(edges[i])\n        ways_to_connect %= MOD\n    \n    # Total number of spanning trees\n    total_spanning_trees = (ways_to_choose_k * ways_to_connect) % MOD\n    return total_spanning_trees\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = []\n\nfor i in range(k, n):\n    edge = list(map(int, data[2 + (i-k) * (k+1): 2 + (i-k+1) * (k+1)]))\n    edges.append(edge)\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    # Initialize the adjacency list\n    adj = defaultdict(list)\n    for i in range(k, n):\n        for j in edges[i-k]:\n            adj[i].append(j)\n            adj[j].append(i)\n    \n    # Function to calculate the determinant of a matrix modulo MOD\n    def determinant(matrix):\n        if len(matrix) == 1:\n            return matrix[0][0]\n        det = 0\n        for j in range(len(matrix[0])):\n            minor = [row[:j] + row[j+1:] for row in matrix[1:]]\n            det += (-1) ** j * matrix[0][j] * determinant(minor)\n        return det % MOD\n    \n    # Laplacian matrix\n    laplacian = [[0] * n for _ in range(n)]\n    for i in range(n):\n        laplacian[i][i] = len(adj[i])\n        for j in adj[i]:\n            laplacian[i][j] -= 1\n    \n    # Calculate the determinant of the Laplacian matrix\n    return determinant(laplacian)\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * k: 2 + (i + 1) * k])) for i in range(n - k)]\n\n# Output the result\nprint(count_spanning_trees(n, k, edges))",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_spanning_trees(n, k, edges):\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    if k == 3:\n        return 6\n    if k == 4:\n        return 24\n    if k == 5:\n        return 120\n    \n    # Calculate the number of ways to choose k vertices from n vertices\n    def nCr(n, r):\n        return factorial(n) // (factorial(r) * factorial(n - r))\n    \n    # Calculate the number of spanning trees using Cayley's formula\n    return nCr(n, k) * factorial(k - 1) % MOD\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nedges = [list(map(int, data[2 + i * (k + 1):2 + (i + 1) * (k + 1)])) for i in range(n - k)]\n\n# Calculate and print the result\nresult = count_spanning_trees(n, k, edges)\nprint(result)"
        ]
    },
    {
        "question_title": "Different Subsets For All Tuples",
        "question_content": "For a sequence a of n integers between 1 and m, inclusive, denote f(a) as the number of distinct subsequences of a (including the empty subsequence).\n\nYou are given two positive integers n and m. Let S be the set of all sequences of length n consisting of numbers from 1 to m. Compute the sum f(a) over all a in S modulo 109 + 7.\n\n\nInput Format\nThe only line contains two integers n and m (1 \u2264 n, m \u2264 106) \u2014 the number of elements in arrays and the upper bound for elements.\n\n\nOutput Format\nPrint the only integer c \u2014 the desired sum modulo 109 + 7.\n\n\nSample Input 1\n\n1 3\n\nSample Output 1\n\n6\n\n\nSample Input 2\n\n2 2\n\nSample Output 2\n\n14\n\n\nSample Input 3\n\n3 3\n\nSample Output 3\n\n174",
        "platform": "codeforces",
        "question_id": "660/E",
        "contest_id": "660",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the DP array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Include or exclude the empty subsequence\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD\n    dp = new_dp\n\n# The result is the number of distinct subsequences minus the empty subsequence\nresult = (dp[m] - 1) % MOD\n\n# Print the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the dp array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0]\n    for j in range(1, m + 1):\n        new_dp[j] = (2 * dp[j] - dp[j - 1]) % MOD\n    dp = new_dp\n\n# The result is the sum of all distinct subsequences minus the empty subsequence\nresult = (dp[m] - 1 + MOD) % MOD\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\n\n# Constants\nMOD = 10**9 + 7\n\n# Initialize the DP array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Compute the number of distinct subsequences\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Include the empty subsequence\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD\n    dp = new_dp\n\n# The result is the number of distinct subsequences of a sequence of length n\nresult = dp[m]\n\n# Print the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the DP array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Double the count including the empty subsequence\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD\n    dp = new_dp\n\n# The result is the number of distinct subsequences minus 1 (to exclude the empty subsequence)\nresult = (dp[m] - 1) % MOD\n\n# Print the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# dp[i][j] will store the number of distinct subsequences of length i using numbers up to j\ndp = [[0] * (m + 1) for _ in range(n + 1)]\ndp[0][0] = 1  # There's one way to have an empty subsequence\n\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        dp[i][j] = (2 * dp[i - 1][j] - dp[i - 1][j - 1]) % MOD\n\n# The answer is the sum of dp[n][j] for all j from 0 to m\nresult = sum(dp[n]) % MOD\n\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the dp array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Double the number of subsequences by including the current element\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD  # Include or exclude the current element\n    dp = new_dp\n\n# The result is the number of subsequences of the full sequence\nresult = dp[m] - 1  # Subtract 1 to exclude the empty subsequence\n\n# Print the result modulo 10^9 + 7\nprint(result % MOD)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the dp array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2 % MOD  # Include the empty subsequence\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD\n    dp = new_dp\n\n# The result is the sum of all distinct subsequences minus the empty subsequence\nresult = (dp[-1] - 1 + MOD) % MOD\n\n# Print the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the dp array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Double the count of subsequences by including the current element\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD  # Include or exclude the current element\n    dp = new_dp\n\n# The result is the number of distinct subsequences minus the empty subsequence\nresult = (dp[m] - 1) % MOD\n\n# Print the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_distinct_subsequences(n, m):\n    if n == 0:\n        return 1\n    if m == 0:\n        return 0\n    \n    dp = [0] * (m + 1)\n    dp[0] = 1\n    \n    for _ in range(n):\n        new_dp = [0] * (m + 1)\n        new_dp[0] = dp[0] * 2 % MOD\n        for j in range(1, m + 1):\n            new_dp[j] = (dp[j - 1] * 2 + dp[j]) % MOD\n        dp = new_dp\n    \n    return dp[m]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    \n    result = count_distinct_subsequences(n, m)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the DP array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Double the number of subsequences by including or excluding the current element\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD  # Include or exclude the current element\n    dp = new_dp\n\n# The result is the number of subsequences of the full sequence\nresult = dp[m] - 1  # Subtract 1 to exclude the empty subsequence\n\n# Print the result modulo 10^9 + 7\nprint(result % MOD)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the DP array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Include or exclude the empty subsequence\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD\n    dp = new_dp\n\n# The result is the number of distinct subsequences minus the empty subsequence\nresult = (dp[m] - 1) % MOD\n\n# Print the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the dp array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0]\n    for j in range(1, m + 1):\n        new_dp[j] = (2 * dp[j] - dp[j - 1]) % MOD\n    dp = new_dp\n\n# The result is the sum of all distinct subsequences minus the empty subsequence\nresult = (dp[m] - 1 + MOD) % MOD\n\n# Print the result\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\n\n# Constants\nMOD = 10**9 + 7\n\n# Initialize the DP array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Compute the number of distinct subsequences\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Include the empty subsequence\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD\n    dp = new_dp\n\n# The result is the number of distinct subsequences of a sequence of length n\nresult = dp[m]\n\n# Print the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the DP array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Double the count including the empty subsequence\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD\n    dp = new_dp\n\n# The result is the number of distinct subsequences minus 1 (to exclude the empty subsequence)\nresult = (dp[m] - 1) % MOD\n\n# Print the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# dp[i][j] will store the number of distinct subsequences of length i using numbers up to j\ndp = [[0] * (m + 1) for _ in range(n + 1)]\ndp[0][0] = 1  # There's one way to have an empty subsequence\n\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        dp[i][j] = (2 * dp[i - 1][j] - dp[i - 1][j - 1]) % MOD\n\n# The answer is the sum of dp[n][j] for all j from 0 to m\nresult = sum(dp[n]) % MOD\n\nprint(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the dp array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Double the number of subsequences by including the current element\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD  # Include or exclude the current element\n    dp = new_dp\n\n# The result is the number of subsequences of the full sequence\nresult = dp[m] - 1  # Subtract 1 to exclude the empty subsequence\n\n# Print the result modulo 10^9 + 7\nprint(result % MOD)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the dp array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2 % MOD  # Include the empty subsequence\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD\n    dp = new_dp\n\n# The result is the sum of all distinct subsequences minus the empty subsequence\nresult = (dp[-1] - 1 + MOD) % MOD\n\n# Print the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the dp array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Double the count of subsequences by including the current element\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD  # Include or exclude the current element\n    dp = new_dp\n\n# The result is the number of distinct subsequences minus the empty subsequence\nresult = (dp[m] - 1) % MOD\n\n# Print the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_distinct_subsequences(n, m):\n    if n == 0:\n        return 1\n    if m == 0:\n        return 0\n    \n    dp = [0] * (m + 1)\n    dp[0] = 1\n    \n    for _ in range(n):\n        new_dp = [0] * (m + 1)\n        new_dp[0] = dp[0] * 2 % MOD\n        for j in range(1, m + 1):\n            new_dp[j] = (dp[j - 1] * 2 + dp[j]) % MOD\n        dp = new_dp\n    \n    return dp[m]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    \n    result = count_distinct_subsequences(n, m)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\n\nMOD = 10**9 + 7\n\n# Initialize the DP array\ndp = [0] * (m + 1)\ndp[0] = 1  # Empty subsequence\n\n# Iterate over each position in the sequence\nfor _ in range(n):\n    new_dp = [0] * (m + 1)\n    new_dp[0] = dp[0] * 2  # Double the number of subsequences by including or excluding the current element\n    for j in range(1, m + 1):\n        new_dp[j] = (dp[j] * 2 + dp[j - 1]) % MOD  # Include or exclude the current element\n    dp = new_dp\n\n# The result is the number of subsequences of the full sequence\nresult = dp[m] - 1  # Subtract 1 to exclude the empty subsequence\n\n# Print the result modulo 10^9 + 7\nprint(result % MOD)"
        ]
    },
    {
        "question_title": "Binary Table",
        "question_content": "You are given a table consisting of n rows and m columns. Each cell of the table contains either 0 or 1. In one move, you are allowed to pick any row or any column and invert all values, that is, replace 0 by 1 and vice versa.\n\nWhat is the minimum number of cells with value 1 you can get after applying some number of operations?\n\n\nInput Format\nThe first line of the input contains two integers n and m (1 \u2264 n \u2264 20, 1 \u2264 m \u2264 100 000)\u00a0\u2014 the number of rows and the number of columns, respectively.\n\nThen n lines follows with the descriptions of the rows. Each line has length m and contains only digits '0' and '1'.\n\n\nOutput Format\nOutput a single integer\u00a0\u2014 the minimum possible number of ones you can get after applying some sequence of operations.\n\n\nSample Input 1\n\n3 4\n0110\n1010\n0111\n\nSample Output 1\n\n2",
        "platform": "codeforces",
        "question_id": "662/C",
        "contest_id": "662",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Function to count number of 1s in the table\ndef count_ones():\n    return sum(sum(row) for row in table)\n\n# Function to flip a row\ndef flip_row(i):\n    table[i] = [1 - x for x in table[i]]\n\n# Function to flip a column\ndef flip_col(j):\n    for i in range(n):\n        table[i][j] = 1 - table[i][j]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(1 << n):\n    for j in range(1 << m):\n        # Apply flips\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n        \n        # Count the number of 1s\n        ones = count_ones()\n        \n        # Update the minimum number of 1s\n        if ones < min_ones:\n            min_ones = ones\n        \n        # Revert flips\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n\n# Output the result\nprint(min_ones)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [data[i + 2] for i in range(n)]\n\n# Function to count the number of 1s in the table\ndef count_ones():\n    return sum(row.count('1') for row in table)\n\n# Function to flip a row\ndef flip_row(i):\n    table[i] = ''.join('1' if x == '0' else '0' for x in table[i])\n\n# Function to flip a column\ndef flip_col(j):\n    for i in range(n):\n        table[i] = table[i][:j] + ('1' if table[i][j] == '0' else '0') + table[i][j+1:]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(1 << n):\n    for j in range(1 << m):\n        # Apply the flips\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n        \n        # Count the number of 1s\n        ones = count_ones()\n        \n        # Update the minimum number of 1s\n        if ones < min_ones:\n            min_ones = ones\n        \n        # Revert the flips\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n\n# Output the result\nprint(min_ones)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Function to count the number of 1s in the table\ndef count_ones(table):\n    return sum(row.count(1) for row in table)\n\n# Function to flip a row\ndef flip_row(table, row_index):\n    table[row_index] = [1 - cell for cell in table[row_index]]\n\n# Function to flip a column\ndef flip_column(table, col_index):\n    for row in table:\n        row[col_index] = 1 - row[col_index]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(1 << n):\n    for j in range(1 << m):\n        current_table = [row[:] for row in table]\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(current_table, k)\n        for k in range(m):\n            if j & (1 << k):\n                flip_column(current_table, k)\n        min_ones = min(min_ones, count_ones(current_table))\n\n# Output the result\nprint(min_ones)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Function to count the number of 1s in the table\ndef count_ones():\n    return sum(sum(row) for row in table)\n\n# Function to invert a row\ndef invert_row(i):\n    table[i] = [1 - x for x in table[i]]\n\n# Function to invert a column\ndef invert_column(j):\n    for i in range(n):\n        table[i][j] = 1 - table[i][j]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(1 << n):\n    for j in range(1 << m):\n        # Apply the operations\n        for k in range(n):\n            if i & (1 << k):\n                invert_row(k)\n        for k in range(m):\n            if j & (1 << k):\n                invert_column(k)\n        \n        # Count the number of 1s\n        ones = count_ones()\n        \n        # Update the minimum number of 1s\n        if ones < min_ones:\n            min_ones = ones\n        \n        # Revert the operations\n        for k in range(m):\n            if j & (1 << k):\n                invert_column(k)\n        for k in range(n):\n            if i & (1 << k):\n                invert_row(k)\n\n# Output the result\nprint(min_ones)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [data[i + 2] for i in range(n)]\n\n# Count the number of 1s in the table\nones_count = sum(row.count('1') for row in table)\n\n# If the number of 1s is even, we can make all cells 0 by inverting rows and columns\n# If the number of 1s is odd, we can make all cells 0 except for one by inverting rows and columns\nif ones_count % 2 == 0:\n    result = 0\nelse:\n    result = 1\n\n# Output the result\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [data[i + 2] for i in range(n)]\n\n# Count the number of 1s in the table\nones_count = sum(row.count('1') for row in table)\n\n# If the number of 1s is odd, we can make it even by flipping a row or column\nif ones_count % 2 == 1:\n    ones_count -= 1\n\n# Output the result\nprint(ones_count)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [data[i + 2] for i in range(n)]\n\n# Count the number of 1s in the first row\nfirst_row_ones = table[0].count('1')\n\n# If the number of 1s in the first row is greater than half the number of columns,\n# flipping the first row will result in fewer 1s.\nif first_row_ones > m // 2:\n    first_row_ones = m - first_row_ones\n\n# Initialize the minimum number of 1s to the number of 1s in the first row\nmin_ones = first_row_ones\n\n# Iterate over the rest of the rows\nfor i in range(1, n):\n    row_ones = table[i].count('1')\n    if row_ones > m // 2:\n        row_ones = m - row_ones\n    min_ones = min(min_ones, row_ones)\n\n# Output the result\nprint(min_ones)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Function to count the number of 1s in the table\ndef count_ones():\n    return sum(row.count(1) for row in table)\n\n# Function to flip a row\ndef flip_row(i):\n    table[i] = [1 - x for x in table[i]]\n\n# Function to flip a column\ndef flip_col(j):\n    for i in range(n):\n        table[i][j] = 1 - table[i][j]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(1 << n):\n    for j in range(1 << m):\n        # Apply the flips\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n        \n        # Count the number of 1s\n        ones = count_ones()\n        \n        # Update the minimum number of 1s\n        if ones < min_ones:\n            min_ones = ones\n        \n        # Revert the flips\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n\n# Output the result\nprint(min_ones)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Function to count the number of 1s in the table\ndef count_ones(table):\n    return sum(sum(row) for row in table)\n\n# Function to flip a row\ndef flip_row(table, row_index):\n    for i in range(m):\n        table[row_index][i] = 1 - table[row_index][i]\n\n# Function to flip a column\ndef flip_column(table, col_index):\n    for i in range(n):\n        table[i][col_index] = 1 - table[i][col_index]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(2 ** n):\n    current_table = [row[:] for row in table]\n    for j in range(n):\n        if i & (1 << j):\n            flip_row(current_table, j)\n    for j in range(m):\n        if sum(current_table[row][j] for row in range(n)) % 2 == 1:\n            flip_column(current_table, j)\n    min_ones = min(min_ones, count_ones(current_table))\n\n# Output the result\nprint(min_ones)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Count the number of 1s in the table\nones_count = sum(sum(row) for row in table)\n\n# If the number of 1s is odd, we can make it even by inverting one row or column\nif ones_count % 2 != 0:\n    ones_count -= 1\n\n# Output the result\nprint(ones_count)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Function to count number of 1s in the table\ndef count_ones():\n    return sum(sum(row) for row in table)\n\n# Function to flip a row\ndef flip_row(i):\n    table[i] = [1 - x for x in table[i]]\n\n# Function to flip a column\ndef flip_col(j):\n    for i in range(n):\n        table[i][j] = 1 - table[i][j]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(1 << n):\n    for j in range(1 << m):\n        # Apply flips\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n        \n        # Count the number of 1s\n        ones = count_ones()\n        \n        # Update the minimum number of 1s\n        if ones < min_ones:\n            min_ones = ones\n        \n        # Revert flips\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n\n# Output the result\nprint(min_ones)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [data[i + 2] for i in range(n)]\n\n# Function to count the number of 1s in the table\ndef count_ones():\n    return sum(row.count('1') for row in table)\n\n# Function to flip a row\ndef flip_row(i):\n    table[i] = ''.join('1' if x == '0' else '0' for x in table[i])\n\n# Function to flip a column\ndef flip_col(j):\n    for i in range(n):\n        table[i] = table[i][:j] + ('1' if table[i][j] == '0' else '0') + table[i][j+1:]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(1 << n):\n    for j in range(1 << m):\n        # Apply the flips\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n        \n        # Count the number of 1s\n        ones = count_ones()\n        \n        # Update the minimum number of 1s\n        if ones < min_ones:\n            min_ones = ones\n        \n        # Revert the flips\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n\n# Output the result\nprint(min_ones)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Function to count the number of 1s in the table\ndef count_ones(table):\n    return sum(row.count(1) for row in table)\n\n# Function to flip a row\ndef flip_row(table, row_index):\n    table[row_index] = [1 - cell for cell in table[row_index]]\n\n# Function to flip a column\ndef flip_column(table, col_index):\n    for row in table:\n        row[col_index] = 1 - row[col_index]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(1 << n):\n    for j in range(1 << m):\n        current_table = [row[:] for row in table]\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(current_table, k)\n        for k in range(m):\n            if j & (1 << k):\n                flip_column(current_table, k)\n        min_ones = min(min_ones, count_ones(current_table))\n\n# Output the result\nprint(min_ones)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Function to count the number of 1s in the table\ndef count_ones():\n    return sum(sum(row) for row in table)\n\n# Function to invert a row\ndef invert_row(i):\n    table[i] = [1 - x for x in table[i]]\n\n# Function to invert a column\ndef invert_column(j):\n    for i in range(n):\n        table[i][j] = 1 - table[i][j]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(1 << n):\n    for j in range(1 << m):\n        # Apply the operations\n        for k in range(n):\n            if i & (1 << k):\n                invert_row(k)\n        for k in range(m):\n            if j & (1 << k):\n                invert_column(k)\n        \n        # Count the number of 1s\n        ones = count_ones()\n        \n        # Update the minimum number of 1s\n        if ones < min_ones:\n            min_ones = ones\n        \n        # Revert the operations\n        for k in range(m):\n            if j & (1 << k):\n                invert_column(k)\n        for k in range(n):\n            if i & (1 << k):\n                invert_row(k)\n\n# Output the result\nprint(min_ones)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [data[i + 2] for i in range(n)]\n\n# Count the number of 1s in the table\nones_count = sum(row.count('1') for row in table)\n\n# If the number of 1s is even, we can make all cells 0 by inverting rows and columns\n# If the number of 1s is odd, we can make all cells 0 except for one by inverting rows and columns\nif ones_count % 2 == 0:\n    result = 0\nelse:\n    result = 1\n\n# Output the result\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [data[i + 2] for i in range(n)]\n\n# Count the number of 1s in the table\nones_count = sum(row.count('1') for row in table)\n\n# If the number of 1s is odd, we can make it even by flipping a row or column\nif ones_count % 2 == 1:\n    ones_count -= 1\n\n# Output the result\nprint(ones_count)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [data[i + 2] for i in range(n)]\n\n# Count the number of 1s in the first row\nfirst_row_ones = table[0].count('1')\n\n# If the number of 1s in the first row is greater than half the number of columns,\n# flipping the first row will result in fewer 1s.\nif first_row_ones > m // 2:\n    first_row_ones = m - first_row_ones\n\n# Initialize the minimum number of 1s to the number of 1s in the first row\nmin_ones = first_row_ones\n\n# Iterate over the rest of the rows\nfor i in range(1, n):\n    row_ones = table[i].count('1')\n    if row_ones > m // 2:\n        row_ones = m - row_ones\n    min_ones = min(min_ones, row_ones)\n\n# Output the result\nprint(min_ones)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Function to count the number of 1s in the table\ndef count_ones():\n    return sum(row.count(1) for row in table)\n\n# Function to flip a row\ndef flip_row(i):\n    table[i] = [1 - x for x in table[i]]\n\n# Function to flip a column\ndef flip_col(j):\n    for i in range(n):\n        table[i][j] = 1 - table[i][j]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(1 << n):\n    for j in range(1 << m):\n        # Apply the flips\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n        \n        # Count the number of 1s\n        ones = count_ones()\n        \n        # Update the minimum number of 1s\n        if ones < min_ones:\n            min_ones = ones\n        \n        # Revert the flips\n        for k in range(m):\n            if j & (1 << k):\n                flip_col(k)\n        for k in range(n):\n            if i & (1 << k):\n                flip_row(k)\n\n# Output the result\nprint(min_ones)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Function to count the number of 1s in the table\ndef count_ones(table):\n    return sum(sum(row) for row in table)\n\n# Function to flip a row\ndef flip_row(table, row_index):\n    for i in range(m):\n        table[row_index][i] = 1 - table[row_index][i]\n\n# Function to flip a column\ndef flip_column(table, col_index):\n    for i in range(n):\n        table[i][col_index] = 1 - table[i][col_index]\n\n# Determine the minimum number of 1s\nmin_ones = float('inf')\nfor i in range(2 ** n):\n    current_table = [row[:] for row in table]\n    for j in range(n):\n        if i & (1 << j):\n            flip_row(current_table, j)\n    for j in range(m):\n        if sum(current_table[row][j] for row in range(n)) % 2 == 1:\n            flip_column(current_table, j)\n    min_ones = min(min_ones, count_ones(current_table))\n\n# Output the result\nprint(min_ones)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ntable = [list(map(int, data[2 + i])) for i in range(n)]\n\n# Count the number of 1s in the table\nones_count = sum(sum(row) for row in table)\n\n# If the number of 1s is odd, we can make it even by inverting one row or column\nif ones_count % 2 != 0:\n    ones_count -= 1\n\n# Output the result\nprint(ones_count)"
        ]
    },
    {
        "question_title": "Beautiful Subarrays",
        "question_content": "One day, ZS the Coder wrote down an array of integers a with elements a1, a2, ..., an.\n\nA subarray of the array a is a sequence al, al + 1, ..., ar for some integers (l, r) such that 1 \u2264 l \u2264 r \u2264 n. ZS the Coder thinks that a subarray of a is beautiful if the bitwise xor of all the elements in the subarray is at least k.\n\nHelp ZS the Coder find the number of beautiful subarrays of a!\n\n\nInput Format\nThe first line contains two integers n and k (1 \u2264 n \u2264 106, 1 \u2264 k \u2264 109) \u2014 the number of elements in the array a and the value of the parameter k.\n\nThe second line contains n integers ai (0 \u2264 ai \u2264 109) \u2014 the elements of the array a.\n\n\nOutput Format\nPrint the only integer c \u2014 the number of beautiful subarrays of the array a.\n\n\nSample Input 1\n\n3 1\n1 2 3\n\nSample Output 1\n\n5\n\n\nSample Input 2\n\n3 2\n1 2 3\n\nSample Output 2\n\n3\n\n\nSample Input 3\n\n3 3\n1 2 3\n\nSample Output 3\n\n2",
        "platform": "codeforces",
        "question_id": "665/E",
        "contest_id": "665",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Dictionary to store the frequency of prefix XOR values\nprefix_xor_count = defaultdict(int)\nprefix_xor_count[0] = 1\n\n# Initialize variables\ncurrent_xor = 0\nbeautiful_subarrays = 0\n\n# Iterate through the array\nfor num in a:\n    current_xor ^= num\n    # Check if there exists a prefix XOR such that the current XOR minus that prefix XOR is at least k\n    beautiful_subarrays += prefix_xor_count[current_xor ^ k]\n    # Update the frequency of the current prefix XOR\n    prefix_xor_count[current_xor] += 1\n\n# Print the result\nprint(beautiful_subarrays)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nprefix_xor_count = defaultdict(int)\nprefix_xor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Count the number of subarrays with xor >= k\n    count += prefix_xor_count[prefix_xor ^ k]\n    # Update the count of prefix xor values\n    prefix_xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nxor_count = defaultdict(int)\nxor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Check for beautiful subarrays\n    count += xor_count[prefix_xor ^ k]\n    count += xor_count[prefix_xor ^ (k - 1)]\n    # Update the count of prefix XOR values\n    xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Dictionary to store the frequency of prefix XOR values\nprefix_xor_count = defaultdict(int)\nprefix_xor_count[0] = 1\ncurrent_xor = 0\nbeautiful_subarrays = 0\n\n# Iterate through the array\nfor num in a:\n    current_xor ^= num\n    # Check if there is a prefix XOR that makes the current subarray beautiful\n    beautiful_subarrays += prefix_xor_count[current_xor ^ k]\n    # Update the frequency of the current prefix XOR\n    prefix_xor_count[current_xor] += 1\n\n# Output the result\nprint(beautiful_subarrays)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nxor_count = defaultdict(int)\nxor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Check if there exists a subarray with xor at least k\n    if prefix_xor >= k:\n        count += 1\n    # Check if there exists a subarray with xor exactly prefix_xor - k\n    if prefix_xor - k in xor_count:\n        count += xor_count[prefix_xor - k]\n    # Update the count of prefix_xor\n    xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nxor_count = defaultdict(int)\nxor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Check for beautiful subarrays\n    count += xor_count[prefix_xor ^ k]\n    # Update the count of prefix_xor\n    xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nprefix_xor_count = defaultdict(int)\nprefix_xor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Count the number of subarrays with xor >= k\n    count += prefix_xor_count[prefix_xor ^ k]\n    count += prefix_xor_count[prefix_xor ^ (k - 1)]\n    # Update the count of prefix xor values\n    prefix_xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nprefix_xor_count = defaultdict(int)\nprefix_xor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Check if there exists a prefix XOR such that the current prefix XOR\n    # minus that prefix XOR is at least k\n    count += prefix_xor_count[prefix_xor ^ k]\n    # Increment the count of the current prefix XOR\n    prefix_xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nxor_count = defaultdict(int)\nxor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Check for beautiful subarrays\n    count += xor_count[prefix_xor ^ k]\n    xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nxor_count = defaultdict(int)\nxor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Count the number of subarrays with xor at least k\n    count += xor_count[prefix_xor ^ k]\n    # Update the count of prefix_xor in the dictionary\n    xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Dictionary to store the frequency of prefix XOR values\nprefix_xor_count = defaultdict(int)\nprefix_xor_count[0] = 1\n\n# Initialize variables\ncurrent_xor = 0\nbeautiful_subarrays = 0\n\n# Iterate through the array\nfor num in a:\n    current_xor ^= num\n    # Check if there exists a prefix XOR such that the current XOR minus that prefix XOR is at least k\n    beautiful_subarrays += prefix_xor_count[current_xor ^ k]\n    # Update the frequency of the current prefix XOR\n    prefix_xor_count[current_xor] += 1\n\n# Print the result\nprint(beautiful_subarrays)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nprefix_xor_count = defaultdict(int)\nprefix_xor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Count the number of subarrays with xor >= k\n    count += prefix_xor_count[prefix_xor ^ k]\n    # Update the count of prefix xor values\n    prefix_xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nxor_count = defaultdict(int)\nxor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Check for beautiful subarrays\n    count += xor_count[prefix_xor ^ k]\n    count += xor_count[prefix_xor ^ (k - 1)]\n    # Update the count of prefix XOR values\n    xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Dictionary to store the frequency of prefix XOR values\nprefix_xor_count = defaultdict(int)\nprefix_xor_count[0] = 1\ncurrent_xor = 0\nbeautiful_subarrays = 0\n\n# Iterate through the array\nfor num in a:\n    current_xor ^= num\n    # Check if there is a prefix XOR that makes the current subarray beautiful\n    beautiful_subarrays += prefix_xor_count[current_xor ^ k]\n    # Update the frequency of the current prefix XOR\n    prefix_xor_count[current_xor] += 1\n\n# Output the result\nprint(beautiful_subarrays)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nxor_count = defaultdict(int)\nxor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Check if there exists a subarray with xor at least k\n    if prefix_xor >= k:\n        count += 1\n    # Check if there exists a subarray with xor exactly prefix_xor - k\n    if prefix_xor - k in xor_count:\n        count += xor_count[prefix_xor - k]\n    # Update the count of prefix_xor\n    xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nxor_count = defaultdict(int)\nxor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Check for beautiful subarrays\n    count += xor_count[prefix_xor ^ k]\n    # Update the count of prefix_xor\n    xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nprefix_xor_count = defaultdict(int)\nprefix_xor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Count the number of subarrays with xor >= k\n    count += prefix_xor_count[prefix_xor ^ k]\n    count += prefix_xor_count[prefix_xor ^ (k - 1)]\n    # Update the count of prefix xor values\n    prefix_xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nprefix_xor_count = defaultdict(int)\nprefix_xor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Check if there exists a prefix XOR such that the current prefix XOR\n    # minus that prefix XOR is at least k\n    count += prefix_xor_count[prefix_xor ^ k]\n    # Increment the count of the current prefix XOR\n    prefix_xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nxor_count = defaultdict(int)\nxor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Check for beautiful subarrays\n    count += xor_count[prefix_xor ^ k]\n    xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Initialize variables\ncount = 0\nprefix_xor = 0\nxor_count = defaultdict(int)\nxor_count[0] = 1\n\n# Iterate through the array\nfor num in a:\n    prefix_xor ^= num\n    # Count the number of subarrays with xor at least k\n    count += xor_count[prefix_xor ^ k]\n    # Update the count of prefix_xor in the dictionary\n    xor_count[prefix_xor] += 1\n\n# Print the result\nprint(count)"
        ]
    },
    {
        "question_title": "Lena and Queries",
        "question_content": "Lena is a programmer. She got a task to solve at work.\n\nThere is an empty set of pairs of integers and n queries to process. Each query is one of three types:\n\n1. Add a pair (a, b) to the set.\n2. Remove a pair added in the query number i. All queries are numbered with integers from 1 to n.\n3. For a given integer q find the maximal value x\u00b7q + y over all pairs (x, y) from the set.\n\nHelp Lena to process the queries.\n\n\nInput Format\nThe first line of input contains integer n (1 \u2264 n \u2264 3\u00b7105) \u2014 the number of queries.\n\nEach of the next n lines starts with integer t (1 \u2264 t \u2264 3) \u2014 the type of the query.\n\nA pair of integers a and b ( - 109 \u2264 a, b \u2264 109) follows in the query of the first type.\n\nAn integer i (1 \u2264 i \u2264 n) follows in the query of the second type. It is guaranteed that i is less than the number of the query, the query number i has the first type and the pair from the i-th query is not already removed.\n\nAn integer q ( - 109 \u2264 q \u2264 109) follows in the query of the third type.\n\n\nOutput Format\nFor the queries of the third type print on a separate line the desired maximal value of x\u00b7q + y.\n\nIf there are no pairs in the set print \"EMPTY SET\".\n\n\nSample Input 1\n\n7\n3 1\n1 2 3\n3 1\n1 -1 100\n3 1\n2 4\n3 1\n\nSample Output 1\n\nEMPTY SET\n5\n99\n5",
        "platform": "codeforces",
        "question_id": "678/F",
        "contest_id": "678",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\n# YOUR CODE HERE\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index])\n            queries.append((t, i))\n            index += 1\n        elif t == 3:\n            q = int(data[index])\n            queries.append((t, q))\n            index += 1\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    \n    for query in queries:\n        t = query[0]\n        if t == 1:\n            a, b = query[1], query[2]\n            pairs.append((a, b))\n        elif t == 2:\n            i = query[1]\n            removed[i] = True\n        elif t == 3:\n            q = query[1]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[pairs.index((a, b)) + 1]]\n            if not valid_pairs:\n                print(\"EMPTY SET\")\n            else:\n                max_value = float('-inf')\n                for a, b in valid_pairs:\n                    max_value = max(max_value, a * q + b)\n                print(max_value)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Initialize variables\nn = int(data[0])\nqueries = data[1:]\n\n# Initialize a sorted list to store pairs\npairs = SortedList()\n\n# Process each query\nindex = 0\nresults = []\nfor i in range(n):\n    t = int(queries[index])\n    index += 1\n    \n    if t == 1:\n        a = int(queries[index])\n        b = int(queries[index + 1])\n        index += 2\n        pairs.add((a, b))\n    elif t == 2:\n        i = int(queries[index]) - 1\n        index += 1\n        pairs.remove((pairs[i][0], pairs[i][1]))\n    elif t == 3:\n        q = int(queries[index])\n        index += 1\n        if not pairs:\n            results.append(\"EMPTY SET\")\n        else:\n            max_value = float('-inf')\n            for a, b in pairs:\n                max_value = max(max_value, a * q + b)\n            results.append(str(max_value))\n\n# Write results to stdout\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1])\n            queries.append((t, i))\n            index += 2\n        elif t == 3:\n            q = int(data[index + 1])\n            queries.append((t, q))\n            index += 2\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[pairs.index((a, b)) + 1]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                values = [a * q + b for a, b in valid_pairs]\n                results.append(str(max(values)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1])\n            queries.append((t, i))\n            index += 2\n        elif t == 3:\n            q = int(data[index + 1])\n            queries.append((t, q))\n            index += 2\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[i]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                max_value = float('-inf')\n                for a, b in valid_pairs:\n                    max_value = max(max_value, a * q + b)\n                results.append(str(max_value))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index])\n            queries.append((t, i))\n            index += 1\n        elif t == 3:\n            q = int(data[index])\n            queries.append((t, q))\n            index += 1\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[pairs.index((a, b)) + 1]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                values = [a * q + b for a, b in valid_pairs]\n                results.append(max(values))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for _ in range(n):\n        t = int(data[index])\n        index += 1\n        if t == 1:\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            queries.append((t, a, b))\n        elif t == 2:\n            i = int(data[index])\n            index += 1\n            queries.append((t, i))\n        elif t == 3:\n            q = int(data[index])\n            index += 1\n            queries.append((t, q))\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[pairs.index((a, b)) + 1]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                max_value = float('-inf')\n                for a, b in valid_pairs:\n                    max_value = max(max_value, a * q + b)\n                results.append(str(max_value))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nqueries = data[1:]\n\ni = 0\npairs = SortedList()\nresults = []\n\nfor t in range(n):\n    if queries[i] == '1':\n        a = int(queries[i + 1])\n        b = int(queries[i + 2])\n        pairs.add((a, b))\n        i += 3\n    elif queries[i] == '2':\n        index = int(queries[i + 1]) - 1\n        pairs.remove((pairs[index][0], pairs[index][1]))\n        i += 2\n    elif queries[i] == '3':\n        q = int(queries[i + 1])\n        if not pairs:\n            results.append(\"EMPTY SET\")\n        else:\n            max_value = float('-inf')\n            for a, b in pairs:\n                max_value = max(max_value, a * q + b)\n            results.append(str(max_value))\n        i += 2\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1])\n            queries.append((t, i))\n            index += 2\n        elif t == 3:\n            q = int(data[index + 1])\n            queries.append((t, q))\n            index += 2\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            if not pairs:\n                print(\"EMPTY SET\")\n            else:\n                valid_pairs = [(a, b) for a, b in pairs if not removed[pairs.index((a, b)) + 1]]\n                if not valid_pairs:\n                    print(\"EMPTY SET\")\n                else:\n                    max_value = float('-inf')\n                    for a, b in valid_pairs:\n                        max_value = max(max_value, a * q + b)\n                    print(max_value)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1])\n            queries.append((t, i))\n            index += 2\n        elif t == 3:\n            q = int(data[index + 1])\n            queries.append((t, q))\n            index += 2\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[i]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                max_value = float('-inf')\n                for a, b in valid_pairs:\n                    max_value = max(max_value, a * q + b)\n                results.append(str(max_value))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1])\n            queries.append((t, i))\n            index += 2\n        elif t == 3:\n            q = int(data[index + 1])\n            queries.append((t, q))\n            index += 2\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[i]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                max_value = float('-inf')\n                for a, b in valid_pairs:\n                    max_value = max(max_value, a * q + b)\n                results.append(str(max_value))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom sortedcontainers import SortedList\n\n# YOUR CODE HERE\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index])\n            queries.append((t, i))\n            index += 1\n        elif t == 3:\n            q = int(data[index])\n            queries.append((t, q))\n            index += 1\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    \n    for query in queries:\n        t = query[0]\n        if t == 1:\n            a, b = query[1], query[2]\n            pairs.append((a, b))\n        elif t == 2:\n            i = query[1]\n            removed[i] = True\n        elif t == 3:\n            q = query[1]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[pairs.index((a, b)) + 1]]\n            if not valid_pairs:\n                print(\"EMPTY SET\")\n            else:\n                max_value = float('-inf')\n                for a, b in valid_pairs:\n                    max_value = max(max_value, a * q + b)\n                print(max_value)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Initialize variables\nn = int(data[0])\nqueries = data[1:]\n\n# Initialize a sorted list to store pairs\npairs = SortedList()\n\n# Process each query\nindex = 0\nresults = []\nfor i in range(n):\n    t = int(queries[index])\n    index += 1\n    \n    if t == 1:\n        a = int(queries[index])\n        b = int(queries[index + 1])\n        index += 2\n        pairs.add((a, b))\n    elif t == 2:\n        i = int(queries[index]) - 1\n        index += 1\n        pairs.remove((pairs[i][0], pairs[i][1]))\n    elif t == 3:\n        q = int(queries[index])\n        index += 1\n        if not pairs:\n            results.append(\"EMPTY SET\")\n        else:\n            max_value = float('-inf')\n            for a, b in pairs:\n                max_value = max(max_value, a * q + b)\n            results.append(str(max_value))\n\n# Write results to stdout\nfor result in results:\n    print(result)",
            "import sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1])\n            queries.append((t, i))\n            index += 2\n        elif t == 3:\n            q = int(data[index + 1])\n            queries.append((t, q))\n            index += 2\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[pairs.index((a, b)) + 1]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                values = [a * q + b for a, b in valid_pairs]\n                results.append(str(max(values)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1])\n            queries.append((t, i))\n            index += 2\n        elif t == 3:\n            q = int(data[index + 1])\n            queries.append((t, q))\n            index += 2\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[i]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                max_value = float('-inf')\n                for a, b in valid_pairs:\n                    max_value = max(max_value, a * q + b)\n                results.append(str(max_value))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index])\n            queries.append((t, i))\n            index += 1\n        elif t == 3:\n            q = int(data[index])\n            queries.append((t, q))\n            index += 1\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[pairs.index((a, b)) + 1]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                values = [a * q + b for a, b in valid_pairs]\n                results.append(max(values))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for _ in range(n):\n        t = int(data[index])\n        index += 1\n        if t == 1:\n            a = int(data[index])\n            b = int(data[index + 1])\n            index += 2\n            queries.append((t, a, b))\n        elif t == 2:\n            i = int(data[index])\n            index += 1\n            queries.append((t, i))\n        elif t == 3:\n            q = int(data[index])\n            index += 1\n            queries.append((t, q))\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[pairs.index((a, b)) + 1]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                max_value = float('-inf')\n                for a, b in valid_pairs:\n                    max_value = max(max_value, a * q + b)\n                results.append(str(max_value))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nqueries = data[1:]\n\ni = 0\npairs = SortedList()\nresults = []\n\nfor t in range(n):\n    if queries[i] == '1':\n        a = int(queries[i + 1])\n        b = int(queries[i + 2])\n        pairs.add((a, b))\n        i += 3\n    elif queries[i] == '2':\n        index = int(queries[i + 1]) - 1\n        pairs.remove((pairs[index][0], pairs[index][1]))\n        i += 2\n    elif queries[i] == '3':\n        q = int(queries[i + 1])\n        if not pairs:\n            results.append(\"EMPTY SET\")\n        else:\n            max_value = float('-inf')\n            for a, b in pairs:\n                max_value = max(max_value, a * q + b)\n            results.append(str(max_value))\n        i += 2\n\nfor result in results:\n    print(result)",
            "import sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1])\n            queries.append((t, i))\n            index += 2\n        elif t == 3:\n            q = int(data[index + 1])\n            queries.append((t, q))\n            index += 2\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            if not pairs:\n                print(\"EMPTY SET\")\n            else:\n                valid_pairs = [(a, b) for a, b in pairs if not removed[pairs.index((a, b)) + 1]]\n                if not valid_pairs:\n                    print(\"EMPTY SET\")\n                else:\n                    max_value = float('-inf')\n                    for a, b in valid_pairs:\n                        max_value = max(max_value, a * q + b)\n                    print(max_value)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1])\n            queries.append((t, i))\n            index += 2\n        elif t == 3:\n            q = int(data[index + 1])\n            queries.append((t, q))\n            index += 2\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[i]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                max_value = float('-inf')\n                for a, b in valid_pairs:\n                    max_value = max(max_value, a * q + b)\n                results.append(str(max_value))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom sortedcontainers import SortedList\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    queries = []\n    \n    for i in range(n):\n        t = int(data[index])\n        if t == 1:\n            a = int(data[index + 1])\n            b = int(data[index + 2])\n            queries.append((t, a, b))\n            index += 3\n        elif t == 2:\n            i = int(data[index + 1])\n            queries.append((t, i))\n            index += 2\n        elif t == 3:\n            q = int(data[index + 1])\n            queries.append((t, q))\n            index += 2\n    \n    pairs = []\n    removed = [False] * (n + 1)\n    results = []\n    \n    for t, *args in queries:\n        if t == 1:\n            a, b = args\n            pairs.append((a, b))\n        elif t == 2:\n            i = args[0]\n            removed[i] = True\n        elif t == 3:\n            q = args[0]\n            valid_pairs = [(a, b) for a, b in pairs if not removed[i]]\n            if not valid_pairs:\n                results.append(\"EMPTY SET\")\n            else:\n                max_value = float('-inf')\n                for a, b in valid_pairs:\n                    max_value = max(max_value, a * q + b)\n                results.append(str(max_value))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Sonya and Problem Wihtout a Legend",
        "question_content": "Sonya was unable to think of a story for this problem, so here comes the formal description.\n\nYou are given the array containing n positive integers. At one turn you can pick any element and increase or decrease it by 1. The goal is the make the array strictly increasing by making the minimum possible number of operations. You are allowed to change elements in any way, they can become negative or equal to 0.\n\n\nInput Format\nThe first line of the input contains a single integer n (1 \u2264 n \u2264 3000)\u00a0\u2014 the length of the array.\n\nNext line contains n integer ai (1 \u2264 ai \u2264 109).\n\n\nOutput Format\nPrint the minimum number of operation required to make the array strictly increasing.\n\n\nSample Input 1\n\n7\n2 1 5 11 5 9 11\n\nSample Output 1\n\n9\n\n\nSample Input 2\n\n5\n5 4 3 2 1\n\nSample Output 2\n\n12\n\n\nNote\nIn the first sample, the array is going to look as follows:\n\n2 3 5 6 7 9 11\n\n|2 - 2| + |1 - 3| + |5 - 5| + |11 - 6| + |5 - 7| + |9 - 9| + |11 - 11| = 9\n\nAnd for the second sample:\n\n1 2 3 4 5\n\n|5 - 1| + |4 - 2| + |3 - 3| + |2 - 4| + |1 - 5| = 12",
        "platform": "codeforces",
        "question_id": "713/C",
        "contest_id": "713",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\noperations = 0\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\nprint(operations)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\noperations = 0\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\nprint(operations)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the number of operations\noperations = 0\n\n# Iterate through the array and make it strictly increasing\nfor i in range(1, n):\n    if a[i] <= a[i - 1]:\n        operations += a[i - 1] - a[i] + 1\n        a[i] = a[i - 1] + 1\n\n# Print the result\nprint(operations)"
        ]
    },
    {
        "question_title": "Maximum path",
        "question_content": "You are given a rectangular table 3 x n. Each cell contains an integer. You can move from one cell to another if they share a side.\n\nFind such path from the upper left cell to the bottom right cell of the table that doesn't visit any of the cells twice, and the sum of numbers written in the cells of this path is maximum possible.\n\n\nInput Format\nThe first line contains an integer n (1 \u2264 n \u2264 105) \u00a0\u2014 the number of columns in the table.\n\nNext three lines contain n integers each \u00a0\u2014 the description of the table. The j-th number in the i-th line corresponds to the cell aij ( - 109 \u2264 aij \u2264 109) of the table.\n\n\nOutput Format\nOutput the maximum sum of numbers on a path from the upper left cell to the bottom right cell of the table, that doesn't visit any of the cells twice.\n\n\nSample Input 1\n\n3\n1 1 1\n1 -1 1\n1 1 1\n\nSample Output 1\n\n7\n\n\nSample Input 2\n\n5\n10 10 10 -1 -1\n-1 10 10 10 10\n-1 10 10 10 10\n\nSample Output 2\n\n110\n\n\nNote\nThe path for the first example:\n\nThe path for the second example:",
        "platform": "codeforces",
        "question_id": "762/D",
        "contest_id": "762",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1+n*i:1+n*(i+1)])) for i in range(3)]\n\n# Initialize the maximum sum to a very small number\nmax_sum = float('-inf')\n\n# Iterate over all possible paths\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            for l in range(n):\n                # Check if the path is valid\n                if (i == 0 and j == 0 and k == 1 and l == 1) or \\\n                   (i == 0 and j == 1 and k == 1 and l == 2) or \\\n                   (i == 1 and j == 0 and k == 2 and l == 1) or \\\n                   (i == 1 and j == 1 and k == 2 and l == 2):\n                    # Calculate the sum of the path\n                    path_sum = grid[0][i] + grid[1][j] + grid[2][k] + grid[2][l]\n                    # Update the maximum sum\n                    max_sum = max(max_sum, path_sum)\n\n# Output the maximum sum\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1 + i * n:1 + (i + 1) * n])) for i in range(3)]\n\n# Initialize the DP table\ndp = [[-float('inf')] * n for _ in range(3)]\ndp[0][0] = grid[0][0]\n\n# Fill the DP table\nfor i in range(3):\n    for j in range(n):\n        if i == 0 and j == 0:\n            continue\n        if i > 0:\n            dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j])\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i][j - 1] + grid[i][j])\n\n# The answer is in the bottom right cell\nprint(dp[2][n - 1])\n```",
            "```python\nimport sys\nfrom collections import deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ngrid = []\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\n# Initialize variables\nmax_sum = float('-inf')\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nvisited = set()\n\n# Depth-first search function\ndef dfs(x, y, current_sum):\n    global max_sum\n    if x == 2 and y == n - 1:\n        max_sum = max(max_sum, current_sum)\n        return\n    visited.add((x, y))\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < 3 and 0 <= ny < n and (nx, ny) not in visited:\n            dfs(nx, ny, current_sum + grid[nx][ny])\n    visited.remove((x, y))\n\n# Start DFS from the top-left cell\ndfs(0, 0, grid[0][0])\n\n# Output the result\nprint(max_sum)\n```",
            "```python\nimport sys\nfrom collections import deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ngrid = []\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\n# Initialize variables\nmax_sum = float('-inf')\ndirections = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n# Depth-first search function\ndef dfs(x, y, path_sum, visited):\n    global max_sum\n    if x == n - 1 and y == 2 * n - 2:\n        max_sum = max(max_sum, path_sum)\n        return\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < 2 * n and not visited[nx][ny]:\n            visited[nx][ny] = True\n            dfs(nx, ny, path_sum + grid[ny // n][nx], visited)\n            visited[nx][ny] = False\n\n# Start DFS from the top-left cell\nvisited = [[False] * (2 * n) for _ in range(n)]\nvisited[0][0] = True\ndfs(0, 0, grid[0][0], visited)\n\n# Output the result\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1+i*n:(i+1)*n+1])) for i in range(3)]\n\n# Initialize the maximum sum to a very small number\nmax_sum = float('-inf')\n\n# Iterate over all possible paths\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            for l in range(n):\n                # Check if the path is valid\n                if (i == 0 and j == 0 and k == 1 and l == 1) or \\\n                   (i == 0 and j == 1 and k == 1 and l == 2) or \\\n                   (i == 1 and j == 0 and k == 2 and l == 1) or \\\n                   (i == 1 and j == 1 and k == 2 and l == 2):\n                    # Calculate the sum of the path\n                    path_sum = grid[0][i] + grid[1][j] + grid[2][k] + grid[2][l]\n                    # Update the maximum sum\n                    max_sum = max(max_sum, path_sum)\n\n# Output the maximum sum\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\n\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\ndp = [[-float('inf')] * n for _ in range(3)]\n\ndp[0][0] = grid[0][0]\n\nfor i in range(3):\n    for j in range(n):\n        if i == 0 and j == 0:\n            continue\n        if i > 0:\n            dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j])\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i][j - 1] + grid[i][j])\n\nprint(dp[2][n - 1])\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\n\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\n# Initialize the DP table\ndp = [[-float('inf')] * n for _ in range(3)]\n\n# Starting point\ndp[0][0] = grid[0][0]\n\n# Fill the DP table\nfor i in range(3):\n    for j in range(n):\n        if i == 0 and j == 0:\n            continue\n        if i > 0:\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j])\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j])\n\n# The answer is in the bottom right cell\nprint(dp[2][n-1])\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\ngrid = []\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\n# Initialize variables\nmax_sum = float('-inf')\ndirections = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n# Depth-First Search (DFS) function\ndef dfs(x, y, path_sum, visited):\n    global max_sum\n    if x == n - 1 and y == 2:\n        max_sum = max(max_sum, path_sum)\n        return\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < 3 and (nx, ny) not in visited:\n            visited.add((nx, ny))\n            dfs(nx, ny, path_sum + grid[ny][nx], visited)\n            visited.remove((nx, ny))\n\n# Start DFS from the top-left cell\nvisited = set()\nvisited.add((0, 0))\ndfs(0, 0, grid[0][0], visited)\n\n# Output the result\nprint(max_sum)\n```",
            "```python\nimport sys\nfrom collections import deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [[0] * n for _ in range(3)]\nindex = 1\n\nfor i in range(3):\n    for j in range(n):\n        grid[i][j] = int(data[index])\n        index += 1\n\n# Directions for moving right, down, and left\ndirections = [(0, 1), (1, 0), (0, -1)]\n\n# Initialize the maximum sum to a very small number\nmax_sum = float('-inf')\n\n# Use a deque to store the path and its sum\nqueue = deque([(0, 0, grid[0][0])])\n\nwhile queue:\n    x, y, current_sum = queue.popleft()\n    \n    # Check if we have reached the bottom right cell\n    if x == 2 and y == n - 1:\n        max_sum = max(max_sum, current_sum)\n        continue\n    \n    # Try moving in all possible directions\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        \n        # Check if the new position is within bounds and not visited\n        if 0 <= nx < 3 and 0 <= ny < n:\n            queue.append((nx, ny, current_sum + grid[nx][ny]))\n\n# Output the maximum sum\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\n\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\n# Initialize the DP table\ndp = [[-float('inf')] * n for _ in range(3)]\n\n# Starting point\ndp[0][0] = grid[0][0]\n\n# Fill the DP table\nfor i in range(3):\n    for j in range(n):\n        if i == 0 and j == 0:\n            continue\n        if i > 0:\n            dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j])\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i][j - 1] + grid[i][j])\n\n# The answer is in the bottom right cell\nprint(dp[2][n - 1])\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1+n*i:1+n*(i+1)])) for i in range(3)]\n\n# Initialize the maximum sum to a very small number\nmax_sum = float('-inf')\n\n# Iterate over all possible paths\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            for l in range(n):\n                # Check if the path is valid\n                if (i == 0 and j == 0 and k == 1 and l == 1) or \\\n                   (i == 0 and j == 1 and k == 1 and l == 2) or \\\n                   (i == 1 and j == 0 and k == 2 and l == 1) or \\\n                   (i == 1 and j == 1 and k == 2 and l == 2):\n                    # Calculate the sum of the path\n                    path_sum = grid[0][i] + grid[1][j] + grid[2][k] + grid[2][l]\n                    # Update the maximum sum\n                    max_sum = max(max_sum, path_sum)\n\n# Output the maximum sum\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1 + i * n:1 + (i + 1) * n])) for i in range(3)]\n\n# Initialize the DP table\ndp = [[-float('inf')] * n for _ in range(3)]\ndp[0][0] = grid[0][0]\n\n# Fill the DP table\nfor i in range(3):\n    for j in range(n):\n        if i == 0 and j == 0:\n            continue\n        if i > 0:\n            dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j])\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i][j - 1] + grid[i][j])\n\n# The answer is in the bottom right cell\nprint(dp[2][n - 1])",
            "import sys\nfrom collections import deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ngrid = []\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\n# Initialize variables\nmax_sum = float('-inf')\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\nvisited = set()\n\n# Depth-first search function\ndef dfs(x, y, current_sum):\n    global max_sum\n    if x == 2 and y == n - 1:\n        max_sum = max(max_sum, current_sum)\n        return\n    visited.add((x, y))\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < 3 and 0 <= ny < n and (nx, ny) not in visited:\n            dfs(nx, ny, current_sum + grid[nx][ny])\n    visited.remove((x, y))\n\n# Start DFS from the top-left cell\ndfs(0, 0, grid[0][0])\n\n# Output the result\nprint(max_sum)",
            "import sys\nfrom collections import deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ngrid = []\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\n# Initialize variables\nmax_sum = float('-inf')\ndirections = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n# Depth-first search function\ndef dfs(x, y, path_sum, visited):\n    global max_sum\n    if x == n - 1 and y == 2 * n - 2:\n        max_sum = max(max_sum, path_sum)\n        return\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < 2 * n and not visited[nx][ny]:\n            visited[nx][ny] = True\n            dfs(nx, ny, path_sum + grid[ny // n][nx], visited)\n            visited[nx][ny] = False\n\n# Start DFS from the top-left cell\nvisited = [[False] * (2 * n) for _ in range(n)]\nvisited[0][0] = True\ndfs(0, 0, grid[0][0], visited)\n\n# Output the result\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1+i*n:(i+1)*n+1])) for i in range(3)]\n\n# Initialize the maximum sum to a very small number\nmax_sum = float('-inf')\n\n# Iterate over all possible paths\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            for l in range(n):\n                # Check if the path is valid\n                if (i == 0 and j == 0 and k == 1 and l == 1) or \\\n                   (i == 0 and j == 1 and k == 1 and l == 2) or \\\n                   (i == 1 and j == 0 and k == 2 and l == 1) or \\\n                   (i == 1 and j == 1 and k == 2 and l == 2):\n                    # Calculate the sum of the path\n                    path_sum = grid[0][i] + grid[1][j] + grid[2][k] + grid[2][l]\n                    # Update the maximum sum\n                    max_sum = max(max_sum, path_sum)\n\n# Output the maximum sum\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\n\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\ndp = [[-float('inf')] * n for _ in range(3)]\n\ndp[0][0] = grid[0][0]\n\nfor i in range(3):\n    for j in range(n):\n        if i == 0 and j == 0:\n            continue\n        if i > 0:\n            dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j])\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i][j - 1] + grid[i][j])\n\nprint(dp[2][n - 1])",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\n\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\n# Initialize the DP table\ndp = [[-float('inf')] * n for _ in range(3)]\n\n# Starting point\ndp[0][0] = grid[0][0]\n\n# Fill the DP table\nfor i in range(3):\n    for j in range(n):\n        if i == 0 and j == 0:\n            continue\n        if i > 0:\n            dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j])\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j])\n\n# The answer is in the bottom right cell\nprint(dp[2][n-1])",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\ngrid = []\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\n# Initialize variables\nmax_sum = float('-inf')\ndirections = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n# Depth-First Search (DFS) function\ndef dfs(x, y, path_sum, visited):\n    global max_sum\n    if x == n - 1 and y == 2:\n        max_sum = max(max_sum, path_sum)\n        return\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < 3 and (nx, ny) not in visited:\n            visited.add((nx, ny))\n            dfs(nx, ny, path_sum + grid[ny][nx], visited)\n            visited.remove((nx, ny))\n\n# Start DFS from the top-left cell\nvisited = set()\nvisited.add((0, 0))\ndfs(0, 0, grid[0][0], visited)\n\n# Output the result\nprint(max_sum)",
            "import sys\nfrom collections import deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [[0] * n for _ in range(3)]\nindex = 1\n\nfor i in range(3):\n    for j in range(n):\n        grid[i][j] = int(data[index])\n        index += 1\n\n# Directions for moving right, down, and left\ndirections = [(0, 1), (1, 0), (0, -1)]\n\n# Initialize the maximum sum to a very small number\nmax_sum = float('-inf')\n\n# Use a deque to store the path and its sum\nqueue = deque([(0, 0, grid[0][0])])\n\nwhile queue:\n    x, y, current_sum = queue.popleft()\n    \n    # Check if we have reached the bottom right cell\n    if x == 2 and y == n - 1:\n        max_sum = max(max_sum, current_sum)\n        continue\n    \n    # Try moving in all possible directions\n    for dx, dy in directions:\n        nx, ny = x + dx, y + dy\n        \n        # Check if the new position is within bounds and not visited\n        if 0 <= nx < 3 and 0 <= ny < n:\n            queue.append((nx, ny, current_sum + grid[nx][ny]))\n\n# Output the maximum sum\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\n\nindex = 1\nfor i in range(3):\n    row = list(map(int, data[index:index + n]))\n    grid.append(row)\n    index += n\n\n# Initialize the DP table\ndp = [[-float('inf')] * n for _ in range(3)]\n\n# Starting point\ndp[0][0] = grid[0][0]\n\n# Fill the DP table\nfor i in range(3):\n    for j in range(n):\n        if i == 0 and j == 0:\n            continue\n        if i > 0:\n            dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j])\n        if j > 0:\n            dp[i][j] = max(dp[i][j], dp[i][j - 1] + grid[i][j])\n\n# The answer is in the bottom right cell\nprint(dp[2][n - 1])"
        ]
    },
    {
        "question_title": "Bear and Rectangle Strips",
        "question_content": "Limak has a grid that consists of 2 rows and n columns. The j-th cell in the i-th row contains an integer ti, j which can be positive, negative or zero.\n\nA non-empty rectangle of cells is called nice if and only if the sum of numbers in its cells is equal to 0.\n\nLimak wants to choose some nice rectangles and give them to his friends, as gifts. No two chosen rectangles should share a cell. What is the maximum possible number of nice rectangles Limak can choose?\n\n\nInput Format\nThe first line of the input contains an integer n (1 \u2264 n \u2264 300 000)\u00a0\u2014 the number of columns in the grid.\n\nThe next two lines contain numbers in the grid. The i-th of those two lines contains n integers ti, 1, ti, 2, ..., ti, n ( - 109 \u2264 ti, j \u2264 109).\n\n\nOutput Format\nPrint one integer, denoting the maximum possible number of cell-disjoint nice rectangles.\n\n\nSample Input 1\n\n6\n70 70 70 70 70 -15\n90 -60 -30 30 -30 15\n\nSample Output 1\n\n3\n\n\nSample Input 2\n\n4\n0 -1 0 0\n0 0 1 0\n\nSample Output 2\n\n6\n\n\nSample Input 3\n\n3\n1000000000 999999999 -1000000000\n999999999 -1000000000 -999999998\n\nSample Output 3\n\n1\n\n\nNote\nIn the first sample, there are four nice rectangles:\n\nLimak can't choose all of them because they are not disjoint. He should take three nice rectangles: those denoted as blue frames on the drawings.\n\nIn the second sample, it's optimal to choose six nice rectangles, each consisting of one cell with a number 0.\n\nIn the third sample, the only nice rectangle is the whole grid\u00a0\u2014 the sum of all numbers is 0. Clearly, Limak can choose at most one nice rectangle, so the answer is 1.",
        "platform": "codeforces",
        "question_id": "771/E",
        "contest_id": "771",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    prefix_sums = [defaultdict(int) for _ in range(2)]\n    prefix_sums[0][0] = 1\n    prefix_sums[1][0] = 1\n    count = 0\n    \n    for i in range(2):\n        current_sum = 0\n        for j in range(n):\n            current_sum += grid[i][j]\n            count += prefix_sums[i][current_sum]\n            prefix_sums[i][current_sum] += 1\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1 + i * n:1 + (i + 1) * n])) for i in range(2)]\n\n# Calculate and print the result\nprint(max_nice_rectangles(n, grid))\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Function to calculate the maximum number of nice rectangles\ndef max_nice_rectangles(grid):\n    n = len(grid[0])\n    prefix_sum = [[0] * (n + 1) for _ in range(3)]\n    nice_rectangles = 0\n    \n    for i in range(1, 3):\n        for j in range(1, n + 1):\n            prefix_sum[i][j] = prefix_sum[i][j-1] + grid[i-1][j-1]\n    \n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            seen = defaultdict(int)\n            seen[0] = 1\n            current_sum = 0\n            for k in range(1, 3):\n                current_sum += prefix_sum[k][j] - prefix_sum[k][i-1]\n                nice_rectangles += seen[current_sum]\n                seen[current_sum] += 1\n    \n    return nice_rectangles\n\n# Calculate and print the result\nresult = max_nice_rectangles(grid)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Calculate prefix sums for each row\nprefix_sum_row1 = [0] * (n + 1)\nprefix_sum_row2 = [0] * (n + 1)\nfor j in range(n):\n    prefix_sum_row1[j+1] = prefix_sum_row1[j] + grid[0][j]\n    prefix_sum_row2[j+1] = prefix_sum_row2[j] + grid[1][j]\n\n# Dictionary to store the count of prefix sums\nprefix_sum_count = defaultdict(int)\nprefix_sum_count[0] = 2  # Initial count for prefix sum 0\n\n# Variables to store the result and current prefix sum\nresult = 0\ncurrent_sum = 0\n\n# Iterate through each column\nfor j in range(n):\n    # Update the current prefix sum\n    current_sum += grid[0][j] - grid[1][j]\n    \n    # Check if there is a previous prefix sum that makes the current sum zero\n    if current_sum in prefix_sum_count:\n        result += prefix_sum_count[current_sum]\n    \n    # Update the prefix sum count\n    prefix_sum_count[current_sum] += 1\n\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    # Calculate the prefix sum for each row\n    prefix_sum = [[0] * (n + 1) for _ in range(2)]\n    for i in range(2):\n        for j in range(n):\n            prefix_sum[i][j + 1] = prefix_sum[i][j] + grid[i][j]\n    \n    # Dictionary to store the frequency of prefix sums\n    prefix_sum_count = defaultdict(int)\n    prefix_sum_count[0] = 1  # Initialize with prefix sum 0\n    \n    max_rectangles = 0\n    \n    for j in range(n + 1):\n        current_sum = 0\n        for i in range(2):\n            current_sum += prefix_sum[i][j]\n            max_rectangles += prefix_sum_count[current_sum]\n            prefix_sum_count[current_sum] += 1\n    \n    return max_rectangles\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\nfor i in range(2):\n    row = list(map(int, data[1 + i * n:1 + (i + 1) * n]))\n    grid.append(row)\n\n# Calculate and print the result\nresult = max_nice_rectangles(n, grid)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    prefix_sum = defaultdict(int)\n    prefix_sum[0] = 1\n    current_sum = 0\n    count = 0\n    \n    for row in grid:\n        current_sum = 0\n        for num in row:\n            current_sum += num\n            count += prefix_sum[current_sum]\n            prefix_sum[current_sum] += 1\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\nfor i in range(2):\n    row = list(map(int, data[2 + i * n: 2 + (i + 1) * n]))\n    grid.append(row)\n\n# Solve the problem\nresult = max_nice_rectangles(n, grid)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Calculate prefix sums for each row\nprefix_sum_row1 = [0] * (n + 1)\nprefix_sum_row2 = [0] * (n + 1)\nfor j in range(n):\n    prefix_sum_row1[j+1] = prefix_sum_row1[j] + grid[0][j]\n    prefix_sum_row2[j+1] = prefix_sum_row2[j] + grid[1][j]\n\n# Dictionary to store the frequency of prefix sums\nprefix_sum_freq = defaultdict(int)\nprefix_sum_freq[0] = 2  # Initial prefix sum of 0 for both rows\n\n# Variable to store the maximum number of nice rectangles\nmax_nice_rectangles = 0\n\n# Iterate through all possible pairs of columns\nfor i in range(n):\n    for j in range(i, n):\n        # Calculate the current prefix sums for the subgrid\n        current_sum_row1 = prefix_sum_row1[j+1] - prefix_sum_row1[i]\n        current_sum_row2 = prefix_sum_row2[j+1] - prefix_sum_row2[i]\n        \n        # Check if the current subgrid is nice\n        if current_sum_row1 == current_sum_row2:\n            max_nice_rectangles += 1\n\n# Output the result\nprint(max_nice_rectangles)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    prefix_sums = defaultdict(int)\n    prefix_sums[0] = 1\n    current_sum = 0\n    count = 0\n    \n    for i in range(n):\n        current_sum += grid[0][i]\n        count += prefix_sums[current_sum]\n        prefix_sums[current_sum] += 1\n    \n    current_sum = 0\n    for i in range(n):\n        current_sum += grid[1][i]\n        count += prefix_sums[current_sum]\n        prefix_sums[current_sum] += 1\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Solve the problem\nresult = max_nice_rectangles(n, grid)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Calculate the prefix sums for each row\nprefix_sum_row1 = [0] * (n + 1)\nprefix_sum_row2 = [0] * (n + 1)\nfor j in range(n):\n    prefix_sum_row1[j+1] = prefix_sum_row1[j] + grid[0][j]\n    prefix_sum_row2[j+1] = prefix_sum_row2[j] + grid[1][j]\n\n# Dictionary to store the frequency of prefix sums\nprefix_sum_count = defaultdict(int)\nprefix_sum_count[0] = 2  # Initial count for the prefix sum 0\n\n# Variable to store the maximum number of nice rectangles\nmax_nice_rectangles = 0\n\n# Iterate through all possible pairs of columns\nfor i in range(n):\n    for j in range(i, n):\n        # Calculate the sum of the subgrid from columns i to j\n        subgrid_sum = prefix_sum_row1[j+1] - prefix_sum_row1[i] + prefix_sum_row2[j+1] - prefix_sum_row2[i]\n        # If the sum is zero, it's a nice rectangle\n        if subgrid_sum == 0:\n            max_nice_rectangles += 1\n        # Update the prefix sum count\n        prefix_sum_count[subgrid_sum] += 1\n\n# Output the result\nprint(max_nice_rectangles)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    # Dictionary to store the prefix sum and its first occurrence column index\n    prefix_sum_indices = defaultdict(list)\n    prefix_sum_indices[0].append(-1)  # To handle the case when the sum is zero from the start\n    current_sum = 0\n    max_rectangles = 0\n\n    for col in range(n):\n        current_sum += grid[0][col]\n        prefix_sum_indices[current_sum].append(col)\n\n        for row in range(1, 2):\n            current_sum += grid[row][col]\n            if current_sum in prefix_sum_indices:\n                # Calculate the number of nice rectangles ending at (row, col)\n                max_rectangles += len(prefix_sum_indices[current_sum]) - 1\n\n    return max_rectangles\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Calculate and print the result\nresult = max_nice_rectangles(n, grid)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    prefix_sums = defaultdict(int)\n    prefix_sums[0] = 1\n    current_sum = 0\n    count = 0\n    \n    for row in grid:\n        for num in row:\n            current_sum += num\n            count += prefix_sums[current_sum]\n            prefix_sums[current_sum] += 1\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\nfor i in range(2):\n    row = list(map(int, data[2 + i * n: 2 + (i + 1) * n]))\n    grid.append(row)\n\n# Calculate and print the result\nresult = max_nice_rectangles(n, grid)\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    prefix_sums = [defaultdict(int) for _ in range(2)]\n    prefix_sums[0][0] = 1\n    prefix_sums[1][0] = 1\n    count = 0\n    \n    for i in range(2):\n        current_sum = 0\n        for j in range(n):\n            current_sum += grid[i][j]\n            count += prefix_sums[i][current_sum]\n            prefix_sums[i][current_sum] += 1\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1 + i * n:1 + (i + 1) * n])) for i in range(2)]\n\n# Calculate and print the result\nprint(max_nice_rectangles(n, grid))",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Function to calculate the maximum number of nice rectangles\ndef max_nice_rectangles(grid):\n    n = len(grid[0])\n    prefix_sum = [[0] * (n + 1) for _ in range(3)]\n    nice_rectangles = 0\n    \n    for i in range(1, 3):\n        for j in range(1, n + 1):\n            prefix_sum[i][j] = prefix_sum[i][j-1] + grid[i-1][j-1]\n    \n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            seen = defaultdict(int)\n            seen[0] = 1\n            current_sum = 0\n            for k in range(1, 3):\n                current_sum += prefix_sum[k][j] - prefix_sum[k][i-1]\n                nice_rectangles += seen[current_sum]\n                seen[current_sum] += 1\n    \n    return nice_rectangles\n\n# Calculate and print the result\nresult = max_nice_rectangles(grid)\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Calculate prefix sums for each row\nprefix_sum_row1 = [0] * (n + 1)\nprefix_sum_row2 = [0] * (n + 1)\nfor j in range(n):\n    prefix_sum_row1[j+1] = prefix_sum_row1[j] + grid[0][j]\n    prefix_sum_row2[j+1] = prefix_sum_row2[j] + grid[1][j]\n\n# Dictionary to store the count of prefix sums\nprefix_sum_count = defaultdict(int)\nprefix_sum_count[0] = 2  # Initial count for prefix sum 0\n\n# Variables to store the result and current prefix sum\nresult = 0\ncurrent_sum = 0\n\n# Iterate through each column\nfor j in range(n):\n    # Update the current prefix sum\n    current_sum += grid[0][j] - grid[1][j]\n    \n    # Check if there is a previous prefix sum that makes the current sum zero\n    if current_sum in prefix_sum_count:\n        result += prefix_sum_count[current_sum]\n    \n    # Update the prefix sum count\n    prefix_sum_count[current_sum] += 1\n\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    # Calculate the prefix sum for each row\n    prefix_sum = [[0] * (n + 1) for _ in range(2)]\n    for i in range(2):\n        for j in range(n):\n            prefix_sum[i][j + 1] = prefix_sum[i][j] + grid[i][j]\n    \n    # Dictionary to store the frequency of prefix sums\n    prefix_sum_count = defaultdict(int)\n    prefix_sum_count[0] = 1  # Initialize with prefix sum 0\n    \n    max_rectangles = 0\n    \n    for j in range(n + 1):\n        current_sum = 0\n        for i in range(2):\n            current_sum += prefix_sum[i][j]\n            max_rectangles += prefix_sum_count[current_sum]\n            prefix_sum_count[current_sum] += 1\n    \n    return max_rectangles\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\nfor i in range(2):\n    row = list(map(int, data[1 + i * n:1 + (i + 1) * n]))\n    grid.append(row)\n\n# Calculate and print the result\nresult = max_nice_rectangles(n, grid)\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    prefix_sum = defaultdict(int)\n    prefix_sum[0] = 1\n    current_sum = 0\n    count = 0\n    \n    for row in grid:\n        current_sum = 0\n        for num in row:\n            current_sum += num\n            count += prefix_sum[current_sum]\n            prefix_sum[current_sum] += 1\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\nfor i in range(2):\n    row = list(map(int, data[2 + i * n: 2 + (i + 1) * n]))\n    grid.append(row)\n\n# Solve the problem\nresult = max_nice_rectangles(n, grid)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Calculate prefix sums for each row\nprefix_sum_row1 = [0] * (n + 1)\nprefix_sum_row2 = [0] * (n + 1)\nfor j in range(n):\n    prefix_sum_row1[j+1] = prefix_sum_row1[j] + grid[0][j]\n    prefix_sum_row2[j+1] = prefix_sum_row2[j] + grid[1][j]\n\n# Dictionary to store the frequency of prefix sums\nprefix_sum_freq = defaultdict(int)\nprefix_sum_freq[0] = 2  # Initial prefix sum of 0 for both rows\n\n# Variable to store the maximum number of nice rectangles\nmax_nice_rectangles = 0\n\n# Iterate through all possible pairs of columns\nfor i in range(n):\n    for j in range(i, n):\n        # Calculate the current prefix sums for the subgrid\n        current_sum_row1 = prefix_sum_row1[j+1] - prefix_sum_row1[i]\n        current_sum_row2 = prefix_sum_row2[j+1] - prefix_sum_row2[i]\n        \n        # Check if the current subgrid is nice\n        if current_sum_row1 == current_sum_row2:\n            max_nice_rectangles += 1\n\n# Output the result\nprint(max_nice_rectangles)",
            "import sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    prefix_sums = defaultdict(int)\n    prefix_sums[0] = 1\n    current_sum = 0\n    count = 0\n    \n    for i in range(n):\n        current_sum += grid[0][i]\n        count += prefix_sums[current_sum]\n        prefix_sums[current_sum] += 1\n    \n    current_sum = 0\n    for i in range(n):\n        current_sum += grid[1][i]\n        count += prefix_sums[current_sum]\n        prefix_sums[current_sum] += 1\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Solve the problem\nresult = max_nice_rectangles(n, grid)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Calculate the prefix sums for each row\nprefix_sum_row1 = [0] * (n + 1)\nprefix_sum_row2 = [0] * (n + 1)\nfor j in range(n):\n    prefix_sum_row1[j+1] = prefix_sum_row1[j] + grid[0][j]\n    prefix_sum_row2[j+1] = prefix_sum_row2[j] + grid[1][j]\n\n# Dictionary to store the frequency of prefix sums\nprefix_sum_count = defaultdict(int)\nprefix_sum_count[0] = 2  # Initial count for the prefix sum 0\n\n# Variable to store the maximum number of nice rectangles\nmax_nice_rectangles = 0\n\n# Iterate through all possible pairs of columns\nfor i in range(n):\n    for j in range(i, n):\n        # Calculate the sum of the subgrid from columns i to j\n        subgrid_sum = prefix_sum_row1[j+1] - prefix_sum_row1[i] + prefix_sum_row2[j+1] - prefix_sum_row2[i]\n        # If the sum is zero, it's a nice rectangle\n        if subgrid_sum == 0:\n            max_nice_rectangles += 1\n        # Update the prefix sum count\n        prefix_sum_count[subgrid_sum] += 1\n\n# Output the result\nprint(max_nice_rectangles)",
            "import sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    # Dictionary to store the prefix sum and its first occurrence column index\n    prefix_sum_indices = defaultdict(list)\n    prefix_sum_indices[0].append(-1)  # To handle the case when the sum is zero from the start\n    current_sum = 0\n    max_rectangles = 0\n\n    for col in range(n):\n        current_sum += grid[0][col]\n        prefix_sum_indices[current_sum].append(col)\n\n        for row in range(1, 2):\n            current_sum += grid[row][col]\n            if current_sum in prefix_sum_indices:\n                # Calculate the number of nice rectangles ending at (row, col)\n                max_rectangles += len(prefix_sum_indices[current_sum]) - 1\n\n    return max_rectangles\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = [list(map(int, data[1:n+1])), list(map(int, data[n+1:2*n+1]))]\n\n# Calculate and print the result\nresult = max_nice_rectangles(n, grid)\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\ndef max_nice_rectangles(n, grid):\n    prefix_sums = defaultdict(int)\n    prefix_sums[0] = 1\n    current_sum = 0\n    count = 0\n    \n    for row in grid:\n        for num in row:\n            current_sum += num\n            count += prefix_sums[current_sum]\n            prefix_sums[current_sum] += 1\n    \n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ngrid = []\nfor i in range(2):\n    row = list(map(int, data[2 + i * n: 2 + (i + 1) * n]))\n    grid.append(row)\n\n# Calculate and print the result\nresult = max_nice_rectangles(n, grid)\nprint(result)"
        ]
    },
    {
        "question_title": "Array Queries",
        "question_content": "a is an array of n positive integers, all of which are not greater than n.\n\nYou have to process q queries to this array. Each query is represented by two numbers p and k. Several operations are performed in each query; each operation changes p to p + ap + k. There operations are applied until p becomes greater than n. The answer to the query is the number of performed operations.\n\n\nInput Format\nThe first line contains one integer n (1 \u2264 n \u2264 100000).\n\nThe second line contains n integers \u2014 elements of a (1 \u2264 ai \u2264 n for each i from 1 to n).\n\nThe third line containts one integer q (1 \u2264 q \u2264 100000).\n\nThen q lines follow. Each line contains the values of p and k for corresponding query (1 \u2264 p, k \u2264 n).\n\n\nOutput Format\nPrint q integers, ith integer must be equal to the answer to ith query.\n\n\nSample Input 1\n\n3\n1 1 1\n3\n1 1\n2 1\n3 1\n\nSample Output 1\n\n2\n1\n1\n\n\nNote\nConsider first example:\n\nIn first query after first operation p = 3, after second operation p = 5.\n\nIn next two queries p is greater than n after the first operation.",
        "platform": "codeforces",
        "question_id": "797/E",
        "contest_id": "797",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print the results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print the results\nprint('\\n'.join(map(str, results)))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Write output to stdout\nprint('\\n'.join(map(str, results)))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nresults = []\n\nindex = n + 2\nfor _ in range(q):\n    p = int(data[index])\n    k = int(data[index + 1])\n    count = 0\n    while p <= n:\n        p += a[p-1] + k\n        count += 1\n    results.append(count)\n    index += 2\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p = p + a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p = p + a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print the results\nprint('\\n'.join(map(str, results)))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print results\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nresults = []\n\nindex = n + 2\nfor _ in range(q):\n    p = int(data[index])\n    k = int(data[index + 1])\n    index += 2\n    \n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    \n    results.append(operations)\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print the results\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print the results\nprint('\\n'.join(map(str, results)))",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Write output to stdout\nprint('\\n'.join(map(str, results)))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nresults = []\n\nindex = n + 2\nfor _ in range(q):\n    p = int(data[index])\n    k = int(data[index + 1])\n    count = 0\n    while p <= n:\n        p += a[p-1] + k\n        count += 1\n    results.append(count)\n    index += 2\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p = p + a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print results\nfor result in results:\n    print(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p = p + a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print the results\nprint('\\n'.join(map(str, results)))",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\nqueries = [(int(data[n+2+2*i]), int(data[n+3+2*i])) for i in range(q)]\n\n# Process each query\nresults = []\nfor p, k in queries:\n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    results.append(operations)\n\n# Print results\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nresults = []\n\nindex = n + 2\nfor _ in range(q):\n    p = int(data[index])\n    k = int(data[index + 1])\n    index += 2\n    \n    operations = 0\n    while p <= n:\n        p += a[p-1] + k\n        operations += 1\n    \n    results.append(operations)\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "April Fools' Problem (medium)",
        "question_content": "The marmots need to prepare k problems for HC2 over n days. Each problem, once prepared, also has to be printed.\n\nThe preparation of a problem on day i (at most one per day) costs ai CHF, and the printing of a problem on day i (also at most one per day) costs bi CHF. Of course, a problem cannot be printed before it has been prepared (but doing both on the same day is fine).\n\nWhat is the minimum cost of preparation and printing?\n\n\nInput Format\nThe first line of input contains two space-separated integers n and k (1 \u2264 k \u2264 n \u2264 2200). The second line contains n space-separated integers a1, ..., an (1 \\leq a_i \\leq 10^9) \u2014 the preparation costs. The third line contains n space-separated integers b1, ..., bn (1 \\leq b_i \\leq 10^9) \u2014 the printing costs.\n\n\nOutput Format\nOutput the minimum cost of preparation and printing k problems \u2014 that is, the minimum possible sum ai1 + ai2 + ... + aik + bj1 + bj2 + ... + bjk, where 1 \u2264 i1 < i2 < ... < ik \u2264 n, 1 \u2264 j1 < j2 < ... < jk \u2264 n and i1 \u2264 j1, i2 \u2264 j2, ..., ik \u2264 jk.\n\n\nSample Input 1\n\n8 4\n3 8 7 9 9 4 6 8\n2 5 9 4 3 8 9 1\n\nSample Output 1\n\n32\n\n\nNote\nIn the sample testcase, one optimum solution is to prepare the first problem on day 1 and print it on day 1, prepare the second problem on day 2 and print it on day 4, prepare the third problem on day 3 and print it on day 5, and prepare the fourth problem on day 6 and print it on day 8.",
        "platform": "codeforces",
        "question_id": "802/N",
        "contest_id": "802",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort the preparation and printing costs\na.sort()\nb.sort()\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(k):\n    min_cost += a[i] + b[i]\n\n# Output the result\nprint(min_cost)\n```",
            "```python\nimport sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Combine preparation and printing costs into a single list of tuples\ncosts = [(a[i], b[i]) for i in range(n)]\n# Sort the costs by the sum of preparation and printing costs\ncosts.sort(key=lambda x: x[0] + x[1])\n\n# Use a min-heap to keep track of the k smallest costs\nmin_heap = []\nfor cost in costs[:k]:\n    heapq.heappush(min_heap, cost)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor _ in range(k):\n    min_cost += heapq.heappop(min_heap)[0] + heapq.heappop(min_heap)[1]\n\nprint(min_cost)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort preparation and printing costs\na.sort()\nb.sort()\n\n# Calculate minimum cost\nmin_cost = 0\nfor i in range(k):\n    min_cost += a[i] + b[i]\n\n# Output the result\nprint(min_cost)\n```",
            "```python\nimport sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Combine preparation and printing costs into a single list of tuples\n# Each tuple is (cost, is_preparation)\ncosts = [(a[i], True) for i in range(n)] + [(b[i], False) for i in range(n)]\n\n# Sort the costs by cost, and then by whether it's a preparation or printing cost\ncosts.sort()\n\n# Use a min-heap to keep track of the k lowest preparation costs\nheap = []\ntotal_cost = 0\n\nfor cost, is_preparation in costs:\n    if is_preparation:\n        heapq.heappush(heap, cost)\n    else:\n        if heap:\n            # If there are preparation costs available, use the lowest one\n            total_cost += heapq.heappop(heap) + cost\n        else:\n            # If no preparation costs are available, use the current printing cost\n            total_cost += cost\n\nprint(total_cost)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort the preparation and printing costs\na.sort()\nb.sort()\n\n# The minimum cost is the sum of the k smallest preparation costs\n# and the k smallest printing costs\nmin_cost = sum(a[:k]) + sum(b[:k])\n\nprint(min_cost)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort the costs\na.sort()\nb.sort()\n\n# Calculate the minimum cost\nmin_cost = sum(a[:k]) + sum(b[:k])\n\n# Output the result\nprint(min_cost)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Combine preparation and printing costs\ncosts = [(a[i], b[i]) for i in range(n)]\n\n# Sort costs by the sum of preparation and printing costs\ncosts.sort(key=lambda x: x[0] + x[1])\n\n# Use a min-heap to keep track of the minimum costs\nheap = []\nfor i in range(k):\n    heapq.heappush(heap, costs[i])\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(k):\n    min_cost += heap[i][0] + heap[i][1]\n\n# Output the result\nprint(min_cost)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort the preparation and printing costs\na.sort()\nb.sort()\n\n# Calculate the minimum cost\nmin_cost = sum(a[:k]) + sum(b[:k])\n\n# Output the result\nprint(min_cost)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort preparation and printing costs\na.sort()\nb.sort()\n\n# Calculate minimum cost\nmin_cost = 0\nfor i in range(k):\n    min_cost += a[i] + b[i]\n\n# Output the result\nprint(min_cost)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Combine preparation and printing costs\ncosts = [(a[i], b[i]) for i in range(n)]\n\n# Sort costs by the sum of preparation and printing costs\ncosts.sort(key=lambda x: x[0] + x[1])\n\n# Use a min-heap to keep track of the k smallest costs\nheap = []\nfor cost in costs[:k]:\n    heapq.heappush(heap, cost)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor _ in range(k):\n    min_cost += heapq.heappop(heap)[0] + heapq.heappop(heap)[1]\n\n# Output the result\nprint(min_cost)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort the preparation and printing costs\na.sort()\nb.sort()\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(k):\n    min_cost += a[i] + b[i]\n\n# Output the result\nprint(min_cost)",
            "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Combine preparation and printing costs into a single list of tuples\ncosts = [(a[i], b[i]) for i in range(n)]\n# Sort the costs by the sum of preparation and printing costs\ncosts.sort(key=lambda x: x[0] + x[1])\n\n# Use a min-heap to keep track of the k smallest costs\nmin_heap = []\nfor cost in costs[:k]:\n    heapq.heappush(min_heap, cost)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor _ in range(k):\n    min_cost += heapq.heappop(min_heap)[0] + heapq.heappop(min_heap)[1]\n\nprint(min_cost)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort preparation and printing costs\na.sort()\nb.sort()\n\n# Calculate minimum cost\nmin_cost = 0\nfor i in range(k):\n    min_cost += a[i] + b[i]\n\n# Output the result\nprint(min_cost)",
            "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Combine preparation and printing costs into a single list of tuples\n# Each tuple is (cost, is_preparation)\ncosts = [(a[i], True) for i in range(n)] + [(b[i], False) for i in range(n)]\n\n# Sort the costs by cost, and then by whether it's a preparation or printing cost\ncosts.sort()\n\n# Use a min-heap to keep track of the k lowest preparation costs\nheap = []\ntotal_cost = 0\n\nfor cost, is_preparation in costs:\n    if is_preparation:\n        heapq.heappush(heap, cost)\n    else:\n        if heap:\n            # If there are preparation costs available, use the lowest one\n            total_cost += heapq.heappop(heap) + cost\n        else:\n            # If no preparation costs are available, use the current printing cost\n            total_cost += cost\n\nprint(total_cost)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort the preparation and printing costs\na.sort()\nb.sort()\n\n# The minimum cost is the sum of the k smallest preparation costs\n# and the k smallest printing costs\nmin_cost = sum(a[:k]) + sum(b[:k])\n\nprint(min_cost)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort the costs\na.sort()\nb.sort()\n\n# Calculate the minimum cost\nmin_cost = sum(a[:k]) + sum(b[:k])\n\n# Output the result\nprint(min_cost)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Combine preparation and printing costs\ncosts = [(a[i], b[i]) for i in range(n)]\n\n# Sort costs by the sum of preparation and printing costs\ncosts.sort(key=lambda x: x[0] + x[1])\n\n# Use a min-heap to keep track of the minimum costs\nheap = []\nfor i in range(k):\n    heapq.heappush(heap, costs[i])\n\n# Calculate the minimum cost\nmin_cost = 0\nfor i in range(k):\n    min_cost += heap[i][0] + heap[i][1]\n\n# Output the result\nprint(min_cost)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort the preparation and printing costs\na.sort()\nb.sort()\n\n# Calculate the minimum cost\nmin_cost = sum(a[:k]) + sum(b[:k])\n\n# Output the result\nprint(min_cost)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Sort preparation and printing costs\na.sort()\nb.sort()\n\n# Calculate minimum cost\nmin_cost = 0\nfor i in range(k):\n    min_cost += a[i] + b[i]\n\n# Output the result\nprint(min_cost)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:2+n]))\nb = list(map(int, data[2+n:]))\n\n# Combine preparation and printing costs\ncosts = [(a[i], b[i]) for i in range(n)]\n\n# Sort costs by the sum of preparation and printing costs\ncosts.sort(key=lambda x: x[0] + x[1])\n\n# Use a min-heap to keep track of the k smallest costs\nheap = []\nfor cost in costs[:k]:\n    heapq.heappush(heap, cost)\n\n# Calculate the minimum cost\nmin_cost = 0\nfor _ in range(k):\n    min_cost += heapq.heappop(heap)[0] + heapq.heappop(heap)[1]\n\n# Output the result\nprint(min_cost)"
        ]
    },
    {
        "question_title": "April Fools' Problem (hard)",
        "question_content": "The plans for HC2 are rather far-fetched: we are just over 500 000 days away from HC2 3387, for example, and accordingly we are planning to have a couple hundred thousand problems in that edition (we hope that programming contests will become wildly more popular). The marmots need to get to work, and they could use a good plan...\n\n\nInput Format\nSame as the medium version, but the limits have changed: 1 \u2264 k \u2264 n \u2264 500 000.\n\n\nOutput Format\nSame as the medium version.\n\n\nSample Input 1\n\n8 4\n3 8 7 9 9 4 6 8\n2 5 9 4 3 8 9 1\n\nSample Output 1\n\n32",
        "platform": "codeforces",
        "question_id": "802/O",
        "contest_id": "802",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    A = list(map(int, data[2:2+n]))\n    B = list(map(int, data[2+n:2+2*n]))\n    \n    A.sort()\n    B.sort(reverse=True)\n    \n    max_sum = 0\n    for i in range(k):\n        max_sum += A[i] + B[i]\n    \n    print(max_sum)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\n# Sort the lists\na.sort()\nb.sort(reverse=True)\n\n# Calculate the maximum sum\nmax_sum = 0\nfor i in range(k):\n    max_sum += a[i] + b[i]\n\n# Write the result to stdout\nprint(max_sum)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\na.sort()\nb.sort(reverse=True)\n\nresult = 0\nfor i in range(n):\n    result += min(a[i], b[i])\n\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\n# Sort the lists\na.sort()\nb.sort(reverse=True)\n\n# Calculate the maximum sum\nmax_sum = 0\nfor i in range(n):\n    max_sum += min(a[i], b[i])\n\n# Output the result\nprint(max_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\na.sort()\nb.sort(reverse=True)\n\nresult = 0\nfor i in range(k):\n    result += a[i] * b[i]\n\nprint(result)\n```",
            "```python\nimport sys\nimport math\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\n# Calculate the sum of the minimum values of pairs (a[i], b[i])\nresult = sum(min(a[i], b[i]) for i in range(n))\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    A = list(map(int, data[2:2+n]))\n    B = list(map(int, data[2+n:]))\n    \n    A.sort()\n    B.sort(reverse=True)\n    \n    total = 0\n    for i in range(k):\n        total += A[i] * B[i]\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\na.sort()\nb.sort(reverse=True)\n\nresult = 0\nfor i in range(k):\n    result += a[i] * b[i]\n\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\na.sort()\nb.sort(reverse=True)\n\nresult = 0\nfor i in range(k):\n    result += a[i] * b[i]\n\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_cost_to_connect(n, k, costs):\n    min_heap = []\n    for i in range(n):\n        heapq.heappush(min_heap, (costs[i], i))\n    \n    connected = set()\n    total_cost = 0\n    \n    while len(connected) < n:\n        cost, node = heapq.heappop(min_heap)\n        if node in connected:\n            continue\n        connected.add(node)\n        total_cost += cost\n        \n        if len(connected) == n:\n            break\n        \n        for neighbor in range(n):\n            if neighbor not in connected:\n                heapq.heappush(min_heap, (costs[neighbor], neighbor))\n    \n    return total_cost\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    costs = list(map(int, data[2:2*n+2]))\n    \n    result = min_cost_to_connect(n, k, costs)\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    A = list(map(int, data[2:2+n]))\n    B = list(map(int, data[2+n:2+2*n]))\n    \n    A.sort()\n    B.sort(reverse=True)\n    \n    max_sum = 0\n    for i in range(k):\n        max_sum += A[i] + B[i]\n    \n    print(max_sum)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\n# Sort the lists\na.sort()\nb.sort(reverse=True)\n\n# Calculate the maximum sum\nmax_sum = 0\nfor i in range(k):\n    max_sum += a[i] + b[i]\n\n# Write the result to stdout\nprint(max_sum)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\na.sort()\nb.sort(reverse=True)\n\nresult = 0\nfor i in range(n):\n    result += min(a[i], b[i])\n\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\n# Sort the lists\na.sort()\nb.sort(reverse=True)\n\n# Calculate the maximum sum\nmax_sum = 0\nfor i in range(n):\n    max_sum += min(a[i], b[i])\n\n# Output the result\nprint(max_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\na.sort()\nb.sort(reverse=True)\n\nresult = 0\nfor i in range(k):\n    result += a[i] * b[i]\n\nprint(result)",
            "import sys\nimport math\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\n# Calculate the sum of the minimum values of pairs (a[i], b[i])\nresult = sum(min(a[i], b[i]) for i in range(n))\n\n# Write the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    A = list(map(int, data[2:2+n]))\n    B = list(map(int, data[2+n:]))\n    \n    A.sort()\n    B.sort(reverse=True)\n    \n    total = 0\n    for i in range(k):\n        total += A[i] * B[i]\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\na.sort()\nb.sort(reverse=True)\n\nresult = 0\nfor i in range(k):\n    result += a[i] * b[i]\n\nprint(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:n+2]))\nb = list(map(int, data[n+2:]))\n\na.sort()\nb.sort(reverse=True)\n\nresult = 0\nfor i in range(k):\n    result += a[i] * b[i]\n\nprint(result)",
            "import sys\nimport heapq\n\ndef min_cost_to_connect(n, k, costs):\n    min_heap = []\n    for i in range(n):\n        heapq.heappush(min_heap, (costs[i], i))\n    \n    connected = set()\n    total_cost = 0\n    \n    while len(connected) < n:\n        cost, node = heapq.heappop(min_heap)\n        if node in connected:\n            continue\n        connected.add(node)\n        total_cost += cost\n        \n        if len(connected) == n:\n            break\n        \n        for neighbor in range(n):\n            if neighbor not in connected:\n                heapq.heappush(min_heap, (costs[neighbor], neighbor))\n    \n    return total_cost\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    costs = list(map(int, data[2:2*n+2]))\n    \n    result = min_cost_to_connect(n, k, costs)\n    print(result)"
        ]
    },
    {
        "question_title": "Coprime Subsequences",
        "question_content": "Let's call a non-empty sequence of positive integers a1, a2... ak coprime if the greatest common divisor of all elements of this sequence is equal to 1.\n\nGiven an array a consisting of n positive integers, find the number of its coprime subsequences. Since the answer may be very large, print it modulo 109 + 7.\n\nNote that two subsequences are considered different if chosen indices are different. For example, in the array [1, 1] there are 3 different subsequences: [1], [1] and [1, 1].\n\n\nInput Format\nThe first line contains one integer number n (1 \u2264 n \u2264 100000).\n\nThe second line contains n integer numbers a1, a2... an (1 \u2264 ai \u2264 100000).\n\n\nOutput Format\nPrint the number of coprime subsequences of a modulo 109 + 7.\n\n\nSample Input 1\n\n3\n1 2 3\n\nSample Output 1\n\n5\n\n\nSample Input 2\n\n4\n1 1 1 1\n\nSample Output 2\n\n15\n\n\nSample Input 3\n\n7\n1 3 5 15 3 105 35\n\nSample Output 3\n\n100\n\n\nNote\nIn the first example coprime subsequences are:\n\n1. 1\n2. 1, 2\n3. 1, 3\n4. 1, 2, 3\n5. 2, 3\n\nIn the second example all subsequences are coprime.",
        "platform": "codeforces",
        "question_id": "803/F",
        "contest_id": "803",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) == 1:\n                dp[i + 1] = (dp[i + 1] + dp[j]) % MOD\n    return (dp[n] - 1) % MOD\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = count_coprime_subsequences(a)\n    print(result)\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(n, a):\n    dp = [1] + [0] * n\n    for i in range(n):\n        dp[i] = (dp[i-1] * 2 + 1) % MOD\n        for j in range(i):\n            if gcd(a[i], a[j]) == 1:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = count_coprime_subsequences(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) == 1:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return sum(dp) % MOD\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    print(coprime_subsequences(a))\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(n):\n        for j in range(i + 1):\n            dp[i + 1] = (dp[i + 1] + dp[j] * gcd(a[i], reduce(gcd, a[j:i + 1]))) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = count_coprime_subsequences(a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(n):\n        dp[i + 1] = dp[i] * 2\n        for j in range(i):\n            if gcd(a[i], a[j]) == 1:\n                dp[i + 1] += dp[j]\n    return dp[n] - 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = count_coprime_subsequences(a)\n    print(result % MOD)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] * 2\n        for j in range(i - 1, -1, -1):\n            if gcd(a[i - 1], reduce(gcd, a[j:i])) == 1:\n                dp[i] += dp[j]\n                dp[i] %= MOD\n    return dp[n] - 1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_coprime_subsequences(a)\nprint(result)\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef coprime_subsequences_count(n, a):\n    dp = [1] * (n + 1)\n    for i in range(n):\n        dp[i + 1] = dp[i] * 2\n        for j in range(i):\n            if reduce(gcd, a[j:i+1]) == 1:\n                dp[i + 1] += dp[j]\n    return dp[n] - 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = coprime_subsequences_count(n, a)\n    print(result % MOD)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(n):\n        for j in range(i):\n            if reduce(gcd, a[j:i+1]) == 1:\n                dp[i+1] = (dp[i+1] + dp[j]) % MOD\n    return (dp[n] - 1) % MOD\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    print(coprime_subsequences(a))\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(n):\n        dp[i + 1] = dp[i] * 2\n        for j in range(i):\n            if gcd(a[i], a[j]) == 1:\n                dp[i + 1] += dp[j]\n                dp[i + 1] %= MOD\n    return dp[n]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_coprime_subsequences(a)\nprint(result)\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef coprime_subsequences(n, a):\n    dp = [1] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1]\n        for j in range(i - 1, -1, -1):\n            if gcd(a[i - 1], a[j]) == 1:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = coprime_subsequences(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) == 1:\n                dp[i + 1] = (dp[i + 1] + dp[j]) % MOD\n    return (dp[n] - 1) % MOD\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = count_coprime_subsequences(a)\n    print(result)",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(n, a):\n    dp = [1] + [0] * n\n    for i in range(n):\n        dp[i] = (dp[i-1] * 2 + 1) % MOD\n        for j in range(i):\n            if gcd(a[i], a[j]) == 1:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = count_coprime_subsequences(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if gcd(a[i], a[j]) == 1:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return sum(dp) % MOD\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    print(coprime_subsequences(a))",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(n):\n        for j in range(i + 1):\n            dp[i + 1] = (dp[i + 1] + dp[j] * gcd(a[i], reduce(gcd, a[j:i + 1]))) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = count_coprime_subsequences(a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(n):\n        dp[i + 1] = dp[i] * 2\n        for j in range(i):\n            if gcd(a[i], a[j]) == 1:\n                dp[i + 1] += dp[j]\n    return dp[n] - 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = count_coprime_subsequences(a)\n    print(result % MOD)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] * 2\n        for j in range(i - 1, -1, -1):\n            if gcd(a[i - 1], reduce(gcd, a[j:i])) == 1:\n                dp[i] += dp[j]\n                dp[i] %= MOD\n    return dp[n] - 1\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_coprime_subsequences(a)\nprint(result)",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef coprime_subsequences_count(n, a):\n    dp = [1] * (n + 1)\n    for i in range(n):\n        dp[i + 1] = dp[i] * 2\n        for j in range(i):\n            if reduce(gcd, a[j:i+1]) == 1:\n                dp[i + 1] += dp[j]\n    return dp[n] - 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = coprime_subsequences_count(n, a)\n    print(result % MOD)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(n):\n        for j in range(i):\n            if reduce(gcd, a[j:i+1]) == 1:\n                dp[i+1] = (dp[i+1] + dp[j]) % MOD\n    return (dp[n] - 1) % MOD\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    print(coprime_subsequences(a))",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_coprime_subsequences(a):\n    n = len(a)\n    dp = [1] * (n + 1)\n    for i in range(n):\n        dp[i + 1] = dp[i] * 2\n        for j in range(i):\n            if gcd(a[i], a[j]) == 1:\n                dp[i + 1] += dp[j]\n                dp[i + 1] %= MOD\n    return dp[n]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_coprime_subsequences(a)\nprint(result)",
            "import sys\nfrom math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef coprime_subsequences(n, a):\n    dp = [1] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1]\n        for j in range(i - 1, -1, -1):\n            if gcd(a[i - 1], a[j]) == 1:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[n]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    result = coprime_subsequences(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Periodic RMQ Problem",
        "question_content": "You are given an array a consisting of positive integers and q queries to this array. There are two types of queries:\n\n- 1 l r x \u2014 for each index i such that l \u2264 i \u2264 r set ai = x.\n- 2 l r \u2014 find the minimum among such ai that l \u2264 i \u2264 r.\n\nWe decided that this problem is too easy. So the array a is given in a compressed form: there is an array b consisting of n elements and a number k in the input, and before all queries a is equal to the concatenation of k arrays b (so the size of a is n\u00b7k).\n\n\nInput Format\nThe first line contains two integers n and k (1 \u2264 n \u2264 105, 1 \u2264 k \u2264 104).\n\nThe second line contains n integers \u2014 elements of the array b (1 \u2264 bi \u2264 109).\n\nThe third line contains one integer q (1 \u2264 q \u2264 105).\n\nThen q lines follow, each representing a query. Each query is given either as 1 l r x \u2014 set all elements in the segment from l till r (including borders) to x (1 \u2264 l \u2264 r \u2264 n\u00b7k, 1 \u2264 x \u2264 109) or as 2 l r \u2014 find the minimum among all elements in the segment from l till r (1 \u2264 l \u2264 r \u2264 n\u00b7k).\n\n\nOutput Format\nFor each query of type 2 print the answer to this query \u2014 the minimum on the corresponding segment.\n\n\nSample Input 1\n\n3 1\n1 2 3\n3\n2 1 3\n1 1 2 4\n2 1 3\n\nSample Output 1\n\n1\n3\n\n\nSample Input 2\n\n3 2\n1 2 3\n5\n2 4 4\n1 4 4 5\n2 4 4\n1 1 6 1\n2 6 6\n\nSample Output 2\n\n1\n5\n1",
        "platform": "codeforces",
        "question_id": "803/G",
        "contest_id": "803",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nqueries = data[2+n+1:]\n\nindex = 2 * n + 1\nresults = []\n\nfor i in range(q):\n    query = queries[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for j in range(l, r):\n            a[j] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\n\nfor _ in range(q):\n    query = data[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2]) - 1\n        x = int(query[3])\n        for i in range(l, r + 1):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2]) - 1\n        results.append(min(a[l:r + 1]))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\n\nfor _ in range(q):\n    query = data[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nqueries = data[2+n+1:]\n\nindex = 2 * n + 1\nresults = []\n\nfor i in range(q):\n    query = queries[index:index+5]\n    index += 5\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for j in range(l, r):\n            a[j] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\nfor _ in range(q):\n    query = data[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\nfor _ in range(q):\n    query = data[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\n\nfor _ in range(q):\n    query = list(map(int, data[index:index+4]))\n    index += 4\n    if query[0] == 1:\n        l = query[1] - 1\n        r = query[2]\n        x = query[3]\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == 2:\n        l = query[1] - 1\n        r = query[2]\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\n\nfor _ in range(q):\n    query = data[index:index+5]\n    index += 5\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\nfor _ in range(q):\n    query = data[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query = list(map(int, data[index:index+4]))\n    queries.append(query)\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        l = query[1] - 1\n        r = query[2]\n        x = query[3]\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == 2:\n        l = query[1] - 1\n        r = query[2]\n        min_val = min(a[l:r])\n        print(min_val)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nqueries = data[2+n+1:]\n\nindex = 2 * n + 1\nresults = []\n\nfor i in range(q):\n    query = queries[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for j in range(l, r):\n            a[j] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\n\nfor _ in range(q):\n    query = data[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2]) - 1\n        x = int(query[3])\n        for i in range(l, r + 1):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2]) - 1\n        results.append(min(a[l:r + 1]))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\n\nfor _ in range(q):\n    query = data[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nqueries = data[2+n+1:]\n\nindex = 2 * n + 1\nresults = []\n\nfor i in range(q):\n    query = queries[index:index+5]\n    index += 5\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for j in range(l, r):\n            a[j] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\nfor _ in range(q):\n    query = data[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\nfor _ in range(q):\n    query = data[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\n\nfor _ in range(q):\n    query = list(map(int, data[index:index+4]))\n    index += 4\n    if query[0] == 1:\n        l = query[1] - 1\n        r = query[2]\n        x = query[3]\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == 2:\n        l = query[1] - 1\n        r = query[2]\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\n\nfor _ in range(q):\n    query = data[index:index+5]\n    index += 5\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\nindex = 2 + n\n\nresults = []\nfor _ in range(q):\n    query = data[index:index+4]\n    index += 4\n    if query[0] == '1':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        x = int(query[3])\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2])\n        results.append(min(a[l:r]))\n\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\nb = list(map(int, data[2:2+n]))\nq = int(data[2+n])\n\na = b * k\n\nqueries = []\nindex = 2 + n\nfor _ in range(q):\n    query = list(map(int, data[index:index+4]))\n    queries.append(query)\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        l = query[1] - 1\n        r = query[2]\n        x = query[3]\n        for i in range(l, r):\n            a[i] = x\n    elif query[0] == 2:\n        l = query[1] - 1\n        r = query[2]\n        min_val = min(a[l:r])\n        print(min_val)"
        ]
    },
    {
        "question_title": "Bipartite Checking",
        "question_content": "You are given an undirected graph consisting of n vertices. Initially there are no edges in the graph. Also you are given q queries, each query either adds one undirected edge to the graph or removes it. After each query you have to check if the resulting graph is bipartite (that is, you can paint all vertices of the graph into two colors so that there is no edge connecting two vertices of the same color).\n\n\nInput Format\nThe first line contains two integers n and q (2 \u2264 n, q \u2264 100000).\n\nThen q lines follow. ith line contains two numbers xi and yi (1 \u2264 xi < yi \u2264 n). These numbers describe ith query: if there is an edge between vertices xi and yi, then remove it, otherwise add it.\n\n\nOutput Format\nPrint q lines. ith line must contain YES if the graph is bipartite after ith query, and NO otherwise.\n\n\nSample Input 1\n\n3 5\n2 3\n1 3\n1 2\n1 2\n1 2\n\nSample Output 1\n\nYES\nYES\nNO\nYES\nNO",
        "platform": "codeforces",
        "question_id": "813/F",
        "contest_id": "813",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import deque\n\ndef is_bipartite(graph, n):\n    color = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        if color[i] == -1:\n            color[i] = 0\n            queue = deque([i])\n            while queue:\n                node = queue.popleft()\n                for neighbor in graph[node]:\n                    if color[neighbor] == -1:\n                        color[neighbor] = 1 - color[node]\n                        queue.append(neighbor)\n                    elif color[neighbor] == color[node]:\n                        return False\n    return True\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    index = 2\n    results = []\n    \n    for _ in range(q):\n        xi = int(data[index])\n        yi = int(data[index + 1])\n        index += 2\n        \n        if (xi, yi) in graph[xi]:\n            graph[xi].remove(yi)\n            graph[yi].remove(xi)\n        else:\n            graph[xi].append(yi)\n            graph[yi].append(xi)\n        \n        if is_bipartite(graph, n):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "On the Bench",
        "question_content": "A year ago on the bench in public park Leha found an array of n numbers. Leha believes that permutation p is right if for all 1 \u2264 i < n condition, that api\u00b7api + 1 is not perfect square, holds. Leha wants to find number of right permutations modulo 109 + 7.\n\n\nInput Format\nFirst line of input data contains single integer n (1 \u2264 n \u2264 300) \u2014 length of the array.\n\nNext line contains n integers a1, a2, ... , an (1 \u2264 ai \u2264 109) \u2014 found array.\n\n\nOutput Format\nOutput single integer \u2014 number of right permutations modulo 109 + 7.\n\n\nSample Input 1\n\n3\n1 2 4\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n7\n5 2 4 2 4 1 1\n\nSample Output 2\n\n144\n\n\nNote\nFor first example:\n\n[1, 2, 4] \u2014 right permutation, because 2 and 8 are not perfect squares.\n\n[1, 4, 2] \u2014 wrong permutation, because 4 is square of 2.\n\n[2, 1, 4] \u2014 wrong permutation, because 4 is square of 2.\n\n[2, 4, 1] \u2014 wrong permutation, because 4 is square of 2.\n\n[4, 1, 2] \u2014 wrong permutation, because 4 is square of 2.\n\n[4, 2, 1] \u2014 right permutation, because 8 and 2 are not perfect squares.",
        "platform": "codeforces",
        "question_id": "840/C",
        "contest_id": "840",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j] + a[i] * a[j] + 1):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n    \n    return count % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j]):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n                count %= MOD\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j]):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n                count %= MOD\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    def is_right_permutation(p):\n        for i in range(n - 1):\n            if is_perfect_square(p[i] * p[i + 1]):\n                return False\n        return True\n\n    from itertools import permutations\n    count = 0\n    for perm in permutations(a):\n        if is_right_permutation(perm):\n            count += 1\n    return count % MOD\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Calculate and print the result\nresult = count_right_permutations(n, a)\nprint(result)\n```",
            "```python\nimport sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j]):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n    \n    return count % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j] + 1):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n                count %= MOD\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if not is_perfect_square(a[i] * a[j] + a[i] * a[j + 1]):\n                    count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n    return count % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    def is_right_permutation(p):\n        for i in range(n - 1):\n            if is_perfect_square(p[i] * p[i + 1]):\n                return False\n        return True\n\n    from itertools import permutations\n    count = 0\n    for p in permutations(a):\n        if is_right_permutation(p):\n            count += 1\n    return count % MOD\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = count_right_permutations(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j]):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n    \n    return count % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nimport math\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        dp[i] = 0\n        for j in range(i):\n            if not is_perfect_square(a[i-1] * a[j]):\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    return dp[n]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_right_permutations(n, a)\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j] + a[i] * a[j] + 1):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n    \n    return count % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j]):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n                count %= MOD\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j]):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n                count %= MOD\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    def is_right_permutation(p):\n        for i in range(n - 1):\n            if is_perfect_square(p[i] * p[i + 1]):\n                return False\n        return True\n\n    from itertools import permutations\n    count = 0\n    for perm in permutations(a):\n        if is_right_permutation(perm):\n            count += 1\n    return count % MOD\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Calculate and print the result\nresult = count_right_permutations(n, a)\nprint(result)",
            "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j]):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n    \n    return count % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j] + 1):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n                count %= MOD\n    \n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if not is_perfect_square(a[i] * a[j] + a[i] * a[j + 1]):\n                    count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n    return count % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    def is_right_permutation(p):\n        for i in range(n - 1):\n            if is_perfect_square(p[i] * p[i + 1]):\n                return False\n        return True\n\n    from itertools import permutations\n    count = 0\n    for p in permutations(a):\n        if is_right_permutation(p):\n            count += 1\n    return count % MOD\n\n# Read input\nn = int(sys.stdin.readline().strip())\na = list(map(int, sys.stdin.readline().strip().split()))\n\n# Solve the problem\nresult = count_right_permutations(n, a)\n\n# Write output\nprint(result)",
            "import sys\nimport math\n\nMOD = 10**9 + 7\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    if n == 1:\n        return 1\n    \n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j and not is_perfect_square(a[i] * a[j]):\n                count += count_right_permutations(n - 2, a[:i] + a[i+1:j] + a[j+1:])\n    \n    return count % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = count_right_permutations(n, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nimport math\n\ndef is_perfect_square(x):\n    s = int(math.isqrt(x))\n    return s * s == x\n\ndef count_right_permutations(n, a):\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        dp[i] = 0\n        for j in range(i):\n            if not is_perfect_square(a[i-1] * a[j]):\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    return dp[n]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = count_right_permutations(n, a)\nprint(result)"
        ]
    },
    {
        "question_title": "Shortest Path Problem?",
        "question_content": "You are given an undirected graph with weighted edges. The length of some path between two vertices is the bitwise xor of weights of all edges belonging to this path (if some edge is traversed more than once, then it is included in bitwise xor the same number of times). You have to find the minimum length of path between vertex 1 and vertex n.\n\nNote that graph can contain multiple edges and loops. It is guaranteed that the graph is connected.\n\n\nInput Format\nThe first line contains two numbers n and m (1 \u2264 n \u2264 100000, n - 1 \u2264 m \u2264 100000) \u2014 the number of vertices and the number of edges, respectively.\n\nThen m lines follow, each line containing three integer numbers x, y and w (1 \u2264 x, y \u2264 n, 0 \u2264 w \u2264 108). These numbers denote an edge that connects vertices x and y and has weight w.\n\n\nOutput Format\nPrint one number \u2014 the minimum length of path between vertices 1 and n.\n\n\nSample Input 1\n\n3 3\n1 2 3\n1 3 2\n3 2 0\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n2 2\n1 1 3\n1 2 3\n\nSample Output 2\n\n0",
        "platform": "codeforces",
        "question_id": "845/G",
        "contest_id": "845",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set([start])\n    while queue:\n        current, xor_value = queue.popleft()\n        if current == end:\n            return xor_value\n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, xor_value ^ weight))\n    return float('inf')\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_length = bfs(1, n)\n\n# Print the result\nprint(min_length)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set()\n    visited.add(start)\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return -1\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_path_length = bfs(1, n)\nprint(min_path_length)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nfor i in range(m):\n    x = int(data[3 + 3 * i]) - 1\n    y = int(data[4 + 3 * i]) - 1\n    w = int(data[5 + 3 * i])\n    edges.append((x, y, w))\n\n# Initialize graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# Initialize distance array with infinity\ndist = [float('inf')] * n\ndist[0] = 0\n\n# Initialize queue for BFS\nqueue = deque([0])\n\nwhile queue:\n    u = queue.popleft()\n    for v, w in graph[u]:\n        new_dist = dist[u] ^ w\n        if new_dist < dist[v]:\n            dist[v] = new_dist\n            queue.append(v)\n\n# Print the minimum distance to vertex n-1\nprint(dist[n-1])\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set()\n    visited.add(start)\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return -1  # In case there is no path, though the problem guarantees there is one\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_path_length = bfs(1, n)\n\n# Print the result\nprint(min_path_length)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set([start])\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return -1  # In case there is no path, though the problem guarantees there is one\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_path_length = bfs(1, n)\n\n# Print the result\nprint(min_path_length)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# Initialize the queue for BFS\nqueue = deque([(1, 0)])\nvisited = set([1])\nmin_path_length = float('inf')\n\n# Perform BFS\nwhile queue:\n    current, current_path_length = queue.popleft()\n    if current == n:\n        min_path_length = min(min_path_length, current_path_length)\n        continue\n    for neighbor, weight in graph[current]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            queue.append((neighbor, current_path_length ^ weight))\n\n# Print the result\nprint(min_path_length)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nfor i in range(m):\n    x = int(data[3 + 3 * i])\n    y = int(data[4 + 3 * i])\n    w = int(data[5 + 3 * i])\n    edges.append((x, y, w))\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# Initialize the queue for BFS\nqueue = deque([(1, 0)])\nvisited = set([1])\n\n# Perform BFS\nwhile queue:\n    current, xor_value = queue.popleft()\n    if current == n:\n        print(xor_value)\n        break\n    for neighbor, weight in graph[current]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            queue.append((neighbor, xor_value ^ weight))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set([start])\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return float('inf')\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_length = bfs(1, n)\n\n# Print the result\nprint(min_length)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set([start])\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return float('inf')\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_length = bfs(1, n)\n\n# Print the result\nprint(min_length)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set([start])\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return float('inf')\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_path_length = bfs(1, n)\n\n# Print the result\nprint(min_path_length)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set([start])\n    while queue:\n        current, xor_value = queue.popleft()\n        if current == end:\n            return xor_value\n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, xor_value ^ weight))\n    return float('inf')\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_length = bfs(1, n)\n\n# Print the result\nprint(min_length)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set()\n    visited.add(start)\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return -1\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_path_length = bfs(1, n)\nprint(min_path_length)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nfor i in range(m):\n    x = int(data[3 + 3 * i]) - 1\n    y = int(data[4 + 3 * i]) - 1\n    w = int(data[5 + 3 * i])\n    edges.append((x, y, w))\n\n# Initialize graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# Initialize distance array with infinity\ndist = [float('inf')] * n\ndist[0] = 0\n\n# Initialize queue for BFS\nqueue = deque([0])\n\nwhile queue:\n    u = queue.popleft()\n    for v, w in graph[u]:\n        new_dist = dist[u] ^ w\n        if new_dist < dist[v]:\n            dist[v] = new_dist\n            queue.append(v)\n\n# Print the minimum distance to vertex n-1\nprint(dist[n-1])",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set()\n    visited.add(start)\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return -1  # In case there is no path, though the problem guarantees there is one\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_path_length = bfs(1, n)\n\n# Print the result\nprint(min_path_length)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set([start])\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return -1  # In case there is no path, though the problem guarantees there is one\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_path_length = bfs(1, n)\n\n# Print the result\nprint(min_path_length)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# Initialize the queue for BFS\nqueue = deque([(1, 0)])\nvisited = set([1])\nmin_path_length = float('inf')\n\n# Perform BFS\nwhile queue:\n    current, current_path_length = queue.popleft()\n    if current == n:\n        min_path_length = min(min_path_length, current_path_length)\n        continue\n    for neighbor, weight in graph[current]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            queue.append((neighbor, current_path_length ^ weight))\n\n# Print the result\nprint(min_path_length)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nfor i in range(m):\n    x = int(data[3 + 3 * i])\n    y = int(data[4 + 3 * i])\n    w = int(data[5 + 3 * i])\n    edges.append((x, y, w))\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# Initialize the queue for BFS\nqueue = deque([(1, 0)])\nvisited = set([1])\n\n# Perform BFS\nwhile queue:\n    current, xor_value = queue.popleft()\n    if current == n:\n        print(xor_value)\n        break\n    for neighbor, weight in graph[current]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            queue.append((neighbor, xor_value ^ weight))",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set([start])\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return float('inf')\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_length = bfs(1, n)\n\n# Print the result\nprint(min_length)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set([start])\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return float('inf')\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_length = bfs(1, n)\n\n# Print the result\nprint(min_length)",
            "import sys\nfrom collections import defaultdict, deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    x = int(data[index])\n    y = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((x, y, w))\n    index += 3\n\n# Build the graph\ngraph = defaultdict(list)\nfor x, y, w in edges:\n    graph[x].append((y, w))\n    graph[y].append((x, w))\n\n# BFS to find the minimum path length using bitwise XOR\ndef bfs(start, end):\n    queue = deque([(start, 0)])\n    visited = set([start])\n    \n    while queue:\n        current, current_xor = queue.popleft()\n        \n        if current == end:\n            return current_xor\n        \n        for neighbor, weight in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, current_xor ^ weight))\n    \n    return float('inf')\n\n# Find the minimum path length from vertex 1 to vertex n\nmin_path_length = bfs(1, n)\n\n# Print the result\nprint(min_path_length)"
        ]
    },
    {
        "question_title": "Buy Low Sell High",
        "question_content": "You can perfectly predict the price of a certain stock for the next N days. You would like to profit on this knowledge, but only want to transact one share of stock per day. That is, each day you will either buy one share, sell one share, or do nothing. Initially you own zero shares, and you cannot sell shares when you don't own any. At the end of the N days you would like to again own zero shares, but want to have as much money as possible.\n\n\nInput Format\nInput begins with an integer N (2 \u2264 N \u2264 3\u00b7105), the number of days.\n\nFollowing this is a line with exactly N integers p1, p2, ..., pN (1 \u2264 pi \u2264 106). The price of one share of stock on the i-th day is given by pi.\n\n\nOutput Format\nPrint the maximum amount of money you can end up with at the end of N days.\n\n\nSample Input 1\n\n9\n10 5 4 7 9 12 6 2 10\n\nSample Output 1\n\n20\n\n\nSample Input 2\n\n20\n3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4\n\nSample Output 2\n\n41\n\n\nNote\nIn the first example, buy a share at 5, buy another at 4, sell one at 9 and another at 12. Then buy at 2 and sell at 10. The total profit is - 5 - 4 + 9 + 12 - 2 + 10 = 20.",
        "platform": "codeforces",
        "question_id": "865/D",
        "contest_id": "865",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have any\n        current_hold = -price\n    else:\n        # Sell a share if we have one\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of days\nN = int(data[0])\n\n# Parse the stock prices\nprices = list(map(int, data[1:]))\n\n# Initialize variables to keep track of the maximum profit\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    # If we are not holding any shares, buy one at the current price\n    if current_hold == 0:\n        current_hold = -price\n    else:\n        # If we are holding a share, sell it at the current price and add the profit to max_profit\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_holdings = 0\ncurrent_balance = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_holdings == 0:\n        # Buy a share if we don't have any\n        current_holdings += 1\n        current_balance -= price\n    else:\n        # Sell a share if we have one\n        current_holdings -= 1\n        current_balance += price\n        # Update max_profit if the current balance is higher\n        max_profit = max(max_profit, current_balance)\n\n# Print the maximum profit\nprint(max_profit)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\ncurrent_money = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have any\n        current_hold += 1\n        current_money -= price\n    else:\n        # Sell a share if we have one\n        current_hold -= 1\n        current_money += price\n\n# The final amount of money we have is the answer\nprint(current_money)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have one\n        current_hold = -price\n    else:\n        # Sell the share if we have one\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have any\n        current_hold = -price\n    else:\n        # Sell the share if we have one\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\ncurrent_money = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have one\n        current_hold += 1\n        current_money -= price\n    else:\n        # Sell the share if we have one\n        current_hold -= 1\n        current_money += price\n\n# The final money we have is the maximum profit\nprint(current_money)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\ncurrent_money = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have one\n        current_hold = 1\n        current_money -= price\n    else:\n        # Sell the share if we have one\n        current_hold = 0\n        current_money += price\n\n# The final money we have is the maximum profit\nprint(current_money)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't own any\n        current_hold = -price\n    else:\n        # Sell a share if we own one\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have one\n        current_hold = -price\n    else:\n        # Sell the share if we have one\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have any\n        current_hold = -price\n    else:\n        # Sell a share if we have one\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of days\nN = int(data[0])\n\n# Parse the stock prices\nprices = list(map(int, data[1:]))\n\n# Initialize variables to keep track of the maximum profit\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    # If we are not holding any shares, buy one at the current price\n    if current_hold == 0:\n        current_hold = -price\n    else:\n        # If we are holding a share, sell it at the current price and add the profit to max_profit\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_holdings = 0\ncurrent_balance = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_holdings == 0:\n        # Buy a share if we don't have any\n        current_holdings += 1\n        current_balance -= price\n    else:\n        # Sell a share if we have one\n        current_holdings -= 1\n        current_balance += price\n        # Update max_profit if the current balance is higher\n        max_profit = max(max_profit, current_balance)\n\n# Print the maximum profit\nprint(max_profit)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\ncurrent_money = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have any\n        current_hold += 1\n        current_money -= price\n    else:\n        # Sell a share if we have one\n        current_hold -= 1\n        current_money += price\n\n# The final amount of money we have is the answer\nprint(current_money)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have one\n        current_hold = -price\n    else:\n        # Sell the share if we have one\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have any\n        current_hold = -price\n    else:\n        # Sell the share if we have one\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\ncurrent_money = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have one\n        current_hold += 1\n        current_money -= price\n    else:\n        # Sell the share if we have one\n        current_hold -= 1\n        current_money += price\n\n# The final money we have is the maximum profit\nprint(current_money)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\ncurrent_money = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have one\n        current_hold = 1\n        current_money -= price\n    else:\n        # Sell the share if we have one\n        current_hold = 0\n        current_money += price\n\n# The final money we have is the maximum profit\nprint(current_money)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't own any\n        current_hold = -price\n    else:\n        # Sell a share if we own one\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nN = int(data[0])\nprices = list(map(int, data[1:]))\n\n# Initialize variables\nmax_profit = 0\ncurrent_hold = 0\n\n# Iterate through the prices\nfor price in prices:\n    if current_hold == 0:\n        # Buy a share if we don't have one\n        current_hold = -price\n    else:\n        # Sell the share if we have one\n        max_profit += price + current_hold\n        current_hold = 0\n\n# Print the maximum profit\nprint(max_profit)"
        ]
    },
    {
        "question_title": "Yet Another Minimization Problem",
        "question_content": "You are given an array of n integers a1... an. The cost of a subsegment is the number of unordered pairs of distinct indices within the subsegment that contain equal elements. Split the given array into k non-intersecting non-empty subsegments so that the sum of their costs is minimum possible. Each element should be present in exactly one subsegment.\n\n\nInput Format\nThe first line contains two integers n and k (2 \u2264 n \u2264 105, 2 \u2264 k \u2264 min (n, 20)) \u00a0\u2014 the length of the array and the number of segments you need to split the array into.\n\nThe next line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 n)\u00a0\u2014 the elements of the array.\n\n\nOutput Format\nPrint single integer: the minimum possible total cost of resulting subsegments.\n\n\nSample Input 1\n\n7 3\n1 1 3 3 3 2 1\n\nSample Output 1\n\n1\n\n\nSample Input 2\n\n10 2\n1 2 1 2 1 2 1 2 1 2\n\nSample Output 2\n\n8\n\n\nSample Input 3\n\n13 3\n1 2 2 2 1 2 1 1 1 2 2 1 1\n\nSample Output 3\n\n9\n\n\nNote\nIn the first example it's optimal to split the sequence into the following three subsegments: [1], [1, 3], [3, 3, 2, 1]. The costs are 0, 0 and 1, thus the answer is 1.\n\nIn the second example it's optimal to split the sequence in two equal halves. The cost for each half is 4.\n\nIn the third example it's optimal to split the sequence in the following way: [1, 2, 2, 2, 1], [2, 1, 1, 1, 2], [2, 1, 1]. The costs are 4, 4, 1.",
        "platform": "codeforces",
        "question_id": "868/F",
        "contest_id": "868",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Calculate the cost of the entire array\n    total_cost = 0\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n            total_cost += count[num] - 1\n        else:\n            count[num] = 1\n    \n    # If k is 1, the entire array is one segment\n    if k == 1:\n        return total_cost\n    \n    # Calculate the cost if we split the array into k segments\n    segment_cost = total_cost\n    for i in range(k - 1):\n        segment_cost += n - 1\n    \n    return segment_cost\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = min_cost_subsegments(n, k, a)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the cost of splitting at a given position\ndef cost_at_position(pos):\n    count = defaultdict(int)\n    cost = 0\n    for i in range(pos):\n        count[a[i]] += 1\n        if count[a[i]] > 1:\n            cost += count[a[i]] - 1\n    return cost\n\n# Binary search for the minimum cost\nleft, right = 0, n\nwhile left < right:\n    mid = (left + right) // 2\n    if mid < k:\n        left = mid + 1\n    else:\n        right = mid\n\n# Calculate the minimum cost for the optimal split\nmin_cost = float('inf')\nfor i in range(k - 1, n, k):\n    min_cost = min(min_cost, cost_at_position(i))\n\n# Output the result\nprint(min_cost)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Initialize the cost array\n    cost = [0] * (n + 1)\n    \n    # Calculate the cost for each subsegment\n    for i in range(1, n + 1):\n        cost[i] = cost[i - 1] + a[i - 1] * (i - 1) - (i - a[i - 1])\n    \n    # Initialize the dp array\n    dp = [float('inf')] * (k + 1)\n    dp[0] = 0\n    \n    # Fill the dp array\n    for i in range(1, k + 1):\n        for j in range(i, n + 1):\n            dp[i] = min(dp[i], dp[i - 1] + cost[j] - cost[i - 1])\n    \n    return dp[k]\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the minimum cost\nresult = min_cost_subsegments(n, k, a)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Calculate the cost of splitting the array into k segments\n    def cost_of_segments(segments: List[List[int]]) -> int:\n        total_cost = 0\n        for segment in segments:\n            count = {}\n            for num in segment:\n                if num in count:\n                    count[num] += 1\n                else:\n                    count[num] = 1\n            total_cost += sum(v * (v - 1) // 2 for v in count.values())\n        return total_cost\n\n    # Try to split the array into k segments and find the minimum cost\n    def try_split(start: int, k: int) -> int:\n        if k == 1:\n            return cost_of_segments([[a[start:]]])\n        min_cost = float('inf')\n        for end in range(start + 1, n - k + 2):\n            min_cost = min(min_cost, cost_of_segments([[a[start:end]]]) + try_split(end, k - 1))\n        return min_cost\n\n    return try_split(0, k)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the minimum cost\nresult = min_cost_subsegments(n, k, a)\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Calculate the cost of a subsegment\n    def cost(subsegment: List[int]) -> int:\n        count = {}\n        for num in subsegment:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        total_cost = 0\n        for freq in count.values():\n            total_cost += freq * (freq - 1) // 2\n        return total_cost\n    \n    # Initialize the DP table\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for l in range(i):\n                dp[i][j] = min(dp[i][j], dp[l][j - 1] + cost(a[l:i]))\n    \n    return dp[n][k]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = min_cost_subsegments(n, k, a)\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the cost of splitting at each position\ncost = [0] * (n + 1)\ncount = defaultdict(int)\nfor i in range(n):\n    count[a[i]] += 1\n    cost[i + 1] = cost[i] + count[a[i]] * (count[a[i]] - 1) // 2\n\n# Dynamic programming to find the minimum cost to split into k segments\ndp = [float('inf')] * (k + 1)\ndp[0] = 0\nfor i in range(1, k + 1):\n    for j in range(i, n + 1):\n        dp[i] = min(dp[i], dp[i - 1] + cost[j] - cost[i - 1])\n\n# Output the result\nprint(dp[k])\n```",
            "```python\nimport sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the cost of splitting the array into k segments\ndef calculate_cost(segments):\n    total_cost = 0\n    for segment in segments:\n        count = defaultdict(int)\n        for num in segment:\n            count[num] += 1\n        for freq in count.values():\n            total_cost += freq * (freq - 1) // 2\n    return total_cost\n\n# Initialize variables\nbest_cost = float('inf')\nbest_segments = []\n\n# Try all possible ways to split the array into k segments\ndef split_array(start, end, segments):\n    if len(segments) == k:\n        cost = calculate_cost(segments)\n        if cost < best_cost:\n            best_cost = cost\n            best_segments = segments.copy()\n        return\n    if start == end:\n        return\n    for i in range(start, end):\n        segments.append(a[start:i+1])\n        split_array(i+1, end, segments)\n        segments.pop()\n\n# Start the recursive splitting\nsplit_array(0, n, [])\n\n# Print the minimum cost\nprint(best_cost)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Calculate the cost of splitting the array into k segments\n    def cost_of_segments(segments: List[List[int]]) -> int:\n        total_cost = 0\n        for segment in segments:\n            count = {}\n            for num in segment:\n                if num in count:\n                    count[num] += 1\n                else:\n                    count[num] = 1\n            for freq in count.values():\n                if freq > 1:\n                    total_cost += freq * (freq - 1) // 2\n        return total_cost\n\n    # Function to find the minimum cost of splitting the array into k segments\n    def min_cost(k: int) -> int:\n        if k == 1:\n            return cost_of_segments([[a]])\n        if k == n:\n            return cost_of_segments([[a[i]] for i in range(n)])\n        \n        min_cost = float('inf')\n        for i in range(1, n):\n            left_segment = a[:i]\n            right_segment = a[i:]\n            left_cost = cost_of_segments([[left_segment]])\n            right_cost = min_cost(k - 1)\n            min_cost = min(min_cost, left_cost + right_cost)\n        \n        return min_cost\n\n    return min_cost(k)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the minimum cost\nresult = min_cost_subsegments(n, k, a)\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Calculate the cost of a subsegment\n    def cost(subsegment: List[int]) -> int:\n        count = {}\n        for num in subsegment:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        return sum(v * (v - 1) // 2 for v in count.values())\n    \n    # Initialize the DP table\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for l in range(i):\n                dp[i][j] = min(dp[i][j], dp[l][j - 1] + cost(a[l:i]))\n    \n    return dp[n][k]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = min_cost_subsegments(n, k, a)\nprint(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Initialize the cost array\n    cost = [0] * (n + 1)\n    \n    # Calculate the cost for each subsegment ending at each index\n    for i in range(1, n + 1):\n        cost[i] = cost[i - 1]\n        count = [0] * (n + 1)\n        for j in range(i, 0, -1):\n            count[a[j - 1]] += 1\n            if count[a[j - 1]] > 1:\n                cost[i] += count[a[j - 1]] - 1\n    \n    # Initialize the dp array\n    dp = [float('inf')] * (k + 1)\n    dp[0] = 0\n    \n    # Fill the dp array\n    for i in range(1, k + 1):\n        for j in range(n, 0, -1):\n            dp[i] = min(dp[i], dp[i - 1] + cost[j])\n    \n    return dp[k]\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the minimum cost\nresult = min_cost_subsegments(n, k, a)\n\n# Write the result to stdout\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Calculate the cost of the entire array\n    total_cost = 0\n    count = {}\n    for num in a:\n        if num in count:\n            count[num] += 1\n            total_cost += count[num] - 1\n        else:\n            count[num] = 1\n    \n    # If k is 1, the entire array is one segment\n    if k == 1:\n        return total_cost\n    \n    # Calculate the cost if we split the array into k segments\n    segment_cost = total_cost\n    for i in range(k - 1):\n        segment_cost += n - 1\n    \n    return segment_cost\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = min_cost_subsegments(n, k, a)\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the cost of splitting at a given position\ndef cost_at_position(pos):\n    count = defaultdict(int)\n    cost = 0\n    for i in range(pos):\n        count[a[i]] += 1\n        if count[a[i]] > 1:\n            cost += count[a[i]] - 1\n    return cost\n\n# Binary search for the minimum cost\nleft, right = 0, n\nwhile left < right:\n    mid = (left + right) // 2\n    if mid < k:\n        left = mid + 1\n    else:\n        right = mid\n\n# Calculate the minimum cost for the optimal split\nmin_cost = float('inf')\nfor i in range(k - 1, n, k):\n    min_cost = min(min_cost, cost_at_position(i))\n\n# Output the result\nprint(min_cost)",
            "import sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Initialize the cost array\n    cost = [0] * (n + 1)\n    \n    # Calculate the cost for each subsegment\n    for i in range(1, n + 1):\n        cost[i] = cost[i - 1] + a[i - 1] * (i - 1) - (i - a[i - 1])\n    \n    # Initialize the dp array\n    dp = [float('inf')] * (k + 1)\n    dp[0] = 0\n    \n    # Fill the dp array\n    for i in range(1, k + 1):\n        for j in range(i, n + 1):\n            dp[i] = min(dp[i], dp[i - 1] + cost[j] - cost[i - 1])\n    \n    return dp[k]\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the minimum cost\nresult = min_cost_subsegments(n, k, a)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Calculate the cost of splitting the array into k segments\n    def cost_of_segments(segments: List[List[int]]) -> int:\n        total_cost = 0\n        for segment in segments:\n            count = {}\n            for num in segment:\n                if num in count:\n                    count[num] += 1\n                else:\n                    count[num] = 1\n            total_cost += sum(v * (v - 1) // 2 for v in count.values())\n        return total_cost\n\n    # Try to split the array into k segments and find the minimum cost\n    def try_split(start: int, k: int) -> int:\n        if k == 1:\n            return cost_of_segments([[a[start:]]])\n        min_cost = float('inf')\n        for end in range(start + 1, n - k + 2):\n            min_cost = min(min_cost, cost_of_segments([[a[start:end]]]) + try_split(end, k - 1))\n        return min_cost\n\n    return try_split(0, k)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the minimum cost\nresult = min_cost_subsegments(n, k, a)\nprint(result)",
            "import sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Calculate the cost of a subsegment\n    def cost(subsegment: List[int]) -> int:\n        count = {}\n        for num in subsegment:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        total_cost = 0\n        for freq in count.values():\n            total_cost += freq * (freq - 1) // 2\n        return total_cost\n    \n    # Initialize the DP table\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for l in range(i):\n                dp[i][j] = min(dp[i][j], dp[l][j - 1] + cost(a[l:i]))\n    \n    return dp[n][k]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = min_cost_subsegments(n, k, a)\nprint(result)",
            "import sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the cost of splitting at each position\ncost = [0] * (n + 1)\ncount = defaultdict(int)\nfor i in range(n):\n    count[a[i]] += 1\n    cost[i + 1] = cost[i] + count[a[i]] * (count[a[i]] - 1) // 2\n\n# Dynamic programming to find the minimum cost to split into k segments\ndp = [float('inf')] * (k + 1)\ndp[0] = 0\nfor i in range(1, k + 1):\n    for j in range(i, n + 1):\n        dp[i] = min(dp[i], dp[i - 1] + cost[j] - cost[i - 1])\n\n# Output the result\nprint(dp[k])",
            "import sys\nfrom collections import defaultdict\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the cost of splitting the array into k segments\ndef calculate_cost(segments):\n    total_cost = 0\n    for segment in segments:\n        count = defaultdict(int)\n        for num in segment:\n            count[num] += 1\n        for freq in count.values():\n            total_cost += freq * (freq - 1) // 2\n    return total_cost\n\n# Initialize variables\nbest_cost = float('inf')\nbest_segments = []\n\n# Try all possible ways to split the array into k segments\ndef split_array(start, end, segments):\n    if len(segments) == k:\n        cost = calculate_cost(segments)\n        if cost < best_cost:\n            best_cost = cost\n            best_segments = segments.copy()\n        return\n    if start == end:\n        return\n    for i in range(start, end):\n        segments.append(a[start:i+1])\n        split_array(i+1, end, segments)\n        segments.pop()\n\n# Start the recursive splitting\nsplit_array(0, n, [])\n\n# Print the minimum cost\nprint(best_cost)",
            "import sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Calculate the cost of splitting the array into k segments\n    def cost_of_segments(segments: List[List[int]]) -> int:\n        total_cost = 0\n        for segment in segments:\n            count = {}\n            for num in segment:\n                if num in count:\n                    count[num] += 1\n                else:\n                    count[num] = 1\n            for freq in count.values():\n                if freq > 1:\n                    total_cost += freq * (freq - 1) // 2\n        return total_cost\n\n    # Function to find the minimum cost of splitting the array into k segments\n    def min_cost(k: int) -> int:\n        if k == 1:\n            return cost_of_segments([[a]])\n        if k == n:\n            return cost_of_segments([[a[i]] for i in range(n)])\n        \n        min_cost = float('inf')\n        for i in range(1, n):\n            left_segment = a[:i]\n            right_segment = a[i:]\n            left_cost = cost_of_segments([[left_segment]])\n            right_cost = min_cost(k - 1)\n            min_cost = min(min_cost, left_cost + right_cost)\n        \n        return min_cost\n\n    return min_cost(k)\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the minimum cost\nresult = min_cost_subsegments(n, k, a)\nprint(result)",
            "import sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Calculate the cost of a subsegment\n    def cost(subsegment: List[int]) -> int:\n        count = {}\n        for num in subsegment:\n            if num in count:\n                count[num] += 1\n            else:\n                count[num] = 1\n        return sum(v * (v - 1) // 2 for v in count.values())\n    \n    # Initialize the DP table\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for l in range(i):\n                dp[i][j] = min(dp[i][j], dp[l][j - 1] + cost(a[l:i]))\n    \n    return dp[n][k]\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate and print the result\nresult = min_cost_subsegments(n, k, a)\nprint(result)",
            "import sys\nfrom typing import List\n\ndef min_cost_subsegments(n: int, k: int, a: List[int]) -> int:\n    # Initialize the cost array\n    cost = [0] * (n + 1)\n    \n    # Calculate the cost for each subsegment ending at each index\n    for i in range(1, n + 1):\n        cost[i] = cost[i - 1]\n        count = [0] * (n + 1)\n        for j in range(i, 0, -1):\n            count[a[j - 1]] += 1\n            if count[a[j - 1]] > 1:\n                cost[i] += count[a[j - 1]] - 1\n    \n    # Initialize the dp array\n    dp = [float('inf')] * (k + 1)\n    dp[0] = 0\n    \n    # Fill the dp array\n    for i in range(1, k + 1):\n        for j in range(n, 0, -1):\n            dp[i] = min(dp[i], dp[i - 1] + cost[j])\n    \n    return dp[k]\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\n# Calculate the minimum cost\nresult = min_cost_subsegments(n, k, a)\n\n# Write the result to stdout\nprint(result)"
        ]
    },
    {
        "question_title": "Points, Lines and Ready-made Titles",
        "question_content": "You are given n distinct points on a plane with integral coordinates. For each point you can either draw a vertical line through it, draw a horizontal line through it, or do nothing.\n\nYou consider several coinciding straight lines as a single one. How many distinct pictures you can get? Print the answer modulo 109 + 7.\n\n\nInput Format\nThe first line contains single integer n (1 \u2264 n \u2264 105)\u00a0\u2014 the number of points.\n\nn lines follow. The (i + 1)-th of these lines contains two integers xi, yi ( - 109 \u2264 xi, yi \u2264 109)\u00a0\u2014 coordinates of the i-th point.\n\nIt is guaranteed that all points are distinct.\n\n\nOutput Format\nPrint the number of possible distinct pictures modulo 109 + 7.\n\n\nSample Input 1\n\n4\n1 1\n1 2\n2 1\n2 2\n\nSample Output 1\n\n16\n\n\nSample Input 2\n\n2\n-1 -1\n0 1\n\nSample Output 2\n\n9\n\n\nNote\nIn the first example there are two vertical and two horizontal lines passing through the points. You can get pictures with any subset of these lines. For example, you can get the picture containing all four lines in two ways (each segment represents a line containing it).\n\nThe first way: The second way:\n\nIn the second example you can work with two points independently. The number of pictures is 32 = 9.",
        "platform": "codeforces",
        "question_id": "870/E",
        "contest_id": "870",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    x_counts = Counter(point[0] for point in points)\n    y_counts = Counter(point[1] for point in points)\n    \n    total_pictures = 1\n    for count in x_counts.values():\n        total_pictures = (total_pictures * (count + 1)) % MOD\n    for count in y_counts.values():\n        total_pictures = (total_pictures * (count + 1)) % MOD\n    \n    return total_pictures\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_distinct_pictures(n, points)\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    vertical_lines = defaultdict(int)\n    horizontal_lines = defaultdict(int)\n    \n    for x, y in points:\n        vertical_lines[x] += 1\n        horizontal_lines[y] += 1\n    \n    num_vertical = sum(vertical_lines.values())\n    num_horizontal = sum(horizontal_lines.values())\n    \n    distinct_pictures = (1 << num_vertical) * (1 << num_horizontal) % MOD\n    \n    return distinct_pictures\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_distinct_pictures(n, points)\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Count distinct x and y coordinates\nx_count = defaultdict(int)\ny_count = defaultdict(int)\n\nfor x, y in points:\n    x_count[x] += 1\n    y_count[y] += 1\n\n# Calculate the number of distinct pictures\nresult = 1\nmod = 10**9 + 7\n\nfor count in x_count.values():\n    result = (result * (count + 1)) % mod\n\nfor count in y_count.values():\n    result = (result * (count + 1)) % mod\n\n# Print the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    vertical_lines = defaultdict(int)\n    horizontal_lines = defaultdict(int)\n    \n    for x, y in points:\n        vertical_lines[x] += 1\n        horizontal_lines[y] += 1\n    \n    num_vertical = sum(vertical_lines.values())\n    num_horizontal = sum(horizontal_lines.values())\n    \n    # Total number of distinct pictures\n    total_pictures = (1 << num_vertical) * (1 << num_horizontal)\n    \n    return total_pictures % MOD\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_distinct_pictures(n, points)\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Count distinct x and y coordinates\nx_counts = Counter(point[0] for point in points)\ny_counts = Counter(point[1] for point in points)\n\n# Calculate the number of distinct pictures\nresult = 1\nfor count in x_counts.values():\n    result = (result * (2**count)) % (10**9 + 7)\nfor count in y_counts.values():\n    result = (result * (2**count)) % (10**9 + 7)\n\n# Print the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    x_counts = Counter(point[0] for point in points)\n    y_counts = Counter(point[1] for point in points)\n    \n    total_pictures = 1\n    for count in x_counts.values():\n        total_pictures = (total_pictures * (count + 1)) % MOD\n    for count in y_counts.values():\n        total_pictures = (total_pictures * (count + 1)) % MOD\n    \n    return total_pictures\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    points = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n    \n    result = count_distinct_pictures(n, points)\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    vertical_lines = defaultdict(int)\n    horizontal_lines = defaultdict(int)\n    \n    for x, y in points:\n        vertical_lines[x] += 1\n        horizontal_lines[y] += 1\n    \n    num_vertical_lines = len(vertical_lines)\n    num_horizontal_lines = len(horizontal_lines)\n    \n    total_pictures = (1 << num_vertical_lines) * (1 << num_horizontal_lines)\n    \n    return total_pictures % MOD\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_distinct_pictures(n, points)\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    vertical_lines = defaultdict(int)\n    horizontal_lines = defaultdict(int)\n    \n    for x, y in points:\n        vertical_lines[x] += 1\n        horizontal_lines[y] += 1\n    \n    num_vertical = sum(vertical_lines.values())\n    num_horizontal = sum(horizontal_lines.values())\n    \n    # Total number of distinct pictures is 2^(num_vertical + num_horizontal)\n    result = pow(2, num_vertical + num_horizontal, MOD)\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_distinct_pictures(n, points)\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    vertical_lines = defaultdict(int)\n    horizontal_lines = defaultdict(int)\n    \n    for x, y in points:\n        vertical_lines[x] += 1\n        horizontal_lines[y] += 1\n    \n    total_pictures = 1\n    for count in vertical_lines.values():\n        total_pictures = (total_pictures * (1 << count)) % MOD\n    \n    for count in horizontal_lines.values():\n        total_pictures = (total_pictures * (1 << count)) % MOD\n    \n    return total_pictures\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline().strip())\n    points = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n    \n    result = count_distinct_pictures(n, points)\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Count distinct x and y coordinates\nx_count = defaultdict(int)\ny_count = defaultdict(int)\n\nfor x, y in points:\n    x_count[x] += 1\n    y_count[y] += 1\n\n# Calculate the number of distinct pictures\nresult = 1\nMOD = 10**9 + 7\n\nfor count in x_count.values():\n    result = (result * (count + 1)) % MOD\n\nfor count in y_count.values():\n    result = (result * (count + 1)) % MOD\n\n# Print the result\nprint(result)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    x_counts = Counter(point[0] for point in points)\n    y_counts = Counter(point[1] for point in points)\n    \n    total_pictures = 1\n    for count in x_counts.values():\n        total_pictures = (total_pictures * (count + 1)) % MOD\n    for count in y_counts.values():\n        total_pictures = (total_pictures * (count + 1)) % MOD\n    \n    return total_pictures\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_distinct_pictures(n, points)\nprint(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    vertical_lines = defaultdict(int)\n    horizontal_lines = defaultdict(int)\n    \n    for x, y in points:\n        vertical_lines[x] += 1\n        horizontal_lines[y] += 1\n    \n    num_vertical = sum(vertical_lines.values())\n    num_horizontal = sum(horizontal_lines.values())\n    \n    distinct_pictures = (1 << num_vertical) * (1 << num_horizontal) % MOD\n    \n    return distinct_pictures\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_distinct_pictures(n, points)\nprint(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Count distinct x and y coordinates\nx_count = defaultdict(int)\ny_count = defaultdict(int)\n\nfor x, y in points:\n    x_count[x] += 1\n    y_count[y] += 1\n\n# Calculate the number of distinct pictures\nresult = 1\nmod = 10**9 + 7\n\nfor count in x_count.values():\n    result = (result * (count + 1)) % mod\n\nfor count in y_count.values():\n    result = (result * (count + 1)) % mod\n\n# Print the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    vertical_lines = defaultdict(int)\n    horizontal_lines = defaultdict(int)\n    \n    for x, y in points:\n        vertical_lines[x] += 1\n        horizontal_lines[y] += 1\n    \n    num_vertical = sum(vertical_lines.values())\n    num_horizontal = sum(horizontal_lines.values())\n    \n    # Total number of distinct pictures\n    total_pictures = (1 << num_vertical) * (1 << num_horizontal)\n    \n    return total_pictures % MOD\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_distinct_pictures(n, points)\nprint(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Count distinct x and y coordinates\nx_counts = Counter(point[0] for point in points)\ny_counts = Counter(point[1] for point in points)\n\n# Calculate the number of distinct pictures\nresult = 1\nfor count in x_counts.values():\n    result = (result * (2**count)) % (10**9 + 7)\nfor count in y_counts.values():\n    result = (result * (2**count)) % (10**9 + 7)\n\n# Print the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    x_counts = Counter(point[0] for point in points)\n    y_counts = Counter(point[1] for point in points)\n    \n    total_pictures = 1\n    for count in x_counts.values():\n        total_pictures = (total_pictures * (count + 1)) % MOD\n    for count in y_counts.values():\n        total_pictures = (total_pictures * (count + 1)) % MOD\n    \n    return total_pictures\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    points = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n    \n    result = count_distinct_pictures(n, points)\n    print(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    vertical_lines = defaultdict(int)\n    horizontal_lines = defaultdict(int)\n    \n    for x, y in points:\n        vertical_lines[x] += 1\n        horizontal_lines[y] += 1\n    \n    num_vertical_lines = len(vertical_lines)\n    num_horizontal_lines = len(horizontal_lines)\n    \n    total_pictures = (1 << num_vertical_lines) * (1 << num_horizontal_lines)\n    \n    return total_pictures % MOD\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_distinct_pictures(n, points)\nprint(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    vertical_lines = defaultdict(int)\n    horizontal_lines = defaultdict(int)\n    \n    for x, y in points:\n        vertical_lines[x] += 1\n        horizontal_lines[y] += 1\n    \n    num_vertical = sum(vertical_lines.values())\n    num_horizontal = sum(horizontal_lines.values())\n    \n    # Total number of distinct pictures is 2^(num_vertical + num_horizontal)\n    result = pow(2, num_vertical + num_horizontal, MOD)\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = count_distinct_pictures(n, points)\nprint(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef count_distinct_pictures(n, points):\n    vertical_lines = defaultdict(int)\n    horizontal_lines = defaultdict(int)\n    \n    for x, y in points:\n        vertical_lines[x] += 1\n        horizontal_lines[y] += 1\n    \n    total_pictures = 1\n    for count in vertical_lines.values():\n        total_pictures = (total_pictures * (1 << count)) % MOD\n    \n    for count in horizontal_lines.values():\n        total_pictures = (total_pictures * (1 << count)) % MOD\n    \n    return total_pictures\n\nif __name__ == \"__main__\":\n    n = int(sys.stdin.readline().strip())\n    points = [tuple(map(int, sys.stdin.readline().strip().split())) for _ in range(n)]\n    \n    result = count_distinct_pictures(n, points)\n    print(result)",
            "# YOUR CODE HERE\nimport sys\nfrom collections import defaultdict\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of points\nn = int(data[0])\n\n# Points coordinates\npoints = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Count distinct x and y coordinates\nx_count = defaultdict(int)\ny_count = defaultdict(int)\n\nfor x, y in points:\n    x_count[x] += 1\n    y_count[y] += 1\n\n# Calculate the number of distinct pictures\nresult = 1\nMOD = 10**9 + 7\n\nfor count in x_count.values():\n    result = (result * (count + 1)) % MOD\n\nfor count in y_count.values():\n    result = (result * (count + 1)) % MOD\n\n# Print the result\nprint(result)"
        ]
    },
    {
        "question_title": "Binary Matrix",
        "question_content": "You are given a matrix of size n x m. Each element of the matrix is either 1 or 0. You have to determine the number of connected components consisting of 1's. Two cells belong to the same component if they have a common border, and both elements in these cells are 1's.\n\nNote that the memory limit is unusual!\n\n\nInput Format\nThe first line contains two numbers n and m (1 \u2264 n \u2264 212, 4 \u2264 m \u2264 214) \u2014 the number of rows and columns, respectively. It is guaranteed that m is divisible by 4.\n\nThen the representation of matrix follows. Each of n next lines contains \\frac{m}{4} one-digit hexadecimal numbers (that is, these numbers can be represented either as digits from 0 to 9 or as uppercase Latin letters from A to F). Binary representation of each of these numbers denotes next 4 elements of the matrix in the corresponding row. For example, if the number B is given, then the corresponding elements are 1011, and if the number is 5, then the corresponding elements are 0101.\n\nElements are not separated by whitespaces.\n\n\nOutput Format\nPrint the number of connected components consisting of 1's.\n\n\nSample Input 1\n\n3 4\n1\nA\n8\n\nSample Output 1\n\n3\n\n\nSample Input 2\n\n2 8\n5F\nE3\n\nSample Output 2\n\n2\n\n\nSample Input 3\n\n1 4\n0\n\nSample Output 3\n\n0\n\n\nNote\nIn the first example the matrix is:\n\nIt is clear that it has three components.\n\nThe second example:\n\nIt is clear that the number of components is 2.\n\nThere are no 1's in the third example, so the answer is 0.",
        "platform": "codeforces",
        "question_id": "884/E",
        "contest_id": "884",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n    \n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n    \n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n    \n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n    \n    return component_count\n\n# Read input\nn, m = map(int, sys.stdin.readline().split())\nmatrix = [int(x, 16) for x in sys.stdin.read().split()]\n\n# Convert matrix to 2D list of 1s and 0s\nmatrix_2d = []\nfor i in range(n):\n    row = []\n    for j in range(m // 4):\n        num = matrix[i * (m // 4) + j]\n        for k in range(3, -1, -1):\n            row.append((num >> k) & 1)\n    matrix_2d.append(row)\n\n# Count components\nresult = count_components(n, m, matrix_2d)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = []\n\nfor i in range(n):\n    row = data[2 + i]\n    for j in range(0, m, 4):\n        hex_val = int(row[j:j+4], 16)\n        for k in range(3, -1, -1):\n            matrix.append((i, j + k, (hex_val >> k) & 1))\n\n# Directions for moving up, down, left, right\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n# Function to perform BFS and count connected components\ndef bfs(start):\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        x, y, val = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and matrix[nx * m + ny] == (nx, ny, 1) and (nx, ny, 1) not in visited:\n                visited.add((nx, ny, 1))\n                queue.append((nx, ny, 1))\n\n# Main logic\nvisited = set()\ncomponent_count = 0\n\nfor i in range(n * m):\n    if matrix[i] == (i // m, i % m, 1) and matrix[i] not in visited:\n        bfs(matrix[i])\n        component_count += 1\n\n# Output the result\nprint(component_count)\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n\n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n\n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n\n    return component_count\n\n# Read input\nn, m = map(int, sys.stdin.readline().split())\nmatrix = []\nfor _ in range(n):\n    row = sys.stdin.readline().strip()\n    for char in row:\n        matrix.append(int(char, 16))\n\n# Solve the problem\nresult = count_components(n, m, matrix)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n\n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n\n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n\n    return component_count\n\n# Read input\nn, m = map(int, sys.stdin.readline().split())\nmatrix = []\nfor _ in range(n):\n    row = sys.stdin.readline().strip()\n    for char in row:\n        binary = bin(int(char, 16))[2:].zfill(4)\n        matrix.append([int(bit) for bit in binary])\n\n# Solve the problem\nresult = count_components(n, m, matrix)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n\n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n\n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n\n    return component_count\n\n# Read input\nn, m = map(int, input().split())\nmatrix = []\nfor _ in range(n):\n    row = input().strip()\n    matrix.append([int(row[i:i+1], 16) & (1 << (3 - j)) & 1 for j in range(m // 4)])\n\n# Output the result\nprint(count_components(n, m, matrix))\n```",
            "```python\nimport sys\nfrom collections import deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\n# Convert hexadecimal to binary and create the matrix\nmatrix = []\nfor i in range(n):\n    hex_val = data[2 + i]\n    binary_str = bin(int(hex_val, 16))[2:].zfill(m)\n    matrix.append([int(bit) for bit in binary_str])\n\n# Directions for moving up, down, left, and right\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n# Function to perform BFS and count connected components\ndef bfs(x, y):\n    queue = deque([(x, y)])\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 1:\n                matrix[nx][ny] = 0  # Mark as visited\n                queue.append((nx, ny))\n\n# Count the number of connected components\ncomponent_count = 0\nfor i in range(n):\n    for j in range(m):\n        if matrix[i][j] == 1:\n            bfs(i, j)\n            component_count += 1\n\n# Output the result\nprint(component_count)\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n\n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n\n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n\n    return component_count\n\n# Read input\nn, m = map(int, input().split())\nmatrix = []\nfor _ in range(n):\n    row = input().strip()\n    binary_row = ''.join(format(int(char, 16), '04b') for char in row)\n    matrix.append([int(bit) for bit in binary_row])\n\n# Output the result\nprint(count_components(n, m, matrix))\n```",
            "```python\nimport sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n\n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n\n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n\n    return component_count\n\n# Read input\nn, m = map(int, input().split())\nmatrix = []\nfor _ in range(n):\n    row = input().strip()\n    binary_row = ''.join(format(int(char, 16), '04b') for char in row)\n    matrix.append([int(bit) for bit in binary_row])\n\n# Output the result\nprint(count_components(n, m, matrix))\n```",
            "```python\nimport sys\nfrom collections import deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = []\n\nindex = 2\nfor i in range(n):\n    row = []\n    for j in range(m // 4):\n        hex_val = data[index]\n        index += 1\n        for k in range(3, -1, -1):\n            bit = (int(hex_val, 16) >> k) & 1\n            row.append(bit)\n    matrix.append(row)\n\n# Function to perform BFS and count connected components\ndef bfs(x, y):\n    queue = deque([(x, y)])\n    visited.add((x, y))\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 1 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n\n# Initialize visited set\nvisited = set()\n\n# Count connected components\ncomponent_count = 0\nfor i in range(n):\n    for j in range(m):\n        if matrix[i][j] == 1 and (i, j) not in visited:\n            bfs(i, j)\n            component_count += 1\n\n# Output the result\nprint(component_count)\n```",
            "```python\nimport sys\nfrom collections import deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\nmatrix = [int(data[i+2], 16) for i in range(n)]\n\n# Convert the matrix to a 2D list of 1s and 0s\nmatrix_2d = []\nfor row in matrix:\n    row_2d = []\n    for i in range(m // 4):\n        binary = format(row >> (i * 4), '04b')\n        row_2d.extend([int(bit) for bit in binary])\n    matrix_2d.append(row_2d)\n\n# Function to perform BFS and count connected components\ndef bfs(x, y):\n    queue = deque([(x, y)])\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < n and 0 <= ny < m and matrix_2d[nx][ny] == 1:\n                matrix_2d[nx][ny] = 0\n                queue.append((nx, ny))\n\n# Count the number of connected components\ncomponent_count = 0\nfor i in range(n):\n    for j in range(m):\n        if matrix_2d[i][j] == 1:\n            bfs(i, j)\n            component_count += 1\n\n# Print the result\nprint(component_count)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n    \n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n    \n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n    \n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n    \n    return component_count\n\n# Read input\nn, m = map(int, sys.stdin.readline().split())\nmatrix = [int(x, 16) for x in sys.stdin.read().split()]\n\n# Convert matrix to 2D list of 1s and 0s\nmatrix_2d = []\nfor i in range(n):\n    row = []\n    for j in range(m // 4):\n        num = matrix[i * (m // 4) + j]\n        for k in range(3, -1, -1):\n            row.append((num >> k) & 1)\n    matrix_2d.append(row)\n\n# Count components\nresult = count_components(n, m, matrix_2d)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = []\n\nfor i in range(n):\n    row = data[2 + i]\n    for j in range(0, m, 4):\n        hex_val = int(row[j:j+4], 16)\n        for k in range(3, -1, -1):\n            matrix.append((i, j + k, (hex_val >> k) & 1))\n\n# Directions for moving up, down, left, right\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n# Function to perform BFS and count connected components\ndef bfs(start):\n    queue = deque([start])\n    visited.add(start)\n    while queue:\n        x, y, val = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and matrix[nx * m + ny] == (nx, ny, 1) and (nx, ny, 1) not in visited:\n                visited.add((nx, ny, 1))\n                queue.append((nx, ny, 1))\n\n# Main logic\nvisited = set()\ncomponent_count = 0\n\nfor i in range(n * m):\n    if matrix[i] == (i // m, i % m, 1) and matrix[i] not in visited:\n        bfs(matrix[i])\n        component_count += 1\n\n# Output the result\nprint(component_count)",
            "import sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n\n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n\n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n\n    return component_count\n\n# Read input\nn, m = map(int, sys.stdin.readline().split())\nmatrix = []\nfor _ in range(n):\n    row = sys.stdin.readline().strip()\n    for char in row:\n        matrix.append(int(char, 16))\n\n# Solve the problem\nresult = count_components(n, m, matrix)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n\n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n\n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n\n    return component_count\n\n# Read input\nn, m = map(int, sys.stdin.readline().split())\nmatrix = []\nfor _ in range(n):\n    row = sys.stdin.readline().strip()\n    for char in row:\n        binary = bin(int(char, 16))[2:].zfill(4)\n        matrix.append([int(bit) for bit in binary])\n\n# Solve the problem\nresult = count_components(n, m, matrix)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n\n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n\n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n\n    return component_count\n\n# Read input\nn, m = map(int, input().split())\nmatrix = []\nfor _ in range(n):\n    row = input().strip()\n    matrix.append([int(row[i:i+1], 16) & (1 << (3 - j)) & 1 for j in range(m // 4)])\n\n# Output the result\nprint(count_components(n, m, matrix))",
            "import sys\nfrom collections import deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\n# Convert hexadecimal to binary and create the matrix\nmatrix = []\nfor i in range(n):\n    hex_val = data[2 + i]\n    binary_str = bin(int(hex_val, 16))[2:].zfill(m)\n    matrix.append([int(bit) for bit in binary_str])\n\n# Directions for moving up, down, left, and right\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n# Function to perform BFS and count connected components\ndef bfs(x, y):\n    queue = deque([(x, y)])\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 1:\n                matrix[nx][ny] = 0  # Mark as visited\n                queue.append((nx, ny))\n\n# Count the number of connected components\ncomponent_count = 0\nfor i in range(n):\n    for j in range(m):\n        if matrix[i][j] == 1:\n            bfs(i, j)\n            component_count += 1\n\n# Output the result\nprint(component_count)",
            "import sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n\n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n\n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n\n    return component_count\n\n# Read input\nn, m = map(int, input().split())\nmatrix = []\nfor _ in range(n):\n    row = input().strip()\n    binary_row = ''.join(format(int(char, 16), '04b') for char in row)\n    matrix.append([int(bit) for bit in binary_row])\n\n# Output the result\nprint(count_components(n, m, matrix))",
            "import sys\nfrom collections import deque\n\ndef count_components(n, m, matrix):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and matrix[x][y] == 1 and not visited[x][y]\n\n    def bfs(start_x, start_y):\n        queue = deque([(start_x, start_y)])\n        visited[start_x][start_y] = True\n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n\n    visited = [[False] * m for _ in range(n)]\n    component_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                bfs(i, j)\n                component_count += 1\n\n    return component_count\n\n# Read input\nn, m = map(int, input().split())\nmatrix = []\nfor _ in range(n):\n    row = input().strip()\n    binary_row = ''.join(format(int(char, 16), '04b') for char in row)\n    matrix.append([int(bit) for bit in binary_row])\n\n# Output the result\nprint(count_components(n, m, matrix))",
            "import sys\nfrom collections import deque\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nmatrix = []\n\nindex = 2\nfor i in range(n):\n    row = []\n    for j in range(m // 4):\n        hex_val = data[index]\n        index += 1\n        for k in range(3, -1, -1):\n            bit = (int(hex_val, 16) >> k) & 1\n            row.append(bit)\n    matrix.append(row)\n\n# Function to perform BFS and count connected components\ndef bfs(x, y):\n    queue = deque([(x, y)])\n    visited.add((x, y))\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 1 and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n\n# Initialize visited set\nvisited = set()\n\n# Count connected components\ncomponent_count = 0\nfor i in range(n):\n    for j in range(m):\n        if matrix[i][j] == 1 and (i, j) not in visited:\n            bfs(i, j)\n            component_count += 1\n\n# Output the result\nprint(component_count)",
            "import sys\nfrom collections import deque\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\nmatrix = [int(data[i+2], 16) for i in range(n)]\n\n# Convert the matrix to a 2D list of 1s and 0s\nmatrix_2d = []\nfor row in matrix:\n    row_2d = []\n    for i in range(m // 4):\n        binary = format(row >> (i * 4), '04b')\n        row_2d.extend([int(bit) for bit in binary])\n    matrix_2d.append(row_2d)\n\n# Function to perform BFS and count connected components\ndef bfs(x, y):\n    queue = deque([(x, y)])\n    while queue:\n        cx, cy = queue.popleft()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < n and 0 <= ny < m and matrix_2d[nx][ny] == 1:\n                matrix_2d[nx][ny] = 0\n                queue.append((nx, ny))\n\n# Count the number of connected components\ncomponent_count = 0\nfor i in range(n):\n    for j in range(m):\n        if matrix_2d[i][j] == 1:\n            bfs(i, j)\n            component_count += 1\n\n# Print the result\nprint(component_count)"
        ]
    },
    {
        "question_title": "Xor-MST",
        "question_content": "You are given a complete undirected graph with n vertices. A number ai is assigned to each vertex, and the weight of an edge between vertices i and j is equal to ai xor aj.\n\nCalculate the weight of the minimum spanning tree in this graph.\n\n\nInput Format\nThe first line contains n (1 \u2264 n \u2264 200000) \u2014 the number of vertices in the graph.\n\nThe second line contains n integers a1, a2, ..., an (0 \u2264 ai < 230) \u2014 the numbers assigned to the vertices.\n\n\nOutput Format\nPrint one number \u2014 the weight of the minimum spanning tree in the graph.\n\n\nSample Input 1\n\n5\n1 2 3 4 5\n\nSample Output 1\n\n8\n\n\nSample Input 2\n\n4\n1 2 3 4\n\nSample Output 2\n\n8",
        "platform": "codeforces",
        "question_id": "888/G",
        "contest_id": "888",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nimport heapq\n\ndef minimum_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the weight of the minimum spanning tree\nresult = minimum_spanning_tree_weight(n, a)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of vertices\nn = int(data[0])\n\n# Values assigned to vertices\na = list(map(int, data[1:]))\n\n# Function to calculate the weight of the minimum spanning tree\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort edges by weight\n    edges.sort()\n    \n    # Union-Find data structure to detect cycles\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Minimum spanning tree weight\n    mst_weight = 0\n    num_edges = 0\n    \n    for weight, i, j in edges:\n        if find(i) != find(j):\n            union(i, j)\n            mst_weight += weight\n            num_edges += 1\n            if num_edges == n - 1:\n                break\n    \n    return mst_weight\n\n# Calculate and print the result\nresult = min_spanning_tree_weight(n, a)\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = min_spanning_tree_weight(n, a)\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the degree of each vertex\ndegree = [0] * n\nfor i in range(n):\n    for j in range(i + 1, n):\n        degree[i] ^= a[j]\n        degree[j] ^= a[i]\n\n# Find the two vertices with the minimum degree\nmin_degree = float('inf')\nmin_index = -1\nfor i in range(n):\n    if degree[i] < min_degree:\n        min_degree = degree[i]\n        min_index = i\n\n# The minimum spanning tree weight is twice the minimum degree\nresult = 2 * min_degree\n\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_spanning_tree(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the weight of the minimum spanning tree\nresult = min_spanning_tree(n, a)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the minimum spanning tree weight\nprint(min_spanning_tree_weight(n, a))\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the weight of the minimum spanning tree\nresult = min_spanning_tree_weight(n, a)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use Kruskal's algorithm to find the minimum spanning tree\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = min_spanning_tree_weight(n, a)\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of vertices\nn = int(data[0])\n\n# Parse the list of vertex values\na = list(map(int, data[1:]))\n\n# Function to calculate the weight of the minimum spanning tree\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Initialize the minimum spanning tree weight\n    mst_weight = 0\n    num_edges = 0\n    \n    # Add edges to the minimum spanning tree\n    for weight, i, j in edges:\n        if find(i) != find(j):\n            union(i, j)\n            mst_weight += weight\n            num_edges += 1\n            if num_edges == n - 1:\n                break\n    \n    return mst_weight\n\n# Calculate the minimum spanning tree weight\nresult = min_spanning_tree_weight(n, a)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport heapq\n\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the weight of the minimum spanning tree\nresult = min_spanning_tree_weight(n, a)\n\n# Write the result to stdout\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nimport heapq\n\ndef minimum_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the weight of the minimum spanning tree\nresult = minimum_spanning_tree_weight(n, a)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of vertices\nn = int(data[0])\n\n# Values assigned to vertices\na = list(map(int, data[1:]))\n\n# Function to calculate the weight of the minimum spanning tree\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort edges by weight\n    edges.sort()\n    \n    # Union-Find data structure to detect cycles\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Minimum spanning tree weight\n    mst_weight = 0\n    num_edges = 0\n    \n    for weight, i, j in edges:\n        if find(i) != find(j):\n            union(i, j)\n            mst_weight += weight\n            num_edges += 1\n            if num_edges == n - 1:\n                break\n    \n    return mst_weight\n\n# Calculate and print the result\nresult = min_spanning_tree_weight(n, a)\nprint(result)",
            "import sys\nimport heapq\n\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = min_spanning_tree_weight(n, a)\nprint(result)",
            "import sys\nimport heapq\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the degree of each vertex\ndegree = [0] * n\nfor i in range(n):\n    for j in range(i + 1, n):\n        degree[i] ^= a[j]\n        degree[j] ^= a[i]\n\n# Find the two vertices with the minimum degree\nmin_degree = float('inf')\nmin_index = -1\nfor i in range(n):\n    if degree[i] < min_degree:\n        min_degree = degree[i]\n        min_index = i\n\n# The minimum spanning tree weight is twice the minimum degree\nresult = 2 * min_degree\n\nprint(result)",
            "import sys\nimport heapq\n\ndef min_spanning_tree(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the weight of the minimum spanning tree\nresult = min_spanning_tree(n, a)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the minimum spanning tree weight\nprint(min_spanning_tree_weight(n, a))",
            "import sys\nimport heapq\n\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the weight of the minimum spanning tree\nresult = min_spanning_tree_weight(n, a)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use Kruskal's algorithm to find the minimum spanning tree\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = min_spanning_tree_weight(n, a)\nprint(result)",
            "import sys\nimport heapq\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the number of vertices\nn = int(data[0])\n\n# Parse the list of vertex values\na = list(map(int, data[1:]))\n\n# Function to calculate the weight of the minimum spanning tree\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Initialize the minimum spanning tree weight\n    mst_weight = 0\n    num_edges = 0\n    \n    # Add edges to the minimum spanning tree\n    for weight, i, j in edges:\n        if find(i) != find(j):\n            union(i, j)\n            mst_weight += weight\n            num_edges += 1\n            if num_edges == n - 1:\n                break\n    \n    return mst_weight\n\n# Calculate the minimum spanning tree weight\nresult = min_spanning_tree_weight(n, a)\n\n# Write the result to stdout\nprint(result)",
            "import sys\nimport heapq\n\ndef min_spanning_tree_weight(n, a):\n    # Create a list of edges with their weights\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            weight = a[i] ^ a[j]\n            edges.append((weight, i, j))\n    \n    # Sort the edges by weight\n    edges.sort()\n    \n    # Use a union-find data structure to keep track of connected components\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootX] = rootY\n    \n    # Kruskal's algorithm to find the minimum spanning tree\n    mst_weight = 0\n    for weight, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst_weight += weight\n    \n    return mst_weight\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the weight of the minimum spanning tree\nresult = min_spanning_tree_weight(n, a)\n\n# Write the result to stdout\nprint(result)"
        ]
    },
    {
        "question_title": "Mod Mod Mod",
        "question_content": "You are given a sequence of integers a1, a2, ..., an. Let f(x,n) = x \\bmod a_n, and f(x,i) = (x \\bmod a_i) + f(x \\bmod a_i, i+1) for 1 \u2264 i < n. Here, \\bmod denotes the modulus operation. Find the maximum value of f(x, 1) over all nonnegative integers x.\n\n\nInput Format\nThe first line contains a single integer n (1 \u2264 n \u2264 200000)\u00a0\u2014 the length of the sequence.\n\nThe second lines contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 1013)\u00a0\u2014 the elements of the sequence.\n\n\nOutput Format\nOutput a single integer\u00a0\u2014 the maximum value of f(x, 1) over all nonnegative integers x.\n\n\nSample Input 1\n\n2\n10 5\n\nSample Output 1\n\n13\n\n\nSample Input 2\n\n5\n5 4 3 2 1\n\nSample Output 2\n\n6\n\n\nSample Input 3\n\n4\n5 10 5 10\n\nSample Output 3\n\n16\n\n\nNote\nIn the first example you can choose, for example, x = 19.\n\nIn the second example you can choose, for example, x = 3 or x = 2.",
        "platform": "codeforces",
        "question_id": "889/E",
        "contest_id": "889",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nmax_value = 0\n\nfor i in range(n):\n    max_value = max(max_value, a[i] - 1)\n\nprint(max_value)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nmax_value = 0\nfor i in range(n):\n    max_value = max(max_value, a[i] - 1)\n\nprint(max_value)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result\nresult = 0\n\n# Iterate over the sequence in reverse order\nfor i in range(n-1, -1, -1):\n    # Update the result with the maximum value of f(x, i)\n    result = (result + a[i] - 1) // a[i] * a[i]\n\n# Output the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# The function f(x, 1) is maximized when x is a multiple of the least common multiple (LCM) of the sequence a\n# This is because the LCM will give us the largest possible value for x % a_i for all i\nfrom math import gcd\nfrom functools import reduce\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\nlcm_value = reduce(lcm, a)\n\n# The maximum value of f(x, 1) is then lcm_value - 1\nprint(lcm_value - 1)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nmax_value = 0\nfor i in range(n):\n    max_value = max(max_value, a[i] - 1)\n\nprint(max_value)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result\nresult = 0\n\n# Iterate over the sequence in reverse order\nfor i in range(n-1, -1, -1):\n    # Update the result with the maximum value of f(x, i)\n    result = (result + a[i] - 1) // a[i]\n\n# Output the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result\nresult = 0\n\n# Iterate over all possible values of x\nfor x in range(10**14):\n    # Compute f(x, 1)\n    f_x_1 = x % a[-1]\n    for i in range(n-2, -1, -1):\n        f_x_1 = (x % a[i]) + f_x_1\n    # Update the result if the current value is greater\n    if f_x_1 > result:\n        result = f_x_1\n\n# Output the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result\nresult = 0\n\n# Iterate over the sequence in reverse order\nfor i in range(n-1, -1, -1):\n    # Update the result with the maximum value of f(x, i)\n    result = (result + a[i] - 1) // a[i]\n\n# Output the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef max_f(n, a):\n    max_val = 0\n    for i in range(n):\n        max_val = max(max_val, a[i] - 1)\n    return max_val\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = max_f(n, a)\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nmax_value = 0\nfor i in range(n):\n    max_value = max(max_value, a[i] - 1)\n\nprint(max_value)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nmax_value = 0\n\nfor i in range(n):\n    max_value = max(max_value, a[i] - 1)\n\nprint(max_value)",
            "# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nmax_value = 0\nfor i in range(n):\n    max_value = max(max_value, a[i] - 1)\n\nprint(max_value)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result\nresult = 0\n\n# Iterate over the sequence in reverse order\nfor i in range(n-1, -1, -1):\n    # Update the result with the maximum value of f(x, i)\n    result = (result + a[i] - 1) // a[i] * a[i]\n\n# Output the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# The function f(x, 1) is maximized when x is a multiple of the least common multiple (LCM) of the sequence a\n# This is because the LCM will give us the largest possible value for x % a_i for all i\nfrom math import gcd\nfrom functools import reduce\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\nlcm_value = reduce(lcm, a)\n\n# The maximum value of f(x, 1) is then lcm_value - 1\nprint(lcm_value - 1)",
            "# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nmax_value = 0\nfor i in range(n):\n    max_value = max(max_value, a[i] - 1)\n\nprint(max_value)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result\nresult = 0\n\n# Iterate over the sequence in reverse order\nfor i in range(n-1, -1, -1):\n    # Update the result with the maximum value of f(x, i)\n    result = (result + a[i] - 1) // a[i]\n\n# Output the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result\nresult = 0\n\n# Iterate over all possible values of x\nfor x in range(10**14):\n    # Compute f(x, 1)\n    f_x_1 = x % a[-1]\n    for i in range(n-2, -1, -1):\n        f_x_1 = (x % a[i]) + f_x_1\n    # Update the result if the current value is greater\n    if f_x_1 > result:\n        result = f_x_1\n\n# Output the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the result\nresult = 0\n\n# Iterate over the sequence in reverse order\nfor i in range(n-1, -1, -1):\n    # Update the result with the maximum value of f(x, i)\n    result = (result + a[i] - 1) // a[i]\n\n# Output the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\ndef max_f(n, a):\n    max_val = 0\n    for i in range(n):\n        max_val = max(max_val, a[i] - 1)\n    return max_val\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate and print the result\nresult = max_f(n, a)\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nmax_value = 0\nfor i in range(n):\n    max_value = max(max_value, a[i] - 1)\n\nprint(max_value)"
        ]
    },
    {
        "question_title": "Envy",
        "question_content": "For a connected undirected weighted graph G, MST (minimum spanning tree) is a subgraph of G that contains all of G's vertices, is a tree, and sum of its edges is minimum possible.\n\nYou are given a graph G. If you run a MST algorithm on graph it would give you only one MST and it causes other edges to become jealous. You are given some queries, each query contains a set of edges of graph G, and you should determine whether there is a MST containing all these edges or not.\n\n\nInput Format\nThe first line contains two integers n, m (2 \u2264 n, m \u2264 5\u00b7105, n - 1 \u2264 m)\u00a0\u2014 the number of vertices and edges in the graph and the number of queries.\n\nThe i-th of the next m lines contains three integers ui, vi, wi (ui \u2260 vi, 1 \u2264 wi \u2264 5\u00b7105)\u00a0\u2014 the endpoints and weight of the i-th edge. There can be more than one edges between two vertices. It's guaranteed that the given graph is connected.\n\nThe next line contains a single integer q (1 \u2264 q \u2264 5\u00b7105)\u00a0\u2014 the number of queries.\n\nq lines follow, the i-th of them contains the i-th query. It starts with an integer ki (1 \u2264 ki \u2264 n - 1)\u00a0\u2014 the size of edges subset and continues with ki distinct space-separated integers from 1 to m\u00a0\u2014 the indices of the edges. It is guaranteed that the sum of ki for 1 \u2264 i \u2264 q does not exceed 5\u00b7105.\n\n\nOutput Format\nFor each query you should print \"YES\" (without quotes) if there's a MST containing these edges and \"NO\" (of course without quotes again) otherwise.\n\n\nSample Input 1\n\n5 7\n1 2 2\n1 3 2\n2 3 1\n2 4 1\n3 4 1\n3 5 2\n4 5 2\n4\n2 3 4\n3 3 4 5\n2 1 7\n2 1 2\n\nSample Output 1\n\nYES\nNO\nYES\nNO\n\n\nNote\nThis is the graph of sample:\n\nWeight of minimum spanning tree on this graph is 6.\n\nMST with edges (1, 3, 4, 6), contains all of edges from the first query, so answer on the first query is \"YES\".\n\nEdges from the second query form a cycle of length 3, so there is no spanning tree including these three edges. Thus, answer is \"NO\".",
        "platform": "codeforces",
        "question_id": "891/C",
        "contest_id": "891",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom heapq import heappop, heappush\n\ndef kruskal(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    mst = []\n    for u, v, w in edges:\n        if find(u-1) != find(v-1):\n            union(u-1, v-1)\n            mst.append((w, u, v))\n    return mst\n\ndef solve(n, m, edges, queries):\n    edges.sort()\n    mst_edges = kruskal(n, edges)\n    mst_set = set(mst_edges)\n\n    results = []\n    for query in queries:\n        query_edges = [edges[i-1] for i in query[1:]]\n        query_set = set(query_edges)\n        if query_set.issubset(mst_set):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((w, u, v))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        k = int(data[index])\n        query = [int(data[index + i]) for i in range(1, k + 1)]\n        queries.append((k, query))\n        index += k + 1\n    \n    results = solve(n, m, edges, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom heapq import heappop, heappush\n\ndef kruskal(n, edges, queries):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    def is_mst_with_edges(edges):\n        for u, v, w in edges:\n            if find(u) != find(v):\n                union(u, v)\n        for u, v, w in edges:\n            if find(u) == find(v):\n                return False\n        return True\n\n    results = []\n    for query in queries:\n        ki = query[0]\n        edge_indices = query[1:]\n        edges_in_query = [edges[i - 1] for i in edge_indices]\n        if is_mst_with_edges(edges_in_query):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        ki = int(data[index])\n        edge_indices = list(map(int, data[index + 1:index + 1 + ki]))\n        queries.append((ki, edge_indices))\n        index += 1 + ki\n    \n    results = kruskal(n, edges, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal_mst(edges, n):\n    parent = list(range(n))\n    rank = [0] * n\n    mst = []\n    edges.sort(key=lambda x: x[2])\n\n    for u, v, w in edges:\n        x = find(parent, u - 1)\n        y = find(parent, v - 1)\n        if x != y:\n            union(parent, rank, x, y)\n            mst.append((u, v, w))\n\n    return mst\n\ndef check_query(edges, query):\n    n = len(edges) + 1\n    mst = kruskal_mst(edges, n)\n    mst_edges = set()\n    for u, v, w in mst:\n        mst_edges.add((u, v))\n        mst_edges.add((v, u))\n\n    for u, v, w in query:\n        if (u, v) not in mst_edges and (v, u) not in mst_edges:\n            return \"NO\"\n    return \"YES\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        ki = int(data[index])\n        query = []\n        for _ in range(ki):\n            query.append((int(data[index + 1]), int(data[index + 2]), int(data[index + 3])))\n            index += 4\n        queries.append(query)\n    \n    for query in queries:\n        print(check_query(edges, query))\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal_mst(edges, n):\n    parent = list(range(n))\n    rank = [0] * n\n    mst_edges = []\n    edges.sort(key=lambda x: x[2])\n    for u, v, w in edges:\n        x = find(parent, u - 1)\n        y = find(parent, v - 1)\n        if x != y:\n            union(parent, rank, x, y)\n            mst_edges.append((u, v, w))\n    return mst_edges\n\ndef has_mst_with_edges(edges, queries):\n    n = len(edges) + 1\n    mst_edges = kruskal_mst(edges, n)\n    mst_set = set()\n    for u, v, w in mst_edges:\n        mst_set.add((u, v))\n        mst_set.add((v, u))\n    \n    results = []\n    for query in queries:\n        query_edges = set()\n        for edge_index in query[1:]:\n            u, v, w = edges[edge_index - 1]\n            query_edges.add((u, v))\n            query_edges.add((v, u))\n        \n        if len(query_edges) != len(query_edges) - 1:\n            results.append(\"NO\")\n            continue\n        \n        visited = set()\n        queue = deque([1])\n        while queue:\n            node = queue.popleft()\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in range(1, n + 1):\n                if (node, neighbor) in query_edges or (neighbor, node) in query_edges:\n                    queue.append(neighbor)\n        \n        if len(visited) == n:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\nq = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(q):\n    k = int(data[index])\n    query = [int(data[index + i]) for i in range(1, k + 1)]\n    queries.append((k, query))\n    index += k + 1\n\n# Solve and write output\nresults = has_mst_with_edges(edges, queries)\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal_mst(edges, n):\n    parent = list(range(n))\n    rank = [0] * n\n    mst = []\n    edges.sort(key=lambda x: x[2])\n\n    for u, v, w in edges:\n        x = find(parent, u - 1)\n        y = find(parent, v - 1)\n\n        if x != y:\n            union(parent, rank, x, y)\n            mst.append((u, v, w))\n\n    return mst\n\ndef has_mst_with_edges(edges, queries, n):\n    mst_edges = kruskal_mst(edges, n)\n    mst_set = set(mst_edges)\n\n    for query in queries:\n        query_edges = [edges[i - 1] for i in query[1:]]\n        query_set = set(query_edges)\n\n        if query_set.issubset(mst_set):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\n\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\nq = int(data[index])\nqueries = []\n\nindex += 1\nfor _ in range(q):\n    k = int(data[index])\n    query = [int(data[index + i]) for i in range(1, k + 1)]\n    queries.append((k, query))\n    index += k\n\n# Process queries\nhas_mst_with_edges(edges, queries, n)\n```",
            "```python\nimport sys\nfrom heapq import heappop, heappush\n\ndef kruskal(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    mst = []\n    for u, v, w in edges:\n        if find(u-1) != find(v-1):\n            union(u-1, v-1)\n            mst.append((w, u, v))\n    return mst\n\ndef can_form_mst(n, edges, query_edges):\n    all_edges = edges[:]\n    for q in query_edges:\n        all_edges.append((edges[q-1][2], edges[q-1][0], edges[q-1][1]))\n    mst = kruskal(n, all_edges)\n    return len(mst) == n - 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        k = int(data[index])\n        query_edges = list(map(int, data[index + 1:index + 1 + k]))\n        queries.append((k, query_edges))\n        index += 1 + k\n    \n    results = []\n    for k, query_edges in queries:\n        if can_form_mst(n, edges, query_edges):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal_mst(edges, n):\n    parent = list(range(n))\n    rank = [0] * n\n    mst = []\n    edges.sort(key=lambda x: x[2])\n    for u, v, w in edges:\n        x = find(parent, u - 1)\n        y = find(parent, v - 1)\n        if x != y:\n            union(parent, rank, x, y)\n            mst.append((u, v, w))\n    return mst\n\ndef has_mst_with_edges(edges, queries):\n    n = len(edges) + 1\n    mst = kruskal_mst(edges, n)\n    mst_edges = set()\n    for u, v, w in mst:\n        mst_edges.add((u, v))\n        mst_edges.add((v, u))\n    \n    results = []\n    for query in queries:\n        query_edges = set()\n        for edge_index in query[1:]:\n            u, v, w = edges[edge_index - 1]\n            query_edges.add((u, v))\n            query_edges.add((v, u))\n        \n        if len(query_edges) != len(query_edges) or len(query_edges) != len(mst_edges):\n            results.append(\"NO\")\n            continue\n        \n        parent = list(range(n))\n        rank = [0] * n\n        for u, v in query_edges:\n            x = find(parent, u - 1)\n            y = find(parent, v - 1)\n            if x == y:\n                results.append(\"NO\")\n                break\n            union(parent, rank, x, y)\n        else:\n            results.append(\"YES\")\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\nq = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(q):\n    k = int(data[index])\n    query = [int(data[index + i]) for i in range(1, k + 1)]\n    queries.append((k, query))\n    index += k + 1\n\n# Solve the problem\nresults = has_mst_with_edges(edges, queries)\n\n# Write output\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef kruskal(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    mst_edges = []\n    for u, v, w in edges:\n        if find(u - 1) != find(v - 1):\n            union(u - 1, v - 1)\n            mst_edges.append((w, u, v))\n    return mst_edges\n\ndef can_form_mst(n, edges, query_edges):\n    mst_edges = kruskal(n, edges)\n    mst_set = set()\n    for w, u, v in mst_edges:\n        mst_set.add((u, v))\n        mst_set.add((v, u))\n\n    for edge in query_edges:\n        u, v = edge\n        if (u, v) not in mst_set and (v, u) not in mst_set:\n            return \"NO\"\n    return \"YES\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        ki = int(data[index])\n        query_edges = []\n        for _ in range(ki):\n            query_edges.append((int(data[index + 1]), int(data[index + 2])))\n            index += 3\n        queries.append(query_edges)\n    \n    results = []\n    for query_edges in queries:\n        result = can_form_mst(n, edges, query_edges)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom heapq import heappop, heappush\n\ndef kruskal(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    mst = []\n    for u, v, w in edges:\n        if find(u - 1) != find(v - 1):\n            union(u - 1, v - 1)\n            mst.append((w, u, v))\n    return mst\n\ndef has_mst_with_edges(n, edges, query_edges):\n    all_edges = edges[:]\n    for q in query_edges:\n        all_edges.append((edges[q - 1][2], edges[q - 1][0], edges[q - 1][1]))\n    mst = kruskal(n, all_edges)\n    return len(mst) == n - 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        ki = int(data[index])\n        query_edges = [int(data[index + i + 1]) for i in range(ki)]\n        queries.append(query_edges)\n        index += ki + 1\n    \n    for query in queries:\n        if has_mst_with_edges(n, edges, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef kruskal(n, edges, queries):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    def is_valid_mst(edges):\n        for u, v, w in edges:\n            if find(u) != find(v):\n                union(u, v)\n        for u, v, w in edges:\n            if find(u) == find(v):\n                return False\n        return True\n\n    results = []\n    for query in queries:\n        ki = query[0]\n        edge_indices = query[1:]\n        selected_edges = [edges[i - 1] for i in edge_indices]\n        if is_valid_mst(selected_edges):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        ki = int(data[index])\n        edge_indices = list(map(int, data[index + 1:index + 1 + ki]))\n        queries.append((ki, edge_indices))\n        index += 1 + ki\n    \n    results = kruskal(n, edges, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom heapq import heappop, heappush\n\ndef kruskal(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    mst = []\n    for u, v, w in edges:\n        if find(u-1) != find(v-1):\n            union(u-1, v-1)\n            mst.append((w, u, v))\n    return mst\n\ndef solve(n, m, edges, queries):\n    edges.sort()\n    mst_edges = kruskal(n, edges)\n    mst_set = set(mst_edges)\n\n    results = []\n    for query in queries:\n        query_edges = [edges[i-1] for i in query[1:]]\n        query_set = set(query_edges)\n        if query_set.issubset(mst_set):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((w, u, v))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        k = int(data[index])\n        query = [int(data[index + i]) for i in range(1, k + 1)]\n        queries.append((k, query))\n        index += k + 1\n    \n    results = solve(n, m, edges, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom heapq import heappop, heappush\n\ndef kruskal(n, edges, queries):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    def is_mst_with_edges(edges):\n        for u, v, w in edges:\n            if find(u) != find(v):\n                union(u, v)\n        for u, v, w in edges:\n            if find(u) == find(v):\n                return False\n        return True\n\n    results = []\n    for query in queries:\n        ki = query[0]\n        edge_indices = query[1:]\n        edges_in_query = [edges[i - 1] for i in edge_indices]\n        if is_mst_with_edges(edges_in_query):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        ki = int(data[index])\n        edge_indices = list(map(int, data[index + 1:index + 1 + ki]))\n        queries.append((ki, edge_indices))\n        index += 1 + ki\n    \n    results = kruskal(n, edges, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal_mst(edges, n):\n    parent = list(range(n))\n    rank = [0] * n\n    mst = []\n    edges.sort(key=lambda x: x[2])\n\n    for u, v, w in edges:\n        x = find(parent, u - 1)\n        y = find(parent, v - 1)\n        if x != y:\n            union(parent, rank, x, y)\n            mst.append((u, v, w))\n\n    return mst\n\ndef check_query(edges, query):\n    n = len(edges) + 1\n    mst = kruskal_mst(edges, n)\n    mst_edges = set()\n    for u, v, w in mst:\n        mst_edges.add((u, v))\n        mst_edges.add((v, u))\n\n    for u, v, w in query:\n        if (u, v) not in mst_edges and (v, u) not in mst_edges:\n            return \"NO\"\n    return \"YES\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        ki = int(data[index])\n        query = []\n        for _ in range(ki):\n            query.append((int(data[index + 1]), int(data[index + 2]), int(data[index + 3])))\n            index += 4\n        queries.append(query)\n    \n    for query in queries:\n        print(check_query(edges, query))\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal_mst(edges, n):\n    parent = list(range(n))\n    rank = [0] * n\n    mst_edges = []\n    edges.sort(key=lambda x: x[2])\n    for u, v, w in edges:\n        x = find(parent, u - 1)\n        y = find(parent, v - 1)\n        if x != y:\n            union(parent, rank, x, y)\n            mst_edges.append((u, v, w))\n    return mst_edges\n\ndef has_mst_with_edges(edges, queries):\n    n = len(edges) + 1\n    mst_edges = kruskal_mst(edges, n)\n    mst_set = set()\n    for u, v, w in mst_edges:\n        mst_set.add((u, v))\n        mst_set.add((v, u))\n    \n    results = []\n    for query in queries:\n        query_edges = set()\n        for edge_index in query[1:]:\n            u, v, w = edges[edge_index - 1]\n            query_edges.add((u, v))\n            query_edges.add((v, u))\n        \n        if len(query_edges) != len(query_edges) - 1:\n            results.append(\"NO\")\n            continue\n        \n        visited = set()\n        queue = deque([1])\n        while queue:\n            node = queue.popleft()\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in range(1, n + 1):\n                if (node, neighbor) in query_edges or (neighbor, node) in query_edges:\n                    queue.append(neighbor)\n        \n        if len(visited) == n:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\nq = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(q):\n    k = int(data[index])\n    query = [int(data[index + i]) for i in range(1, k + 1)]\n    queries.append((k, query))\n    index += k + 1\n\n# Solve and write output\nresults = has_mst_with_edges(edges, queries)\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal_mst(edges, n):\n    parent = list(range(n))\n    rank = [0] * n\n    mst = []\n    edges.sort(key=lambda x: x[2])\n\n    for u, v, w in edges:\n        x = find(parent, u - 1)\n        y = find(parent, v - 1)\n\n        if x != y:\n            union(parent, rank, x, y)\n            mst.append((u, v, w))\n\n    return mst\n\ndef has_mst_with_edges(edges, queries, n):\n    mst_edges = kruskal_mst(edges, n)\n    mst_set = set(mst_edges)\n\n    for query in queries:\n        query_edges = [edges[i - 1] for i in query[1:]]\n        query_set = set(query_edges)\n\n        if query_set.issubset(mst_set):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\n\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\nq = int(data[index])\nqueries = []\n\nindex += 1\nfor _ in range(q):\n    k = int(data[index])\n    query = [int(data[index + i]) for i in range(1, k + 1)]\n    queries.append((k, query))\n    index += k\n\n# Process queries\nhas_mst_with_edges(edges, queries, n)",
            "import sys\nfrom heapq import heappop, heappush\n\ndef kruskal(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    mst = []\n    for u, v, w in edges:\n        if find(u-1) != find(v-1):\n            union(u-1, v-1)\n            mst.append((w, u, v))\n    return mst\n\ndef can_form_mst(n, edges, query_edges):\n    all_edges = edges[:]\n    for q in query_edges:\n        all_edges.append((edges[q-1][2], edges[q-1][0], edges[q-1][1]))\n    mst = kruskal(n, all_edges)\n    return len(mst) == n - 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        k = int(data[index])\n        query_edges = list(map(int, data[index + 1:index + 1 + k]))\n        queries.append((k, query_edges))\n        index += 1 + k\n    \n    results = []\n    for k, query_edges in queries:\n        if can_form_mst(n, edges, query_edges):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef kruskal_mst(edges, n):\n    parent = list(range(n))\n    rank = [0] * n\n    mst = []\n    edges.sort(key=lambda x: x[2])\n    for u, v, w in edges:\n        x = find(parent, u - 1)\n        y = find(parent, v - 1)\n        if x != y:\n            union(parent, rank, x, y)\n            mst.append((u, v, w))\n    return mst\n\ndef has_mst_with_edges(edges, queries):\n    n = len(edges) + 1\n    mst = kruskal_mst(edges, n)\n    mst_edges = set()\n    for u, v, w in mst:\n        mst_edges.add((u, v))\n        mst_edges.add((v, u))\n    \n    results = []\n    for query in queries:\n        query_edges = set()\n        for edge_index in query[1:]:\n            u, v, w = edges[edge_index - 1]\n            query_edges.add((u, v))\n            query_edges.add((v, u))\n        \n        if len(query_edges) != len(query_edges) or len(query_edges) != len(mst_edges):\n            results.append(\"NO\")\n            continue\n        \n        parent = list(range(n))\n        rank = [0] * n\n        for u, v in query_edges:\n            x = find(parent, u - 1)\n            y = find(parent, v - 1)\n            if x == y:\n                results.append(\"NO\")\n                break\n            union(parent, rank, x, y)\n        else:\n            results.append(\"YES\")\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    w = int(data[index + 2])\n    edges.append((u, v, w))\n    index += 3\n\nq = int(data[index])\nqueries = []\nindex += 1\nfor _ in range(q):\n    k = int(data[index])\n    query = [int(data[index + i]) for i in range(1, k + 1)]\n    queries.append((k, query))\n    index += k + 1\n\n# Solve the problem\nresults = has_mst_with_edges(edges, queries)\n\n# Write output\nfor result in results:\n    print(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef kruskal(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    mst_edges = []\n    for u, v, w in edges:\n        if find(u - 1) != find(v - 1):\n            union(u - 1, v - 1)\n            mst_edges.append((w, u, v))\n    return mst_edges\n\ndef can_form_mst(n, edges, query_edges):\n    mst_edges = kruskal(n, edges)\n    mst_set = set()\n    for w, u, v in mst_edges:\n        mst_set.add((u, v))\n        mst_set.add((v, u))\n\n    for edge in query_edges:\n        u, v = edge\n        if (u, v) not in mst_set and (v, u) not in mst_set:\n            return \"NO\"\n    return \"YES\"\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        ki = int(data[index])\n        query_edges = []\n        for _ in range(ki):\n            query_edges.append((int(data[index + 1]), int(data[index + 2])))\n            index += 3\n        queries.append(query_edges)\n    \n    results = []\n    for query_edges in queries:\n        result = can_form_mst(n, edges, query_edges)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom heapq import heappop, heappush\n\ndef kruskal(n, edges):\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    mst = []\n    for u, v, w in edges:\n        if find(u - 1) != find(v - 1):\n            union(u - 1, v - 1)\n            mst.append((w, u, v))\n    return mst\n\ndef has_mst_with_edges(n, edges, query_edges):\n    all_edges = edges[:]\n    for q in query_edges:\n        all_edges.append((edges[q - 1][2], edges[q - 1][0], edges[q - 1][1]))\n    mst = kruskal(n, all_edges)\n    return len(mst) == n - 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        ki = int(data[index])\n        query_edges = [int(data[index + i + 1]) for i in range(ki)]\n        queries.append(query_edges)\n        index += ki + 1\n    \n    for query in queries:\n        if has_mst_with_edges(n, edges, query):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef kruskal(n, edges, queries):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n\n    def is_valid_mst(edges):\n        for u, v, w in edges:\n            if find(u) != find(v):\n                union(u, v)\n        for u, v, w in edges:\n            if find(u) == find(v):\n                return False\n        return True\n\n    results = []\n    for query in queries:\n        ki = query[0]\n        edge_indices = query[1:]\n        selected_edges = [edges[i - 1] for i in edge_indices]\n        if is_valid_mst(selected_edges):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    index += 2\n    \n    edges = []\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        edges.append((u, v, w))\n        index += 3\n    \n    q = int(data[index])\n    index += 1\n    \n    queries = []\n    for _ in range(q):\n        ki = int(data[index])\n        edge_indices = list(map(int, data[index + 1:index + 1 + ki]))\n        queries.append((ki, edge_indices))\n        index += 1 + ki\n    \n    results = kruskal(n, edges, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Counting Arrays",
        "question_content": "You are given two positive integer numbers x and y. An array F is called an y-factorization of x iff the following conditions are met:\n\n- There are y elements in F, and all of them are integer numbers;\n- \\prod_{i=1}^{y} F_i = x.\n\nYou have to count the number of pairwise distinct arrays that are y-factorizations of x. Two arrays A and B are considered different iff there exists at least one index i (1 \u2264 i \u2264 y) such that Ai \u2260 Bi. Since the answer can be very large, print it modulo 109 + 7.\n\n\nInput Format\nThe first line contains one integer q (1 \u2264 q \u2264 105) \u2014 the number of testcases to solve.\n\nThen q lines follow, each containing two integers xi and yi (1 \u2264 xi, yi \u2264 106). Each of these lines represents a testcase.\n\n\nOutput Format\nPrint q integers. i-th integer has to be equal to the number of yi-factorizations of xi modulo 109 + 7.\n\n\nSample Input 1\n\n2\n6 3\n4 2\n\nSample Output 1\n\n36\n6\n\n\nNote\nIn the second testcase of the example there are six y-factorizations:\n\n- { - 4,  - 1};\n- { - 2,  - 2};\n- { - 1,  - 4};\n- {1, 4};\n- {2, 2};\n- {4, 1}.",
        "platform": "codeforces",
        "question_id": "893/E",
        "contest_id": "893",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1\n    \n    factors = []\n    for i in range(2, int(x**0.5) + 1):\n        while x % i == 0:\n            factors.append(i)\n            x //= i\n    if x > 1:\n        factors.append(x)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    if num_factors < y:\n        return 0\n    \n    numerator = factorial(num_factors + y - 1)\n    denominator = factorial(y - 1) * factorial(num_factors)\n    \n    return (numerator * pow(denominator, MOD - 2, MOD)) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        result = count_factorizations(x, y)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1 if x == 1 else 0\n    \n    factors = []\n    for i in range(2, int(x**0.5) + 1):\n        while x % i == 0:\n            factors.append(i)\n            x //= i\n    if x > 1:\n        factors.append(x)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    # Calculate the number of ways to distribute the factors into y groups\n    numerator = factorial(num_factors + y - 1)\n    denominator = factorial(y - 1) * factorial(num_factors)\n    \n    # Calculate the number of distinct factorizations\n    result = 1\n    for count in factor_counts.values():\n        result = result * pow(count + y - 1, MOD - 2, MOD) % MOD\n    \n    return result * numerator // denominator % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_y_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1\n    \n    factors = []\n    for i in range(2, int(x**0.5) + 1):\n        while x % i == 0:\n            factors.append(i)\n            x //= i\n    if x > 1:\n        factors.append(x)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    # Calculate the number of ways to distribute the factors into y groups\n    numerator = factorial(num_factors + y - 1)\n    denominator = factorial(y - 1) * factorial(num_factors)\n    \n    # Calculate the number of ways to assign the factors to the groups\n    for count in factor_counts.values():\n        numerator //= factorial(count)\n    \n    return (numerator * pow(denominator, MOD - 2, MOD)) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_y_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_y_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1\n    if x < y:\n        return 0\n    \n    def prime_factors(n):\n        i = 2\n        factors = {}\n        while i * i <= n:\n            while (n % i) == 0:\n                if i in factors:\n                    factors[i] += 1\n                else:\n                    factors[i] = 1\n                n //= i\n            i += 1\n        if n > 1:\n            factors[n] = 1\n        return factors\n    \n    factors = prime_factors(x)\n    count = 1\n    for exp in factors.values():\n        count *= factorial(exp + y - 1) // (factorial(exp) * factorial(y - 1))\n        count %= MOD\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_y_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_y_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1\n    \n    factors = []\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            factors.append(i)\n            if i != x // i:\n                factors.append(x // i)\n    \n    count = 0\n    for factor in factors:\n        if x % factor == 0:\n            count += count_y_factorizations(x // factor, y - 1)\n    \n    return count % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_y_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_factorizations(x, y):\n    if y == 1:\n        return 1\n    if x < y:\n        return 0\n    \n    factors = []\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            factors.append(i)\n            if i != x // i:\n                factors.append(x // i)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    if num_factors < y:\n        return 0\n    \n    def multinomial_mod(n, counts):\n        result = factorial(n) % MOD\n        for count in counts.values():\n            result = result * pow(factorial(count), MOD - 2, MOD) % MOD\n        return result\n    \n    def count_ways(counts, y):\n        if y == 0:\n            return 1\n        if not counts:\n            return 0\n        \n        result = 0\n        for factor, count in counts.items():\n            if count >= y:\n                new_counts = counts.copy()\n                new_counts[factor] -= y\n                result = (result + count_ways(new_counts, 0)) % MOD\n            if count >= y - 1:\n                new_counts = counts.copy()\n                new_counts[factor] -= y - 1\n                result = (result + count_ways(new_counts, 1)) % MOD\n        return result\n    \n    return count_ways(factor_counts, y - 1) * multinomial_mod(num_factors, factor_counts) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1 if x == 1 else 0\n    \n    factors = []\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            factors.append(i)\n            if i != x // i:\n                factors.append(x // i)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    if num_factors < y:\n        return 0\n    \n    def multinomial_mod(n, counts):\n        numerator = factorial(n) % MOD\n        denominator = 1\n        for count in counts.values():\n            denominator = (denominator * factorial(count)) % MOD\n        return (numerator * pow(denominator, MOD - 2, MOD)) % MOD\n    \n    def count_ways(counts, y):\n        if y == 1:\n            return 1\n        if len(counts) == 1:\n            return 0\n        \n        result = 0\n        for i in range(1, y):\n            for subset in combinations(counts.keys(), i):\n                remaining_counts = counts.copy()\n                for key in subset:\n                    remaining_counts[key] -= 1\n                    if remaining_counts[key] == 0:\n                        del remaining_counts[key]\n                result = (result + count_ways(remaining_counts, y - i)) % MOD\n        return result\n    \n    return count_ways(factor_counts, y)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1 if x == 1 else 0\n    \n    factors = []\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            factors.append(i)\n            if i != x // i:\n                factors.append(x // i)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    if num_factors < y:\n        return 0\n    \n    def multinomial(n, counts):\n        result = factorial(n)\n        for count in counts.values():\n            result = result * pow(factorial(count), MOD - 2, MOD) % MOD\n        return result\n    \n    def count_partitions(n, k):\n        if k == 1:\n            return 1\n        if n == 0:\n            return 1\n        return (count_partitions(n - 1, k - 1) + k * count_partitions(n - 1, k)) % MOD\n    \n    partitions = count_partitions(num_factors, y)\n    result = multinomial(num_factors, factor_counts) * partitions % MOD\n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_y_factorizations(x, y):\n    if y == 1:\n        return 1\n    if x < y:\n        return 0\n    \n    factors = []\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            factors.append(i)\n            if i != x // i:\n                factors.append(x // i)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    if num_factors < y:\n        return 0\n    \n    def multinomial_mod(n, counts):\n        numerator = 1\n        for count in counts.values():\n            numerator = numerator * pow(factorial(count), MOD - 2, MOD) % MOD\n        return numerator\n    \n    def factorial(n):\n        if n == 0:\n            return 1\n        result = 1\n        for i in range(2, n + 1):\n            result = result * i % MOD\n        return result\n    \n    def count_partitions(n, k):\n        if k == 1:\n            return 1\n        if n < k:\n            return 0\n        return (count_partitions(n - 1, k - 1) + count_partitions(n // 2, k)) % MOD\n    \n    def count_y_factorizations_recursive(x, y):\n        if y == 1:\n            return 1\n        if x < y:\n            return 0\n        \n        count = 0\n        for i in range(1, x + 1):\n            if x % i == 0:\n                count = (count + count_y_factorizations_recursive(x // i, y - 1)) % MOD\n        return count\n    \n    return count_y_factorizations_recursive(x, y)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        result = count_y_factorizations(x, y)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_y_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1\n    \n    factors = []\n    for i in range(2, int(x**0.5) + 1):\n        while x % i == 0:\n            factors.append(i)\n            x //= i\n    if x > 1:\n        factors.append(x)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    # Calculate the number of ways to distribute the factors into y groups\n    numerator = factorial(num_factors + y - 1)\n    denominator = factorial(y - 1) * factorial(num_factors)\n    \n    # Calculate the number of distinct factorizations\n    result = numerator // denominator\n    \n    # Calculate the number of ways to assign the prime factors to the groups\n    for count in factor_counts.values():\n        result = result * pow(count + y - 1, MOD - 2, MOD) % MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        result = count_y_factorizations(x, y)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1\n    \n    factors = []\n    for i in range(2, int(x**0.5) + 1):\n        while x % i == 0:\n            factors.append(i)\n            x //= i\n    if x > 1:\n        factors.append(x)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    if num_factors < y:\n        return 0\n    \n    numerator = factorial(num_factors + y - 1)\n    denominator = factorial(y - 1) * factorial(num_factors)\n    \n    return (numerator * pow(denominator, MOD - 2, MOD)) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        result = count_factorizations(x, y)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1 if x == 1 else 0\n    \n    factors = []\n    for i in range(2, int(x**0.5) + 1):\n        while x % i == 0:\n            factors.append(i)\n            x //= i\n    if x > 1:\n        factors.append(x)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    # Calculate the number of ways to distribute the factors into y groups\n    numerator = factorial(num_factors + y - 1)\n    denominator = factorial(y - 1) * factorial(num_factors)\n    \n    # Calculate the number of distinct factorizations\n    result = 1\n    for count in factor_counts.values():\n        result = result * pow(count + y - 1, MOD - 2, MOD) % MOD\n    \n    return result * numerator // denominator % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_y_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1\n    \n    factors = []\n    for i in range(2, int(x**0.5) + 1):\n        while x % i == 0:\n            factors.append(i)\n            x //= i\n    if x > 1:\n        factors.append(x)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    # Calculate the number of ways to distribute the factors into y groups\n    numerator = factorial(num_factors + y - 1)\n    denominator = factorial(y - 1) * factorial(num_factors)\n    \n    # Calculate the number of ways to assign the factors to the groups\n    for count in factor_counts.values():\n        numerator //= factorial(count)\n    \n    return (numerator * pow(denominator, MOD - 2, MOD)) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_y_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_y_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1\n    if x < y:\n        return 0\n    \n    def prime_factors(n):\n        i = 2\n        factors = {}\n        while i * i <= n:\n            while (n % i) == 0:\n                if i in factors:\n                    factors[i] += 1\n                else:\n                    factors[i] = 1\n                n //= i\n            i += 1\n        if n > 1:\n            factors[n] = 1\n        return factors\n    \n    factors = prime_factors(x)\n    count = 1\n    for exp in factors.values():\n        count *= factorial(exp + y - 1) // (factorial(exp) * factorial(y - 1))\n        count %= MOD\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_y_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_y_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1\n    \n    factors = []\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            factors.append(i)\n            if i != x // i:\n                factors.append(x // i)\n    \n    count = 0\n    for factor in factors:\n        if x % factor == 0:\n            count += count_y_factorizations(x // factor, y - 1)\n    \n    return count % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_y_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_factorizations(x, y):\n    if y == 1:\n        return 1\n    if x < y:\n        return 0\n    \n    factors = []\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            factors.append(i)\n            if i != x // i:\n                factors.append(x // i)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    if num_factors < y:\n        return 0\n    \n    def multinomial_mod(n, counts):\n        result = factorial(n) % MOD\n        for count in counts.values():\n            result = result * pow(factorial(count), MOD - 2, MOD) % MOD\n        return result\n    \n    def count_ways(counts, y):\n        if y == 0:\n            return 1\n        if not counts:\n            return 0\n        \n        result = 0\n        for factor, count in counts.items():\n            if count >= y:\n                new_counts = counts.copy()\n                new_counts[factor] -= y\n                result = (result + count_ways(new_counts, 0)) % MOD\n            if count >= y - 1:\n                new_counts = counts.copy()\n                new_counts[factor] -= y - 1\n                result = (result + count_ways(new_counts, 1)) % MOD\n        return result\n    \n    return count_ways(factor_counts, y - 1) * multinomial_mod(num_factors, factor_counts) % MOD\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1 if x == 1 else 0\n    \n    factors = []\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            factors.append(i)\n            if i != x // i:\n                factors.append(x // i)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    if num_factors < y:\n        return 0\n    \n    def multinomial_mod(n, counts):\n        numerator = factorial(n) % MOD\n        denominator = 1\n        for count in counts.values():\n            denominator = (denominator * factorial(count)) % MOD\n        return (numerator * pow(denominator, MOD - 2, MOD)) % MOD\n    \n    def count_ways(counts, y):\n        if y == 1:\n            return 1\n        if len(counts) == 1:\n            return 0\n        \n        result = 0\n        for i in range(1, y):\n            for subset in combinations(counts.keys(), i):\n                remaining_counts = counts.copy()\n                for key in subset:\n                    remaining_counts[key] -= 1\n                    if remaining_counts[key] == 0:\n                        del remaining_counts[key]\n                result = (result + count_ways(remaining_counts, y - i)) % MOD\n        return result\n    \n    return count_ways(factor_counts, y)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1 if x == 1 else 0\n    \n    factors = []\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            factors.append(i)\n            if i != x // i:\n                factors.append(x // i)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    if num_factors < y:\n        return 0\n    \n    def multinomial(n, counts):\n        result = factorial(n)\n        for count in counts.values():\n            result = result * pow(factorial(count), MOD - 2, MOD) % MOD\n        return result\n    \n    def count_partitions(n, k):\n        if k == 1:\n            return 1\n        if n == 0:\n            return 1\n        return (count_partitions(n - 1, k - 1) + k * count_partitions(n - 1, k)) % MOD\n    \n    partitions = count_partitions(num_factors, y)\n    result = multinomial(num_factors, factor_counts) * partitions % MOD\n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        results.append(count_factorizations(x, y))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\nfrom collections import Counter\n\nMOD = 10**9 + 7\n\ndef count_y_factorizations(x, y):\n    if y == 1:\n        return 1\n    if x < y:\n        return 0\n    \n    factors = []\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            factors.append(i)\n            if i != x // i:\n                factors.append(x // i)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    if num_factors < y:\n        return 0\n    \n    def multinomial_mod(n, counts):\n        numerator = 1\n        for count in counts.values():\n            numerator = numerator * pow(factorial(count), MOD - 2, MOD) % MOD\n        return numerator\n    \n    def factorial(n):\n        if n == 0:\n            return 1\n        result = 1\n        for i in range(2, n + 1):\n            result = result * i % MOD\n        return result\n    \n    def count_partitions(n, k):\n        if k == 1:\n            return 1\n        if n < k:\n            return 0\n        return (count_partitions(n - 1, k - 1) + count_partitions(n // 2, k)) % MOD\n    \n    def count_y_factorizations_recursive(x, y):\n        if y == 1:\n            return 1\n        if x < y:\n            return 0\n        \n        count = 0\n        for i in range(1, x + 1):\n            if x % i == 0:\n                count = (count + count_y_factorizations_recursive(x // i, y - 1)) % MOD\n        return count\n    \n    return count_y_factorizations_recursive(x, y)\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        result = count_y_factorizations(x, y)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import Counter\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef count_y_factorizations(x, y):\n    if x == 1:\n        return 1\n    if y == 1:\n        return 1\n    \n    factors = []\n    for i in range(2, int(x**0.5) + 1):\n        while x % i == 0:\n            factors.append(i)\n            x //= i\n    if x > 1:\n        factors.append(x)\n    \n    factor_counts = Counter(factors)\n    num_factors = len(factor_counts)\n    \n    # Calculate the number of ways to distribute the factors into y groups\n    numerator = factorial(num_factors + y - 1)\n    denominator = factorial(y - 1) * factorial(num_factors)\n    \n    # Calculate the number of distinct factorizations\n    result = numerator // denominator\n    \n    # Calculate the number of ways to assign the prime factors to the groups\n    for count in factor_counts.values():\n        result = result * pow(count + y - 1, MOD - 2, MOD) % MOD\n    \n    return result\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        x = int(data[index])\n        y = int(data[index + 1])\n        index += 2\n        result = count_y_factorizations(x, y)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Letters Removing",
        "question_content": "Petya has a string of length n consisting of small and large English letters and digits.\n\nHe performs m operations. Each operation is described with two integers l and r and a character c: Petya removes from the string all characters c on positions between l and r, inclusive. It's obvious that the length of the string remains the same or decreases after each operation.\n\nFind how the string will look like after Petya performs all m operations.\n\n\nInput Format\nThe first string contains two integers n and m (1 \u2264 n, m \u2264 2\u00b7105) \u2014 the length of the string and the number of operations.\n\nThe second line contains the string of length n, consisting of small and large English letters and digits. Positions in the string are enumerated from 1.\n\nEach of the next m lines contains two integers l and r (1 \u2264 l \u2264 r), followed by a character c, which is a small or large English letter or a digit. This line describes one operation. It is guaranteed that r doesn't exceed the length of the string s before current operation.\n\n\nOutput Format\nPrint the string Petya will obtain after performing all m operations. If the strings becomes empty after all operations, print an empty line.\n\n\nSample Input 1\n\n4 2\nabac\n1 3 a\n2 2 c\n\nSample Output 1\n\nb\n\n\nSample Input 2\n\n3 2\nA0z\n1 3 0\n1 1 z\n\nSample Output 2\n\nAz\n\n\nSample Input 3\n\n10 4\nagtFrgF4aF\n2 5 g\n4 9 F\n1 5 4\n1 7 a\n\nSample Output 3\n\ntFrg4\n\n\nSample Input 4\n\n9 5\naAAaBBccD\n1 4 a\n5 6 c\n2 3 B\n4 4 D\n2 3 A\n\nSample Output 4\n\nAB\n\n\nNote\nIn the first example during the first operation both letters 'a' are removed, so the string becomes \"bc\". During the second operation the letter 'c' (on the second position) is removed, and the string becomes \"b\".\n\nIn the second example during the first operation Petya removes '0' from the second position. After that the string becomes \"Az\". During the second operations the string doesn't change.",
        "platform": "codeforces",
        "question_id": "899/F",
        "contest_id": "899",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\n# Initialize a list to keep track of characters to remove\nremove = [False] * n\n\n# Process each operation\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    for j in range(l, r + 1):\n        if s[j] == c:\n            remove[j] = True\n\n# Build the result string\nresult = []\nfor i in range(n):\n    if not remove[i]:\n        result.append(s[i])\n\n# Print the result\nprint(''.join(result))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + i * 3]) - 1\n    r = int(data[4 + i * 3]) - 1\n    c = data[5 + i * 3]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\n# Process each operation\noperations = []\nfor i in range(m):\n    l = int(data[3 + i * 3]) - 1\n    r = int(data[4 + i * 3]) - 1\n    c = data[5 + i * 3]\n    operations.append((l, r, c))\n\n# Apply operations\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\n# Print the result\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\n# Process each operation\nfor i in range(3, 3 + 3 * m, 3):\n    l = int(data[i]) - 1\n    r = int(data[i + 1]) - 1\n    c = data[i + 2]\n    \n    # Remove all occurrences of c from positions l to r\n    s = s[:l] + s[l:].replace(c, '')\n\n# Print the resulting string\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + i * 3]) - 1\n    r = int(data[4 + i * 3]) - 1\n    c = data[5 + i * 3]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\n# Initialize a list to keep track of characters to remove\nremove = [False] * n\n\n# Process each operation\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    for j in range(l, r + 1):\n        if s[j] == c:\n            remove[j] = True\n\n# Build the result string\nresult = []\nfor i in range(n):\n    if not remove[i]:\n        result.append(s[i])\n\n# Print the result\nprint(''.join(result))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + i * 3]) - 1\n    r = int(data[4 + i * 3]) - 1\n    c = data[5 + i * 3]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\n# Process each operation\noperations = []\nfor i in range(m):\n    l = int(data[3 + i * 3]) - 1\n    r = int(data[4 + i * 3]) - 1\n    c = data[5 + i * 3]\n    operations.append((l, r, c))\n\n# Apply operations\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\n# Print the result\nprint(s)",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\n# Process each operation\nfor i in range(3, 3 + 3 * m, 3):\n    l = int(data[i]) - 1\n    r = int(data[i + 1]) - 1\n    c = data[i + 2]\n    \n    # Remove all occurrences of c from positions l to r\n    s = s[:l] + s[l:].replace(c, '')\n\n# Print the resulting string\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + i * 3]) - 1\n    r = int(data[4 + i * 3]) - 1\n    c = data[5 + i * 3]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\ns = data[2]\n\noperations = []\nfor i in range(m):\n    l = int(data[3 + 3 * i]) - 1\n    r = int(data[4 + 3 * i]) - 1\n    c = data[5 + 3 * i]\n    operations.append((l, r, c))\n\nfor l, r, c in operations:\n    s = s[:l] + s[l:].replace(c, '')\n\nprint(s)"
        ]
    },
    {
        "question_title": "Almost Difference",
        "question_content": "Let's denote a function\n\nd(x,y) = \\begin{cases} y - x, & \\text{if } |x-y| > 1 \\\\ 0, & \\text{if } |x-y| \\leq 1 \\end{cases}\n\nYou are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 \u2264 i \u2264 j \u2264 n.\n\n\nInput Format\nThe first line contains one integer n (1 \u2264 n \u2264 200000) \u2014 the number of elements in a.\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 109) \u2014 elements of the array.\n\n\nOutput Format\nPrint one integer \u2014 the sum of d(ai, aj) over all pairs (i, j) such that 1 \u2264 i \u2264 j \u2264 n.\n\n\nSample Input 1\n\n5\n1 2 3 1 3\n\nSample Output 1\n\n4\n\n\nSample Input 2\n\n4\n6 6 5 5\n\nSample Output 2\n\n0\n\n\nSample Input 3\n\n4\n6 6 4 4\n\nSample Output 3\n\n-8\n\n\nNote\nIn the first example:\n\n1. d(a1, a2) = 0;\n2. d(a1, a3) = 2;\n3. d(a1, a4) = 0;\n4. d(a1, a5) = 2;\n5. d(a2, a3) = 0;\n6. d(a2, a4) = 0;\n7. d(a2, a5) = 0;\n8. d(a3, a4) =  - 2;\n9. d(a3, a5) = 0;\n10. d(a4, a5) = 2.",
        "platform": "codeforces",
        "question_id": "903/D",
        "contest_id": "903",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the sum\nresult = 0\n\n# Iterate over all pairs (i, j) such that 1 \u2264 i \u2264 j \u2264 n\nfor i in range(n):\n    for j in range(i, n):\n        if abs(a[i] - a[j]) > 1:\n            result += abs(a[i] - a[j])\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the sum\nresult = 0\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Calculate the sum of d(ai, aj) for all pairs (i, j)\nfor i in range(n):\n    for j in range(i, n):\n        if abs(a[i] - a[j]) > 1:\n            result += a[j] - a[i]\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the sum of d(ai, aj) for all pairs (i, j)\nresult = 0\ncount = Counter(a)\n\nfor x in count:\n    for y in count:\n        if abs(x - y) > 1:\n            result += (count[x] * count[y]) * (abs(x - y) - 1)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Initialize the sum\ntotal_sum = 0\n\n# Iterate through the array to calculate the sum of d(ai, aj)\nfor i in range(n):\n    for j in range(i + 1, n):\n        if abs(a[i] - a[j]) > 1:\n            total_sum += a[j] - a[i]\n\n# Print the result\nprint(total_sum)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Initialize the sum\ntotal_sum = 0\n\n# Iterate through the array to calculate the sum of d(ai, aj)\nfor i in range(n):\n    for j in range(i, n):\n        if abs(a[i] - a[j]) > 1:\n            total_sum += a[j] - a[i]\n\n# Print the result\nprint(total_sum)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Initialize the sum\ntotal_sum = 0\n\n# Iterate through the array to calculate the sum of d(ai, aj)\nfor i in range(n):\n    for j in range(i, n):\n        diff = a[j] - a[i]\n        if diff > 1:\n            total_sum += diff\n\n# Print the result\nprint(total_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Initialize the result\nresult = 0\n\n# Iterate through the array to calculate the sum of d(ai, aj)\nfor i in range(n):\n    # Count how many elements are less than a[i] - 1\n    less_than = i\n    # Count how many elements are greater than a[i] + 1\n    greater_than = n - i - 1\n    \n    # Add the contribution of a[i] to the result\n    result += (less_than * (a[i] - 1)) - (greater_than * (a[i] + 1))\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Initialize the sum\ntotal_sum = 0\n\n# Iterate through the array to calculate the sum of d(ai, aj)\nfor i in range(n):\n    for j in range(i, n):\n        if abs(a[i] - a[j]) > 1:\n            total_sum += a[j] - a[i]\n\n# Print the result\nprint(total_sum)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the sum\ntotal_sum = 0\n\n# Iterate over all pairs (i, j) such that 1 \u2264 i \u2264 j \u2264 n\nfor i in range(n):\n    for j in range(i, n):\n        if abs(a[i] - a[j]) > 1:\n            total_sum += abs(a[i] - a[j])\n\n# Print the result\nprint(total_sum)\n```",
            "```python\nimport sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the sum of d(ai, aj) for all pairs (i, j)\nresult = 0\ncount = Counter(a)\n\nfor num in a:\n    count[num] -= 1\n    result += num * count[num]\n    count[num] += 1\n\n# Print the result\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the sum\nresult = 0\n\n# Iterate over all pairs (i, j) such that 1 \u2264 i \u2264 j \u2264 n\nfor i in range(n):\n    for j in range(i, n):\n        if abs(a[i] - a[j]) > 1:\n            result += abs(a[i] - a[j])\n\n# Print the result\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the sum\nresult = 0\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Calculate the sum of d(ai, aj) for all pairs (i, j)\nfor i in range(n):\n    for j in range(i, n):\n        if abs(a[i] - a[j]) > 1:\n            result += a[j] - a[i]\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import Counter\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the sum of d(ai, aj) for all pairs (i, j)\nresult = 0\ncount = Counter(a)\n\nfor x in count:\n    for y in count:\n        if abs(x - y) > 1:\n            result += (count[x] * count[y]) * (abs(x - y) - 1)\n\n# Print the result\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Initialize the sum\ntotal_sum = 0\n\n# Iterate through the array to calculate the sum of d(ai, aj)\nfor i in range(n):\n    for j in range(i + 1, n):\n        if abs(a[i] - a[j]) > 1:\n            total_sum += a[j] - a[i]\n\n# Print the result\nprint(total_sum)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Initialize the sum\ntotal_sum = 0\n\n# Iterate through the array to calculate the sum of d(ai, aj)\nfor i in range(n):\n    for j in range(i, n):\n        if abs(a[i] - a[j]) > 1:\n            total_sum += a[j] - a[i]\n\n# Print the result\nprint(total_sum)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Initialize the sum\ntotal_sum = 0\n\n# Iterate through the array to calculate the sum of d(ai, aj)\nfor i in range(n):\n    for j in range(i, n):\n        diff = a[j] - a[i]\n        if diff > 1:\n            total_sum += diff\n\n# Print the result\nprint(total_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Initialize the result\nresult = 0\n\n# Iterate through the array to calculate the sum of d(ai, aj)\nfor i in range(n):\n    # Count how many elements are less than a[i] - 1\n    less_than = i\n    # Count how many elements are greater than a[i] + 1\n    greater_than = n - i - 1\n    \n    # Add the contribution of a[i] to the result\n    result += (less_than * (a[i] - 1)) - (greater_than * (a[i] + 1))\n\n# Print the result\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Sort the array to facilitate the calculation\na.sort()\n\n# Initialize the sum\ntotal_sum = 0\n\n# Iterate through the array to calculate the sum of d(ai, aj)\nfor i in range(n):\n    for j in range(i, n):\n        if abs(a[i] - a[j]) > 1:\n            total_sum += a[j] - a[i]\n\n# Print the result\nprint(total_sum)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize the sum\ntotal_sum = 0\n\n# Iterate over all pairs (i, j) such that 1 \u2264 i \u2264 j \u2264 n\nfor i in range(n):\n    for j in range(i, n):\n        if abs(a[i] - a[j]) > 1:\n            total_sum += abs(a[i] - a[j])\n\n# Print the result\nprint(total_sum)",
            "import sys\nfrom collections import Counter\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Calculate the sum of d(ai, aj) for all pairs (i, j)\nresult = 0\ncount = Counter(a)\n\nfor num in a:\n    count[num] -= 1\n    result += num * count[num]\n    count[num] += 1\n\n# Print the result\nprint(result)"
        ]
    },
    {
        "question_title": "New Year and Original Order",
        "question_content": "Let S(n) denote the number that represents the digits of n in sorted order. For example, S(1) = 1, S(5) = 5, S(50394) = 3459, S(353535) = 333555.\n\nGiven a number X, compute \\sum_{1 \\leq k \\leq X} S(k) modulo 109 + 7.\n\n\nInput Format\nThe first line of input will contain the integer X (1 \u2264 X \u2264 10700).\n\n\nOutput Format\nPrint a single integer, the answer to the question.\n\n\nSample Input 1\n\n21\n\nSample Output 1\n\n195\n\n\nSample Input 2\n\n345342\n\nSample Output 2\n\n390548434\n\n\nNote\nThe first few values of S are 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 12. The sum of these values is 195.",
        "platform": "codeforces",
        "question_id": "908/G",
        "contest_id": "908",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\n# Read input from stdin\nX = int(sys.stdin.read().strip())\n\n# Compute and print the result\nresult = sum_S(X)\nprint(result)\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\n# Read input from stdin\nX = int(sys.stdin.read().strip())\n\n# Compute and print the result\nresult = sum_S(X)\nprint(result)\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total += S(k)\n        total %= MOD\n    return total\n\n# Read input from stdin\nX = int(sys.stdin.read().strip())\n\n# Compute the result\nresult = sum_S(X)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total += S(k)\n        total %= MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total += S(k)\n        total %= MOD\n    return total\n\n# Read input from stdin\nX = int(sys.stdin.read().strip())\n\n# Compute the result\nresult = sum_S(X)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\nimport sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total += S(k)\n        total %= MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)",
            "import sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\n# Read input from stdin\nX = int(sys.stdin.read().strip())\n\n# Compute and print the result\nresult = sum_S(X)\nprint(result)",
            "import sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\n# Read input from stdin\nX = int(sys.stdin.read().strip())\n\n# Compute and print the result\nresult = sum_S(X)\nprint(result)",
            "import sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)",
            "import sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total += S(k)\n        total %= MOD\n    return total\n\n# Read input from stdin\nX = int(sys.stdin.read().strip())\n\n# Compute the result\nresult = sum_S(X)\n\n# Write the result to stdout\nprint(result)",
            "import sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total += S(k)\n        total %= MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)",
            "import sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)",
            "import sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total = (total + S(k)) % MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)",
            "import sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total += S(k)\n        total %= MOD\n    return total\n\n# Read input from stdin\nX = int(sys.stdin.read().strip())\n\n# Compute the result\nresult = sum_S(X)\n\n# Write the result to stdout\nprint(result)",
            "import sys\n\nMOD = 10**9 + 7\n\ndef S(n):\n    return int(''.join(sorted(str(n))))\n\ndef sum_S(X):\n    total = 0\n    for k in range(1, X + 1):\n        total += S(k)\n        total %= MOD\n    return total\n\nif __name__ == \"__main__\":\n    X = int(sys.stdin.read().strip())\n    result = sum_S(X)\n    print(result)"
        ]
    },
    {
        "question_title": "Mass Change Queries",
        "question_content": "You are given an array a consisting of n integers. You have to process q queries to this array; each query is given as four numbers l, r, x and y, denoting that for every i such that l \u2264 i \u2264 r and ai = x you have to set ai equal to y.\n\nPrint the array after all queries are processed.\n\n\nInput Format\nThe first line contains one integer n (1 \u2264 n \u2264 200000) \u2014 the size of array a.\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 100) \u2014 the elements of array a.\n\nThe third line contains one integer q (1 \u2264 q \u2264 200000) \u2014 the number of queries you have to process.\n\nThen q lines follow. i-th line contains four integers l, r, x and y denoting i-th query (1 \u2264 l \u2264 r \u2264 n, 1 \u2264 x, y \u2264 100).\n\n\nOutput Format\nPrint n integers \u2014 elements of array a after all changes are made.\n\n\nSample Input 1\n\n5\n1 2 3 4 5\n3\n3 5 3 5\n1 5 5 1\n1 5 1 5\n\nSample Output 1\n\n5 2 5 4 5",
        "platform": "codeforces",
        "question_id": "911/G",
        "contest_id": "911",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nfor i in range(n):\n    print(a[i], end=' ')\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2 + 4*i])\n    r = int(data[n+3 + 4*i])\n    x = int(data[n+4 + 4*i])\n    y = int(data[n+5 + 4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l-1, r):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nfor i in range(n):\n    print(a[i], end=' ')",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2 + 4*i])\n    r = int(data[n+3 + 4*i])\n    x = int(data[n+4 + 4*i])\n    y = int(data[n+5 + 4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l-1, r):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    l = int(data[n+2+4*i]) - 1\n    r = int(data[n+3+4*i]) - 1\n    x = int(data[n+4+4*i])\n    y = int(data[n+5+4*i])\n    queries.append((l, r, x, y))\n\nfor l, r, x, y in queries:\n    for i in range(l, r+1):\n        if a[i] == x:\n            a[i] = y\n\nprint(' '.join(map(str, a)))"
        ]
    },
    {
        "question_title": "Substrings in a String",
        "question_content": "Given a string s, process q queries, each having one of the following forms:\n\n- 1 i c \u2014 Change the i-th character in the string to c.\n- 2 l r y \u2014 Consider the substring of s starting at position l and ending at position r. Output the number of times y occurs as a substring in it.\n\n\nInput Format\nThe first line of the input contains the string s (1 \u2264 |s| \u2264 105) of lowercase English letters.\n\nThe second line contains an integer q (1 \u2264 q \u2264 105) \u00a0\u2014 the number of queries to process.\n\nThe next q lines describe the queries and may have one of the following forms:\n\n- 1 i c (1 \u2264 i \u2264 |s|)\n- 2 l r y (1 \u2264 l \u2264 r \u2264 |s|)\n\nc is a lowercase English letter and y is a non-empty string consisting of only lowercase English letters.\n\nThe sum of |y| over all queries of second type is at most 105.\n\nIt is guaranteed that there is at least one query of second type.\n\nAll strings are 1-indexed.\n\n|s| is the length of the string s.\n\n\nOutput Format\nFor each query of type 2, output the required answer in a separate line.\n\n\nSample Input 1\n\nababababa\n3\n2 1 7 aba\n1 5 c\n2 1 7 aba\n\nSample Output 1\n\n3\n1\n\n\nSample Input 2\n\nabcdcbc\n5\n2 1 7 bc\n1 4 b\n2 4 7 bc\n1 2 a\n2 1 4 aa\n\nSample Output 2\n\n2\n2\n1\n\n\nNote\nConsider the first sample case. Initially, the string aba occurs 3 times in the range [1, 7]. Note that two occurrences may overlap.\n\nAfter the update, the string becomes ababcbaba and now aba occurs only once in the range [1, 7].",
        "platform": "codeforces",
        "question_id": "914/F",
        "contest_id": "914",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query = data[index:index+4]\n    if query[0] == '1':\n        i = int(query[1]) - 1\n        c = query[2]\n        queries.append((1, i, c))\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2]) - 1\n        y = query[3]\n        queries.append((2, l, r, y))\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        i, c = query[1], query[2]\n        s = s[:i] + c + s[i+1:]\n    elif query[0] == 2:\n        l, r, y = query[1], query[2], query[3]\n        substring = s[l:r+1]\n        count = substring.count(y)\n        print(count)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query = data[index:index+4]\n    if query[0] == '1':\n        queries.append((1, int(query[1]) - 1, query[2]))\n    else:\n        queries.append((2, int(query[1]) - 1, int(query[2]) - 1, query[3]))\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        s = s[:query[1]] + query[2] + s[query[1] + 1:]\n    else:\n        l, r, y = query[1], query[2], query[3]\n        count = s[l:r+1].count(y)\n        print(count)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Initialize the string and query index\ns = data[0]\nq = int(data[1])\nindex = 2\n\n# Process each query\nresults = []\nfor _ in range(q):\n    query_type = int(data[index])\n    index += 1\n    \n    if query_type == 1:\n        i = int(data[index]) - 1\n        c = data[index + 1]\n        s = s[:i] + c + s[i + 1:]\n        index += 2\n    elif query_type == 2:\n        l = int(data[index]) - 1\n        r = int(data[index + 1])\n        y = data[index + 2]\n        count = s[l:r+1].count(y)\n        results.append(count)\n        index += 3\n\n# Output the results for type 2 queries\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        c = data[index + 2]\n        queries.append((query_type, i, c))\n        index += 3\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        y = data[index + 3]\n        queries.append((query_type, l, r, y))\n        index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        s = s[:query[1]] + query[2] + s[query[1] + 1:]\n    elif query[0] == 2:\n        l, r, y = query[1], query[2], query[3]\n        count = s[l:r+1].count(y)\n        print(count)\n```",
            "```python\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    s = data[0]\n    q = int(data[1])\n    index = 2\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            i = int(data[index]) - 1\n            c = data[index + 1]\n            s = s[:i] + c + s[i + 1:]\n            index += 2\n        elif query_type == 2:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            y = data[index + 2]\n            count = s[l:r+1].count(y)\n            print(count)\n            index += 3\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        c = data[index + 2]\n        queries.append((query_type, i, c))\n        index += 3\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        y = data[index + 3]\n        queries.append((query_type, l, r, y))\n        index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        s = s[:query[1]] + query[2] + s[query[1] + 1:]\n    elif query[0] == 2:\n        l, r, y = query[1], query[2], query[3]\n        count = s[l:r+1].count(y)\n        print(count)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        c = data[index + 2]\n        queries.append((query_type, i, c))\n        index += 3\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        y = data[index + 3]\n        queries.append((query_type, l, r, y))\n        index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        s = s[:query[1]] + query[2] + s[query[1] + 1:]\n    elif query[0] == 2:\n        l, r, y = query[1], query[2], query[3]\n        count = s[l:r+1].count(y)\n        print(count)\n```",
            "```python\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    s = data[0]\n    q = int(data[1])\n    index = 2\n    \n    results = []\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            i = int(data[index]) - 1\n            c = data[index + 1]\n            s = s[:i] + c + s[i + 1:]\n            index += 2\n        elif query_type == 2:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            y = data[index + 2]\n            count = s[l:r+1].count(y)\n            results.append(count)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    s = data[0]\n    q = int(data[1])\n    index = 2\n    \n    results = []\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            i = int(data[index]) - 1\n            c = data[index + 1]\n            s = s[:i] + c + s[i + 1:]\n            index += 2\n        elif query_type == 2:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            y = data[index + 2]\n            count = s[l:r+1].count(y)\n            results.append(count)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        c = data[index + 2]\n        queries.append((query_type, i, c))\n        index += 3\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        y = data[index + 3]\n        queries.append((query_type, l, r, y))\n        index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        s = s[:query[1]] + query[2] + s[query[1] + 1:]\n    elif query[0] == 2:\n        l, r, y = query[1], query[2], query[3]\n        count = s[l:r+1].count(y)\n        print(count)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query = data[index:index+4]\n    if query[0] == '1':\n        i = int(query[1]) - 1\n        c = query[2]\n        queries.append((1, i, c))\n    elif query[0] == '2':\n        l = int(query[1]) - 1\n        r = int(query[2]) - 1\n        y = query[3]\n        queries.append((2, l, r, y))\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        i, c = query[1], query[2]\n        s = s[:i] + c + s[i+1:]\n    elif query[0] == 2:\n        l, r, y = query[1], query[2], query[3]\n        substring = s[l:r+1]\n        count = substring.count(y)\n        print(count)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query = data[index:index+4]\n    if query[0] == '1':\n        queries.append((1, int(query[1]) - 1, query[2]))\n    else:\n        queries.append((2, int(query[1]) - 1, int(query[2]) - 1, query[3]))\n    index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        s = s[:query[1]] + query[2] + s[query[1] + 1:]\n    else:\n        l, r, y = query[1], query[2], query[3]\n        count = s[l:r+1].count(y)\n        print(count)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Initialize the string and query index\ns = data[0]\nq = int(data[1])\nindex = 2\n\n# Process each query\nresults = []\nfor _ in range(q):\n    query_type = int(data[index])\n    index += 1\n    \n    if query_type == 1:\n        i = int(data[index]) - 1\n        c = data[index + 1]\n        s = s[:i] + c + s[i + 1:]\n        index += 2\n    elif query_type == 2:\n        l = int(data[index]) - 1\n        r = int(data[index + 1])\n        y = data[index + 2]\n        count = s[l:r+1].count(y)\n        results.append(count)\n        index += 3\n\n# Output the results for type 2 queries\nfor result in results:\n    print(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        c = data[index + 2]\n        queries.append((query_type, i, c))\n        index += 3\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        y = data[index + 3]\n        queries.append((query_type, l, r, y))\n        index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        s = s[:query[1]] + query[2] + s[query[1] + 1:]\n    elif query[0] == 2:\n        l, r, y = query[1], query[2], query[3]\n        count = s[l:r+1].count(y)\n        print(count)",
            "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    s = data[0]\n    q = int(data[1])\n    index = 2\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            i = int(data[index]) - 1\n            c = data[index + 1]\n            s = s[:i] + c + s[i + 1:]\n            index += 2\n        elif query_type == 2:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            y = data[index + 2]\n            count = s[l:r+1].count(y)\n            print(count)\n            index += 3\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        c = data[index + 2]\n        queries.append((query_type, i, c))\n        index += 3\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        y = data[index + 3]\n        queries.append((query_type, l, r, y))\n        index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        s = s[:query[1]] + query[2] + s[query[1] + 1:]\n    elif query[0] == 2:\n        l, r, y = query[1], query[2], query[3]\n        count = s[l:r+1].count(y)\n        print(count)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        c = data[index + 2]\n        queries.append((query_type, i, c))\n        index += 3\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        y = data[index + 3]\n        queries.append((query_type, l, r, y))\n        index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        s = s[:query[1]] + query[2] + s[query[1] + 1:]\n    elif query[0] == 2:\n        l, r, y = query[1], query[2], query[3]\n        count = s[l:r+1].count(y)\n        print(count)",
            "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    s = data[0]\n    q = int(data[1])\n    index = 2\n    \n    results = []\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            i = int(data[index]) - 1\n            c = data[index + 1]\n            s = s[:i] + c + s[i + 1:]\n            index += 2\n        elif query_type == 2:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            y = data[index + 2]\n            count = s[l:r+1].count(y)\n            results.append(count)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    s = data[0]\n    q = int(data[1])\n    index = 2\n    \n    results = []\n    \n    for _ in range(q):\n        query_type = int(data[index])\n        index += 1\n        \n        if query_type == 1:\n            i = int(data[index]) - 1\n            c = data[index + 1]\n            s = s[:i] + c + s[i + 1:]\n            index += 2\n        elif query_type == 2:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            y = data[index + 2]\n            count = s[l:r+1].count(y)\n            results.append(count)\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nq = int(data[1])\n\nqueries = []\nindex = 2\nfor _ in range(q):\n    query_type = int(data[index])\n    if query_type == 1:\n        i = int(data[index + 1]) - 1\n        c = data[index + 2]\n        queries.append((query_type, i, c))\n        index += 3\n    elif query_type == 2:\n        l = int(data[index + 1]) - 1\n        r = int(data[index + 2]) - 1\n        y = data[index + 3]\n        queries.append((query_type, l, r, y))\n        index += 4\n\nfor query in queries:\n    if query[0] == 1:\n        s = s[:query[1]] + query[2] + s[query[1] + 1:]\n    elif query[0] == 2:\n        l, r, y = query[1], query[2], query[3]\n        count = s[l:r+1].count(y)\n        print(count)"
        ]
    },
    {
        "question_title": "SUM and REPLACE",
        "question_content": "Let D(x) be the number of positive divisors of a positive integer x. For example, D(2) = 2 (2 is divisible by 1 and 2), D(6) = 4 (6 is divisible by 1, 2, 3 and 6).\n\nYou are given an array a of n integers. You have to process two types of queries:\n\n1. REPLACE l r \u2014 for every i \\in [l, r] replace ai with D(ai);\n2. SUM l r \u2014 calculate \\sum_{i=l}^{r}a_i.\n\nPrint the answer for each SUM query.\n\n\nInput Format\nThe first line contains two integers n and m (1 \u2264 n, m \u2264 3\u00b7105) \u2014 the number of elements in the array and the number of queries to process, respectively.\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 106) \u2014 the elements of the array.\n\nThen m lines follow, each containing 3 integers ti, li, ri denoting i-th query. If ti = 1, then i-th query is REPLACE li ri, otherwise it's SUM li ri (1 \u2264 ti \u2264 2, 1 \u2264 li \u2264 ri \u2264 n).\n\nThere is at least one SUM query.\n\n\nOutput Format\nFor each SUM query print the answer to it.\n\n\nSample Input 1\n\n7 6\n6 4 1 10 3 2 4\n2 1 7\n2 4 5\n1 3 5\n2 4 4\n1 5 7\n2 1 7\n\nSample Output 1\n\n30\n13\n4\n22",
        "platform": "codeforces",
        "question_id": "920/F",
        "contest_id": "920",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom math import sqrt\n\n# Function to calculate the number of divisors of a number\ndef D(x):\n    count = 0\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+3*i]), int(data[2+n+3*i+1]), int(data[2+n+3*i+2])) for i in range(m)]\n\n# Process queries\nfor query in queries:\n    t, l, r = query\n    if t == 1:\n        for i in range(l-1, r):\n            a[i] = D(a[i])\n    elif t == 2:\n        result = sum(a[l-1:r])\n        print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef count_divisors(x: int) -> int:\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            count += 1\n            if i != x // i:\n                count += 1\n    return count\n\ndef process_queries(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            for i in range(query[1] - 1, query[2]):\n                a[i] = count_divisors(a[i])\n        elif query[0] == 2:\n            result = sum(a[query[1] - 1:query[2]])\n            results.append(result)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    queries = []\n    index = 2 + n\n    for _ in range(m):\n        ti = int(data[index])\n        li = int(data[index + 1])\n        ri = int(data[index + 2])\n        queries.append([ti, li, ri])\n        index += 3\n    \n    results = process_queries(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import sqrt\n\n# Function to calculate the number of divisors of a number\ndef D(x):\n    count = 0\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = list(map(int, data[2+n:]))\n\n# Process each query\nindex = 0\nresults = []\nfor i in range(m):\n    ti = queries[index]\n    li = queries[index + 1] - 1\n    ri = queries[index + 2] - 1\n    index += 3\n    if ti == 1:\n        for j in range(li, ri + 1):\n            a[j] = D(a[j])\n    else:\n        results.append(sum(a[li:ri + 1]))\n\n# Print the results for each SUM query\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom math import sqrt\n\n# Function to calculate the number of divisors\ndef D(x):\n    count = 0\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = list(map(int, data[2+n:]))\n\n# Process queries\nindex = 2 + n\nresults = []\nfor i in range(m):\n    ti = queries[index]\n    li = queries[index + 1] - 1\n    ri = queries[index + 2] - 1\n    index += 3\n    if ti == 1:\n        for j in range(li, ri + 1):\n            a[j] = D(a[j])\n    elif ti == 2:\n        results.append(sum(a[li:ri + 1]))\n\n# Output results\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom math import sqrt\n\n# Function to calculate the number of divisors of a number\ndef D(x):\n    count = 0\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    ti = int(data[index])\n    li = int(data[index + 1]) - 1\n    ri = int(data[index + 2]) - 1\n    queries.append((ti, li, ri))\n    index += 3\n\n# Process each query\nfor ti, li, ri in queries:\n    if ti == 1:\n        for i in range(li, ri + 1):\n            a[i] = D(a[i])\n    elif ti == 2:\n        result = sum(a[li:ri + 1])\n        print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef count_divisors(x: int) -> int:\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            count += 1\n            if i != x // i:\n                count += 1\n    return count\n\ndef process_queries(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            l, r = query[1] - 1, query[2]\n            for i in range(l, r):\n                a[i] = count_divisors(a[i])\n        elif query[0] == 2:\n            l, r = query[1] - 1, query[2]\n            results.append(sum(a[l:r]))\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    queries = []\n    index = 2 + n\n    for i in range(m):\n        ti = int(data[index])\n        li = int(data[index + 1])\n        ri = int(data[index + 2])\n        queries.append([ti, li, ri])\n        index += 3\n    \n    results = process_queries(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef count_divisors(x: int) -> int:\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            count += 1\n            if i != x // i:\n                count += 1\n    return count\n\ndef process_queries(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            l, r = query[1] - 1, query[2]\n            for i in range(l, r):\n                a[i] = count_divisors(a[i])\n        elif query[0] == 2:\n            l, r = query[1] - 1, query[2]\n            results.append(sum(a[l:r]))\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    queries = []\n    index = 2 + n\n    for _ in range(m):\n        ti = int(data[index])\n        li = int(data[index + 1])\n        ri = int(data[index + 2])\n        queries.append([ti, li, ri])\n        index += 3\n    \n    results = process_queries(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import sqrt\n\n# Function to calculate the number of divisors of a number\ndef D(x):\n    count = 0\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = list(map(int, data[2+n:]))\n\n# Process each query\nindex = 0\nresults = []\nfor i in range(m):\n    ti = queries[index]\n    li = queries[index + 1] - 1\n    ri = queries[index + 2] - 1\n    index += 3\n    if ti == 1:\n        for j in range(li, ri + 1):\n            a[j] = D(a[j])\n    else:\n        results.append(sum(a[li:ri + 1]))\n\n# Print the results for each SUM query\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef count_divisors(x: int) -> int:\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            count += 1\n            if i != x // i:\n                count += 1\n    return count\n\ndef process_queries(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            l, r = query[1] - 1, query[2]\n            for i in range(l, r):\n                a[i] = count_divisors(a[i])\n        elif query[0] == 2:\n            l, r = query[1] - 1, query[2]\n            result = sum(a[l:r])\n            results.append(result)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    queries = [[int(data[2+n+3*i]) for i in range(3)] for _ in range(m)]\n    \n    results = process_queries(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom typing import List\n\ndef count_divisors(x: int) -> int:\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef process_queries(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            l, r = query[1] - 1, query[2]\n            for i in range(l, r):\n                a[i] = count_divisors(a[i])\n        elif query[0] == 2:\n            l, r = query[1] - 1, query[2]\n            result = sum(a[l:r])\n            results.append(result)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    queries = []\n    index = 2 + n\n    for i in range(m):\n        ti = int(data[index])\n        li = int(data[index + 1])\n        ri = int(data[index + 2])\n        queries.append([ti, li, ri])\n        index += 3\n    \n    results = process_queries(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom math import sqrt\n\n# Function to calculate the number of divisors of a number\ndef D(x):\n    count = 0\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = [(int(data[2+n+3*i]), int(data[2+n+3*i+1]), int(data[2+n+3*i+2])) for i in range(m)]\n\n# Process queries\nfor query in queries:\n    t, l, r = query\n    if t == 1:\n        for i in range(l-1, r):\n            a[i] = D(a[i])\n    elif t == 2:\n        result = sum(a[l-1:r])\n        print(result)",
            "import sys\nfrom typing import List\n\ndef count_divisors(x: int) -> int:\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            count += 1\n            if i != x // i:\n                count += 1\n    return count\n\ndef process_queries(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            for i in range(query[1] - 1, query[2]):\n                a[i] = count_divisors(a[i])\n        elif query[0] == 2:\n            result = sum(a[query[1] - 1:query[2]])\n            results.append(result)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    queries = []\n    index = 2 + n\n    for _ in range(m):\n        ti = int(data[index])\n        li = int(data[index + 1])\n        ri = int(data[index + 2])\n        queries.append([ti, li, ri])\n        index += 3\n    \n    results = process_queries(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import sqrt\n\n# Function to calculate the number of divisors of a number\ndef D(x):\n    count = 0\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = list(map(int, data[2+n:]))\n\n# Process each query\nindex = 0\nresults = []\nfor i in range(m):\n    ti = queries[index]\n    li = queries[index + 1] - 1\n    ri = queries[index + 2] - 1\n    index += 3\n    if ti == 1:\n        for j in range(li, ri + 1):\n            a[j] = D(a[j])\n    else:\n        results.append(sum(a[li:ri + 1]))\n\n# Print the results for each SUM query\nfor result in results:\n    print(result)",
            "import sys\nfrom math import sqrt\n\n# Function to calculate the number of divisors\ndef D(x):\n    count = 0\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = list(map(int, data[2+n:]))\n\n# Process queries\nindex = 2 + n\nresults = []\nfor i in range(m):\n    ti = queries[index]\n    li = queries[index + 1] - 1\n    ri = queries[index + 2] - 1\n    index += 3\n    if ti == 1:\n        for j in range(li, ri + 1):\n            a[j] = D(a[j])\n    elif ti == 2:\n        results.append(sum(a[li:ri + 1]))\n\n# Output results\nfor result in results:\n    print(result)",
            "import sys\nfrom math import sqrt\n\n# Function to calculate the number of divisors of a number\ndef D(x):\n    count = 0\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = []\n\nindex = 2 + n\nfor _ in range(m):\n    ti = int(data[index])\n    li = int(data[index + 1]) - 1\n    ri = int(data[index + 2]) - 1\n    queries.append((ti, li, ri))\n    index += 3\n\n# Process each query\nfor ti, li, ri in queries:\n    if ti == 1:\n        for i in range(li, ri + 1):\n            a[i] = D(a[i])\n    elif ti == 2:\n        result = sum(a[li:ri + 1])\n        print(result)",
            "import sys\nfrom typing import List\n\ndef count_divisors(x: int) -> int:\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            count += 1\n            if i != x // i:\n                count += 1\n    return count\n\ndef process_queries(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            l, r = query[1] - 1, query[2]\n            for i in range(l, r):\n                a[i] = count_divisors(a[i])\n        elif query[0] == 2:\n            l, r = query[1] - 1, query[2]\n            results.append(sum(a[l:r]))\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    queries = []\n    index = 2 + n\n    for i in range(m):\n        ti = int(data[index])\n        li = int(data[index + 1])\n        ri = int(data[index + 2])\n        queries.append([ti, li, ri])\n        index += 3\n    \n    results = process_queries(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom typing import List\n\ndef count_divisors(x: int) -> int:\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            count += 1\n            if i != x // i:\n                count += 1\n    return count\n\ndef process_queries(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            l, r = query[1] - 1, query[2]\n            for i in range(l, r):\n                a[i] = count_divisors(a[i])\n        elif query[0] == 2:\n            l, r = query[1] - 1, query[2]\n            results.append(sum(a[l:r]))\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    queries = []\n    index = 2 + n\n    for _ in range(m):\n        ti = int(data[index])\n        li = int(data[index + 1])\n        ri = int(data[index + 2])\n        queries.append([ti, li, ri])\n        index += 3\n    \n    results = process_queries(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import sqrt\n\n# Function to calculate the number of divisors of a number\ndef D(x):\n    count = 0\n    for i in range(1, int(sqrt(x)) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\nqueries = list(map(int, data[2+n:]))\n\n# Process each query\nindex = 0\nresults = []\nfor i in range(m):\n    ti = queries[index]\n    li = queries[index + 1] - 1\n    ri = queries[index + 2] - 1\n    index += 3\n    if ti == 1:\n        for j in range(li, ri + 1):\n            a[j] = D(a[j])\n    else:\n        results.append(sum(a[li:ri + 1]))\n\n# Print the results for each SUM query\nfor result in results:\n    print(result)",
            "import sys\nfrom typing import List\n\ndef count_divisors(x: int) -> int:\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            count += 1\n            if i != x // i:\n                count += 1\n    return count\n\ndef process_queries(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            l, r = query[1] - 1, query[2]\n            for i in range(l, r):\n                a[i] = count_divisors(a[i])\n        elif query[0] == 2:\n            l, r = query[1] - 1, query[2]\n            result = sum(a[l:r])\n            results.append(result)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    queries = [[int(data[2+n+3*i]) for i in range(3)] for _ in range(m)]\n    \n    results = process_queries(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom typing import List\n\ndef count_divisors(x: int) -> int:\n    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            if i * i == x:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef process_queries(n: int, m: int, a: List[int], queries: List[List[int]]) -> List[int]:\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            l, r = query[1] - 1, query[2]\n            for i in range(l, r):\n                a[i] = count_divisors(a[i])\n        elif query[0] == 2:\n            l, r = query[1] - 1, query[2]\n            result = sum(a[l:r])\n            results.append(result)\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    queries = []\n    index = 2 + n\n    for i in range(m):\n        ti = int(data[index])\n        li = int(data[index + 1])\n        ri = int(data[index + 2])\n        queries.append([ti, li, ri])\n        index += 3\n    \n    results = process_queries(n, m, a, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "List Of Integers",
        "question_content": "Let's denote as L(x, p) an infinite sequence of integers y such that gcd(p, y) = 1 and y > x (where gcd is the greatest common divisor of two integer numbers), sorted in ascending order. The elements of L(x, p) are 1-indexed; for example, 9, 13 and 15 are the first, the second and the third elements of L(7, 22), respectively.\n\nYou have to process t queries. Each query is denoted by three integers x, p and k, and the answer to this query is k-th element of L(x, p).\n\n\nInput Format\nThe first line contains one integer t (1 \u2264 t \u2264 30000) \u2014 the number of queries to process.\n\nThen t lines follow. i-th line contains three integers x, p and k for i-th query (1 \u2264 x, p, k \u2264 106).\n\n\nOutput Format\nPrint t integers, where i-th integer is the answer to i-th query.\n\n\nSample Input 1\n\n3\n7 22 1\n7 22 2\n7 22 3\n\nSample Output 1\n\n9\n13\n15\n\n\nSample Input 2\n\n5\n42 42 42\n43 43 43\n44 44 44\n45 45 45\n46 46 46\n\nSample Output 2\n\n187\n87\n139\n128\n141",
        "platform": "codeforces",
        "question_id": "920/G",
        "contest_id": "920",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef L(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(L(x, p, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef L(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        results.append(L(x, p, k))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import gcd\n\ndef find_kth_element(x, p, k):\n    count = 0\n    y = x + 1\n    while True:\n        if gcd(p, y) == 1:\n            count += 1\n            if count == k:\n                return y\n        y += 1\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        x = int(data[index])\n        p = int(data[index + 1])\n        k = int(data[index + 2])\n        index += 3\n        result = find_kth_element(x, p, k)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Picking Strings",
        "question_content": "Alice has a string consisting of characters 'A', 'B' and 'C'. Bob can use the following transitions on any substring of our string in any order any number of times:\n\n- A \\rightarrow BC\n- B \\rightarrow AC\n- C \\rightarrow AB\n- AAA \\rightarrow empty string\n\nNote that a substring is one or more consecutive characters. For given queries, determine whether it is possible to obtain the target string from source.\n\n\nInput Format\nThe first line contains a string S (1 \u2264 |S| \u2264 105). The second line contains a string T (1 \u2264 |T| \u2264 105), each of these strings consists only of uppercase English letters 'A', 'B' and 'C'.\n\nThe third line contains the number of queries Q (1 \u2264 Q \u2264 105).\n\nThe following Q lines describe queries. The i-th of these lines contains four space separated integers ai, bi, ci, di. These represent the i-th query: is it possible to create T[ci..di] from S[ai..bi] by applying the above transitions finite amount of times?\n\nHere, U[x..y] is a substring of U that begins at index x (indexed from 1) and ends at index y. In particular, U[1..|U|] is the whole string U.\n\nIt is guaranteed that 1 \u2264 a \u2264 b \u2264 |S| and 1 \u2264 c \u2264 d \u2264 |T|.\n\n\nOutput Format\nPrint a string of Q characters, where the i-th character is '1' if the answer to the i-th query is positive, and '0' otherwise.\n\n\nSample Input 1\n\nAABCCBAAB\nABCB\n5\n1 3 1 2\n2 2 2 4\n7 9 1 1\n3 4 2 3\n4 5 1 3\n\nSample Output 1\n\n10011\n\n\nNote\nIn the first query we can achieve the result, for instance, by using transitions AAB \\rightarrow AAAC \\rightarrow AAAAB \\rightarrow AB.\n\nThe third query asks for changing AAB to A\u00a0\u2014 but in this case we are not able to get rid of the character 'B'.",
        "platform": "codeforces",
        "question_id": "923/D",
        "contest_id": "923",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Extract the source and target strings\nS = data[0]\nT = data[1]\n\n# Extract the number of queries\nQ = int(data[2])\n\n# Initialize the result list\nresult = []\n\n# Process each query\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    index += 4\n    \n    # Extract the substring from S\n    substring_S = S[ai:bi + 1]\n    \n    # Check if the substring can be transformed into the target substring\n    if substring_S == T[ci:di + 1]:\n        result.append('1')\n    else:\n        result.append('0')\n\n# Print the result\nprint(''.join(result))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef can_transform(substring, target):\n    if substring == target:\n        return True\n    if len(substring) < len(target):\n        return False\n    if substring[:3] == 'AAA':\n        return can_transform(substring[3:], target)\n    if substring[0] == 'A':\n        return can_transform('BC' + substring[1:], target) or can_transform('AC' + substring[1:], target)\n    if substring[0] == 'B':\n        return can_transform('AC' + substring[1:], target) or can_transform('AB' + substring[1:], target)\n    if substring[0] == 'C':\n        return can_transform('AB' + substring[1:], target) or can_transform('BC' + substring[1:], target)\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi + 1]\n    target = T[ci:di + 1]\n    if can_transform(substring, target):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef is_possible(substring):\n    stack = []\n    for char in substring:\n        if char == 'A':\n            stack.append('A')\n        elif char == 'B':\n            if stack and stack[-1] == 'A':\n                stack.pop()\n                stack.append('B')\n            else:\n                return False\n        elif char == 'C':\n            if stack and stack[-1] == 'B':\n                stack.pop()\n                stack.append('C')\n            else:\n                return False\n    return not stack\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi+1]\n    target = T[ci:di+1]\n    if len(substring) != len(target):\n        result.append('0')\n        continue\n    if is_possible(substring):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef can_transform(source, target):\n    if len(source) != len(target):\n        return False\n    if source == target:\n        return True\n    if 'A' not in source and 'B' not in source and 'C' not in source:\n        return False\n    if 'A' in source and 'B' in source and 'C' in source:\n        return True\n    if 'A' in source and 'B' not in source and 'C' not in source:\n        return False\n    if 'A' not in source and 'B' in source and 'C' not in source:\n        return False\n    if 'A' not in source and 'B' not in source and 'C' in source:\n        return False\n    if 'A' in source and 'B' in source and 'C' not in source:\n        return False\n    if 'A' in source and 'B' not in source and 'C' in source:\n        return False\n    if 'A' not in source and 'B' in source and 'C' in source:\n        return False\n    return False\n\nresult = []\nfor ai, bi, ci, di in queries:\n    source = S[ai:bi+1]\n    target = T[ci:di+1]\n    if can_transform(source, target):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef is_possible(substring):\n    if len(substring) == 3 and substring == 'AAA':\n        return True\n    if len(substring) == 1:\n        return substring in 'ABC'\n    if len(substring) == 2:\n        return substring in ['AB', 'BC', 'CA']\n    if len(substring) == 3:\n        if substring == 'ABC' or substring == 'BCA' or substring == 'CAB':\n            return True\n    return False\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi+1]\n    target = T[ci:di+1]\n    if len(substring) != len(target):\n        result.append('0')\n        continue\n    if substring == target:\n        result.append('1')\n        continue\n    if is_possible(substring):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef is_possible(substring):\n    if substring == T:\n        return True\n    if len(substring) == 3 and substring == 'AAA':\n        return True\n    if len(substring) == 1:\n        return False\n    if substring[0] == 'A':\n        if is_possible(substring[1:] + 'C') or is_possible(substring[1:] + 'B'):\n            return True\n    elif substring[0] == 'B':\n        if is_possible(substring[1:] + 'A') or is_possible(substring[1:] + 'C'):\n            return True\n    elif substring[0] == 'C':\n        if is_possible(substring[1:] + 'A') or is_possible(substring[1:] + 'B'):\n            return True\n    return False\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi+1]\n    target = T[ci:di+1]\n    if is_possible(substring):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef can_transform(sub, target):\n    if sub == target:\n        return True\n    if len(sub) < len(target):\n        return False\n    if sub[:3] == 'AAA':\n        return can_transform(sub[3:], target)\n    if sub[0] == 'A':\n        return can_transform('BC' + sub[1:], target) or can_transform('AC' + sub[1:], target) or can_transform('AB' + sub[1:], target)\n    if sub[0] == 'B':\n        return can_transform('AC' + sub[1:], target) or can_transform('AB' + sub[1:], target) or can_transform('AA' + sub[1:], target)\n    if sub[0] == 'C':\n        return can_transform('AB' + sub[1:], target) or can_transform('AA' + sub[1:], target) or can_transform('BB' + sub[1:], target)\n\nresult = []\nfor ai, bi, ci, di in queries:\n    sub = S[ai:bi + 1]\n    target = T[ci:di + 1]\n    if can_transform(sub, target):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef is_possible(substring):\n    if substring == T:\n        return True\n    if len(substring) == 3 and substring == 'AAA':\n        return True\n    if len(substring) < 3:\n        return False\n    if substring[0] == 'A':\n        if is_possible(substring[1:] + 'C'):\n            return True\n        if is_possible(substring[2:] + 'B'):\n            return True\n    elif substring[0] == 'B':\n        if is_possible(substring[1:] + 'A'):\n            return True\n        if is_possible(substring[2:] + 'C'):\n            return True\n    elif substring[0] == 'C':\n        if is_possible(substring[1:] + 'B'):\n            return True\n        if is_possible(substring[2:] + 'A'):\n            return True\n    return False\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi+1]\n    target = T[ci:di+1]\n    if is_possible(substring) and is_possible(target):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef is_possible(substring):\n    if substring == T:\n        return True\n    if len(substring) == 3 and substring == 'AAA':\n        return True\n    if 'A' in substring:\n        if is_possible(substring.replace('A', 'BC')):\n            return True\n    if 'B' in substring:\n        if is_possible(substring.replace('B', 'AC')):\n            return True\n    if 'C' in substring:\n        if is_possible(substring.replace('C', 'AB')):\n            return True\n    return False\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi+1]\n    target = T[ci:di+1]\n    if is_possible(substring):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\nresult = []\n\ndef can_transform(subs, target):\n    if subs == target:\n        return True\n    if len(subs) < len(target):\n        return False\n    if subs[:3] == 'AAA':\n        return can_transform(subs[3:], target)\n    if subs[0] == 'A':\n        return can_transform(subs[1:], target.replace('A', 'BC', 1)) or can_transform(subs[1:], target.replace('A', 'AC', 1)) or can_transform(subs[1:], target.replace('A', 'AB', 1))\n    if subs[0] == 'B':\n        return can_transform(subs[1:], target.replace('B', 'AC', 1)) or can_transform(subs[1:], target.replace('B', 'AB', 1)) or can_transform(subs[1:], target.replace('B', 'AA', 1))\n    if subs[0] == 'C':\n        return can_transform(subs[1:], target.replace('C', 'AB', 1)) or can_transform(subs[1:], target.replace('C', 'AA', 1)) or can_transform(subs[1:], target.replace('C', 'BB', 1))\n\nfor ai, bi, ci, di in queries:\n    subs = S[ai:bi + 1]\n    target = T[ci:di + 1]\n    if can_transform(subs, target):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Extract the source and target strings\nS = data[0]\nT = data[1]\n\n# Extract the number of queries\nQ = int(data[2])\n\n# Initialize the result list\nresult = []\n\n# Process each query\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    index += 4\n    \n    # Extract the substring from S\n    substring_S = S[ai:bi + 1]\n    \n    # Check if the substring can be transformed into the target substring\n    if substring_S == T[ci:di + 1]:\n        result.append('1')\n    else:\n        result.append('0')\n\n# Print the result\nprint(''.join(result))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef can_transform(substring, target):\n    if substring == target:\n        return True\n    if len(substring) < len(target):\n        return False\n    if substring[:3] == 'AAA':\n        return can_transform(substring[3:], target)\n    if substring[0] == 'A':\n        return can_transform('BC' + substring[1:], target) or can_transform('AC' + substring[1:], target)\n    if substring[0] == 'B':\n        return can_transform('AC' + substring[1:], target) or can_transform('AB' + substring[1:], target)\n    if substring[0] == 'C':\n        return can_transform('AB' + substring[1:], target) or can_transform('BC' + substring[1:], target)\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi + 1]\n    target = T[ci:di + 1]\n    if can_transform(substring, target):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef is_possible(substring):\n    stack = []\n    for char in substring:\n        if char == 'A':\n            stack.append('A')\n        elif char == 'B':\n            if stack and stack[-1] == 'A':\n                stack.pop()\n                stack.append('B')\n            else:\n                return False\n        elif char == 'C':\n            if stack and stack[-1] == 'B':\n                stack.pop()\n                stack.append('C')\n            else:\n                return False\n    return not stack\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi+1]\n    target = T[ci:di+1]\n    if len(substring) != len(target):\n        result.append('0')\n        continue\n    if is_possible(substring):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef can_transform(source, target):\n    if len(source) != len(target):\n        return False\n    if source == target:\n        return True\n    if 'A' not in source and 'B' not in source and 'C' not in source:\n        return False\n    if 'A' in source and 'B' in source and 'C' in source:\n        return True\n    if 'A' in source and 'B' not in source and 'C' not in source:\n        return False\n    if 'A' not in source and 'B' in source and 'C' not in source:\n        return False\n    if 'A' not in source and 'B' not in source and 'C' in source:\n        return False\n    if 'A' in source and 'B' in source and 'C' not in source:\n        return False\n    if 'A' in source and 'B' not in source and 'C' in source:\n        return False\n    if 'A' not in source and 'B' in source and 'C' in source:\n        return False\n    return False\n\nresult = []\nfor ai, bi, ci, di in queries:\n    source = S[ai:bi+1]\n    target = T[ci:di+1]\n    if can_transform(source, target):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef is_possible(substring):\n    if len(substring) == 3 and substring == 'AAA':\n        return True\n    if len(substring) == 1:\n        return substring in 'ABC'\n    if len(substring) == 2:\n        return substring in ['AB', 'BC', 'CA']\n    if len(substring) == 3:\n        if substring == 'ABC' or substring == 'BCA' or substring == 'CAB':\n            return True\n    return False\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi+1]\n    target = T[ci:di+1]\n    if len(substring) != len(target):\n        result.append('0')\n        continue\n    if substring == target:\n        result.append('1')\n        continue\n    if is_possible(substring):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef is_possible(substring):\n    if substring == T:\n        return True\n    if len(substring) == 3 and substring == 'AAA':\n        return True\n    if len(substring) == 1:\n        return False\n    if substring[0] == 'A':\n        if is_possible(substring[1:] + 'C') or is_possible(substring[1:] + 'B'):\n            return True\n    elif substring[0] == 'B':\n        if is_possible(substring[1:] + 'A') or is_possible(substring[1:] + 'C'):\n            return True\n    elif substring[0] == 'C':\n        if is_possible(substring[1:] + 'A') or is_possible(substring[1:] + 'B'):\n            return True\n    return False\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi+1]\n    target = T[ci:di+1]\n    if is_possible(substring):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef can_transform(sub, target):\n    if sub == target:\n        return True\n    if len(sub) < len(target):\n        return False\n    if sub[:3] == 'AAA':\n        return can_transform(sub[3:], target)\n    if sub[0] == 'A':\n        return can_transform('BC' + sub[1:], target) or can_transform('AC' + sub[1:], target) or can_transform('AB' + sub[1:], target)\n    if sub[0] == 'B':\n        return can_transform('AC' + sub[1:], target) or can_transform('AB' + sub[1:], target) or can_transform('AA' + sub[1:], target)\n    if sub[0] == 'C':\n        return can_transform('AB' + sub[1:], target) or can_transform('AA' + sub[1:], target) or can_transform('BB' + sub[1:], target)\n\nresult = []\nfor ai, bi, ci, di in queries:\n    sub = S[ai:bi + 1]\n    target = T[ci:di + 1]\n    if can_transform(sub, target):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef is_possible(substring):\n    if substring == T:\n        return True\n    if len(substring) == 3 and substring == 'AAA':\n        return True\n    if len(substring) < 3:\n        return False\n    if substring[0] == 'A':\n        if is_possible(substring[1:] + 'C'):\n            return True\n        if is_possible(substring[2:] + 'B'):\n            return True\n    elif substring[0] == 'B':\n        if is_possible(substring[1:] + 'A'):\n            return True\n        if is_possible(substring[2:] + 'C'):\n            return True\n    elif substring[0] == 'C':\n        if is_possible(substring[1:] + 'B'):\n            return True\n        if is_possible(substring[2:] + 'A'):\n            return True\n    return False\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi+1]\n    target = T[ci:di+1]\n    if is_possible(substring) and is_possible(target):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\ndef is_possible(substring):\n    if substring == T:\n        return True\n    if len(substring) == 3 and substring == 'AAA':\n        return True\n    if 'A' in substring:\n        if is_possible(substring.replace('A', 'BC')):\n            return True\n    if 'B' in substring:\n        if is_possible(substring.replace('B', 'AC')):\n            return True\n    if 'C' in substring:\n        if is_possible(substring.replace('C', 'AB')):\n            return True\n    return False\n\nresult = []\nfor ai, bi, ci, di in queries:\n    substring = S[ai:bi+1]\n    target = T[ci:di+1]\n    if is_possible(substring):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nS = data[0]\nT = data[1]\nQ = int(data[2])\n\nqueries = []\nindex = 3\nfor _ in range(Q):\n    ai = int(data[index]) - 1\n    bi = int(data[index + 1]) - 1\n    ci = int(data[index + 2]) - 1\n    di = int(data[index + 3]) - 1\n    queries.append((ai, bi, ci, di))\n    index += 4\n\nresult = []\n\ndef can_transform(subs, target):\n    if subs == target:\n        return True\n    if len(subs) < len(target):\n        return False\n    if subs[:3] == 'AAA':\n        return can_transform(subs[3:], target)\n    if subs[0] == 'A':\n        return can_transform(subs[1:], target.replace('A', 'BC', 1)) or can_transform(subs[1:], target.replace('A', 'AC', 1)) or can_transform(subs[1:], target.replace('A', 'AB', 1))\n    if subs[0] == 'B':\n        return can_transform(subs[1:], target.replace('B', 'AC', 1)) or can_transform(subs[1:], target.replace('B', 'AB', 1)) or can_transform(subs[1:], target.replace('B', 'AA', 1))\n    if subs[0] == 'C':\n        return can_transform(subs[1:], target.replace('C', 'AB', 1)) or can_transform(subs[1:], target.replace('C', 'AA', 1)) or can_transform(subs[1:], target.replace('C', 'BB', 1))\n\nfor ai, bi, ci, di in queries:\n    subs = S[ai:bi + 1]\n    target = T[ci:di + 1]\n    if can_transform(subs, target):\n        result.append('1')\n    else:\n        result.append('0')\n\nprint(''.join(result))"
        ]
    },
    {
        "question_title": "Palindrome Partition",
        "question_content": "Given a string s, find the number of ways to split s to substrings such that if there are k substrings (p1, p2, p3, ..., pk) in partition, then pi = pk - i + 1 for all i (1 \u2264 i \u2264 k) and k is even.\n\nSince the number of ways can be large, print it modulo 109 + 7.\n\n\nInput Format\nThe only line of input contains a string s (2 \u2264 |s| \u2264 106) of even length consisting of lowercase Latin letters.\n\n\nOutput Format\nPrint one integer, the number of ways of partitioning the string modulo 109 + 7.\n\n\nSample Input 1\n\nabcdcdab\n\nSample Output 1\n\n1\n\n\nSample Input 2\n\nabbababababbab\n\nSample Output 2\n\n3\n\n\nNote\nIn the first case, the only way to partition the string is ab|cd|cd|ab.\n\nIn the second case, the string can be partitioned as ab|b|ab|ab|ab|ab|b|ab or ab|b|abab|abab|b|ab or abbab|ab|ab|abbab.",
        "platform": "codeforces",
        "question_id": "932/G",
        "contest_id": "932",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_ways(s):\n    n = len(s)\n    if n % 2 != 0:\n        return 0\n    \n    half = n // 2\n    count = 0\n    for i in range(1, half):\n        if s[:i] == s[half+i:half+2*i]:\n            count += 1\n    \n    return count % MOD\n\n# Read input\ninput = sys.stdin.read\ndata = input().strip()\n\n# Solve the problem\nresult = count_ways(data)\n\n# Print the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_partitions(s):\n    n = len(s)\n    if n % 2 != 0:\n        return 0\n    \n    half = n // 2\n    count = 0\n    \n    for i in range(1, half):\n        if s[:i] == s[half+i:half+2*i]:\n            count = (count + 1) % MOD\n    \n    return count\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().strip()\n\n# Solve the problem\nresult = count_partitions(data)\n\n# Write the result to stdout\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef count_ways(s):\n    n = len(s)\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if s[j:i] == s[i-1:j-1:-1]:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[n]\n\nif __name__ == \"__main__\":\n    s = sys.stdin.read().strip()\n    result = count_ways(s)\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\nmod = 10**9 + 7\nn = len(s)\ndp = [0] * (n + 1)\ndp[0] = 1\n\nfor i in range(2, n + 1, 2):\n    for j in range(i - 2, -1, -2):\n        if s[j:i] == s[i-2:i]:\n            dp[i] = (dp[i] + dp[j]) % mod\n\nprint(dp[n])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_partitions(s):\n    n = len(s)\n    if n % 2 != 0:\n        return 0\n    \n    half = n // 2\n    count = 0\n    for i in range(1, half):\n        if s[:i] == s[half+i:half+2*i]:\n            count += 1\n    \n    return count % MOD\n\nif __name__ == \"__main__\":\n    s = sys.stdin.read().strip()\n    result = count_partitions(s)\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef count_partitions(s):\n    n = len(s)\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if s[j:i] == s[i-1:j-1:-1]:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    return dp[n]\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Process the input\ns = data[0]\n\n# Get the result\nresult = count_partitions(s)\n\n# Print the result\nprint(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_partitions(s):\n    n = len(s)\n    if n % 2 != 0:\n        return 0\n    \n    half = n // 2\n    count = 0\n    \n    for i in range(1, half):\n        if s[:i] == s[half+i:half+2*i]:\n            count += 1\n    \n    return count % MOD\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Print the result\nprint(count_partitions(s))\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef count_ways(s):\n    n = len(s)\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if s[j:i] == s[i - j - 1:i]:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[n]\n\nif __name__ == \"__main__\":\n    s = sys.stdin.read().strip()\n    result = count_ways(s)\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nn = len(s)\nmod = 10**9 + 7\n\n# Create a dictionary to store the frequency of each substring\nfreq = {}\nfor i in range(n//2):\n    substring = s[i:i+n//2]\n    if substring in freq:\n        freq[substring] += 1\n    else:\n        freq[substring] = 1\n\n# Calculate the number of ways to partition the string\nways = 1\nfor value in freq.values():\n    ways = (ways * (value + 1)) % mod\n\n# Print the result\nprint(ways)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef count_partitions(s):\n    n = len(s)\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if s[j:i] == s[i - 1:j - 1:-1]:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    return dp[n]\n\nif __name__ == \"__main__\":\n    s = sys.stdin.read().strip()\n    result = count_partitions(s)\n    print(result)\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_ways(s):\n    n = len(s)\n    if n % 2 != 0:\n        return 0\n    \n    half = n // 2\n    count = 0\n    for i in range(1, half):\n        if s[:i] == s[half+i:half+2*i]:\n            count += 1\n    \n    return count % MOD\n\n# Read input\ninput = sys.stdin.read\ndata = input().strip()\n\n# Solve the problem\nresult = count_ways(data)\n\n# Print the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_partitions(s):\n    n = len(s)\n    if n % 2 != 0:\n        return 0\n    \n    half = n // 2\n    count = 0\n    \n    for i in range(1, half):\n        if s[:i] == s[half+i:half+2*i]:\n            count = (count + 1) % MOD\n    \n    return count\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().strip()\n\n# Solve the problem\nresult = count_partitions(data)\n\n# Write the result to stdout\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\ndef count_ways(s):\n    n = len(s)\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if s[j:i] == s[i-1:j-1:-1]:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[n]\n\nif __name__ == \"__main__\":\n    s = sys.stdin.read().strip()\n    result = count_ways(s)\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\ns = data[0]\n\nmod = 10**9 + 7\nn = len(s)\ndp = [0] * (n + 1)\ndp[0] = 1\n\nfor i in range(2, n + 1, 2):\n    for j in range(i - 2, -1, -2):\n        if s[j:i] == s[i-2:i]:\n            dp[i] = (dp[i] + dp[j]) % mod\n\nprint(dp[n])",
            "# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_partitions(s):\n    n = len(s)\n    if n % 2 != 0:\n        return 0\n    \n    half = n // 2\n    count = 0\n    for i in range(1, half):\n        if s[:i] == s[half+i:half+2*i]:\n            count += 1\n    \n    return count % MOD\n\nif __name__ == \"__main__\":\n    s = sys.stdin.read().strip()\n    result = count_partitions(s)\n    print(result)",
            "# YOUR CODE HERE\nimport sys\n\ndef count_partitions(s):\n    n = len(s)\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if s[j:i] == s[i-1:j-1:-1]:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    return dp[n]\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Process the input\ns = data[0]\n\n# Get the result\nresult = count_partitions(s)\n\n# Print the result\nprint(result)",
            "# YOUR CODE HERE\nimport sys\n\nMOD = 10**9 + 7\n\ndef count_partitions(s):\n    n = len(s)\n    if n % 2 != 0:\n        return 0\n    \n    half = n // 2\n    count = 0\n    \n    for i in range(1, half):\n        if s[:i] == s[half+i:half+2*i]:\n            count += 1\n    \n    return count % MOD\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Print the result\nprint(count_partitions(s))",
            "# YOUR CODE HERE\nimport sys\n\ndef count_ways(s):\n    n = len(s)\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if s[j:i] == s[i - j - 1:i]:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[n]\n\nif __name__ == \"__main__\":\n    s = sys.stdin.read().strip()\n    result = count_ways(s)\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\ns = data[0]\nn = len(s)\nmod = 10**9 + 7\n\n# Create a dictionary to store the frequency of each substring\nfreq = {}\nfor i in range(n//2):\n    substring = s[i:i+n//2]\n    if substring in freq:\n        freq[substring] += 1\n    else:\n        freq[substring] = 1\n\n# Calculate the number of ways to partition the string\nways = 1\nfor value in freq.values():\n    ways = (ways * (value + 1)) % mod\n\n# Print the result\nprint(ways)",
            "# YOUR CODE HERE\nimport sys\n\ndef count_partitions(s):\n    n = len(s)\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if s[j:i] == s[i - 1:j - 1:-1]:\n                dp[i] = (dp[i] + dp[j]) % MOD\n    \n    return dp[n]\n\nif __name__ == \"__main__\":\n    s = sys.stdin.read().strip()\n    result = count_partitions(s)\n    print(result)"
        ]
    },
    {
        "question_title": "Fafa and Array",
        "question_content": "Fafa has an array A of n positive integers, the function f(A) is defined as \\sum_{i=1}^{n-1} |a_i - a_{i+1}|. He wants to do q queries of two types:\n\n- 1 l r x \u2014 find the maximum possible value of f(A), if x is to be added to one element in the range [l,  r]. You can choose to which element to add x.\n- 2 l r x \u2014 increase all the elements in the range [l,  r] by value x.\n\nNote that queries of type 1 don't affect the array elements.\n\n\nInput Format\nThe first line contains one integer n (3 \u2264 n \u2264 105) \u2014 the length of the array.\n\nThe second line contains n positive integers a1, a2, ..., an (0 < ai \u2264 109) \u2014 the array elements.\n\nThe third line contains an integer q (1 \u2264 q \u2264 105) \u2014 the number of queries.\n\nThen q lines follow, line i describes the i-th query and contains four integers ti li ri xi ( t _ { i } \\in \\{ 1, 2 \\}, 1 < l _ { i } \\leq r _ { i } < n, 0 < x _ { i } \\leq 1 0 ^ { 9 } ).\n\nIt is guaranteed that at least one of the queries is of type 1.\n\n\nOutput Format\nFor each query of type 1, print the answer to the query.\n\n\nSample Input 1\n\n5\n1 1 1 1 1\n5\n1 2 4 1\n2 2 3 1\n2 4 4 2\n2 3 4 1\n1 3 3 2\n\nSample Output 1\n\n2\n8\n\n\nSample Input 2\n\n5\n1 2 3 4 5\n4\n1 2 4 2\n2 2 4 1\n2 3 4 1\n1 2 4 2\n\nSample Output 2\n\n6\n10",
        "platform": "codeforces",
        "question_id": "935/F",
        "contest_id": "935",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    t = int(data[n+2+4*i])\n    l = int(data[n+3+4*i]) - 1\n    r = int(data[n+4+4*i]) - 1\n    x = int(data[n+5+4*i])\n    queries.append((t, l, r, x))\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_f = 0\n    for i in range(l, r+1):\n        new_A = A[:]\n        new_A[i] += x\n        max_f = max(max_f, calculate_f(new_A))\n    return max_f\n\ndef query_2(A, l, r, x):\n    for i in range(l, r+1):\n        A[i] += x\n    return A\n\nfor t, l, r, x in queries:\n    if t == 1:\n        print(query_1(A, l, r, x))\n    elif t == 2:\n        A = query_2(A, l, r, x)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    t = int(data[n+2+4*i])\n    l = int(data[n+3+4*i]) - 1\n    r = int(data[n+4+4*i]) - 1\n    x = int(data[n+5+4*i])\n    queries.append((t, l, r, x))\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r+1):\n        original = A[i]\n        A[i] += x\n        current_f = calculate_f(A)\n        if current_f > max_value:\n            max_value = current_f\n        A[i] = original\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r+1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        result = query_1(A, l, r, x)\n        print(result)\n    elif t == 2:\n        query_2(A, l, r, x)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nindex = n + 2\nfor _ in range(q):\n    t = int(data[index])\n    l = int(data[index + 1]) - 1\n    r = int(data[index + 2]) - 1\n    x = int(data[index + 3])\n    queries.append((t, l, r, x))\n    index += 4\n\ndef f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\nfor t, l, r, x in queries:\n    if t == 1:\n        original = f(A)\n        max_diff = 0\n        for i in range(l, r + 1):\n            A[i] += x\n            current_diff = f(A)\n            max_diff = max(max_diff, current_diff)\n            A[i] -= x\n        print(max_diff)\n    elif t == 2:\n        for i in range(l, r + 1):\n            A[i] += x\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nindex = n + 2\nfor _ in range(q):\n    t = int(data[index])\n    l = int(data[index + 1]) - 1\n    r = int(data[index + 2]) - 1\n    x = int(data[index + 3])\n    queries.append((t, l, r, x))\n    index += 4\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r + 1):\n        original = A[i]\n        A[i] += x\n        current_f = calculate_f(A)\n        if current_f > max_value:\n            max_value = current_f\n        A[i] = original\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r + 1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        result = query_1(A, l, r, x)\n        print(result)\n    elif t == 2:\n        query_2(A, l, r, x)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    t = int(data[n+2+4*i])\n    l = int(data[n+3+4*i]) - 1\n    r = int(data[n+4+4*i]) - 1\n    x = int(data[n+5+4*i])\n    queries.append((t, l, r, x))\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A)-1))\n\ndef query_1(A, l, r, x):\n    max_f = 0\n    for i in range(l, r+1):\n        A[i] += x\n        f = calculate_f(A)\n        if f > max_f:\n            max_f = f\n        A[i] -= x\n    return max_f\n\ndef query_2(A, l, r, x):\n    for i in range(l, r+1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        result = query_1(A, l, r, x)\n        print(result)\n    elif t == 2:\n        query_2(A, l, r, x)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    t = int(data[n+2+4*i])\n    l = int(data[n+3+4*i]) - 1\n    r = int(data[n+4+4*i]) - 1\n    x = int(data[n+5+4*i])\n    queries.append((t, l, r, x))\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\nfor t, l, r, x in queries:\n    if t == 1:\n        original_f = calculate_f(A)\n        max_f = 0\n        for i in range(l, r+1):\n            A[i] += x\n            current_f = calculate_f(A)\n            max_f = max(max_f, current_f)\n            A[i] -= x\n        print(max_f)\n    elif t == 2:\n        for i in range(l, r+1):\n            A[i] += x\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nindex = n + 2\nfor _ in range(q):\n    t = int(data[index])\n    l = int(data[index + 1]) - 1\n    r = int(data[index + 2]) - 1\n    x = int(data[index + 3])\n    queries.append((t, l, r, x))\n    index += 4\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(n-1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r+1):\n        A[i] += x\n        max_value = max(max_value, calculate_f(A))\n        A[i] -= x\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r+1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        print(query_1(A, l, r, x))\n    elif t == 2:\n        query_2(A, l, r, x)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    t = int(data[n+2+4*i])\n    l = int(data[n+3+4*i]) - 1\n    r = int(data[n+4+4*i]) - 1\n    x = int(data[n+5+4*i])\n    queries.append((t, l, r, x))\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r+1):\n        new_A = A[:]\n        new_A[i] += x\n        max_value = max(max_value, calculate_f(new_A))\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r+1):\n        A[i] += x\n    return A\n\nfor t, l, r, x in queries:\n    if t == 1:\n        result = query_1(A, l, r, x)\n        print(result)\n    elif t == 2:\n        A = query_2(A, l, r, x)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nindex = n + 2\nfor _ in range(q):\n    t = int(data[index])\n    l = int(data[index + 1]) - 1\n    r = int(data[index + 2]) - 1\n    x = int(data[index + 3])\n    queries.append((t, l, r, x))\n    index += 4\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r + 1):\n        original = A[i]\n        A[i] += x\n        value = calculate_f(A)\n        if value > max_value:\n            max_value = value\n        A[i] = original\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r + 1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        print(query_1(A, l, r, x))\n    elif t == 2:\n        query_2(A, l, r, x)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nindex = n + 2\nfor _ in range(q):\n    t = int(data[index])\n    l = int(data[index + 1]) - 1\n    r = int(data[index + 2]) - 1\n    x = int(data[index + 3])\n    queries.append((t, l, r, x))\n    index += 4\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r + 1):\n        original = A[i]\n        A[i] += x\n        max_value = max(max_value, calculate_f(A))\n        A[i] = original\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r + 1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        print(query_1(A, l, r, x))\n    elif t == 2:\n        query_2(A, l, r, x)\n```"
        ],
        "code_list": [
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    t = int(data[n+2+4*i])\n    l = int(data[n+3+4*i]) - 1\n    r = int(data[n+4+4*i]) - 1\n    x = int(data[n+5+4*i])\n    queries.append((t, l, r, x))\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_f = 0\n    for i in range(l, r+1):\n        new_A = A[:]\n        new_A[i] += x\n        max_f = max(max_f, calculate_f(new_A))\n    return max_f\n\ndef query_2(A, l, r, x):\n    for i in range(l, r+1):\n        A[i] += x\n    return A\n\nfor t, l, r, x in queries:\n    if t == 1:\n        print(query_1(A, l, r, x))\n    elif t == 2:\n        A = query_2(A, l, r, x)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    t = int(data[n+2+4*i])\n    l = int(data[n+3+4*i]) - 1\n    r = int(data[n+4+4*i]) - 1\n    x = int(data[n+5+4*i])\n    queries.append((t, l, r, x))\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r+1):\n        original = A[i]\n        A[i] += x\n        current_f = calculate_f(A)\n        if current_f > max_value:\n            max_value = current_f\n        A[i] = original\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r+1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        result = query_1(A, l, r, x)\n        print(result)\n    elif t == 2:\n        query_2(A, l, r, x)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nindex = n + 2\nfor _ in range(q):\n    t = int(data[index])\n    l = int(data[index + 1]) - 1\n    r = int(data[index + 2]) - 1\n    x = int(data[index + 3])\n    queries.append((t, l, r, x))\n    index += 4\n\ndef f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\nfor t, l, r, x in queries:\n    if t == 1:\n        original = f(A)\n        max_diff = 0\n        for i in range(l, r + 1):\n            A[i] += x\n            current_diff = f(A)\n            max_diff = max(max_diff, current_diff)\n            A[i] -= x\n        print(max_diff)\n    elif t == 2:\n        for i in range(l, r + 1):\n            A[i] += x",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nindex = n + 2\nfor _ in range(q):\n    t = int(data[index])\n    l = int(data[index + 1]) - 1\n    r = int(data[index + 2]) - 1\n    x = int(data[index + 3])\n    queries.append((t, l, r, x))\n    index += 4\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r + 1):\n        original = A[i]\n        A[i] += x\n        current_f = calculate_f(A)\n        if current_f > max_value:\n            max_value = current_f\n        A[i] = original\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r + 1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        result = query_1(A, l, r, x)\n        print(result)\n    elif t == 2:\n        query_2(A, l, r, x)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    t = int(data[n+2+4*i])\n    l = int(data[n+3+4*i]) - 1\n    r = int(data[n+4+4*i]) - 1\n    x = int(data[n+5+4*i])\n    queries.append((t, l, r, x))\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A)-1))\n\ndef query_1(A, l, r, x):\n    max_f = 0\n    for i in range(l, r+1):\n        A[i] += x\n        f = calculate_f(A)\n        if f > max_f:\n            max_f = f\n        A[i] -= x\n    return max_f\n\ndef query_2(A, l, r, x):\n    for i in range(l, r+1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        result = query_1(A, l, r, x)\n        print(result)\n    elif t == 2:\n        query_2(A, l, r, x)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    t = int(data[n+2+4*i])\n    l = int(data[n+3+4*i]) - 1\n    r = int(data[n+4+4*i]) - 1\n    x = int(data[n+5+4*i])\n    queries.append((t, l, r, x))\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\nfor t, l, r, x in queries:\n    if t == 1:\n        original_f = calculate_f(A)\n        max_f = 0\n        for i in range(l, r+1):\n            A[i] += x\n            current_f = calculate_f(A)\n            max_f = max(max_f, current_f)\n            A[i] -= x\n        print(max_f)\n    elif t == 2:\n        for i in range(l, r+1):\n            A[i] += x",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nindex = n + 2\nfor _ in range(q):\n    t = int(data[index])\n    l = int(data[index + 1]) - 1\n    r = int(data[index + 2]) - 1\n    x = int(data[index + 3])\n    queries.append((t, l, r, x))\n    index += 4\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(n-1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r+1):\n        A[i] += x\n        max_value = max(max_value, calculate_f(A))\n        A[i] -= x\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r+1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        print(query_1(A, l, r, x))\n    elif t == 2:\n        query_2(A, l, r, x)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nfor i in range(q):\n    t = int(data[n+2+4*i])\n    l = int(data[n+3+4*i]) - 1\n    r = int(data[n+4+4*i]) - 1\n    x = int(data[n+5+4*i])\n    queries.append((t, l, r, x))\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r+1):\n        new_A = A[:]\n        new_A[i] += x\n        max_value = max(max_value, calculate_f(new_A))\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r+1):\n        A[i] += x\n    return A\n\nfor t, l, r, x in queries:\n    if t == 1:\n        result = query_1(A, l, r, x)\n        print(result)\n    elif t == 2:\n        A = query_2(A, l, r, x)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nindex = n + 2\nfor _ in range(q):\n    t = int(data[index])\n    l = int(data[index + 1]) - 1\n    r = int(data[index + 2]) - 1\n    x = int(data[index + 3])\n    queries.append((t, l, r, x))\n    index += 4\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r + 1):\n        original = A[i]\n        A[i] += x\n        value = calculate_f(A)\n        if value > max_value:\n            max_value = value\n        A[i] = original\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r + 1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        print(query_1(A, l, r, x))\n    elif t == 2:\n        query_2(A, l, r, x)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nA = list(map(int, data[1:n+1]))\nq = int(data[n+1])\n\nqueries = []\nindex = n + 2\nfor _ in range(q):\n    t = int(data[index])\n    l = int(data[index + 1]) - 1\n    r = int(data[index + 2]) - 1\n    x = int(data[index + 3])\n    queries.append((t, l, r, x))\n    index += 4\n\ndef calculate_f(A):\n    return sum(abs(A[i] - A[i+1]) for i in range(len(A) - 1))\n\ndef query_1(A, l, r, x):\n    max_value = 0\n    for i in range(l, r + 1):\n        original = A[i]\n        A[i] += x\n        max_value = max(max_value, calculate_f(A))\n        A[i] = original\n    return max_value\n\ndef query_2(A, l, r, x):\n    for i in range(l, r + 1):\n        A[i] += x\n\nfor t, l, r, x in queries:\n    if t == 1:\n        print(query_1(A, l, r, x))\n    elif t == 2:\n        query_2(A, l, r, x)"
        ]
    },
    {
        "question_title": "Max History",
        "question_content": "You are given an array a of length n. We define fa the following way:\n\n- Initially fa = 0, M = 1;\n- for every 2 \u2264 i \u2264 n if aM < ai then we set fa = fa + aM and then set M = i.\n\nCalculate the sum of fa over all n! permutations of the array a modulo 109 + 7.\n\nNote: two elements are considered different if their indices differ, so for every array a there are exactly n! permutations.\n\n\nInput Format\nThe first line contains integer n (1 \u2264 n \u2264 1 000 000) \u2014 the size of array a.\n\nSecond line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 109).\n\n\nOutput Format\nPrint the only integer, the sum of fa over all n! permutations of the array a modulo 109 + 7.\n\n\nSample Input 1\n\n2\n1 3\n\nSample Output 1\n\n1\n\n\nSample Input 2\n\n3\n1 1 2\n\nSample Output 2\n\n4\n\n\nNote\nFor the second example all the permutations are:\n\n- p = [1, 2, 3] : fa is equal to 1;\n- p = [1, 3, 2] : fa is equal to 1;\n- p = [2, 1, 3] : fa is equal to 1;\n- p = [2, 3, 1] : fa is equal to 1;\n- p = [3, 1, 2] : fa is equal to 0;\n- p = [3, 2, 1] : fa is equal to 0.\n\nWhere p is the array of the indices of initial array a. The sum of fa is equal to 4.",
        "platform": "codeforces",
        "question_id": "938/E",
        "contest_id": "938",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef sum_of_fa_for_permutations(a):\n    n = len(a)\n    total_sum = 0\n    for perm in permutations(a):\n        total_sum = (total_sum + calculate_fa(perm)) % MOD\n    return total_sum\n\ndef permutations(a):\n    if len(a) == 1:\n        yield a\n    else:\n        for i in range(len(a)):\n            for p in permutations(a[:i] + a[i+1:]):\n                yield [a[i]] + p\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = sum_of_fa_for_permutations(a)\n    print(result)\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n\n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_list = [a[i] for i in range(n)]\n        fa = calculate_fa(perm_list)\n        total_sum = (total_sum + fa) % MOD\n\n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_list = [a[i] for i in range(n)]\n        total_sum = (total_sum + calculate_fa(perm_list)) % MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef count_permutations(a):\n    n = len(a)\n    count = factorial(n)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                count //= 2\n                break\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n\n    total_sum = 0\n    for perm in set(permutations(a)):\n        fa = calculate_fa(perm)\n        total_sum = (total_sum + fa) % MOD\n\n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa += a[M - 1]\n            M = i\n    return fa\n\ndef count_permutations(a):\n    n = len(a)\n    count = factorial(n)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                count //= factorial(2)\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n\n    total_sum = 0\n    for perm in set(permutations(a)):\n        fa = calculate_fa(perm)\n        total_sum = (total_sum + fa) % MOD\n\n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_array = [a[i] for i in range(n)]\n        fa = calculate_fa(perm_array)\n        total_sum = (total_sum + fa) % MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa += a[M - 1]\n            M = i\n    return fa\n\ndef count_permutations_with_fixed_max(a, max_index):\n    n = len(a)\n    count = 1\n    for i in range(n):\n        if i != max_index:\n            count *= n - i - 1\n            count %= MOD\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for i in range(n):\n        if i == 0 or a[i] > a[i - 1]:\n            total_sum += calculate_fa(a[:i] + a[i+1:]) * count_permutations_with_fixed_max(a, i)\n            total_sum %= MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_array = [a[i] for i in range(n)]\n        total_sum = (total_sum + calculate_fa(perm_array)) % MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_array = [a[i] for i in range(n)]\n        total_sum = (total_sum + calculate_fa(perm_array)) % MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_list = [a[i] for i in range(n)]\n        perm_list.sort()\n        total_sum = (total_sum + calculate_fa(perm_list)) % MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()\n```"
        ],
        "code_list": [
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef sum_of_fa_for_permutations(a):\n    n = len(a)\n    total_sum = 0\n    for perm in permutations(a):\n        total_sum = (total_sum + calculate_fa(perm)) % MOD\n    return total_sum\n\ndef permutations(a):\n    if len(a) == 1:\n        yield a\n    else:\n        for i in range(len(a)):\n            for p in permutations(a[:i] + a[i+1:]):\n                yield [a[i]] + p\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = sum_of_fa_for_permutations(a)\n    print(result)",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n\n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_list = [a[i] for i in range(n)]\n        fa = calculate_fa(perm_list)\n        total_sum = (total_sum + fa) % MOD\n\n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_list = [a[i] for i in range(n)]\n        total_sum = (total_sum + calculate_fa(perm_list)) % MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef count_permutations(a):\n    n = len(a)\n    count = factorial(n)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                count //= 2\n                break\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n\n    total_sum = 0\n    for perm in set(permutations(a)):\n        fa = calculate_fa(perm)\n        total_sum = (total_sum + fa) % MOD\n\n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa += a[M - 1]\n            M = i\n    return fa\n\ndef count_permutations(a):\n    n = len(a)\n    count = factorial(n)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                count //= factorial(2)\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n\n    total_sum = 0\n    for perm in set(permutations(a)):\n        fa = calculate_fa(perm)\n        total_sum = (total_sum + fa) % MOD\n\n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_array = [a[i] for i in range(n)]\n        fa = calculate_fa(perm_array)\n        total_sum = (total_sum + fa) % MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa += a[M - 1]\n            M = i\n    return fa\n\ndef count_permutations_with_fixed_max(a, max_index):\n    n = len(a)\n    count = 1\n    for i in range(n):\n        if i != max_index:\n            count *= n - i - 1\n            count %= MOD\n    return count\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for i in range(n):\n        if i == 0 or a[i] > a[i - 1]:\n            total_sum += calculate_fa(a[:i] + a[i+1:]) * count_permutations_with_fixed_max(a, i)\n            total_sum %= MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_array = [a[i] for i in range(n)]\n        total_sum = (total_sum + calculate_fa(perm_array)) % MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_array = [a[i] for i in range(n)]\n        total_sum = (total_sum + calculate_fa(perm_array)) % MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom math import factorial\n\nMOD = 10**9 + 7\n\ndef calculate_fa(a):\n    n = len(a)\n    fa = 0\n    M = 1\n    for i in range(2, n + 1):\n        if a[M - 1] < a[i - 1]:\n            fa = (fa + a[M - 1]) % MOD\n            M = i\n    return fa\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    total_sum = 0\n    for perm in range(factorial(n)):\n        perm_list = [a[i] for i in range(n)]\n        perm_list.sort()\n        total_sum = (total_sum + calculate_fa(perm_list)) % MOD\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    main()"
        ]
    },
    {
        "question_title": "Erasing Substrings",
        "question_content": "You are given a string s, initially consisting of n lowercase Latin letters. After that, you perform k operations with it, where k = \\left\\lfloor \\log_2(n) \\right\\rfloor. During i-th operation you must erase some substring of length exactly 2i - 1 from s.\n\nPrint the lexicographically minimal string you may obtain after performing k such operations.\n\n\nInput Format\nThe only line contains one string s consisting of n lowercase Latin letters (1 \u2264 n \u2264 5000).\n\n\nOutput Format\nPrint the lexicographically minimal string you may obtain after performing k operations.\n\n\nSample Input 1\n\nadcbca\n\nSample Output 1\n\naba\n\n\nSample Input 2\n\nabacabadabacaba\n\nSample Output 2\n\naabacaba\n\n\nNote\nPossible operations in examples:\n\n1. adcbca \\rightarrow adcba \\rightarrow aba;\n2. abacabadabacaba \\rightarrow abcabadabacaba \\rightarrow aabadabacaba \\rightarrow aabacaba.",
        "platform": "codeforces",
        "question_id": "938/F",
        "contest_id": "938",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Function to perform the operations\ndef minimize_string(s):\n    k = (len(s).bit_length() - 1)\n    for i in range(k):\n        length = 2**i - 1\n        min_substring = min(s[j:j+length] for j in range(len(s) - length + 1))\n        s = s.replace(min_substring, '', 1)\n    return s\n\n# Get the minimal string\nresult = minimize_string(s)\n\n# Print the result to stdout\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Function to perform the operations\ndef minimize_string(s):\n    k = (len(s).bit_length() - 1)\n    for i in range(k, 0, -1):\n        length = 2**i - 1\n        for j in range(len(s) - length + 1):\n            substring = s[j:j+length]\n            # Find the lexicographically minimal substring of length 2i-1\n            min_substring = min(substring[j:j+1] for j in range(len(substring)))\n            s = s[:j] + min_substring + s[j+1:]\n    return s\n\n# Get the result\nresult = minimize_string(s)\n\n# Print the result to stdout\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Function to perform the operations\ndef minimize_string(s):\n    k = (len(s).bit_length() - 1)\n    for i in range(k, 0, -1):\n        length = 2**i - 1\n        min_substring = min(s[j:j+length] for j in range(len(s) - length + 1))\n        s = s.replace(min_substring, '', 1)\n    return s\n\n# Get the minimal string\nresult = minimize_string(s)\n\n# Print the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport math\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Get the string s\ns = data[0]\n\n# Calculate the number of operations k\nn = len(s)\nk = math.floor(math.log2(n))\n\n# Perform k operations\nfor i in range(k, 0, -1):\n    length = 2 ** i - 1\n    min_substring = min(s[j:j+length] for j in range(n - length + 1))\n    index = s.index(min_substring)\n    s = s[:index] + s[index + length:]\n\n# Print the resulting string\nprint(s)\n```",
            "```python\nimport sys\n\ndef min_string(s):\n    k = (len(s).bit_length() - 1)\n    for i in range(k, 0, -1):\n        length = 2**i - 1\n        for j in range(len(s) - length + 1):\n            s = s[:j] + min(s[j:j+length]) + s[j+length:]\n    return s\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Print the result\nprint(min_string(s))\n```",
            "```python\nimport sys\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Function to perform the operations\ndef minimize_string(s):\n    k = len(s).bit_length() - 1\n    for i in range(k, 0, -1):\n        length = 2**i - 1\n        min_substring = min(s[j:j+length] for j in range(len(s) - length + 1))\n        s = s.replace(min_substring, '', 1)\n    return s\n\n# Get the minimized string\nresult = minimize_string(s)\n\n# Print the result to stdout\nprint(result)\n```",
            "```python\nimport sys\nimport math\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# The only line contains the string s\ns = data[0]\n\n# Calculate the number of operations k\nn = len(s)\nk = math.floor(math.log2(n))\n\n# Function to perform the operation\ndef perform_operation(s, length):\n    min_string = s\n    for i in range(len(s) - length + 1):\n        substring = s[i:i + length]\n        remaining = s[:i] + s[i + length:]\n        if remaining < min_string:\n            min_string = remaining\n    return min_string\n\n# Perform k operations\nfor _ in range(k):\n    s = perform_operation(s, 2**_ - 1)\n\n# Print the result\nprint(s)\n```",
            "```python\nimport sys\n\ndef min_string(s):\n    k = (len(s) - 1).bit_length() - 1\n    for i in range(k, 0, -1):\n        length = 2 ** i - 1\n        s = ''.join(sorted(s[j:j+length] for j in range(0, len(s), length)))\n    return s\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Print the result\nprint(min_string(s))\n```",
            "```python\nimport sys\n\ndef min_string(s):\n    k = len(s).bit_length() - 1\n    for i in range(k, 0, -1):\n        length = 2**i - 1\n        for j in range(len(s) - length + 1):\n            s = s[:j] + min(s[j:j+length], s[j+1:j+length+1]) + s[j+length+1:]\n    return s\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Print the result\nprint(min_string(s))\n```",
            "```python\nimport sys\nimport math\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# The only line contains the string s\ns = data[0]\n\n# Calculate the number of operations k\nn = len(s)\nk = math.floor(math.log2(n))\n\n# Function to perform the operations\ndef perform_operations(s, k):\n    while k > 0:\n        length = 2**k - 1\n        min_substring = min(s[i:i+length] for i in range(len(s) - length + 1))\n        index = s.index(min_substring)\n        s = s[:index] + s[index + length:]\n        k -= 1\n    return s\n\n# Perform the operations and get the result\nresult = perform_operations(s, k)\n\n# Print the result to stdout\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Function to perform the operations\ndef minimize_string(s):\n    k = (len(s).bit_length() - 1)\n    for i in range(k):\n        length = 2**i - 1\n        min_substring = min(s[j:j+length] for j in range(len(s) - length + 1))\n        s = s.replace(min_substring, '', 1)\n    return s\n\n# Get the minimal string\nresult = minimize_string(s)\n\n# Print the result to stdout\nprint(result)",
            "import sys\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Function to perform the operations\ndef minimize_string(s):\n    k = (len(s).bit_length() - 1)\n    for i in range(k, 0, -1):\n        length = 2**i - 1\n        for j in range(len(s) - length + 1):\n            substring = s[j:j+length]\n            # Find the lexicographically minimal substring of length 2i-1\n            min_substring = min(substring[j:j+1] for j in range(len(substring)))\n            s = s[:j] + min_substring + s[j+1:]\n    return s\n\n# Get the result\nresult = minimize_string(s)\n\n# Print the result to stdout\nprint(result)",
            "import sys\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Function to perform the operations\ndef minimize_string(s):\n    k = (len(s).bit_length() - 1)\n    for i in range(k, 0, -1):\n        length = 2**i - 1\n        min_substring = min(s[j:j+length] for j in range(len(s) - length + 1))\n        s = s.replace(min_substring, '', 1)\n    return s\n\n# Get the minimal string\nresult = minimize_string(s)\n\n# Print the result to stdout\nprint(result)",
            "import sys\nimport math\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Get the string s\ns = data[0]\n\n# Calculate the number of operations k\nn = len(s)\nk = math.floor(math.log2(n))\n\n# Perform k operations\nfor i in range(k, 0, -1):\n    length = 2 ** i - 1\n    min_substring = min(s[j:j+length] for j in range(n - length + 1))\n    index = s.index(min_substring)\n    s = s[:index] + s[index + length:]\n\n# Print the resulting string\nprint(s)",
            "import sys\n\ndef min_string(s):\n    k = (len(s).bit_length() - 1)\n    for i in range(k, 0, -1):\n        length = 2**i - 1\n        for j in range(len(s) - length + 1):\n            s = s[:j] + min(s[j:j+length]) + s[j+length:]\n    return s\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Print the result\nprint(min_string(s))",
            "import sys\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Function to perform the operations\ndef minimize_string(s):\n    k = len(s).bit_length() - 1\n    for i in range(k, 0, -1):\n        length = 2**i - 1\n        min_substring = min(s[j:j+length] for j in range(len(s) - length + 1))\n        s = s.replace(min_substring, '', 1)\n    return s\n\n# Get the minimized string\nresult = minimize_string(s)\n\n# Print the result to stdout\nprint(result)",
            "import sys\nimport math\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# The only line contains the string s\ns = data[0]\n\n# Calculate the number of operations k\nn = len(s)\nk = math.floor(math.log2(n))\n\n# Function to perform the operation\ndef perform_operation(s, length):\n    min_string = s\n    for i in range(len(s) - length + 1):\n        substring = s[i:i + length]\n        remaining = s[:i] + s[i + length:]\n        if remaining < min_string:\n            min_string = remaining\n    return min_string\n\n# Perform k operations\nfor _ in range(k):\n    s = perform_operation(s, 2**_ - 1)\n\n# Print the result\nprint(s)",
            "import sys\n\ndef min_string(s):\n    k = (len(s) - 1).bit_length() - 1\n    for i in range(k, 0, -1):\n        length = 2 ** i - 1\n        s = ''.join(sorted(s[j:j+length] for j in range(0, len(s), length)))\n    return s\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Print the result\nprint(min_string(s))",
            "import sys\n\ndef min_string(s):\n    k = len(s).bit_length() - 1\n    for i in range(k, 0, -1):\n        length = 2**i - 1\n        for j in range(len(s) - length + 1):\n            s = s[:j] + min(s[j:j+length], s[j+1:j+length+1]) + s[j+length+1:]\n    return s\n\n# Read input from stdin\ns = sys.stdin.read().strip()\n\n# Print the result\nprint(min_string(s))",
            "import sys\nimport math\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# The only line contains the string s\ns = data[0]\n\n# Calculate the number of operations k\nn = len(s)\nk = math.floor(math.log2(n))\n\n# Function to perform the operations\ndef perform_operations(s, k):\n    while k > 0:\n        length = 2**k - 1\n        min_substring = min(s[i:i+length] for i in range(len(s) - length + 1))\n        index = s.index(min_substring)\n        s = s[:index] + s[index + length:]\n        k -= 1\n    return s\n\n# Perform the operations and get the result\nresult = perform_operations(s, k)\n\n# Print the result to stdout\nprint(result)"
        ]
    },
    {
        "question_title": "Largest Beautiful Number",
        "question_content": "Yes, that's another problem with definition of \"beautiful\" numbers.\n\nLet's call a positive integer x beautiful if its decimal representation without leading zeroes contains even number of digits, and there exists a permutation of this representation which is palindromic. For example, 4242 is a beautiful number, since it contains 4 digits, and there exists a palindromic permutation 2442.\n\nGiven a positive integer s, find the largest beautiful number which is less than s.\n\n\nInput Format\nThe first line contains one integer t (1 \u2264 t \u2264 105) \u2014 the number of testcases you have to solve.\n\nThen t lines follow, each representing one testcase and containing one string which is the decimal representation of number s. It is guaranteed that this string has even length, contains no leading zeroes, and there exists at least one beautiful number less than s.\n\nThe sum of lengths of s over all testcases doesn't exceed 2\u00b7105.\n\n\nOutput Format\nFor each testcase print one line containing the largest beautiful number which is less than s (it is guaranteed that the answer exists).\n\n\nSample Input 1\n\n4\n89\n88\n1000\n28923845\n\nSample Output 1\n\n88\n77\n99\n28923839",
        "platform": "codeforces",
        "question_id": "946/E",
        "contest_id": "946",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\ndef largest_beautiful_number(s):\n    s = list(s)\n    n = len(s)\n    for i in range(n-2, -1, -1):\n        if s[i] < s[i+1]:\n            right = s[i+1:]\n            right.sort(reverse=True)\n            for j in range(len(right)):\n                if right[j] > s[i]:\n                    right[j], s[i] = s[i], right[j]\n                    right.sort(reverse=True)\n                    s[i+1:] = right\n                    return ''.join(s)\n    return ''.join(s[:-1])\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t+1):\n        s = data[i]\n        results.append(largest_beautiful_number(s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\ndef largest_beautiful_number(s):\n    s = list(s)\n    n = len(s)\n    for i in range(n-2, -1, -1):\n        if s[i] < s[i+1]:\n            right = s[i+1:]\n            right.sort(reverse=True)\n            for j in range(len(right)):\n                if right[j] > s[i]:\n                    right[j], s[i] = s[i], right[j]\n                    right.sort(reverse=True)\n                    s[i+1:] = right\n                    return ''.join(s)\n    return ''.join(sorted(s, reverse=True))[:-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t+1):\n        s = data[i]\n        results.append(largest_beautiful_number(s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nfor i in range(1, t + 1):\n    s = data[i]\n    n = len(s)\n    half = n // 2\n    digits = list(s[:half])\n    digits.sort(reverse=True)\n    for j in range(half - 1, -1, -1):\n        if digits[j] < s[half + j]:\n            digits[j] += 1\n            for k in range(j + 1, half):\n                digits[k] = digits[half - (k - j)]\n            break\n    else:\n        digits[-1] -= 1\n        for k in range(half - 1, -1, -1):\n            digits[k] = digits[half - k]\n    result = ''.join(digits) * 2\n    results.append(result)\n\nfor result in results:\n    print(result)\n```",
            "```python\nimport sys\n\ndef largest_beautiful_number(s):\n    s = list(s)\n    n = len(s)\n    for i in range(n-1, -1, -1):\n        if i % 2 == 0 and s[i] > s[i-1]:\n            s[i], s[i-1] = s[i-1], s[i]\n            s[i:] = sorted(s[i:], reverse=True)\n            return ''.join(s)\n    return ''.join(sorted(s, reverse=True))[:-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(t):\n        s = data[i+1]\n        results.append(largest_beautiful_number(s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nfor i in range(1, t + 1):\n    s = data[i]\n    n = len(s)\n    half = n // 2\n    digits = [0] * 10\n    \n    # Count the frequency of each digit in the first half of the number\n    for j in range(half):\n        digits[int(s[j])] += 1\n    \n    # Try to form the largest possible beautiful number\n    for j in range(9, -1, -1):\n        if digits[j] % 2 == 1:\n            digits[j] -= 1\n            break\n    \n    # If no digit can be removed to make the number beautiful, reduce the last digit\n    if j == -1:\n        j = int(s[half - 1])\n        digits[j] -= 1\n        j -= 1\n        while j >= 0 and digits[j] == 0:\n            j -= 1\n        if j >= 0:\n            digits[j] += 1\n        else:\n            digits[0] += 1\n    \n    # Construct the largest possible beautiful number\n    beautiful_number = []\n    for j in range(9, -1, -1):\n        beautiful_number.extend([str(j)] * (digits[j] // 2))\n    \n    # If the number is not beautiful, adjust the last digit\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1] = str(int(beautiful_number[-1]) - 1)\n    \n    # If the number is still not beautiful, reduce the last digit further\n    if len(beautiful_number) * 2 != n:\n        beautiful_number[-1",
            "```python\nimport sys\n\ndef largest_beautiful_number(s):\n    s = list(s)\n    n = len(s)\n    for i in range(n-2, -1, -1):\n        if s[i] < s[i+1]:\n            right = s[i+1:]\n            right.sort(reverse=True)\n            for j in range(len(right)):\n                if right[j] > s[i]:\n                    right[j], s[i] = s[i], right[j]\n                    right.sort(reverse=True)\n                    s[i+1:] = right\n                    return ''.join(s)\n    return ''.join(sorted(s, reverse=True))\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t+1):\n        s = data[i]\n        results.append(largest_beautiful_number(s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\n\ndef largest_beautiful_number(s):\n    s = list(s)\n    n = len(s)\n    for i in range(n-2, -1, -1):\n        if s[i] < s[i+1]:\n            right = s[i+1:]\n            right.sort(reverse=True)\n            for j in range(len(right)):\n                if right[j] > s[i]:\n                    right[j], s[i] = s[i], right[j]\n                    break\n            s[i+1:] = right\n            s[i+1:] = s[i+1:][::-1]\n            return ''.join(s)\n    return ''.join(sorted(s, reverse=True))\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t+1):\n        s = data[i]\n        results.append(largest_beautiful_number(s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nfor i in range(1, t + 1):\n    s = data[i]\n    n = len(s)\n    half = s[:n // 2]\n    half = list(half)\n    half.sort(reverse=True)\n    for j in range(n // 2 - 1, -1, -1):\n        if half[j] < s[n - 1 - j]:\n            half[j] = s[n - 1 - j]\n            half[j + 1:] = sorted(half[j + 1:], reverse=True)\n            break\n    else:\n        half[-1] = str(int(half[-1]) - 1)\n        half = sorted(half, reverse=True)\n    result = half + half[::-1]\n    results.append(''.join(result))\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nfor i in range(1, t + 1):\n    s = data[i]\n    n = len(s)\n    half = s[:n // 2]\n    half = list(half)\n    half.sort(reverse=True)\n    for j in range(n // 2 - 1, -1, -1):\n        if half[j] < s[n - 1 - j]:\n            half[j] = s[n - 1 - j]\n            half[j + 1:] = sorted(half[j + 1:], reverse=True)\n            break\n    else:\n        half[-1] = str(int(half[-1]) - 1)\n        half = sorted(half, reverse=True)\n    results.append(''.join(half) * 2)\n\nfor result in results:\n    print(result)\n```",
            "```python\n# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nfor i in range(1, t + 1):\n    s = data[i]\n    n = len(s)\n    half = n // 2\n    half_str = s[:half]\n    half_list = list(half_str)\n    half_list.sort(reverse=True)\n    for j in range(half - 1, -1, -1):\n        if half_list[j] < s[half + j]:\n            half_list[j] = s[half + j]\n            half_list[j + 1:] = sorted(half_list[j + 1:], reverse=True)\n            break\n    else:\n        half_list[-1] = str(int(half_list[-1]) - 1)\n        half_list = sorted(half_list, reverse=True)\n    result = ''.join(half_list) * 2\n    results.append(result)\n\nfor result in results:\n    print(result)\n```"
        ],
        "code_list": [
            "import sys\n\ndef largest_beautiful_number(s):\n    s = list(s)\n    n = len(s)\n    for i in range(n-2, -1, -1):\n        if s[i] < s[i+1]:\n            right = s[i+1:]\n            right.sort(reverse=True)\n            for j in range(len(right)):\n                if right[j] > s[i]:\n                    right[j], s[i] = s[i], right[j]\n                    right.sort(reverse=True)\n                    s[i+1:] = right\n                    return ''.join(s)\n    return ''.join(s[:-1])\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t+1):\n        s = data[i]\n        results.append(largest_beautiful_number(s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\n\ndef largest_beautiful_number(s):\n    s = list(s)\n    n = len(s)\n    for i in range(n-2, -1, -1):\n        if s[i] < s[i+1]:\n            right = s[i+1:]\n            right.sort(reverse=True)\n            for j in range(len(right)):\n                if right[j] > s[i]:\n                    right[j], s[i] = s[i], right[j]\n                    right.sort(reverse=True)\n                    s[i+1:] = right\n                    return ''.join(s)\n    return ''.join(sorted(s, reverse=True))[:-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t+1):\n        s = data[i]\n        results.append(largest_beautiful_number(s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nfor i in range(1, t + 1):\n    s = data[i]\n    n = len(s)\n    half = n // 2\n    digits = list(s[:half])\n    digits.sort(reverse=True)\n    for j in range(half - 1, -1, -1):\n        if digits[j] < s[half + j]:\n            digits[j] += 1\n            for k in range(j + 1, half):\n                digits[k] = digits[half - (k - j)]\n            break\n    else:\n        digits[-1] -= 1\n        for k in range(half - 1, -1, -1):\n            digits[k] = digits[half - k]\n    result = ''.join(digits) * 2\n    results.append(result)\n\nfor result in results:\n    print(result)",
            "import sys\n\ndef largest_beautiful_number(s):\n    s = list(s)\n    n = len(s)\n    for i in range(n-1, -1, -1):\n        if i % 2 == 0 and s[i] > s[i-1]:\n            s[i], s[i-1] = s[i-1], s[i]\n            s[i:] = sorted(s[i:], reverse=True)\n            return ''.join(s)\n    return ''.join(sorted(s, reverse=True))[:-1]\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(t):\n        s = data[i+1]\n        results.append(largest_beautiful_number(s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "",
            "import sys\n\ndef largest_beautiful_number(s):\n    s = list(s)\n    n = len(s)\n    for i in range(n-2, -1, -1):\n        if s[i] < s[i+1]:\n            right = s[i+1:]\n            right.sort(reverse=True)\n            for j in range(len(right)):\n                if right[j] > s[i]:\n                    right[j], s[i] = s[i], right[j]\n                    right.sort(reverse=True)\n                    s[i+1:] = right\n                    return ''.join(s)\n    return ''.join(sorted(s, reverse=True))\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t+1):\n        s = data[i]\n        results.append(largest_beautiful_number(s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\n\ndef largest_beautiful_number(s):\n    s = list(s)\n    n = len(s)\n    for i in range(n-2, -1, -1):\n        if s[i] < s[i+1]:\n            right = s[i+1:]\n            right.sort(reverse=True)\n            for j in range(len(right)):\n                if right[j] > s[i]:\n                    right[j], s[i] = s[i], right[j]\n                    break\n            s[i+1:] = right\n            s[i+1:] = s[i+1:][::-1]\n            return ''.join(s)\n    return ''.join(sorted(s, reverse=True))\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    for i in range(1, t+1):\n        s = data[i]\n        results.append(largest_beautiful_number(s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nfor i in range(1, t + 1):\n    s = data[i]\n    n = len(s)\n    half = s[:n // 2]\n    half = list(half)\n    half.sort(reverse=True)\n    for j in range(n // 2 - 1, -1, -1):\n        if half[j] < s[n - 1 - j]:\n            half[j] = s[n - 1 - j]\n            half[j + 1:] = sorted(half[j + 1:], reverse=True)\n            break\n    else:\n        half[-1] = str(int(half[-1]) - 1)\n        half = sorted(half, reverse=True)\n    result = half + half[::-1]\n    results.append(''.join(result))\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nfor i in range(1, t + 1):\n    s = data[i]\n    n = len(s)\n    half = s[:n // 2]\n    half = list(half)\n    half.sort(reverse=True)\n    for j in range(n // 2 - 1, -1, -1):\n        if half[j] < s[n - 1 - j]:\n            half[j] = s[n - 1 - j]\n            half[j + 1:] = sorted(half[j + 1:], reverse=True)\n            break\n    else:\n        half[-1] = str(int(half[-1]) - 1)\n        half = sorted(half, reverse=True)\n    results.append(''.join(half) * 2)\n\nfor result in results:\n    print(result)",
            "# YOUR CODE HERE\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nfor i in range(1, t + 1):\n    s = data[i]\n    n = len(s)\n    half = n // 2\n    half_str = s[:half]\n    half_list = list(half_str)\n    half_list.sort(reverse=True)\n    for j in range(half - 1, -1, -1):\n        if half_list[j] < s[half + j]:\n            half_list[j] = s[half + j]\n            half_list[j + 1:] = sorted(half_list[j + 1:], reverse=True)\n            break\n    else:\n        half_list[-1] = str(int(half_list[-1]) - 1)\n        half_list = sorted(half_list, reverse=True)\n    result = ''.join(half_list) * 2\n    results.append(result)\n\nfor result in results:\n    print(result)"
        ]
    },
    {
        "question_title": "Almost Increasing Array",
        "question_content": "We call an array almost increasing if we can erase not more than one element from it so that the array becomes strictly increasing (that is, every element is striclty greater than every element before it).\n\nYou are given an array a consisting of n elements. You are allowed to replace any element with any integer number (and you may do so any number of times you need). What is the minimum number of replacements you have to perform in order to make the array almost increasing?\n\n\nInput Format\nThe first line contains one integer n (2 \u2264 n \u2264 200000) \u2014 the number of elements in a.\n\nThe second line contains n integers a1, a2, ..., an (1 \u2264 ai \u2264 109) \u2014 the array a.\n\n\nOutput Format\nPrint the minimum number of replaces you have to perform so that a is almost increasing.\n\n\nSample Input 1\n\n5\n5 4 3 2 1\n\nSample Output 1\n\n3\n\n\nSample Input 2\n\n5\n1 2 8 9 5\n\nSample Output 2\n\n0",
        "platform": "codeforces",
        "question_id": "946/G",
        "contest_id": "946",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\n\ndef min_replacements_to_almost_increasing(n, a):\n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    return replacements\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = min_replacements_to_almost_increasing(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\n\ndef min_replacements_to_almost_increasing(n, a):\n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n        i += 1\n    return replacements\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = min_replacements_to_almost_increasing(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize variables\nreplacements = 0\ni = 1\n\n# Iterate through the array to find almost increasing subsequence\nwhile i < n:\n    if a[i] <= a[i - 1]:\n        replacements += 1\n        if i > 1 and a[i] <= a[i - 2]:\n            a[i] = a[i - 1] + 1\n        else:\n            a[i - 1] = a[i] - 1\n    i += 1\n\n# Output the result\nprint(replacements)\n```",
            "```python\nimport sys\n\ndef min_replacements_to_almost_increasing(n, a):\n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n        i += 1\n    return replacements\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = min_replacements_to_almost_increasing(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\n\ndef min_replacements_to_almost_increasing(n, a):\n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    return replacements\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = min_replacements_to_almost_increasing(n, a)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndef min_replacements_to_almost_increasing(n, a):\n    if n <= 2:\n        return 0\n    \n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    \n    return replacements\n\nprint(min_replacements_to_almost_increasing(n, a))\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndef min_replacements_to_almost_increasing(n, a):\n    if n <= 2:\n        return 0\n    \n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    \n    return replacements\n\nprint(min_replacements_to_almost_increasing(n, a))\n```",
            "```python\nimport sys\n\ndef min_replacements_to_almost_increasing(n, a):\n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n        i += 1\n    return replacements\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = min_replacements_to_almost_increasing(n, a)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndef min_replacements_to_almost_increasing(n, a):\n    if n <= 2:\n        return 0\n    \n    count = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            count += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    \n    return count\n\nresult = min_replacements_to_almost_increasing(n, a)\nprint(result)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndef min_replacements_to_almost_increasing(n, a):\n    if n <= 2:\n        return 0\n    \n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    \n    return replacements\n\nprint(min_replacements_to_almost_increasing(n, a))\n```"
        ],
        "code_list": [
            "import sys\n\ndef min_replacements_to_almost_increasing(n, a):\n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    return replacements\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = min_replacements_to_almost_increasing(n, a)\n\n# Write output\nprint(result)",
            "import sys\n\ndef min_replacements_to_almost_increasing(n, a):\n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n        i += 1\n    return replacements\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = min_replacements_to_almost_increasing(n, a)\n\n# Write output\nprint(result)",
            "import sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse the input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Initialize variables\nreplacements = 0\ni = 1\n\n# Iterate through the array to find almost increasing subsequence\nwhile i < n:\n    if a[i] <= a[i - 1]:\n        replacements += 1\n        if i > 1 and a[i] <= a[i - 2]:\n            a[i] = a[i - 1] + 1\n        else:\n            a[i - 1] = a[i] - 1\n    i += 1\n\n# Output the result\nprint(replacements)",
            "import sys\n\ndef min_replacements_to_almost_increasing(n, a):\n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n        i += 1\n    return replacements\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = min_replacements_to_almost_increasing(n, a)\n\n# Write output\nprint(result)",
            "import sys\n\ndef min_replacements_to_almost_increasing(n, a):\n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    return replacements\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = min_replacements_to_almost_increasing(n, a)\n\n# Write output\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndef min_replacements_to_almost_increasing(n, a):\n    if n <= 2:\n        return 0\n    \n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    \n    return replacements\n\nprint(min_replacements_to_almost_increasing(n, a))",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndef min_replacements_to_almost_increasing(n, a):\n    if n <= 2:\n        return 0\n    \n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    \n    return replacements\n\nprint(min_replacements_to_almost_increasing(n, a))",
            "import sys\n\ndef min_replacements_to_almost_increasing(n, a):\n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n        i += 1\n    return replacements\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Solve the problem\nresult = min_replacements_to_almost_increasing(n, a)\n\n# Print the result\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndef min_replacements_to_almost_increasing(n, a):\n    if n <= 2:\n        return 0\n    \n    count = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            count += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    \n    return count\n\nresult = min_replacements_to_almost_increasing(n, a)\nprint(result)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\ndef min_replacements_to_almost_increasing(n, a):\n    if n <= 2:\n        return 0\n    \n    replacements = 0\n    i = 1\n    while i < n:\n        if a[i] <= a[i - 1]:\n            replacements += 1\n            if i > 1 and a[i] <= a[i - 2]:\n                a[i] = a[i - 1] + 1\n            else:\n                a[i - 1] = a[i] - 1\n        i += 1\n    \n    return replacements\n\nprint(min_replacements_to_almost_increasing(n, a))"
        ]
    },
    {
        "question_title": "Cheese Board",
        "question_content": "Not to be confused with chessboard.\n\n\nInput Format\nThe first line of input contains a single integer N (1 \u2264 N \u2264 100) \u2014 the number of cheeses you have.\n\nThe next N lines describe the cheeses you have. Each line contains two space-separated strings: the name of the cheese and its type. The name is a string of lowercase English letters between 1 and 10 characters long. The type is either \"soft\" or \"hard. All cheese names are distinct.\n\n\nOutput Format\nOutput a single number.\n\n\nSample Input 1\n\n9\nbrie soft\ncamembert soft\nfeta soft\ngoat soft\nmuenster soft\nasiago hard\ncheddar hard\ngouda hard\nswiss hard\n\nSample Output 1\n\n3\n\n\nSample Input 2\n\n6\nparmesan hard\nemmental hard\nedam hard\ncolby hard\ngruyere hard\nasiago hard\n\nSample Output 2\n\n4",
        "platform": "codeforces",
        "question_id": "952/E",
        "contest_id": "952",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    cheese_name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of types of cheeses\nprint(cheese_types['soft'] + cheese_types['hard'])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of hard cheeses\nprint(cheese_types['hard'])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    cheese_name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of hard cheeses\nprint(cheese_types['hard'])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to store the count of each type of cheese\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Iterate through the cheeses and count the types\nfor i in range(1, 2 * N, 2):\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of types of cheese\nprint(cheese_types['soft'] + cheese_types['hard'])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count the number of soft and hard cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Iterate through the list of cheeses\nfor i in range(1, 2 * N, 2):\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of hard cheeses\nprint(cheese_types['hard'])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of hard cheeses\nprint(cheese_types['hard'])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count the number of soft and hard cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of hard cheeses\nprint(cheese_types['hard'])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Iterate through the list of cheeses\nfor i in range(1, 2 * N, 2):\n    cheese_name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of different types of cheeses\nprint(cheese_types['soft'] + cheese_types['hard'])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of types of cheeses\nprint(cheese_types['soft'] + cheese_types['hard'])\n```",
            "```python\n# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of types of cheeses\nprint(cheese_types['soft'] + cheese_types['hard'])\n```"
        ],
        "code_list": [
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    cheese_name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of types of cheeses\nprint(cheese_types['soft'] + cheese_types['hard'])",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of hard cheeses\nprint(cheese_types['hard'])",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    cheese_name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of hard cheeses\nprint(cheese_types['hard'])",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to store the count of each type of cheese\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Iterate through the cheeses and count the types\nfor i in range(1, 2 * N, 2):\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of types of cheese\nprint(cheese_types['soft'] + cheese_types['hard'])",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count the number of soft and hard cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Iterate through the list of cheeses\nfor i in range(1, 2 * N, 2):\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of hard cheeses\nprint(cheese_types['hard'])",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of hard cheeses\nprint(cheese_types['hard'])",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count the number of soft and hard cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of hard cheeses\nprint(cheese_types['hard'])",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Iterate through the list of cheeses\nfor i in range(1, 2 * N, 2):\n    cheese_name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of different types of cheeses\nprint(cheese_types['soft'] + cheese_types['hard'])",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of types of cheeses\nprint(cheese_types['soft'] + cheese_types['hard'])",
            "# YOUR CODE HERE\nimport sys\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\n# Number of cheeses\nN = int(data[0])\n\n# Dictionary to count types of cheeses\ncheese_types = {'soft': 0, 'hard': 0}\n\n# Process each cheese\nfor i in range(1, 2 * N, 2):\n    name = data[i]\n    cheese_type = data[i + 1]\n    cheese_types[cheese_type] += 1\n\n# Output the number of types of cheeses\nprint(cheese_types['soft'] + cheese_types['hard'])"
        ]
    },
    {
        "question_title": "Heaps",
        "question_content": "You're given a tree with n vertices rooted at 1.\n\nWe say that there's a k-ary heap of depth m located at u if the following holds:\n\n- For m = 1 u itself is a k-ary heap of depth 1.\n- For m > 1 vertex u is a k-ary heap of depth m if at least k of its children are k-ary heaps of depth at least m - 1.\n\nDenote dpk(u) as maximum depth of k-ary heap in the subtree of u (including u). Your goal is to compute \\sum_{k=1}^{n}\\sum_{u=1}^{n}dp_k(u).\n\n\nInput Format\nThe first line contains an integer n denoting the size of the tree (2 \u2264 n \u2264 3\u00b7105).\n\nThe next n - 1 lines contain two integers u, v each, describing vertices connected by i-th edge.\n\nIt's guaranteed that the given configuration forms a tree.\n\n\nOutput Format\nOutput the answer to the task.\n\n\nSample Input 1\n\n4\n1 3\n2 3\n4 3\n\nSample Output 1\n\n21\n\n\nSample Input 2\n\n4\n1 2\n2 3\n3 4\n\nSample Output 2\n\n22\n\n\nNote\nConsider sample case one.\n\nFor k \u2265 3 all dpk will be equal to 1.\n\nFor k = 2 dpk is 2 if u \\in 1,3 and 1 otherwise.\n\nFor k = 1 dpk values are (3, 1, 2, 1) respectively.\n\nTo sum up, 4\u00b71 + 4\u00b71 + 2\u00b72 + 2\u00b71 + 3 + 1 + 2 + 1 = 21.",
        "platform": "codeforces",
        "question_id": "955/F",
        "contest_id": "955",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = data[1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n - 1):\n    u = int(edges[2 * i]) - 1\n    v = int(edges[2 * i + 1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate dpk(u)\ndef dfs(u, parent, k):\n    dp = [0] * (k + 1)\n    dp[1] = 1\n    for v in tree[u]:\n        if v != parent:\n            child_dp = dfs(v, u, k)\n            for i in range(k, 0, -1):\n                dp[i] += child_dp[i - 1]\n    return dp\n\n# Calculate the sum of dpk(u) for all k and u\ntotal_sum = 0\nfor k in range(1, n + 1):\n    dp = dfs(0, -1, k)\n    total_sum += sum(dp)\n\nprint(total_sum)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef dfs(u, parent, graph, dp):\n    dp[u][1] = 1\n    for v in graph[u]:\n        if v != parent:\n            dfs(v, u, graph, dp)\n            for k in range(1, len(dp[u])):\n                dp[u][k] += dp[v][k - 1]\n\ndef solve():\n    n, edges = read_input()\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dfs(1, -1, graph, dp)\n    \n    total_sum = 0\n    for k in range(1, n + 1):\n        for u in range(1, n + 1):\n            total_sum += dp[u][k]\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    solve()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef dfs(u, parent, k, dp):\n    dp[u][k] = 1\n    children = [v for v in graph[u] if v != parent]\n    for v in children:\n        dfs(v, u, k, dp)\n        dp[u][k] = max(dp[u][k], dp[v][k] + 1)\n    return dp[u][k]\n\ndef solve(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for u in range(1, n + 1):\n        dfs(u, -1, u, dp)\n    \n    total_sum = 0\n    for k in range(1, n + 1):\n        for u in range(1, n + 1):\n            total_sum += dp[u][k]\n    \n    return total_sum\n\ndef main():\n    n, edges = read_input()\n    result = solve(n, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges.append((u, v))\n    index += 2\n\nfrom collections import defaultdict, deque\n\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef dfs(node, parent):\n    dp = [0] * (n + 1)\n    dp[node] = 1\n    for child in graph[node]:\n        if child != parent:\n            child_dp = dfs(child, node)\n            for k in range(1, n + 1):\n                dp[k] += child_dp[k]\n                if child_dp[k] >= k:\n                    dp[k] += 1\n    return dp\n\ntotal_sum = 0\nfor k in range(1, n + 1):\n    dp = dfs(1, -1)\n    for i in range(1, n + 1):\n        total_sum += dp[i]\n\nprint(total_sum)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges.append((u, v))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate dpk(u)\ndef dfs(u, parent, k):\n    dpk = [0] * (k + 1)\n    dpk[1] = 1\n    for v in tree[u]:\n        if v != parent:\n            child_dpk = dfs(v, u, k)\n            for i in range(k, 0, -1):\n                dpk[i] += child_dpk[i - 1]\n    return dpk\n\n# Calculate the sum of dpk(u) for all k and u\ntotal_sum = 0\nfor k in range(1, n + 1):\n    dpk = dfs(1, -1, k)\n    total_sum += sum(dpk)\n\nprint(total_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges.append((u, v))\n    index += 2\n\nfrom collections import defaultdict, deque\n\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef dfs(u, parent):\n    dp = [0] * (n + 1)\n    dp[u] = 1\n    for v in graph[u]:\n        if v != parent:\n            child_dp = dfs(v, u)\n            for k in range(1, n + 1):\n                dp[k] += child_dp[k - 1]\n    return dp\n\ntotal_sum = 0\nfor u in range(1, n + 1):\n    dp = dfs(u, -1)\n    for k in range(1, n + 1):\n        total_sum += dp[k]\n\nprint(total_sum)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = data[1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n - 1):\n    u = int(edges[2 * i]) - 1\n    v = int(edges[2 * i + 1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate dpk(u)\ndef dfs(u, parent, k):\n    dp = [0] * (k + 1)\n    dp[1] = 1\n    for v in tree[u]:\n        if v != parent:\n            child_dp = dfs(v, u, k)\n            for i in range(k, 0, -1):\n                dp[i] += child_dp[i - 1]\n    return dp\n\n# Calculate the sum of dpk(u) for all k and u\ntotal_sum = 0\nfor k in range(1, n + 1):\n    dp = dfs(0, -1, k)\n    total_sum += sum(dp)\n\n# Output the result\nprint(total_sum)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef dfs(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    def dfs_util(u, parent, k):\n        nonlocal dp\n        max_depth = 0\n        for v in graph[u]:\n            if v != parent:\n                max_depth = max(max_depth, dfs_util(v, u, k))\n        dp[u][k] = max_depth + 1\n        return dp[u][k]\n    \n    for u in range(1, n + 1):\n        dfs_util(u, -1, 1)\n    \n    total_sum = 0\n    for k in range(1, n + 1):\n        for u in range(1, n + 1):\n            total_sum += dp[u][k]\n    \n    return total_sum\n\ndef main():\n    n, edges = read_input()\n    result = dfs(n, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = data[1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n - 1):\n    u = int(edges[2 * i]) - 1\n    v = int(edges[2 * i + 1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate dpk(u)\ndef dfs(u, parent, k):\n    dp = [0] * (k + 1)\n    dp[1] = 1\n    for v in tree[u]:\n        if v != parent:\n            child_dp = dfs(v, u, k)\n            for i in range(k, 0, -1):\n                dp[i] += child_dp[i - 1]\n    return dp\n\n# Calculate the sum of dpk(u) for all k and u\ntotal_sum = 0\nfor k in range(1, n + 1):\n    dp = dfs(0, -1, k)\n    total_sum += sum(dp)\n\nprint(total_sum)\n```",
            "```python\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = data[1:]\n\n# Build the tree\ntree = [[] for _ in range(n + 1)]\nfor i in range(n - 1):\n    u = int(edges[2 * i]) - 1\n    v = int(edges[2 * i + 1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to compute dpk(u)\ndef dpk(u, parent, k):\n    if len(tree[u]) == 1 and tree[u][0] == parent:\n        return 1\n    max_depth = 0\n    for v in tree[u]:\n        if v != parent:\n            max_depth = max(max_depth, dpk(v, u, k))\n    return max_depth + 1\n\n# Compute the sum of dpk(u) for all k and u\nresult = 0\nfor k in range(1, n + 1):\n    for u in range(n):\n        result += dpk(u, -1, k)\n\n# Output the result\nprint(result)\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = data[1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n - 1):\n    u = int(edges[2 * i]) - 1\n    v = int(edges[2 * i + 1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate dpk(u)\ndef dfs(u, parent, k):\n    dp = [0] * (k + 1)\n    dp[1] = 1\n    for v in tree[u]:\n        if v != parent:\n            child_dp = dfs(v, u, k)\n            for i in range(k, 0, -1):\n                dp[i] += child_dp[i - 1]\n    return dp\n\n# Calculate the sum of dpk(u) for all k and u\ntotal_sum = 0\nfor k in range(1, n + 1):\n    dp = dfs(0, -1, k)\n    total_sum += sum(dp)\n\nprint(total_sum)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef dfs(u, parent, graph, dp):\n    dp[u][1] = 1\n    for v in graph[u]:\n        if v != parent:\n            dfs(v, u, graph, dp)\n            for k in range(1, len(dp[u])):\n                dp[u][k] += dp[v][k - 1]\n\ndef solve():\n    n, edges = read_input()\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dfs(1, -1, graph, dp)\n    \n    total_sum = 0\n    for k in range(1, n + 1):\n        for u in range(1, n + 1):\n            total_sum += dp[u][k]\n    \n    print(total_sum)\n\nif __name__ == \"__main__\":\n    solve()",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef dfs(u, parent, k, dp):\n    dp[u][k] = 1\n    children = [v for v in graph[u] if v != parent]\n    for v in children:\n        dfs(v, u, k, dp)\n        dp[u][k] = max(dp[u][k], dp[v][k] + 1)\n    return dp[u][k]\n\ndef solve(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for u in range(1, n + 1):\n        dfs(u, -1, u, dp)\n    \n    total_sum = 0\n    for k in range(1, n + 1):\n        for u in range(1, n + 1):\n            total_sum += dp[u][k]\n    \n    return total_sum\n\ndef main():\n    n, edges = read_input()\n    result = solve(n, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges.append((u, v))\n    index += 2\n\nfrom collections import defaultdict, deque\n\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef dfs(node, parent):\n    dp = [0] * (n + 1)\n    dp[node] = 1\n    for child in graph[node]:\n        if child != parent:\n            child_dp = dfs(child, node)\n            for k in range(1, n + 1):\n                dp[k] += child_dp[k]\n                if child_dp[k] >= k:\n                    dp[k] += 1\n    return dp\n\ntotal_sum = 0\nfor k in range(1, n + 1):\n    dp = dfs(1, -1)\n    for i in range(1, n + 1):\n        total_sum += dp[i]\n\nprint(total_sum)",
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges.append((u, v))\n    index += 2\n\n# Build the tree\ntree = defaultdict(list)\nfor u, v in edges:\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate dpk(u)\ndef dfs(u, parent, k):\n    dpk = [0] * (k + 1)\n    dpk[1] = 1\n    for v in tree[u]:\n        if v != parent:\n            child_dpk = dfs(v, u, k)\n            for i in range(k, 0, -1):\n                dpk[i] += child_dpk[i - 1]\n    return dpk\n\n# Calculate the sum of dpk(u) for all k and u\ntotal_sum = 0\nfor k in range(1, n + 1):\n    dpk = dfs(1, -1, k)\n    total_sum += sum(dpk)\n\nprint(total_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = []\n\nindex = 1\nfor _ in range(n - 1):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges.append((u, v))\n    index += 2\n\nfrom collections import defaultdict, deque\n\ngraph = defaultdict(list)\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef dfs(u, parent):\n    dp = [0] * (n + 1)\n    dp[u] = 1\n    for v in graph[u]:\n        if v != parent:\n            child_dp = dfs(v, u)\n            for k in range(1, n + 1):\n                dp[k] += child_dp[k - 1]\n    return dp\n\ntotal_sum = 0\nfor u in range(1, n + 1):\n    dp = dfs(u, -1)\n    for k in range(1, n + 1):\n        total_sum += dp[k]\n\nprint(total_sum)",
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = data[1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n - 1):\n    u = int(edges[2 * i]) - 1\n    v = int(edges[2 * i + 1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate dpk(u)\ndef dfs(u, parent, k):\n    dp = [0] * (k + 1)\n    dp[1] = 1\n    for v in tree[u]:\n        if v != parent:\n            child_dp = dfs(v, u, k)\n            for i in range(k, 0, -1):\n                dp[i] += child_dp[i - 1]\n    return dp\n\n# Calculate the sum of dpk(u) for all k and u\ntotal_sum = 0\nfor k in range(1, n + 1):\n    dp = dfs(0, -1, k)\n    total_sum += sum(dp)\n\n# Output the result\nprint(total_sum)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef read_input():\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    edges = []\n    index = 1\n    for _ in range(n - 1):\n        u = int(data[index])\n        v = int(data[index + 1])\n        edges.append((u, v))\n        index += 2\n    return n, edges\n\ndef dfs(n, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    def dfs_util(u, parent, k):\n        nonlocal dp\n        max_depth = 0\n        for v in graph[u]:\n            if v != parent:\n                max_depth = max(max_depth, dfs_util(v, u, k))\n        dp[u][k] = max_depth + 1\n        return dp[u][k]\n    \n    for u in range(1, n + 1):\n        dfs_util(u, -1, 1)\n    \n    total_sum = 0\n    for k in range(1, n + 1):\n        for u in range(1, n + 1):\n            total_sum += dp[u][k]\n    \n    return total_sum\n\ndef main():\n    n, edges = read_input()\n    result = dfs(n, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "import sys\nfrom collections import defaultdict, deque\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = data[1:]\n\n# Build the tree\ntree = defaultdict(list)\nfor i in range(n - 1):\n    u = int(edges[2 * i]) - 1\n    v = int(edges[2 * i + 1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to perform DFS and calculate dpk(u)\ndef dfs(u, parent, k):\n    dp = [0] * (k + 1)\n    dp[1] = 1\n    for v in tree[u]:\n        if v != parent:\n            child_dp = dfs(v, u, k)\n            for i in range(k, 0, -1):\n                dp[i] += child_dp[i - 1]\n    return dp\n\n# Calculate the sum of dpk(u) for all k and u\ntotal_sum = 0\nfor k in range(1, n + 1):\n    dp = dfs(0, -1, k)\n    total_sum += sum(dp)\n\nprint(total_sum)",
            "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nedges = data[1:]\n\n# Build the tree\ntree = [[] for _ in range(n + 1)]\nfor i in range(n - 1):\n    u = int(edges[2 * i]) - 1\n    v = int(edges[2 * i + 1]) - 1\n    tree[u].append(v)\n    tree[v].append(u)\n\n# Function to compute dpk(u)\ndef dpk(u, parent, k):\n    if len(tree[u]) == 1 and tree[u][0] == parent:\n        return 1\n    max_depth = 0\n    for v in tree[u]:\n        if v != parent:\n            max_depth = max(max_depth, dpk(v, u, k))\n    return max_depth + 1\n\n# Compute the sum of dpk(u) for all k and u\nresult = 0\nfor k in range(1, n + 1):\n    for u in range(n):\n        result += dpk(u, -1, k)\n\n# Output the result\nprint(result)"
        ]
    },
    {
        "question_title": "AND Graph",
        "question_content": "You are given a set of size m with integer elements between 0 and 2^{n}-1 inclusive. Let's build an undirected graph on these integers in the following way: connect two integers x and y with an edge if and only if x \\& y = 0. Here \\& is the bitwise AND operation. Count the number of connected components in that graph.\n\n\nInput Format\nIn the first line of input there are two integers n and m (0 \\le n \\le 22, 1 \\le m \\le 2^{n}).\n\nIn the second line there are m integers a_1, a_2, \\ldots, a_m (0 \\le a_{i} < 2^{n})\u00a0\u2014 the elements of the set. All a_{i} are distinct.\n\n\nOutput Format\nPrint the number of connected components.\n\n\nSample Input 1\n\n2 3\n1 2 3\n\nSample Output 1\n\n2\n\n\nSample Input 2\n\n5 5\n5 19 10 20 12\n\nSample Output 2\n\n2\n\n\nNote\nGraph from first sample:\n\nGraph from second sample:",
        "platform": "codeforces",
        "question_id": "986/C",
        "contest_id": "986",
        "contest_date": "2025-01-01T00:00:00",
        "starter_code": "",
        "difficulty": "hard",
        "output_list": [
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            visited.add(element)\n            while queue:\n                current = queue.popleft()\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Count connected components\nresult = count_connected_components(n, m, elements)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            visited.add(element)\n            while queue:\n                current = queue.popleft()\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    for x in elements:\n        for y in elements:\n            if x & y == 0:\n                graph[x].append(y)\n                graph[y].append(x)\n    \n    visited = set()\n    components = 0\n    \n    for x in elements:\n        if x not in visited:\n            components += 1\n            queue = deque([x])\n            while queue:\n                current = queue.popleft()\n                if current not in visited:\n                    visited.add(current)\n                    for neighbor in graph[current]:\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            while queue:\n                current = queue.popleft()\n                if current not in visited:\n                    visited.add(current)\n                    for neighbor in graph[current]:\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            visited.add(element)\n            while queue:\n                current = queue.popleft()\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Count connected components\nresult = count_connected_components(n, m, elements)\n\n# Print the result\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    for x in elements:\n        for y in elements:\n            if x & y == 0:\n                graph[x].append(y)\n                graph[y].append(x)\n    \n    visited = set()\n    components = 0\n    \n    for x in elements:\n        if x not in visited:\n            components += 1\n            queue = deque([x])\n            while queue:\n                node = queue.popleft()\n                if node not in visited:\n                    visited.add(node)\n                    for neighbor in graph[node]:\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            while queue:\n                current = queue.popleft()\n                if current not in visited:\n                    visited.add(current)\n                    for neighbor in graph[current]:\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Calculate and print the number of connected components\nprint(count_connected_components(n, m, elements))\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            visited.add(element)\n            while queue:\n                current = queue.popleft()\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            while queue:\n                current = queue.popleft()\n                if current not in visited:\n                    visited.add(current)\n                    for neighbor in graph[current]:\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Write output\nprint(result)\n```",
            "```python\nimport sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            visited.add(element)\n            while queue:\n                current = queue.popleft()\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Calculate and print the number of connected components\nprint(count_connected_components(n, m, elements))\n```"
        ],
        "code_list": [
            "import sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            visited.add(element)\n            while queue:\n                current = queue.popleft()\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Count connected components\nresult = count_connected_components(n, m, elements)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            visited.add(element)\n            while queue:\n                current = queue.popleft()\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    for x in elements:\n        for y in elements:\n            if x & y == 0:\n                graph[x].append(y)\n                graph[y].append(x)\n    \n    visited = set()\n    components = 0\n    \n    for x in elements:\n        if x not in visited:\n            components += 1\n            queue = deque([x])\n            while queue:\n                current = queue.popleft()\n                if current not in visited:\n                    visited.add(current)\n                    for neighbor in graph[current]:\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            while queue:\n                current = queue.popleft()\n                if current not in visited:\n                    visited.add(current)\n                    for neighbor in graph[current]:\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            visited.add(element)\n            while queue:\n                current = queue.popleft()\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Count connected components\nresult = count_connected_components(n, m, elements)\n\n# Print the result\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    for x in elements:\n        for y in elements:\n            if x & y == 0:\n                graph[x].append(y)\n                graph[y].append(x)\n    \n    visited = set()\n    components = 0\n    \n    for x in elements:\n        if x not in visited:\n            components += 1\n            queue = deque([x])\n            while queue:\n                node = queue.popleft()\n                if node not in visited:\n                    visited.add(node)\n                    for neighbor in graph[node]:\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            while queue:\n                current = queue.popleft()\n                if current not in visited:\n                    visited.add(current)\n                    for neighbor in graph[current]:\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Calculate and print the number of connected components\nprint(count_connected_components(n, m, elements))",
            "import sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            visited.add(element)\n            while queue:\n                current = queue.popleft()\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            while queue:\n                current = queue.popleft()\n                if current not in visited:\n                    visited.add(current)\n                    for neighbor in graph[current]:\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Solve the problem\nresult = count_connected_components(n, m, elements)\n\n# Write output\nprint(result)",
            "import sys\nfrom collections import defaultdict, deque\n\ndef count_connected_components(n, m, elements):\n    graph = defaultdict(list)\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if elements[i] & elements[j] == 0:\n                graph[elements[i]].append(elements[j])\n                graph[elements[j]].append(elements[i])\n    \n    visited = set()\n    components = 0\n    \n    for element in elements:\n        if element not in visited:\n            components += 1\n            queue = deque([element])\n            visited.add(element)\n            while queue:\n                current = queue.popleft()\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n    \n    return components\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nelements = list(map(int, data[2:]))\n\n# Calculate and print the number of connected components\nprint(count_connected_components(n, m, elements))"
        ]
    }
]